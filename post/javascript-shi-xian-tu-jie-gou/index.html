<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="知行合一">
<meta name="theme-color" content="#000">
<title>JavaScript实现图结构 | Tyloo</title>
<link rel="shortcut icon" href="/favicon.ico?v=1615857085891">
<link rel="stylesheet" href="/media/css/pisces.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>





  <meta name="description" content="JavaScript实现图结构" />
  <meta name="keywords" content="" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="pisces">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Tyloo</span>
            </a>  
          
        </div>
        
          <p class="subtitle">知行合一</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout pisces ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body pisces" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">来碗鸡丁炒饭</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">51</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">4</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">4</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  



  <div style="width: 100%; position: relative;">
    <canvas id="canvasDiyBlock" style="width:100%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
    <script src="/media/js/magic/clock.js"></script>
  </div>

</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li><a href="#1%E5%9B%BE%E8%AE%BA">1.图论</a>
<ul>
<li><a href="#11%E5%9B%BE%E7%9A%84%E7%AE%80%E4%BB%8B">1.1.图的简介</a></li>
<li><a href="#12%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA">1.2.图的表示</a></li>
</ul>
</li>
<li><a href="#2%E5%B0%81%E8%A3%85%E5%9B%BE%E7%BB%93%E6%9E%84">2.封装图结构</a>
<ul>
<li><a href="#21%E6%B7%BB%E5%8A%A0%E5%AD%97%E5%85%B8%E7%B1%BB%E5%92%8C%E9%98%9F%E5%88%97%E7%B1%BB">2.1.添加字典类和队列类</a></li>
<li><a href="#22%E5%88%9B%E5%BB%BA%E5%9B%BE%E7%B1%BB">2.2.创建图类</a></li>
<li><a href="#23%E6%B7%BB%E5%8A%A0%E9%A1%B6%E7%82%B9%E4%B8%8E%E8%BE%B9">2.3.添加顶点与边</a></li>
<li><a href="#24%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%87%BA">2.4.转换为字符串输出</a></li>
<li><a href="#25%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86">2.5.图的遍历</a></li>
<li><a href="#26%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0">2.6.完整实现</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://Tyloo-code.github.io/post/javascript-shi-xian-tu-jie-gou/">
      JavaScript实现图结构
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2021-03-01 21:27:29">2021-03-01</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>20<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>4918<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
    
    
    <span id="/post/javascript-shi-xian-tu-jie-gou/" data-flag-title="JavaScript实现图结构" class="meta-item pc-show leancloud_visitors">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-eye"></i>
      <span><span class="language" data-lan="view">浏览量</span>：<span class="leancloud-visitors-count"></span></span>
    </span>
    
  </div>
</section>
            <div class="post-body next-md-body" id="post_body">
              <h1 id="1图论">1.图论</h1>
<h2 id="11图的简介">1.1.图的简介</h2>
<p><strong>什么是图？</strong></p>
<ul>
<li><strong>图结构</strong>是一种与<strong>树结构</strong>有些相似的数据结构；</li>
<li><strong>图论</strong>是数学的一个分支，并且，在数学中，树是图的一种；</li>
<li>图论以图为研究对象，研究<strong>顶点</strong>和<strong>边</strong>组成的<strong>图形</strong>的数学理论和方法；</li>
<li>主要的研究目的为：<strong>事物之间的联系</strong>，<strong>顶点</strong>代表<strong>事物</strong>，<strong>边</strong>代表两个事物间的<strong>关系</strong>；</li>
</ul>
<p><strong>图的特点：</strong></p>
<ul>
<li><strong>一组顶点</strong>：通常用**V **（Vertex）表示顶点的集合；</li>
<li><strong>一组边</strong>：通常用 **E **（Edge）表示边的集合；<br>
1. 边是顶点和顶点之间的连线；<br>
2. 边可以是有向的，也可以是无向的。比如A----B表示无向，A ---&gt; B 表示有向；</li>
</ul>
<p><strong>图的常用术语：</strong></p>
<ul>
<li><strong>顶点</strong>：表示图中的一个<strong>节点</strong>；</li>
<li><strong>边</strong>：表示<strong>顶点和顶点</strong>给之间的<strong>连线</strong>；</li>
<li><strong>相邻顶点</strong>：由一条边连接在一起的顶点称为<strong>相邻顶点</strong>；</li>
<li><strong>度</strong>：一个顶点的<strong>度</strong>是<strong>相邻顶点的数量</strong>；</li>
<li><strong>路径</strong>：
<ol>
<li>简单路径：简单路径要求不包含重复的顶点；</li>
<li>回路：第一个顶点和最后一个顶点<strong>相同</strong>的路径称为回路；</li>
</ol>
</li>
<li><strong>无向图</strong>：图中的所有边都是<strong>没有</strong>方向的；</li>
<li><strong>有向图</strong>：图中的所有边都是<strong>有</strong>方向的；</li>
<li><strong>无权图</strong>：无权图中的边没有任何权重意义；</li>
<li><strong>带权图</strong>：带权图中的边有一定的权重含义；</li>
</ul>
<h2 id="12图的表示">1.2.图的表示</h2>
<p><code>邻接矩阵</code></p>
<p>表示图的常用方式为：<strong>邻接矩阵</strong>。</p>
<ul>
<li>可以使用二维数组来表示邻接矩阵；</li>
<li>邻接矩阵让<strong>每个节点</strong>和<strong>一个整数相关联</strong>，该<strong>整数作为数组的下标值</strong>；</li>
<li>使用一个<strong>二维数组</strong>来表示顶点之间的<strong>连接</strong>；<br>
<img src="https://Tyloo-code.github.io/post-images/1614605612152.png" alt="" loading="lazy"></li>
</ul>
<p>如上图所示：</p>
<ul>
<li>二维数组中的0表示没有连线，1表示有连线；</li>
<li>如：A[ 0 ] [ 3 ] = 1，表示 A 和 C 之间有连接；</li>
<li>邻接矩阵的对角线上的值都为0，表示A - A ，B - B，等自回路都没有连接（自己与自己之间没有连接）；</li>
<li>若为无向图，则邻接矩阵应为对角线上元素全为0的对称矩阵；</li>
</ul>
<p><strong>邻接矩阵的问题：</strong></p>
<ul>
<li>如果图是一个<strong>稀疏图</strong>，那么邻接矩阵中将存在<strong>大量的 0</strong>，造成存储空间的浪费；</li>
</ul>
<p><code>邻接表</code><br>
另外一种表示图的常用方式为：<strong>邻接表。</strong></p>
<ul>
<li>邻接表由图中<strong>每个顶点</strong>以及<strong>和顶点相邻的顶点列表</strong>组成；</li>
<li>这个列表可用多种方式存储，比如：**数组/链表/字典（哈希表）**等都可以；<br>
<img src="https://Tyloo-code.github.io/post-images/1614605685712.png" alt="" loading="lazy"></li>
</ul>
<p>如上图所示：</p>
<ul>
<li>图中可清楚看到<strong>A</strong>与<strong>B、C、D</strong>相邻，假如要表示这些与A顶点相邻的顶点（边），可以通过将它们作为A的值（value）存入到对应的<strong>数组/链表/字典</strong>中。</li>
<li>之后，通过键（key）A可以十分方便地取出对应的数据；</li>
</ul>
<p><strong>邻接表的问题：</strong></p>
<ul>
<li>邻接表可以简单地得出<strong>出度</strong>，即某一顶点指向其他顶点的个数；</li>
<li>但是，邻接表计算<strong>入度</strong>（指向某一顶点的其他顶点的个数称为该顶点的入度）十分困难。此时需要构造<strong>逆邻接表</strong>才能有效计算入度；</li>
</ul>
<h1 id="2封装图结构">2.封装图结构</h1>
<p>在实现过程中采用<strong>邻接表</strong>的方式来表示边，使用<strong>字典类</strong>来存储邻接表。</p>
<h2 id="21添加字典类和队列类">2.1.添加字典类和队列类</h2>
<p>首先需要引入之前实现的，之后会用到的字典类和队列类：</p>
<pre><code>//封装字典类
function Dictionary(){
  //字典属性
  this.items = {}

  //字典操作方法
  //一.在字典中添加键值对
  Dictionary.prototype.set = function(key, value){
    this.items[key] = value
  }

  //二.判断字典中是否有某个key
  Dictionary.prototype.has = function(key){
    return this.items.hasOwnProperty(key)
  }

  //三.从字典中移除元素
  Dictionary.prototype.remove = function(key){
    //1.判断字典中是否有这个key
    if(!this.has(key)) return false

    //2.从字典中删除key
    delete this.items[key]
    return true
  }

  //四.根据key获取value
  Dictionary.prototype.get = function(key){
    return this.has(key) ? this.items[key] : undefined
  }

  //五.获取所有keys
  Dictionary.prototype.keys = function(){
    return Object.keys(this.items)
  }

  //六.size方法
  Dictionary.prototype.keys = function(){
    return this.keys().length
  }

  //七.clear方法
  Dictionary.prototype.clear = function(){
    this.items = {}
  }
}

   // 基于数组封装队列类
    function Queue() {
    // 属性
      this.items = []
    // 方法
    // 1.将元素加入到队列中
    Queue.prototype.enqueue = element =&gt; {
      this.items.push(element)
    }

    // 2.从队列中删除前端元素
    Queue.prototype.dequeue = () =&gt; {
      return this.items.shift()
    }

    // 3.查看前端的元素
    Queue.prototype.front = () =&gt; {
      return this.items[0]
    }

    // 4.查看队列是否为空
    Queue.prototype.isEmpty = () =&gt; {
      return this.items.length == 0;
    }

    // 5.查看队列中元素的个数
    Queue.prototype.size = () =&gt; {
      return this.items.length
    }

    // 6.toString方法
    Queue.prototype.toString = () =&gt; {
      let resultString = ''
        for (let i of this.items){
          resultString += i + ' '
        }
        return resultString
      }
    }
</code></pre>
<h2 id="22创建图类">2.2.创建图类</h2>
<p>先创建图类Graph，并添加基本属性，再实现图类的常用方法：</p>
<pre><code>    //封装图类
    function Graph (){
      //属性：顶点(数组)/边(字典)
      this.vertexes = []  //顶点
      this.edges = new Dictionary() //边
      }
</code></pre>
<h2 id="23添加顶点与边">2.3.添加顶点与边</h2>
<p>如图所示：<br>
<img src="https://Tyloo-code.github.io/post-images/1614685887261.png" alt="" loading="lazy"></p>
<p>创建一个数组对象vertexes存储图的顶点；创建一个字典对象edges存储图的边，其中key为顶点，value为存储key顶点相邻顶点的数组。</p>
<p><strong>代码实现：</strong></p>
<pre><code>     //添加方法
      //一.添加顶点
      Graph.prototype.addVertex = function(v){
        this.vertexes.push(v)
        this.edges.set(v, []) //将边添加到字典中，新增的顶点作为键，对应的值为一个存储边的空数组
      }
      //二.添加边
      Graph.prototype.addEdge = function(v1, v2){//传入两个顶点为它们添加边
        this.edges.get(v1).push(v2)//取出字典对象edges中存储边的数组，并添加关联顶点
        this.edges.get(v2).push(v1)//表示的是无向表，故要添加互相指向的两条边
      }
</code></pre>
<h2 id="24转换为字符串输出">2.4.转换为字符串输出</h2>
<p>为图类Graph添加toString方法，实现以邻接表的形式输出图中各顶点。<br>
<strong>代码实现：</strong></p>
<pre><code> //三.实现toString方法:转换为邻接表形式
      Graph.prototype.toString = function (){
        //1.定义字符串，保存最终结果
        let resultString = &quot;&quot;

        //2.遍历所有的顶点以及顶点对应的边
        for (let i = 0; i &lt; this.vertexes.length; i++) {//遍历所有顶点
          resultString += this.vertexes[i] + '--&gt;'
          let vEdges = this.edges.get(this.vertexes[i])
          for (let j = 0; j &lt; vEdges.length; j++) {//遍历字典中每个顶点对应的数组
            resultString += vEdges[j] + '  ';
          }
          resultString += '\n'
        }
        return resultString
      }
</code></pre>
<p><strong>测试代码：</strong></p>
<pre><code>    //测试代码
    //1.创建图结构
    let graph = new Graph()

    //2.添加顶点
    let myVertexes = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']
    for (let i = 0; i &lt; myVertexes.length; i++) {
      graph.addVertex(myVertexes[i])
    }

    //3.添加边
    graph.addEdge('A', 'B')
    graph.addEdge('A', 'C')
    graph.addEdge('A', 'D')
    graph.addEdge('C', 'D')
    graph.addEdge('C', 'G')
    graph.addEdge('D', 'G')
    graph.addEdge('D', 'H')
    graph.addEdge('B', 'E')
    graph.addEdge('B', 'F')
    graph.addEdge('E', 'I')

    //4.输出结果
    console.log(graph.toString());
</code></pre>
<p><strong>测试结果：</strong><br>
<img src="https://Tyloo-code.github.io/post-images/1614686639566.png" alt="" loading="lazy"></p>
<h2 id="25图的遍历">2.5.图的遍历</h2>
<p><strong>图的遍历思想：</strong></p>
<ul>
<li>图的遍历思想与树的遍历思想一样，意味着需要将图中<strong>所有的顶点</strong>都访问一遍，并且不能有<strong>重复的访问</strong>（上面的toString方法会重复访问）；</li>
</ul>
<p><strong>遍历图的两种算法：</strong></p>
<ul>
<li>广度优先搜索（Breadth - First Search，简称<strong>BFS</strong>）;</li>
<li>深度优先搜索（Depth - First Search，简称<strong>DFS</strong>）;</li>
<li>两种遍历算法都需要指定<strong>第一个被访问的顶点</strong>；</li>
</ul>
<p>为了记录顶点是否被访问过，使用<strong>三种颜色</strong>来表示它们的状态</p>
<ul>
<li><strong>白色</strong>：表示该顶点还没有被访问过；</li>
<li><strong>灰色</strong>：表示该顶点被访问过，但其相邻顶点并未完全被访问过；</li>
<li><strong>黑色</strong>：表示该顶点被访问过，且其所有相邻顶点都被访问过；</li>
</ul>
<p>首先封装initializeColor方法将图中的所有顶点初始化为白色，代码实现如下：</p>
<pre><code>    //四.初始化状态颜色
      Graph.prototype.initializeColor = function(){
        let colors = []
        for (let i = 0; i &lt; this.vertexes.length; i++) {
           colors[this.vertexes[i]] = 'white';
        }
        return colors
      }
</code></pre>
<p><code>广度优先搜索</code><br>
广度优先搜索算法的思路：</p>
<ul>
<li>广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻顶点，就像一次访问图的一层；</li>
<li>也可以说是<strong>先宽后深</strong>地遍历图中的各个顶点；<br>
<img src="https://Tyloo-code.github.io/post-images/1614686757512.png" alt="" loading="lazy"></li>
</ul>
<p><strong>实现思路：</strong></p>
<p>基于<strong>队列</strong>可以简单地实现广度优先搜索算法：</p>
<ul>
<li>首先创建一个队列Q（尾部进，首部出）；</li>
<li>调用封装的initializeColor方法将所有顶点初始化为白色；</li>
<li>指定第一个顶点A，将A标注为灰色（被访问过的节点），并将A放入队列Q中；</li>
<li>循环遍历队列中的元素，只要队列Q非空，就执行以下操作：<br>
1. 先将灰色的A从Q的首部取出；<br>
2. 取出A后，将A的所有未被访问过（白色）的相邻顶点依次从队列Q的尾部加入队列，并变为灰色。以此保证，灰色的相邻顶点不重复加入队列；<br>
3. A的全部相邻节点加入Q后，A变为黑色，在下一次循环中被移除Q外；</li>
</ul>
<p><strong>代码实现：</strong></p>
<pre><code>       //五.实现广度搜索(BFS)
      //传入指定的第一个顶点和处理结果的函数
      Graph.prototype.bfs = function(initV, handler){
        //1.初始化颜色
        let colors = this.initializeColor()

        //2.创建队列
        let que = new Queue()

        //3.将顶点加入到队列中
        que.enqueue(initV)

        //4.循环从队列中取出元素，队列为空才停止
        while(!que.isEmpty()){
          //4.1.从队列首部取出一个顶点
          let v = que.dequeue()

          //4.2.从字典对象edges中获取和该顶点相邻的其他顶点组成的数组
          let vNeighbours = this.edges.get(v)

          //4.3.将v的颜色变为灰色
          colors[v] = 'gray'

          //4.4.遍历v所有相邻的顶点vNeighbours,并且加入队列中
          for (let i = 0; i &lt; vNeighbours.length; i++) {
            const a = vNeighbours[i];
            //判断相邻顶点是否被探测过，被探测过则不加入队列中；并且加入队列后变为灰色，表示被探测过
            if (colors[a] == 'white') {
              colors[a] = 'gray'
              que.enqueue(a)
            }
          }

          //4.5.处理顶点v
          handler(v)

          //4.6.顶点v所有白色的相邻顶点都加入队列后，将顶点v设置为黑色。此时黑色顶点v位于队列最前面，进入下一次while循环时会被取出
          colors[v] = 'black'
        }
      }
</code></pre>
<p><strong>过程详解：</strong></p>
<p>下为指定的第一个顶点为A时的遍历过程：</p>
<ul>
<li>如 a 图所示，将在字典edges中取出的与A相邻的且未被访问过的白色顶点B、C、D放入队列que中并变为灰色，随后将A变为黑色并移出队列；</li>
<li>接着，如图 b 所示，将在字典edges中取出的与B相邻的且未被访问过的白色顶点E、F放入队列que中并变为灰色，随后将B变为黑色并移出队列；<br>
<img src="https://Tyloo-code.github.io/post-images/1614686915234.png" alt="" loading="lazy"></li>
<li>如 c 图所示，将在字典edges中取出的与C相邻的且未被访问过的白色顶点G（A，D也相邻不过已变为灰色，所以不加入队列）放入队列que中并变为灰色，随后将C变为黑色并移出队列；</li>
<li>接着，如图 d 所示，将在字典edges中取出的与D相邻的且未被访问过的白色顶点H放入队列que中并变为灰色，随后将D变为黑色并移出队列。<br>
<img src="https://Tyloo-code.github.io/post-images/1614686933411.png" alt="" loading="lazy"><br>
如此循环直到队列中元素为0，即所有顶点都变黑并移出队列后才停止，此时图中顶点已被全部遍历。</li>
</ul>
<p><strong>测试代码：</strong></p>
<pre><code>   //测试代码
    //1.创建图结构
    let graph = new Graph()

    //2.添加顶点
    let myVertexes = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']
    for (let i = 0; i &lt; myVertexes.length; i++) {
      graph.addVertex(myVertexes[i])
    }

    //3.添加边
    graph.addEdge('A', 'B')
    graph.addEdge('A', 'C')
    graph.addEdge('A', 'D')
    graph.addEdge('C', 'D')
    graph.addEdge('C', 'G')
    graph.addEdge('D', 'G')
    graph.addEdge('D', 'H')
    graph.addEdge('B', 'E')
    graph.addEdge('B', 'F')
    graph.addEdge('E', 'I')
    
    //4.测试bfs遍历方法
    let result = &quot;&quot;
    graph.bfs(graph.vertexes[0], function(v){
      result += v + &quot;-&quot;
    })
    console.log(result);
</code></pre>
<p><strong>测试结果：</strong><br>
<img src="https://Tyloo-code.github.io/post-images/1614686966585.png" alt="" loading="lazy"><br>
可见，安装了广度优先搜索的顺序<strong>不重复</strong>地遍历了<strong>所有</strong>顶点。</p>
<p><code>深度优先搜索</code></p>
<p>广度优先算法的思路：</p>
<ul>
<li>深度优先搜索算法将会从指定的第一个顶点开始遍历图，沿着一条路径遍历直到该路径的最后一个顶点都被访问过为止；</li>
<li>接着沿原来路径回退并探索下一条路径，即<strong>先深后宽</strong>地遍历图中的各个顶点；<br>
<img src="https://Tyloo-code.github.io/post-images/1614687004548.png" alt="" loading="lazy"></li>
</ul>
<p><strong>实现思路：</strong></p>
<ul>
<li>可以使用<strong>栈</strong>结构来实现深度优先搜索算法；</li>
<li>深度优先搜索算法的遍历顺序与二叉搜索树中的先序遍历较为相似，同样可以使用<strong>递归</strong>来实现（递归的本质就是<strong>函数栈</strong>的调用）。</li>
</ul>
<p>基于递归实现深度优先搜索算法：定义dfs方法用于调用递归方法dfsVisit，定义dfsVisit方法用于递归访问图中的各个顶点。</p>
<p>在dfs方法中：</p>
<ul>
<li>首先，调用initializeColor方法将所有顶点初始化为白色；</li>
<li>然后，调用dfsVisit方法遍历图的顶点；</li>
</ul>
<p>在dfsVisit方法中：</p>
<ul>
<li>首先，将传入的指定节点v标注为<strong>灰色</strong>；</li>
<li>接着，处理顶点V；</li>
<li>然后，访问V的相邻顶点；</li>
<li>最后，将顶点v标注为黑色；</li>
</ul>
<p><strong>代码实现：</strong></p>
<pre><code>     //六.实现深度搜索(DFS)
      Graph.prototype.dfs = function(initV, handler){
        //1.初始化顶点颜色
        let colors = this.initializeColor()

        //2.从某个顶点开始依次递归访问
        this.dfsVisit(initV, colors, handler)
      }

      //为了方便递归调用，封装访问顶点的函数，传入三个参数分别表示：指定的第一个顶点、颜色、处理函数
      Graph.prototype.dfsVisit = function(v, colors, handler){
        //1.将颜色设置为灰色
        colors[v] = 'gray'

        //2.处理v顶点
        handler(v)

        //3.访问V的相邻顶点
        let vNeighbours = this.edges.get(v)
        for (let i = 0; i &lt; vNeighbours.length; i++) {
          let a = vNeighbours[i];
          //判断相邻顶点是否为白色，若为白色，递归调用函数继续访问
          if (colors[a] == 'white') {
            this.dfsVisit(a, colors, handler)
          }
          
        }

        //4.将v设置为黑色
        colors[v] = 'black'
      }
</code></pre>
<p><strong>过程详解：</strong></p>
<p>这里主要解释一下代码中的第3步操作：访问指定顶点的相邻顶点。</p>
<ul>
<li>以指定顶点A为例，先从储存顶点及其对应相邻顶点的字典对象edges中取出由顶点A的相邻顶点组成的数组：<br>
<img src="https://Tyloo-code.github.io/post-images/1614687096873.png" alt="" loading="lazy"></li>
<li><strong>第一步</strong>：A顶点变为灰色，随后进入第一个for循环，遍历A白色的相邻顶点：B、C、D；在该for循环的第1次循环中（执行B），B顶点满足：colors == &quot;white&quot;，触发递归，重新调用该方法；</li>
<li><strong>第二步</strong>：B顶点变为灰色，随后进入第二个for循环，遍历B白色的相邻顶点：E、F；在该for循环的第1次循环中（执行E），E顶点满足：colors == &quot;white&quot;，触发递归，重新调用该方法；</li>
<li><strong>第三步</strong>：E顶点变为灰色，随后进入第三个for循环，遍历E白色的相邻顶点：I；在该for循环的第1次循环中（执行I），I顶点满足：colors == &quot;white&quot;，触发递归，重新调用该方法；</li>
<li><strong>第四步</strong>：I顶点变为灰色，随后进入第四个for循环，由于顶点I的相邻顶点E不满足：colors == &quot;white&quot;，停止递归调用。过程如下图所示：<br>
<img src="https://Tyloo-code.github.io/post-images/1614687132186.png" alt="" loading="lazy"></li>
<li><strong>第五步</strong>：递归结束后一路向上返回，首先回到第三个for循环中继续执行其中的第2、3...次循环，每次循环的执行过程与上面的同理，直到递归再次结束后，再返回到第二个for循环中继续执行其中的第2、3...次循环....以此类推直到将图的所有顶点访问完为止。</li>
</ul>
<p>下图为遍历图中各顶点的完整过程：</p>
<ul>
<li><strong>发现</strong>表示访问了该顶点，状态变为<strong>灰色</strong>；</li>
<li><strong>探索</strong>表示既访问了该顶点，也访问了该顶点的全部相邻顶点，状态变为<strong>黑色</strong>；</li>
<li>由于在顶点变为灰色后就调用了处理函数handler，所以handler方法的输出顺序为发现顶点的顺序即：A、B、E、I、F、C、D、G、H 。<br>
<img src="https://Tyloo-code.github.io/post-images/1614687185004.png" alt="" loading="lazy"></li>
</ul>
<p><strong>测试代码：</strong></p>
<pre><code>   //测试代码
    //1.创建图结构
    let graph = new Graph()

    //2.添加顶点
    let myVertexes = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']
    for (let i = 0; i &lt; myVertexes.length; i++) {
      graph.addVertex(myVertexes[i])
    }

    //3.添加边
    graph.addEdge('A', 'B')
    graph.addEdge('A', 'C')
    graph.addEdge('A', 'D')
    graph.addEdge('C', 'D')
    graph.addEdge('C', 'G')
    graph.addEdge('D', 'G')
    graph.addEdge('D', 'H')
    graph.addEdge('B', 'E')
    graph.addEdge('B', 'F')
    graph.addEdge('E', 'I')
    
    //4.测试dfs遍历顶点
    let result = &quot;&quot;
    graph.dfs(graph.vertexes[0], function(v){
      result += v + &quot;-&quot;
    })
    console.log(result);
</code></pre>
<p><strong>测试结果：</strong><br>
<img src="https://Tyloo-code.github.io/post-images/1614687223502.png" alt="" loading="lazy"></p>
<h2 id="26完整实现">2.6.完整实现</h2>
<pre><code>    //封装图结构
    function Graph (){
      //属性：顶点(数组)/边(字典)
      this.vertexes = []  //顶点
      this.edges = new Dictionary() //边

      //方法
      //添加方法
      //一.添加顶点
      Graph.prototype.addVertex = function(v){
        this.vertexes.push(v)
        this.edges.set(v, []) //将边添加到字典中，新增的顶点作为键，对应的值为一个存储边的空数组
      }
      //二.添加边
      Graph.prototype.addEdge = function(v1, v2){//传入两个顶点为它们添加边
        this.edges.get(v1).push(v2)//取出字典对象edges中存储边的数组，并添加关联顶点
        this.edges.get(v2).push(v1)//表示的是无向表，故要添加互相指向的两条边
      }

      //三.实现toString方法:转换为邻接表形式
      Graph.prototype.toString = function (){
        //1.定义字符串，保存最终结果
        let resultString = &quot;&quot;

        //2.遍历所有的顶点以及顶点对应的边
        for (let i = 0; i &lt; this.vertexes.length; i++) {//遍历所有顶点
          resultString += this.vertexes[i] + '--&gt;'
          let vEdges = this.edges.get(this.vertexes[i])
          for (let j = 0; j &lt; vEdges.length; j++) {//遍历字典中每个顶点对应的数组
            resultString += vEdges[j] + '  ';
          }
          resultString += '\n'
        }
        return resultString
      }

      //四.初始化状态颜色
      Graph.prototype.initializeColor = function(){
        let colors = []
        for (let i = 0; i &lt; this.vertexes.length; i++) {
           colors[this.vertexes[i]] = 'white';
        }
        return colors
      }

      //五.实现广度搜索(BFS)
      //传入指定的第一个顶点和处理结果的函数
      Graph.prototype.bfs = function(initV, handler){
        //1.初始化颜色
        let colors = this.initializeColor()

        //2.创建队列
        let que = new Queue()

        //3.将顶点加入到队列中
        que.enqueue(initV)

        //4.循环从队列中取出元素
        while(!que.isEmpty()){
          //4.1.从队列中取出一个顶点
          let v = que.dequeue()

          //4.2.获取和顶点相相邻的其他顶点
          let vNeighbours = this.edges.get(v)

          //4.3.将v的颜色变为灰色
          colors[v] = 'gray'

          //4.4.遍历v所有相邻的顶点vNeighbours,并且加入队列中
          for (let i = 0; i &lt; vNeighbours.length; i++) {
            const a = vNeighbours[i];
            //判断相邻顶点是否被探测过，被探测过则不加入队列中；并且加入队列后变为灰色，表示被探测过
            if (colors[a] == 'white') {
              colors[a] = 'gray'
              que.enqueue(a)
            }
          }

          //4.5.处理顶点v
          handler(v)

          //4.6.顶点v所有白色的相邻顶点都加入队列后，将顶点v设置为黑色。此时黑色顶点v位于队列最前面，进入下一次while循环时会被取出
          colors[v] = 'black'
        }
      }

      //六.实现深度搜索(DFS)
      Graph.prototype.dfs = function(initV, handler){
        //1.初始化顶点颜色
        let colors = this.initializeColor()

        //2.从某个顶点开始依次递归访问
        this.dfsVisit(initV, colors, handler)
      }

      //为了方便递归调用，封装访问顶点的函数，传入三个参数分别表示：指定的第一个顶点、颜色、处理函数
      Graph.prototype.dfsVisit = function(v, colors, handler){
        //1.将颜色设置为灰色
        colors[v] = 'gray'

        //2.处理v顶点
        handler(v)

        //3.访问v相连的其他顶点
        let vNeighbours = this.edges.get(v)
        for (let i = 0; i &lt; vNeighbours.length; i++) {
          let a = vNeighbours[i];
          //判断相邻顶点是否为白色，若为白色，递归调用函数继续访问
          if (colors[a] == 'white') {
            this.dfsVisit(a, colors, handler)
          }
          
        }

        //4.将v设置为黑色
        colors[v] = 'black'
      }
    }
</code></pre>
<br>
<p><a href="https://www.bilibili.com/video/BV1x7411L7Q7?from=search&amp;seid=3912456004602554239">参考资料:JavaScript数据结构与算法</a></p>

            </div>
            
              <div class="reward-btn">
                <div class="reward-btn-text">赞赏</div>
              </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      来碗鸡丁炒饭
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://Tyloo-code.github.io/post/javascript-shi-xian-tu-jie-gou/" title="JavaScript实现图结构">https://Tyloo-code.github.io/post/javascript-shi-xian-tu-jie-gou/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="JavaScript实现排序算法" href="https://Tyloo-code.github.io/post/javascript-shi-xian-pai-xu-suan-fa/">JavaScript实现排序算法</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="JavaScript实现排序算法" href="https://Tyloo-code.github.io/post/javascript-shi-xian-pai-xu-suan-fa/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="JavaScript实现红黑树" href="https://Tyloo-code.github.io/post/javascript-shi-xian-hong-hei-shu/">JavaScript实现红黑树</a>
        <a class="nav-mobile-next" title="JavaScript实现红黑树" href="https://Tyloo-code.github.io/post/javascript-shi-xian-hong-hei-shu/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  
    
      <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>
  var gitalk = new Gitalk({
    clientID: '1d7311971e46d3cb2b7f',
    clientSecret: '825202727778b1d14410ce66b7952398e1213211',
    repo: 'tyloo-code.github.io',
    owner: 'tyloo-code',
    admin: ['tyloo-code'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container')
</script>
    
    
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a
        href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      <a href="http://beian.miit.gov.cn/" target="_blank">京ICP备2020046098号-1</a>
    </div>
  </footer>
  
  
  <div class="pisces back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.onresize = function () {
    calcuHeight();
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, transitionDir, {});
          }
        })
        window.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = "";
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px;border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
            <img id="zfb" class="reward-img" src="\media\images\custom-zfbImg.png" alt="赞赏码">
          
          
            <img id="wx" class="reward-img" src="\media\images\custom-wxImg.png" alt="赞赏码">
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip">打开微信扫一扫，即可进行扫码打赏哦</p>
    </div>
    <div class="bottom">
      
      <div id="zfbBtn" class="pay-text">
        支付宝
      </div>
      
      
      <div id="wxBtn" class="pay-text">
        微信支付
      </div>
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        window.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        window.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        window.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        window.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      window.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      window.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/mian-qian-duan-zhi-shi-dian-shu-li-shou-xie-ti/"" data-c="
          &lt;h1 id=&#34;1-ip地址与整数的相互转换&#34;&gt;1 ip地址与整数的相互转换&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;//IP转成整型
function _ip2int(ip) 
{
    var num = 0;
    ip = ip.split(&amp;quot;.&amp;quot;);
    num = Number(ip[0]) * 256 * 256 * 256 + Number(ip[1]) * 256 * 256 + Number(ip[2]) * 256 + Number(ip[3]);
    num = num &amp;gt;&amp;gt;&amp;gt; 0;
    return num;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;//整型解析为IP地址
function _int2iP(num) 
{
    var str;
    var tt = new Array();
    tt[0] = (num &amp;gt;&amp;gt;&amp;gt; 24) &amp;gt;&amp;gt;&amp;gt; 0;
    tt[1] = ((num &amp;lt;&amp;lt; 8) &amp;gt;&amp;gt;&amp;gt; 24) &amp;gt;&amp;gt;&amp;gt; 0;
    tt[2] = (num &amp;lt;&amp;lt; 16) &amp;gt;&amp;gt;&amp;gt; 24;
    tt[3] = (num &amp;lt;&amp;lt; 24) &amp;gt;&amp;gt;&amp;gt; 24;
    str = String(tt[0]) + &amp;quot;.&amp;quot; + String(tt[1]) + &amp;quot;.&amp;quot; + String(tt[2]) + &amp;quot;.&amp;quot; + String(tt[3]);
    return str;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2-手写原生ajax&#34;&gt;2. 手写原生Ajax&lt;/h1&gt;
&lt;h2 id=&#34;get请求&#34;&gt;Get请求&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const xhr = new XMLHttpRequest()
        xhr.open(&amp;quot;GET&amp;quot;, &amp;quot;http://localhost:3000/users?id=1&amp;quot;)
        xhr.send(null)

        xhr.onreadystatechange = function () {
            if (this.readyState === 4) {
                console.log(this.responseText);
            }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;post请求&#34;&gt;Post请求&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const xhr = new XMLHttpRequest()
        xhr.open(&amp;quot;POST&amp;quot;, &amp;quot;http://localhost:3000/users&amp;quot;)
        xhr.setRequestHeader(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)
        // 转换为json传递
        xhr.send(JSON.stringify({
            &amp;quot;name&amp;quot;: &amp;quot;luke&amp;quot;,
            &amp;quot;age&amp;quot; : 19,
            &amp;quot;class&amp;quot;: 2
        }))

        xhr.onreadystatechange = function () {
            if (this.readyState === 4) {
                console.log(this.responseText);
            }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3-手写实现-bind&#34;&gt;3. 手写实现 bind()&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;Function.prototype.MyBind = function (context, ...args) {
  let self = this;
  return function() {
    return self.apply(context, args);
  }
}

// test
let a = {name: &#39;jack&#39;} 
let test = function() {
  console.log(this.name); // jack
}
let rs = test.MyBind(a);
rs();
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;4-手写实现-apply&#34;&gt;4. 手写实现 apply()&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;Function.prototype.myApply = function (context, args) {
  context.fn = this;
  let res;
  if (!args){
    res = context.fn();
  } else  {
    res = context.fn(...args)
  }
  return res;
}

// test
let obj = {
  name: &#39;jack&#39;
}
function test(arg1, arg2, arg3) {
  console.log(this.name)   // jack
  console.log(arg1, arg2, arg3);  // 1 2 3
}
test.myApply(obj, [1,2,3]);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5-手写实现-call&#34;&gt;5. 手写实现 call()&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;Function.prototype.myCall = function (context, ...rest) {
  context.fn = this;
  var result = context.fn(...rest);
  delete context.fn;
  return result;
}

// test
let obj = {
  name: &#39;jack&#39;
}
function test(arg1, arg2, arg3) {
  console.log(this.name)   // jack
  console.log(arg1, arg2, arg3);  // 1 2 3
}
test.myCall(obj, 1,2,3);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;6-手写实现-instanceof&#34;&gt;6. 手写实现 instanceof&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function myInstanceOf(left, right) {
  let prototype = right.prototype;
  left = left.__proto__;
  while(true) {
    if (!left) return false;
    if (left == prototype) return true;
    left = left.__proto__;
  }
}

console.log(myInstanceOf([], Array));  // true
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;7-手写实现-new&#34;&gt;7. 手写实现 new&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function myNew (fun, ...args) {
  let obj = {};
  obj.__proto__ = fun.prototype;
  let res = fun.apply(obj, args);
  return res instanceof Object ? res : obj;
}

function Animal(name) {
  this.name = name;
}
let animal = myNew(Animal, &#39;dog&#39;);
console.log(animal.name)  // dog
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;8-手写实现-jsonp&#34;&gt;8. 手写实现 jsonp&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;var newscript = document.createElement(&#39;script&#39;);
newscript.src = &#39;https://www.adb.com?callback=fn&#39;
document.body.appendChild(newscript);
function fn(data) {
  console.log(data);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;9-手写实现-promise&#34;&gt;9. 手写实现 Promise&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const PENDING = Symbol();
const REJECTED = Symbol();
const FULLFILLED = Symbol();

const MyPromise = function(fn) {
  this.state = PENDING;
  this.value = &#39;&#39;;

  const resolve = (value) =&amp;gt; {
    this.state = FULLFILLED;
    this.value = value;
  }

  const reject = (error) =&amp;gt; {
    this.state = REJECTED;
    this.value = error;
  }

  this.then = (onFullFill, onReject) =&amp;gt; {
    if (this.state == FULLFILLED) {
      onFullFill(this.value);
    } else {
      onReject(this.value);
    }
  }

  try {
    fn(resolve, reject);
  } catch(error) {
    reject(error);
  }
}

// test
let p = new MyPromise((resolve, reject) =&amp;gt; {
  resolve(&#39;hello&#39;);
})
p.then(res =&amp;gt; {
  console.log(res);  // hello
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;10-手写实现promiseall&#34;&gt;10. 手写实现promise.all()&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function isPromise(obj) {
  return !!obj &amp;amp;&amp;amp; (typeof obj === &#39;function&#39; || typeof obj === &#39;object&#39;) &amp;amp;&amp;amp; typeof obj.then == &#39;function&#39;;
}

function myPromiseAll(arr) {
  let res = []
  return new Promise((resolve, reject) =&amp;gt; {
    for (let i = 0; i &amp;lt; arr.length; i++) {
      if (isPromise(arr[i])) {
        arr[i].then(data =&amp;gt; {
          res[i] = data;
          if (res.length === arr.length) {
            resolve(res)
          }
        }).catch(error =&amp;gt; {
          reject(error)
        })
      } else {
        res[i] = arr[i];
      }
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;11-手写实现promiserace&#34;&gt;11. 手写实现promise.race()&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function myPromiseRace(arr) {
  return new Promise((resolve, reject) =&amp;gt; {
    for (let i = 0; i &amp;lt; arr.length; i++) {
      return arr[i].then(resolve, reject)
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;12-手写实现eventemitter-订阅监听模式&#34;&gt;12. 手写实现EventEmitter 订阅监听模式&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;class EventEmitter {
  constructor() {
    this.events = {};
  }
  on (eventName, callback) {
    if(!this.events[eventName]) {
      this.events[eventName] = [callback];
    } else {
      this.events[eventName].push(callback);
    }
  }

  emit(eventName, ...args) {
    this.events[eventName].forEach(fn =&amp;gt; fn.apply(this, args));
  }

  once(eventName, callback) {
    const fn = () =&amp;gt; {
      callback();
      this.remove(eventName, fn);
    }
    this.on(eventName, fn)
  }

  remove(eventName, callback) {
    this.events[eventName] = this.events[eventName].filter(fn =&amp;gt; fn != callback);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;13-手写settimout-实现-setinterval&#34;&gt;13. 手写setTimout 实现 setInterval&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function myInterval(fn, time) {
  let context = this;
  setTimeout(() =&amp;gt; {
    fn.call(context);
    myInterval(fn, time);
  }, time);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;14-手写实现深拷贝&#34;&gt;14. 手写实现深拷贝&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function deepClone(obj) {
  // 先判断是对象还是数组
  let copy = obj instanceof Array ? [] : {};
  for (let key in obj) {
    // 判断是否是对象上的属性，而不是原型上的属性
    if (obj.hasOwnProperty(key)) {
      // obj[key] 是否是对象，如果是对象，递归遍历
      copy[key] = typeof obj[key] === &#39;object&#39; ? deepClone(obj[key]) : obj[key];
    }
  }
  return copy;
}

// test
console.log(deepClone({name: &#39;jack&#39;, birth: {year: &#39;1997&#39;, month: &#39;10&#39;}})) // {name: &#39;jack&#39;, birth: {…}}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;15-手写实现浅拷贝&#34;&gt;15. 手写实现浅拷贝(...)&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;let obj = {
   a: 100,
   b: [100, 200, 300],
   c: {
      x: 10
   },
   d: /^\d+$/
}
let obj2 = {...obj};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;16-手写实现数组拍平&#34;&gt;16. 手写实现数组拍平&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;var flatten = function(arr) {
  let res = [];
  for (let i = 0; i &amp;lt; arr.length; i++) {
    if (Array.isArray(arr[i])) {
      res = res.concat(flatten(arr[i]))
    } else {
      res.push(arr[i])
    }
  }
  return res;
}

console.log(flatten([1,[1,2,[2,4]],3,5]));  // [1, 1, 2, 2, 4, 3, 5]
&lt;/code&gt;&lt;/pre&gt;
">【面】前端知识点梳理（手写题）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/mian-qian-duan-zhi-shi-dian-shu-li-gong-ju-yu-zu-jian/"" data-c="
          &lt;h1 id=&#34;1-webpack打包原理&#34;&gt;1. webpack打包原理&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615517470320.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1几个关键词&#34;&gt;1.几个关键词&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Entry：入口，Webpack 执行构建的第一步将从 Entry 开始，来找出直接或者间接依赖的文件。&lt;/li&gt;
&lt;li&gt;Output： 出口，规定webpack输出的bundles的路径以及文件名，默认为 ./dist&lt;/li&gt;
&lt;li&gt;Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。&lt;/li&gt;
&lt;li&gt;Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。&lt;/li&gt;
&lt;li&gt;Loader：模块转换器，用于把模块原内容按照需求转换成 webpack 能处理的有效模块&lt;/li&gt;
&lt;li&gt;Plugin：扩展插件，在 webpack 构建流程中的特定时机会广播出对应的事件，插件可以监听这些事件的发生，在特定时机做对应的事情。插件的范围包括从打包优化和压缩，一直到重新定义环境中的变量，可扩展功能丰富。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-webpack-的构建流程&#34;&gt;2. Webpack 的构建流程：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler。&lt;/li&gt;
&lt;li&gt;编译：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理。&lt;/li&gt;
&lt;li&gt;输出：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-loader&#34;&gt;3. loader&lt;/h2&gt;
&lt;p&gt;loader是用来处理各种形式的资源，本质上是一个函数, 接受文件作为参数，返回转化后的结构&lt;/p&gt;
&lt;p&gt;一个loader只做一种转换，比如解析less文件，less建立在css基础上，先解析less，再转为css，再插入到head&lt;/p&gt;
&lt;p&gt;注意：&lt;code&gt;loader&lt;/code&gt; 的调用是&lt;code&gt;链式&lt;/code&gt;调用，&lt;code&gt;从后往前&lt;/code&gt;，所以先写 style-loader 再写 css-loader，less-loader 在最后，执行时先用less-loader将less文件转化为css，再由 css-loader 解析css文件转成对象，传递给 style-loader 插入到 head&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module.exports={
    entry:{...},
    outpath:{path:...,filename:...},
    mode:&#39;production&#39;,
    module:{
        rules:[
            {
                test:/\.less$/,
                use:[
                &#39;style-loader&#39;,
                &#39;css-loader&#39;,
                &#39;less-loader&#39;
                ]
            },
        ]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-常用插件&#34;&gt;4. 常用插件&lt;/h2&gt;
&lt;p&gt;【常用插件】&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ExtractTextPlugin ：从bundle 中提取特定的text到一个文件中。&lt;/li&gt;
&lt;li&gt;DefinePlugin :允许创建一个在编译时可以配置的全局变量，这使得一个应用可以打包编译出多个不同的应用。webpack 在打包编译时会对变量直接做文本替换，所以给定的字符串必须包含字符串本省的实际引号。JSON.string()。&lt;/li&gt;
&lt;li&gt;ProvidePlugin 插件，自动加载对应的模块，而不需要到处 通过import 或者 require 引入。&lt;/li&gt;
&lt;li&gt;CopyWebpackPlugin：将单个文件或者整个目录复制到构建目录&lt;/li&gt;
&lt;li&gt;HtmlWebpackPlugin 简化了 HTML 文件的创建，为应用生成一个 index.html，并添加一个script 脚本标签来加载生成的 bundle.js&lt;/li&gt;
&lt;li&gt;BudlieAnalyzerPlugin: 可视化的webpack 打包后文件的分析插件，作用：1.认识打包后的文件和大小；2.以便优化打包后的文件&lt;/li&gt;
&lt;li&gt;CommonsChunkPlugin :从 bundle中分离出公共的模块，便于缓存使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-热更新&#34;&gt;5. 热更新&lt;/h2&gt;
&lt;p&gt;现象就是你修改代码保存之后，浏览器不会刷新，只会修改你更改过的依赖代码。我们平时用webpack-dev-server如果没有配置，是直接刷新浏览器，并不是热更新。&lt;/p&gt;
&lt;p&gt;大概流程是我们用webpack-dev-server启动一个服务之后，浏览器和服务端是通过websocket进行长连接，webpack内部实现的watch就会监听文件修改，只要有修改就webpack会重新打包编译到内存中，然后webpack-dev-server依赖中间件webpack-dev-middleware和webpack之间进行交互，每次热更新都会请求一个携带hash值的json文件和一个js，websocker传递的也是hash值，内部机制通过hash值检查进行热更新， 至于内部原理，因为水平限制，目前还看不懂。&lt;/p&gt;
&lt;h2 id=&#34;6-优化构建速度&#34;&gt;6. 优化构建速度&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;优化Loader配置&lt;/strong&gt;&lt;br&gt;
Loader处理文件的转换操作是很耗时的，所以需要让尽可能少的文件被Loader处理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优化resolve.modules配置&lt;/strong&gt;&lt;br&gt;
resolve.modules用于配置webpack去哪些目录下寻找第三方模块，默认是[&#39;node_modules&#39;]，但是，它会先去当前目录的./node_modules查找，没有的话再去../node_modules最后到根目录；&lt;code&gt;所以第三方库安到根目录下&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优化resolve.extensions配置&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;频率出现高的文件后缀优先放在前面；&lt;/li&gt;
&lt;li&gt;列表尽可能的小；&lt;/li&gt;
&lt;li&gt;书写导入语句时，尽量写上后缀名&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2-原生js实现轮播图&#34;&gt;2. 原生js实现轮播图&lt;/h1&gt;
&lt;h2 id=&#34;步骤一建立html基本布局&#34;&gt;步骤一：建立html基本布局&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;轮播图&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;wrap&amp;quot; style=&amp;quot;left:-600px;&amp;quot;&amp;gt;
            &amp;lt;img src=&amp;quot;./img/5.jpg&amp;quot; alt=&amp;quot;&amp;quot;&amp;gt;
            &amp;lt;img src=&amp;quot;./img/1.jpg&amp;quot; alt=&amp;quot;&amp;quot;&amp;gt;
            &amp;lt;img src=&amp;quot;./img/2.jpg&amp;quot; alt=&amp;quot;&amp;quot;&amp;gt;
            &amp;lt;img src=&amp;quot;./img/3.jpg&amp;quot; alt=&amp;quot;&amp;quot;&amp;gt;
            &amp;lt;img src=&amp;quot;./img/4.jpg&amp;quot; alt=&amp;quot;&amp;quot;&amp;gt;
            &amp;lt;img src=&amp;quot;./img/5.jpg&amp;quot; alt=&amp;quot;&amp;quot;&amp;gt;
            &amp;lt;img src=&amp;quot;./img/1.jpg&amp;quot; alt=&amp;quot;&amp;quot;&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;buttons&amp;quot;&amp;gt;
            &amp;lt;span&amp;gt;1&amp;lt;/span&amp;gt;
            &amp;lt;span&amp;gt;2&amp;lt;/span&amp;gt;
            &amp;lt;span&amp;gt;3&amp;lt;/span&amp;gt;
            &amp;lt;span&amp;gt;4&amp;lt;/span&amp;gt;
            &amp;lt;span&amp;gt;5&amp;lt;/span&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;a href=&amp;quot;javascript:;&amp;quot; class=&amp;quot;arrow arrow_left&amp;quot;&amp;gt;&amp;amp;lt;&amp;lt;/a&amp;gt;
        &amp;lt;a href=&amp;quot;javascript:;&amp;quot; class=&amp;quot;arrow arrow_right&amp;quot;&amp;gt;&amp;amp;gt;&amp;lt;/a&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只有五张图片，却使用7张来轮播，这是为了实现无缝轮播&lt;/p&gt;
&lt;h2 id=&#34;步骤二-css布局&#34;&gt;步骤二： css布局&lt;/h2&gt;
&lt;p&gt;首先，resetcss，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* {
            margin:0;
            padding:0;
        }
        a{
            text-decoration: none;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着，我们为了让图片只在container中，所以需要限定其宽度和高度并且使用overflow:hidden；将其余的图片隐藏起来，并且我们希望wrap相对于container左右移动，所以设置为relative，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.container {
            position: relative;
            width: 600px;
            height: 400px;
            margin:100px auto 0 auto;
            box-shadow: 0 0 5px green;
            overflow: hidden;
        }            
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们设置wrap是绝对定位的，所以,我们就可以通过控制Left和Right来控制图片的移动了。设置z-index:1;以对后面将要放置的buttons作为参考。 因为共有七张图片，所以width为4200px（每张图片我们设置为600X400）,我们只需让图片左浮动即可实现占满一排了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; .wrap {
            position: absolute;
            width: 4200px;
            height: 400px;
            z-index: 1;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后我们把图片设置位左浮动，并限定其大小，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    .container .wrap img {
            float: left;
            width: 600px;
            height: 400px;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即这时已经显示出了第一张图片。并且充满了整个container(container是有box-shadow的);&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615789086547.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
然后我们把显示次序的buttons放在图片的右下角。并且设置z-index:2;以保证buttons是在图片的上面&lt;br&gt;
的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; .container .buttons {
            position: absolute;
            right: 150px;
            bottom:20px;
            width: 100px;
            height: 10px;
            z-index: 2;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后将buttons下面的span做一个简单的修饰，并且给和图片对应的span设置一个on类，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.container .buttons span {
            margin-left: 5px;
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: green;
            text-align: center;
            color:white;
            cursor: pointer;
        }
        .container .buttons span.on{
            background-color: red;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来，我们把左右切换的箭头加上，然后做简单的修饰，注意：因为这里使用实体来表示左右箭头，所以设置font-size才能改变其大小，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; .container .arrow {
            position: absolute;
            top: 35%;
            color: green;
            padding:0px 14px;
            border-radius: 50%;
            font-size: 50px;
            z-index: 2;
            display: none;
        }
        .container .arrow_left {
            left: 10px;
        }
        .container .arrow_right {
            right: 10px;
        }
        .container:hover .arrow {
            display: block;
        }
        .container .arrow:hover {
            background-color: rgba(0,0,0,0.2);
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;步骤三添加js逻辑&#34;&gt;步骤三：添加js逻辑&lt;/h2&gt;
&lt;p&gt;我们首先获取到 wrap（因为要设置其left才能控制轮播图），然后获取到左右两个箭头，并实现手动轮播，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var wrap = document.querySelector(&amp;quot;.wrap&amp;quot;);
        var next = document.querySelector(&amp;quot;.arrow_right&amp;quot;);
        var prev = document.querySelector(&amp;quot;.arrow_left&amp;quot;);
        next.onclick = function () {
            next_pic();
        }
        prev.onclick = function () {
            prev_pic();
        }
        function next_pic () {
            var newLeft = parseInt(wrap.style.left)-600;
            wrap.style.left = newLeft + &amp;quot;px&amp;quot;;
        }
        function prev_pic () {
            var newLeft = parseInt(wrap.style.left)+600;
            wrap.style.left = newLeft + &amp;quot;px&amp;quot;;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;值得注意的是，这里wrap.style.left是一个字符串，所以要转化为数字才能进行计算，而设定left时就要加上px成为一个字符串了。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615789317683.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看到，在第一页时，left值为-600，所以我们可以点击一次上一张，但是当再点击一次时，就出现了空白。同样的，下一张点击，到-3600是最后一张，就不能再继续点击了。　　&lt;br&gt;
&lt;strong&gt;也就是说，当我们点击下一张到-3600px（这是第一张图片）时，我们需要下次跳转到第二张，即-1200px；这样才能正常跳转；&lt;/strong&gt;&lt;br&gt;
同理，当我们点击上一张到0px（这是第五张图片时），我们希望下次跳转到第四张，即-2400px；&lt;br&gt;
按照这样的思路我们重新将next_pic和prev_pic函数修改如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function next_pic () {
            var newLeft;
            if(wrap.style.left === &amp;quot;-3600px&amp;quot;){
                newLeft = -1200;
            }else{
                newLeft = parseInt(wrap.style.left)-600;
            }
            wrap.style.left = newLeft + &amp;quot;px&amp;quot;;
        }
        function prev_pic () {
            var newLeft;
            if(wrap.style.left === &amp;quot;0px&amp;quot;){
                newLeft = -2400;
            }else{
                newLeft = parseInt(wrap.style.left)+600;
            }
            wrap.style.left = newLeft + &amp;quot;px&amp;quot;;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是，这时我们仅仅时手动循环播放的，我们如果希望自动播放，使用setInterval()即可，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; var timer = null;
        function autoPlay () {
            timer = setInterval(function () {
                next_pic();
            },1000);
        }
        autoPlay();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即先设定一个计时器，然后创建一个可以自动播放的函数，最后调用这个函数即可。 现在它就可以自动播放了，效果如下：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615789447895.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
但是如果我们想要仔细看其中一个图片的时候，我们希望轮播图停止播放，只要clearInterval()即可，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
        var container = document.querySelector(&amp;quot;.container&amp;quot;);
        container.onmouseenter = function () {
            clearInterval(timer);
        }
        container.onmouseleave = function () {
            autoPlay();    
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原理很简单，即设置buttons的index初始值为0，即第一个span的class为on，然后触发next_pic函数时，index加1，当触发prev_pic函数时，inex减1， 并设置当前index的小圆点的class为on， 这就要求index必须设置为全局变量，才能保证它在每一个函数的作用域中。&lt;/p&gt;
&lt;p&gt;添加showCurrentDot函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; var index = 0;
        var dots = document.getElementsByTagName(&amp;quot;span&amp;quot;);
        function showCurrentDot () {
            for(var i = 0, len = dots.length; i &amp;lt; len; i++){
                dots[i].className = &amp;quot;&amp;quot;;
            }
            dots[index].className = &amp;quot;on&amp;quot;;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在next_pic中添加代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;            index++;
            if(index &amp;gt; 4){
                index = 0;
            }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在prev_pic中添加代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;            index--;
            if(index &amp;lt; 0){
                index = 4;
            }
            showCurrentDot();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样，轮播图就可以自动切换，并且小圆点也在随着图片的变化而变化了。&lt;/p&gt;
&lt;p&gt;但是，这距离我们经常看到的轮播图还有一定距离 - - - 当点击小圆点时， 就可跳转到相应图片。 实现原理即：  点击小圆点，就使wrap的Left变成相应的值。代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (var i = 0, len = dots.length; i &amp;lt; len; i++){
            (function(i){
                dots[i].onclick = function () {
                    var dis = index - i;
                    if(index == 4 &amp;amp;&amp;amp; parseInt(wrap.style.left)!==-3000){
                        dis = dis - 5;     
                    }
                    //和使用prev和next相同，在最开始的照片5和最终的照片1在使用时会出现问题，导致符号和位数的出错，做相应地处理即可
                    if(index == 0 &amp;amp;&amp;amp; parseInt(wrap.style.left)!== -600){
                        dis = 5 + dis;
                    }
                    wrap.style.left = (parseInt(wrap.style.left) +  dis * 600)+&amp;quot;px&amp;quot;;
                    index = i;
                    showCurrentDot();
                }
            })(i);            
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原理就是当点击到小圆点时，得到相应的i值，这个i值也就是span的index值，我们拿他和全局变量index作比较，然后重新设置wrap.style.left的值，然后把i值复制给全局变量index，最后显示当前的小原点即可。值得注意的是：这里涉及到了闭包的概念，如果直接使用for循环，则不能得到正确的结果。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615789605021.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-排序算法&#34;&gt;3. 排序算法&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;实现枢纽选择：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//交换两个位置的数据
let swap = function(arr, m, n){
    let temp  = arr[m]
    arr[m] = arr[n]
    arr[n] = temp
}

//快速排序
//1.选择枢纽
let median = function(arr){
  //1.取出中间的位置
  let center = Math.floor(arr.length / 2)
  let right = arr.length - 1 
  let left = 0

  //2.判断大小并进行交换
  if (arr[left] &amp;gt; arr[center]) {
    swap(arr, left, center)
  }
  if (arr[center] &amp;gt; arr[right]){
    swap(arr, center, right)
  }
  if (arr[left] &amp;gt; arr[right]) {
    swap(arr, left, right)
  }
  //3.返回枢纽
  return center
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;快速排序代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//2.快速排序
let QuickSort = function(arr){
  if (arr.length == 0) {
    return []
  }
  let center = median(arr)
  let c = arr.splice(center, 1)
  let l = []
  let r = []

  for (let i = 0; i &amp;lt; arr.length; i++) {
      if (arr[i] &amp;lt; c) {
        l.push(arr[i])
      }else{
        r.push(arr[i])
      }        
  }
  return QuickSort(l).concat(c, QuickSort(r))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;4-二叉树的先序中序后序遍历&#34;&gt;4. 二叉树的先序，中序，后序遍历&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function TreeNode(x){
    this.val=val;
    this.left=null;
    this.right=null;
}
// 递归方法
function threeOrders(root){
    let preArray=[],middleArray=[],lastArray=[];
    //先序遍历：根、左、右
    function preOrder(root){
        if(root){
            preArray.push(root.val);
            preOrder(root.left);
            preOrder(root.right);
        }
    }
    //中序遍历 ： 左 根 右   
    function inOrder(root){
            if(root){
                inOrder(root.left)
                middleArray.push(root.val);
                inOrder(root.right);
            }
    }
    //后序遍历：左右根
    function lastOrder(root){
        if(root){
            lastOrder(root.left);
            lastOrder(root.right);
            lastArray.push(root.val);
        }
    }
    preOrder(root);
    inOrder(root);
    lastOrder(root);
    return [preArray,middleArray,lastArray]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5-加油站问题贪心算法&#34;&gt;5. 加油站问题(贪心算法)&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;基本要素：&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;贪心选择&lt;/code&gt;：在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。&lt;br&gt;
&lt;code&gt;最优子结构&lt;/code&gt;：当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。&lt;/p&gt;
&lt;h2 id=&#34;汽车加油问题&#34;&gt;汽车加油问题&lt;/h2&gt;
&lt;p&gt;一辆汽车加满油后可行驶 n公里。旅途中有若干个加油站。设计一个有效算法，指出应 在哪些加油站停靠加油，使沿途加油次数最少。&lt;/p&gt;
&lt;h2 id=&#34;输入格式&#34;&gt;输入格式:&lt;/h2&gt;
&lt;p&gt;第一行有 2 个正整数n和 k（k&amp;lt;=1000 )，表示汽车加满油后可行驶n公里，且旅途中有 k个加油站。 第二行有 k+1 个整数，表示第 k 个加油站与第k-1 个加油站之间的距离。 第 0 个加油站表示出发地，汽车已加满油。 第 k+1 个加油站表示目的地。&lt;/p&gt;
&lt;h2 id=&#34;输出格式&#34;&gt;输出格式:&lt;/h2&gt;
&lt;p&gt;输出最少加油次数。如果无法到达目的地，则输出“No Solution!”。&lt;/p&gt;
&lt;h2 id=&#34;贪心性质分析&#34;&gt;贪心性质分析：&lt;/h2&gt;
&lt;p&gt;找到汽车满油量时可以行驶的最大路程范围内的最后一个加油站，加油后则继续用此方法前进。需要检查每一小段路程是否超过汽车满油量时的最大支撑路程。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function greedy(n, k, arr){ // n:加满可以行驶的公里数; k:加油站数量; arr:每个加油站之间的距离数组
  　　if (n == 0 || k == 0 || arr.length == 0 || arr[0] &amp;gt; n) {
  　　return &amp;quot;No Solution!&amp;quot;; // arr[0] &amp;gt; n ：如果第一个加油站距离太远，也无法到达
  　　};
  
  　　let res = 0, distance = 0; // res：加油次数;distance：已行驶距离
  　　for(let i = 0; i &amp;lt;= k; i++){
  　　distance += arr[i];
  　　if (distance &amp;gt; n) { // 已行驶距离 &amp;gt; 加满可以行驶的公里数
   　 if(arr[i] &amp;gt; n){ // 如果目前加油站和前一个加油站的距离 &amp;gt; 加满可以行驶的公里数，则无法到达
   　 return &amp;quot;No Solution!&amp;quot;;
  　　};
  
  　　// 可以在上一个加油站加油，行驶到目前的加油站i：
  　　distance = arr[i];
  　　res++; // 加油次数+1
  　　}
  　}
  　　return res;
  }
  
  　　let arr = [1,2,3,4,5,1,6,6];
  　　console.log(greedy(7,7,arr)) // 4
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;6-二分法数组查找&#34;&gt;6. 二分法数组查找&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;二分法实现原理：二分查找可以解决已经排好序数组的查找问题：只要数组中包含target（即要查找的值），那么通过不断缩小包含target数组的范围，最终就可以找到它。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function indexOf(arr,target,start,end){
	 start = start || 0;
	 end = end || arr.length - 1;
	 if(start &amp;gt; end){
	 	return -1;
	 }
	let mid = Math.floor((start + end)/2);
		if(arr[mid] &amp;gt; target) {
			end = mid-1;
			return indexOf(arr,target,start,end);
		}
		else if(arr[mid] &amp;lt; target){
			start = mid + 1;
			return indexOf(arr,target,start,end);
		}
		else {
			return mid;
		}
}
let a = [0,1,2,3,4,5,6,434,435];
console.log(indexOf(a,12));     //打印结果为-1
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;7-反转单链表&#34;&gt;7. 反转单链表&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;var reverseList = function (head) {
    // 闭包
    if (head === undefined || head === null) return null
    var originalHead = head
    var reverseHead
    var reverse = function (head) {
        if (head.next === null) {
            reverseHead = head
            return head
        } else {
            var node = reverse(head.next)
            node.next = head
            if (originalHead === head) {
                head.next = null
                return reverseHead
            } else {
                return head
            }
        }
    }
    return reverse(head)
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;8-取出1000内所有质数&#34;&gt;8. 取出1000内所有质数&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;let num = 1000;
	let res_arr = []; 
	for (var i = 1; i &amp;lt; num; i++) {
		let e = i;
		let noDivision = !divisionItem(res_arr, e)
		if (e != 1 &amp;amp;&amp;amp; noDivision) {
			res_arr.push(e)
		}
	}

	console.log(res_arr);

	// 每一个数字 和已有的自然数进行对比是否可以整除
	function divisionItem(arr, item) {
		let res = false;
		for (var i = 0; i &amp;lt; arr.length; i++) {
			let e = arr[i];
			if (item % e === 0) {
				res = true
				break;
			}
		}
		return res;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;9-找出数组中和为给定值的两个元素&#34;&gt;9. 找出数组中和为给定值的两个元素&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function sameSum(arr, num){
  for (var i =0 ;i&amp;lt;arr.length;i++){
      for (var j = i+1;j&amp;lt;arr.length;j++){
          if (arr[i]+arr[j]==num){
              console.log(&#39;数组中两个元素和为&#39;+num+&#39;的两个数为：&#39;+arr[i]+&#39;和&#39;+arr[j]);
              break;
          }
          //break;
          //如果只要输出一组这样的组合就只要在内层循环里break就可以
      }
  }
}
var arr =[1,2,3,4];
sameSum(arr,5);
&lt;/code&gt;&lt;/pre&gt;
">【面】前端知识点梳理（工具与算法）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/mian-qian-duan-zhi-shi-dian-shu-li-vue/"" data-c="
          &lt;h1 id=&#34;1-vue解决了什么问题&#34;&gt;1. vue解决了什么问题&lt;/h1&gt;
&lt;p&gt;要回答这个问题，要先理解核心知识点：组件化&lt;/p&gt;
&lt;p&gt;组件化就是一种代码设计理念。最开始的面向过程编程使一个文件的代码特别多，难以维护，所以借鉴了后端的面向对象编程，使一个本需要几千行代码的文件可以被拆分成几个几百行的文件。&lt;/p&gt;
&lt;p&gt;一个组件就是一个类 new 出来的一个对象，是一个页面的一个部分，一个组件要负责这一部分的 CSS 展示，DOM 节点的设计，以及 JS 的逻辑。合理拆解组件可以提升代码的可读性以及可维护性，将组件间共性抽离出一个通用组件，让子组件去继承这个通用组件，可以少写很多代码，最小的组件颗粒度是一个元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组件化的演进 ：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1）Angular 提出了通过面向数据编程，不用操作 DOM，但是刚出来时，性能上有瓶颈&lt;br&gt;
2）React 引入了虚拟 DOM 机制，将 DOM 的比对换成了 JS 的比对，加了diff 算法，慢慢的性能的问题就解决了，前端开始大量使用 MVVM 和 MVC 这种框架了。&lt;br&gt;
3）&lt;code&gt;vue 是一个轻量级的 MVVM 模式的框架&lt;/code&gt;，vue 引入虚拟 DOM 的目的跟 React 不同，后者是为了解决性能问题，前者是为了让&lt;code&gt;组件高度抽象化&lt;/code&gt;（虚拟 DOM 使渲染过程抽象化了）。其主要作用是使前端开发变得简单，它的设计模式让没有组件化思维的使用者也在用组件化作开发，所以写的代码不会太差。&lt;br&gt;
PS：如果对前面两个框架不熟悉的话，最好不要在面试时提到它们，否则有被继续问的风险，只谈 vue 就好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;另外 Vue 的一个优势是&lt;code&gt;速度快&lt;/code&gt;，当我们改变数据后，会引起页面重新渲染，引起的重排和重绘的代价是高昂的，有可能会破坏用户体验，让 UI 展示迟缓，重排会引起周围的 DOM 重新排列，这个范围可能是全局也可能是局部，重排的性能花销跟有多少 DOM 节点需要重新构建有关系，因此应该尽可能减少重排的次数，以及它波及的范围。&lt;br&gt;
那么 Vue 将&lt;code&gt;数据更新引起的 watcher 回调放入到 nextTick&lt;/code&gt;中（是一个微任务，当执行栈为空时，就从微任务中一次性拿取所有任务），并且同一个 watcher 只会放入一次，也就是说在当前的事件循环中，无论一个响应式数据改变多少次，&lt;code&gt;最终都只会渲染一次&lt;/code&gt;，nextTick 在下面有讲解。&lt;br&gt;
要了解这段知识点要具备这些基础知识：浏览器渲染过程、JS 运行机制、异步任务、Vue 的双向绑定。确实所有知识都是从基础知识而来的，所以学框架最终就是对基础知识有更深入的理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;2mvvm-的理解&#34;&gt;2.MVVM 的理解&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;回答思路：先聊下 MVC，再聊下 MVVM 的定义，最后进行对比。&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615468604645.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;View 传送指令到 Controller&lt;br&gt;
Controller 完成业务逻辑后，要求 Model 改变状态&lt;br&gt;
Model 将新的数据发送到 View，用户得到反馈&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所有通信都是单向的。MVC 接收用户指令，可以先通过 View 来接收，然后传递给 Controller，也可以直接通过 Controller 来接收指令。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615468656209.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;ViewModel 和 View 之间是通过双向绑定来实现数据的变更&lt;br&gt;
ViewModel 和 Model 之间是浏览器通过 ajax 跟服务器相互通信的过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这两个通信是双向的，且 View 和 Model 之间没有通信。&lt;/p&gt;
&lt;p&gt;MVVM 模式的出现是因为很多后端的代码放到了前端（大前端的到来），前端的代码可维护性、可扩展性以及安全性出现了问题，随着前端框架的演变才有了 MVVM 模式，MVVM 模式和 MVC 模式主要区别在于让开发者的注意力从对 DOM 的操作上，转移到对数据的管理上，即数据是什么，视图就展示什么，使前后端分离更容易，并大大提升了开发效率和代码的可维护性。&lt;/p&gt;
&lt;h1 id=&#34;3-双向绑定的原理数据劫持&#34;&gt;3. 双向绑定的原理？数据劫持？&lt;/h1&gt;
&lt;p&gt;Vue.js是通过&lt;code&gt;数据劫持&lt;/code&gt;以及结合&lt;code&gt;发布者-订阅者&lt;/code&gt;来实现双向绑定的，数据劫持是利用ES5的Object.defineProperty(obj, key, val)来劫持各个属性的的setter以及getter，在数据变动时发布消息给订阅者，从而触发相应的回调来更新视图。&lt;/p&gt;
&lt;p&gt;双向数据绑定，简单点来说分为三个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、Observer：观察者，这里的主要工作是递归地监听对象上的所有属性，在属性值改变的时候，触发相应的watcher。&lt;/li&gt;
&lt;li&gt;2、Watcher：订阅者，当监听的数据值修改时，执行响应的回调函数（Vue里面的更新模板内容）。&lt;/li&gt;
&lt;li&gt;3、Dep：订阅管理器，连接Observer和Watcher的桥梁，每一个Observer对应一个Dep，它内部维护一个数组，保存与该Observer相关的Watcher。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615469169345.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
反向是页面数据的变化映射到 data 中，通过 input 事件监听 input 框数据的改变，JS 得到通知再赋值给 data，只是 VM 框架使手动的过程自动化了。&lt;/p&gt;
&lt;p&gt;正向是数据驱动页面，通过 Object.defineProperty() 这个核心 API，将所有数据变成响应式数据，当访问到一个响应式数据时，就会触发它的 getter 函数，收集依赖，当一个响应式数据变化时，就会触发 setter 函数，通知依赖使视图得到更新。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615711862629.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;4-nexttick&#34;&gt;4. nextTick&lt;/h1&gt;
&lt;p&gt;nextTick 把要执行的任务&lt;code&gt;推入&lt;/code&gt;到一个&lt;code&gt;队列&lt;/code&gt;中，在下一个 tick 同步执行队列的所有任务，它是异步任务中的微任务。（关于 JS 的运行机制，这是基础知识，篇幅有限）&lt;/p&gt;
&lt;p&gt;在 Vue 中，不是每一次数据的改变都会触发所有 wather 的回调，而是将这些回调推入到一个队列中，相同的 id 的 watcher 的回调不会被重复添加，然后在下一个 tick 中再执行这些回调，因此重新渲染是异步的。这么做的好处是：比如我们写了一个将某个响应式数据不断加 1 直到 1000 的代码块，那么视图只会重新渲染一次，即从 0 到 1000，而不是重新渲染 1000 次，这是一种有效的优化手段。&lt;/p&gt;
&lt;p&gt;如果我们在更新了一个响应式数据后，需要同步拿到这个渲染后的 DOM 结果，那么就使用 $nextTick 这个方法，异步拿到这个结果。&lt;/p&gt;
&lt;p&gt;使用方式有两个：&lt;code&gt;回调方式和 Promise 方式&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;this.$nextTick(cb)
this.$nextTick().then(cb)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请注意第一种方式的使用，虽然它们都是异步执行的，但是如果你将第一种方式放在响应式数据更新的前面，那么你拿到的将是老的 DOM 结果。&lt;/p&gt;
&lt;p&gt;因为 wather 的回调函数是在 nextTick 之后执行的，使用第一种方式 wather 的回调函数将和 this.$nextTick(cb) 中的 cb 同步执行，你将它放在响应式数据更新之前的话，会先执行这个 cb，所以拿到的是未被重新渲染的 DOM 结果，而如果是放在之后，你就能拿到被重新渲染的 DOM 结果。而第二种方式的 cb 跟 watcher 的回调函数是异步执行的，所以没有顺序问题。&lt;/p&gt;
&lt;h1 id=&#34;5-生命周期&#34;&gt;5. 生命周期&lt;/h1&gt;
&lt;p&gt;Vue实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载等一系列过程，我们成为Vue 实例的生命周期，钩子就是在某个阶段给你一个做某些处理的机会。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615470829040.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
回答技巧：有哪些生命周期以及在每个生命周期的时机中我们能做的事情。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;beforeCreate 钩子的执行时机是在&lt;code&gt;initState 函数之前&lt;/code&gt;，这个函数会初始化 props、data、methods、watch、computed 等属性，也就意味着，这个&lt;code&gt;钩子是不可以访问&lt;/code&gt;到以上这些属性中的数据的；&lt;/li&gt;
&lt;li&gt;created 钩子的执行时机是在&lt;code&gt;iniState 函数之后&lt;/code&gt;，因此&lt;code&gt;可以访问&lt;/code&gt;到以上这些属性中的数据；&lt;/li&gt;
&lt;li&gt;beforeMount 钩子的执行时机是在 DOM 挂载之前，还是JavaScript中的虚拟DOM形式存在的。执行顺序是先父后子；&lt;/li&gt;
&lt;li&gt;mounted 钩子的执行时机是在 DOM 挂载之后，执行顺序是先子后父；&lt;/li&gt;
&lt;li&gt;beforeUpdate 钩子的执行时机是在数据发生改变，还没有渲染之前；&lt;/li&gt;
&lt;li&gt;updated 钩子的执行时机是数据发生改变，并且被渲染后；&lt;/li&gt;
&lt;li&gt;beforeDestroy 钩子的执行时机是组件即将被销毁之前，也因此组件实例上属性的数据还可以被访问到；&lt;/li&gt;
&lt;li&gt;destroyed 钩子的执行时机是组件被销毁之后。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有两个钩子跟 keep-alive 抽象组件相关的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;activated 钩子的执行时机是在 mounted 钩子之后执行；&lt;/li&gt;
&lt;li&gt;deactivated 钩子的执行时机是在页面退出时，由于会缓存，所以不会销毁组件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;6-虚拟-dom-的原理&#34;&gt;6. 虚拟 DOM 的原理&lt;/h1&gt;
&lt;h2 id=&#34;浏览器渲染引擎工作流程都差不多大致分为5步&#34;&gt;浏览器渲染引擎工作流程都差不多，大致分为5步&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;第一步，用HTML分析器，分析HTML元素，&lt;strong&gt;构建一颗DOM树&lt;/strong&gt;(标记化和树构建)。&lt;/li&gt;
&lt;li&gt;第二步，用CSS分析器，分析CSS文件和元素上的inline样式，生成页面的样式表。&lt;/li&gt;
&lt;li&gt;第三步，将DOM树和样式表，关联起来，构建一颗Render树(这一过程又称为Attachment)。&lt;/li&gt;
&lt;li&gt;第四步，有了Render树，浏览器开始布局，为每个Render树上的节点确定一个在显示屏上出现的精确坐标。&lt;/li&gt;
&lt;li&gt;第五步，Render树和节点显示坐标都有了，就调用每个节点paint方法，把它们绘制出来。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;用我们传统的开发模式，原生JS或JQ操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程&lt;/code&gt;。在一次操作中，我需要更新10个DOM节点，浏览器收到第一个DOM请求后并不知道还有9次更新操作，因此会马上执行流程，最终执行10次。&lt;/p&gt;
&lt;h2 id=&#34;为什么需要虚拟dom它有什么好处&#34;&gt;为什么需要虚拟DOM，它有什么好处&lt;/h2&gt;
&lt;p&gt;虚拟DOM就是为了&lt;code&gt;解决浏览器性能问题&lt;/code&gt;而被设计出来的。&lt;/p&gt;
&lt;p&gt;出现了一个轻量级的对真实 DOM 描述的 JS 对象，称为虚拟 DOM，与真实 DOM 一一对应，将新旧虚拟 DOM 进行 diff，然后生成变更，将变更应用于真实 DOM，最终生成最新的真实 DOM。&lt;strong&gt;这是将大量的 DOM 层面操作，转换成 JS 层面的操作&lt;/strong&gt;，是很划算的。&lt;/p&gt;
&lt;p&gt;如前，若一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的&lt;code&gt;diff&lt;/code&gt;内容保存到本地一个JS对象中，最终将这个JS对象一次性attch到DOM树上，再进行后续操作，避免大量无谓的计算量。所以，用JS对象模拟DOM节点的好处是，页面的更新可以先全部反映在JS对象(虚拟DOM)上，操作内存中的JS对象的速度显然要更快，等更新完成后，再将最终的JS对象映射成真实的DOM，交由浏览器去绘制。&lt;/p&gt;
&lt;h2 id=&#34;diff操作&#34;&gt;Diff操作&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;diff算法的本质是找出两个对象之间的差异，目的是尽可能复用节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Vue的Diff算法与上面的思路大体相似，只比较同级的节点，若找不到与新节点类型相同的节点，则插入一个新节点，若有相同类型的节点则进行节点属性的更新，最后删除新节点列表中不包含的旧节点。&lt;/p&gt;
&lt;p&gt;在实际代码中，会对新旧两棵树进行一个深度的遍历，每个节点都会有一个标记。每遍历到一个节点就把该节点和新的树进行对比，如果有差异就记录到一个对象中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;比较只会在同层级进行, 不会跨层级比较。&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615712855481.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;7-如何实现一个自定义组件不同组件之间如何通信的&#34;&gt;7. 如何实现一个自定义组件，不同组件之间如何通信的？&lt;/h1&gt;
&lt;p&gt;全局注册：Vue.component(tagName, options)&lt;/p&gt;
&lt;p&gt;局部注册：在其他组件中的 components 属性中注册某个组件，就可以使用它了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import HelloWorld from &#39;./components/HelloWorld&#39;

export default {
  components: {
    HelloWorld
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不同组件间通过 &lt;code&gt;props&lt;/code&gt; 和事件中心来通信：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;props 特性和非 props 特性&lt;/strong&gt;：父组件通过属性方式将数据传递给子组件，子组件通过写明 props 来接收数据，如果没有在 props 中接收这个数据，那么这个数据称为非 props 特性（除了 class 和 style），所有非 props 特性存储在 $attrs 中，在子组件中声明 inheritAttrs 为 false，非 props 特性不赋予在子组件的根元素上，再配合 v-bind=&amp;quot;$attrs&amp;quot; 绑定 $attrs 到非根元素上，这样非 props 特性就会赋予在非根元素上，如果是绑定到子组件的子组件，就可以达到跨组件通讯的目的了。&lt;/p&gt;
&lt;p&gt;事件中心简单来说就是将所有事件放在一个对象中，通过一些 API 来管理这些事件。&lt;/p&gt;
&lt;p&gt;我们知道子组件通过 &lt;strong&gt;$emit&lt;/strong&gt; 来触发定义在父组件的自定义事件，并且可以以此传递数据给父组件。这个过程并不是往父组件派发事件，而是往子组件实例派发事件，因为在子组件初始化时，就将所有定义在父组件的绑定在子组件的自定义事件的回调函数，通过 listeners 参数传递给子组件，然后将所有的回调函数以事件名为 key，以对应的回调函数组成的数组为 value，通过 $on 这个 API 添加到 vm._event 对象中（vm 为子组件实例），然后通过 $emit 可以触发具体的回调函数，通过 $off 可以删除具体的回调函数，通过 $once 可以让回调函数只执行一次（先执行 $emit 再执行 $off）。&lt;/p&gt;
&lt;p&gt;所以，我们可以通过 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;（&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;等&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;同&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;于&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;参&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;）&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;来&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;达&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;到&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;跨&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;组&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;件&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;目&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;在&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;子&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;组&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;件&lt;/mi&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;子&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;组&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;件&lt;/mi&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;中&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;这&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;样&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;使&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;用&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;：&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;listeners （等同于 listeners 参数）来达到跨组件的目的，在子组件 A 的子组件 B 中这样使用：v-on=&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.77777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;（&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;等&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;同&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;于&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;参&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;）&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;来&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;达&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;到&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;跨&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;组&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;件&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;目&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;在&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;子&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;组&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;件&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;子&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;组&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;件&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;中&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;这&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;样&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;使&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;用&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;listeners&amp;quot; 可以将父组件的所有绑定在子组件 A 的自定义事件函数传给孙子组件 B，在初始化组件 B 时，就会将那些回调函数都添加到组件 B 实例的对象中，那么在组件 B 中执行 $emit 就可以触发对应的回调函数了。&lt;/p&gt;
&lt;p&gt;也因此 bus 总线机制也就很好理解了，是在根实例的原型上生成一个 vue 实例，然后通过 $on 在这个实例中添加的回调函数，所有地方都可以通过 $emit 来触发这个回调函数，也达到了跨组件通信的目的（所有组件都可以通信了），因为它们都可以访问原型上的这个 vue 实例。&lt;/p&gt;
&lt;p&gt;使用状态管理模式 vuex 实现数据共享，下面这道面试题来回答。&lt;/p&gt;
&lt;p&gt;总结：不同组件之间的通信方式是多样的，因此应该统一规范通信方式，如此有利于代码的维护和开发效率，否则容易混淆一个数据的来源。&lt;/p&gt;
&lt;h1 id=&#34;8-vuex-的理解&#34;&gt;8. vuex 的理解&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;vuex 是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们的项目中多个组件之间进行复杂的数据传值困难的时候，如果我们能把这些公用数据放在一个公共的存储空间去存储，一个组件改变了一个数据，其他的组件就能感知到。&lt;/p&gt;
&lt;p&gt;将这个存储空间理解成一个 store 仓库，由几部分组成：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615511816855.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;所有的公用数据都存储在 state 之中，如果组件想&lt;strong&gt;调用数据&lt;/strong&gt;，直接调用 state 就行，有的时候要&lt;strong&gt;改变 state 数据&lt;/strong&gt;，不能直接用组件去改变 state 数据，必须走一个流程，如果我有异步操作，那么我把异步操作放在 actions 中，或者比较复杂的同步操作，比如批量的同步操作，也可以放在 actions 里面，组件先去调用 actions，actions 去调用 mutations，mutations 放的是同步的对 state 的修改，只有通过 mutations 才能改变公用数据的值。&lt;/p&gt;
&lt;p&gt;但这个流程也不是绝对的，有的时候可以绕过 actions，让组件直接去调用 mutations 修改state 里面的数据，这块需要额外注意的是：当组件调用 actions 的时候，我们调用的是&lt;code&gt;dispatch&lt;/code&gt;方法，然后组件去调用 mutations 的时候，或者 actions 去调用 mutations 的时候，我们都需要调用的 &lt;code&gt;commit&lt;/code&gt; 这个方法，其实就是一个单向数据的改变流程。&lt;/p&gt;
&lt;p&gt;在使用 vuex 的时候，还可以借助 Devtools 这个开发者工具，帮助我们做代码的调试。&lt;/p&gt;
&lt;h1 id=&#34;9-proxy-相比于-defineproperty-的优势&#34;&gt;9. Proxy 相比于 defineProperty 的优势&lt;/h1&gt;
&lt;p&gt;Proxy 是 ES6 提供的一个对象代理，简单来说就是我们不直接对一个（私有）对象进行读写，而是通过这个对象代理对这个对象进行读写，通过对象代理可以对这个对象的&lt;strong&gt;数据作过滤保护&lt;/strong&gt;，使得这个对象可以成为&lt;strong&gt;私有属性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;创建私有属性（只能通过内部提供的方法访问，不能直接访问），ES3 使用的是闭包，ES5 使用的是 defineProperty API，ES6 使用对象代理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;优势一：Proxy 可以直接&lt;code&gt;监听对象本身&lt;/code&gt;，而 defineProperty 只能&lt;code&gt;监听属性&lt;/code&gt;，只有通过递归调用才能监听对象；&lt;br&gt;
优势二：当我们使用数组方法来操作数组后，Proxy 可以直接监听&lt;code&gt;数组变化&lt;/code&gt;，而 defineProperty 是无法监听到的，常用八种数组方法 push, pop, shift, unshift, splice, sort, reverse 在 vue 中能监听得到，是因为 vue 源码中使用了 defineReactive 方法来渲染页面；&lt;br&gt;
优势三：Proxy 有 13 中拦截方式，多于 defineProperty；&lt;br&gt;
优势四：Proxy 返回一个新对象，可以只&lt;code&gt;操作新对象&lt;/code&gt;，不会污染原对象，而 defineProperty 只能遍历对象属性&lt;code&gt;直接修改&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而 defineProperty 的兼容性更好，vue 3.0 版本将会用 Proxy 代替 definProperty。&lt;/p&gt;
&lt;h1 id=&#34;10-computed-和-watch-区别&#34;&gt;10、computed 和 watch 区别&lt;/h1&gt;
&lt;h2 id=&#34;计算属性computed&#34;&gt;计算属性computed :&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;支持缓存，只有依赖数据发生改变，才会重新进行计算&lt;/li&gt;
&lt;li&gt;不支持异步，当computed内有异步操作时无效，无法监听数据的变化&lt;/li&gt;
&lt;li&gt;computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值&lt;/li&gt;
&lt;li&gt;如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed&lt;/li&gt;
&lt;li&gt;如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;侦听属性watch&#34;&gt;侦听属性watch：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;不支持缓存，数据变，直接会触发相应的操作；&lt;/li&gt;
&lt;li&gt;watch支持异步；&lt;/li&gt;
&lt;li&gt;监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；&lt;/li&gt;
&lt;li&gt;当一个属性发生变化时，需要执行对应的操作；一对多；&lt;/li&gt;
&lt;li&gt;监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，&lt;br&gt;
　　immediate：组件加载立即触发回调函数执行，&lt;br&gt;
　　deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异，只有以响应式的方式触发才会被监听到。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + &#39; &#39; + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(&#39; &#39;)
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
},
watch: {
    a: {
      handler(newVal) {
        console.log(newVal)
      },
      deep: true,
      immediate: true
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;11-vue-router-hash-html5-新增的-pushstate&#34;&gt;11. vue-router (hash， HTML5 新增的 pushState)&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;单页应用，如何实现其路由功能---路由原理&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;vue-router 默认启用 &lt;code&gt;hash&lt;/code&gt; 模式，如果只是 hash 的改变在任何时候都不会向后端发起请求，如果想要在一个页面中跳转到一个区域，有两种方法：设置一个锚点：使用 a 标签的 name 属性，二是使用 id 元素，可以在任何元素上使用。&lt;br&gt;
核心原理是利用了 hash 的 &lt;code&gt;onhashchange&lt;/code&gt;事件，一旦 hash 发生改变就会触发这个事件&lt;br&gt;
还可以在路由配置中，用 mode 配置项，值为 history，就可以改成 history 模式，实际上就是使用了浏览器的 history API&lt;br&gt;
通过这种模式可以去掉 hash 的丑陋，但是也有一个问题，如果用户刷新或者手动输入 URL 按回车，那么就会向后端发起请求，如果后端没有匹配的路径，就会报 404 错误，所以后端要配置支持。&lt;br&gt;
&lt;code&gt;核心原理&lt;/code&gt;（跟使用何种模式无关）：利用的的是 history.pushState 和 history.replaceState 方法，并且在后退和前进以及跳转时利用的是 popstate 事件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;vue-router 如何做用户登录权限等&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用 meta 来检测一个目标页面是否需要登陆权限，然后向服务器发送一个带有 Cookie 字段的请求，询问浏览器端的 cookie 中的 sessionID 是否已过期（因为 session 是保存在服务器端的），如果过期就需要重新登陆，跳转到登陆页面，否则表示已是登陆状态，进入目标页面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;你在项目中怎么实现路由的嵌套&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个被渲染组件同样可以包含自己的&amp;lt;router-view&amp;gt;（一个出口）&lt;br&gt;
要在嵌套的出口中渲染组件，需要在 VueRouter 中使用 children 配置&lt;br&gt;
在 children 中的路由不需要以 / 开头，因为是嵌套的路由&lt;br&gt;
除此之外就像和 routes 配置一样的路由配置数组&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;vue-router 有哪几种导航钩子&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;全局的：&lt;br&gt;
全局前置守卫 beforeEach&lt;br&gt;
全局解析守卫（在组件路由所有守卫之后） beforeResolve&lt;br&gt;
全局后置钩子（没有 next 参数，因为不在导航守卫队列中，此时导航被确认） afterEach&lt;br&gt;
router.beforeEach((to,from.next) =&amp;gt; {})&lt;br&gt;
单个路由独享（在路由配置上直接定义）：beforeEnter&lt;br&gt;
组件级：在路由组件内直接调用的守卫，像调用生命周期那样&lt;br&gt;
beforeRouteEnter&lt;br&gt;
这是唯一可以给 next() 传递回调函数作为参数的守卫（对于所有守卫而言的）&lt;br&gt;
其他两个已经可以直接使用 this，所以不需要再传入回调&lt;br&gt;
beforeRouteUpdate 在重复组件中调用这个守卫，所以可以访问 this&lt;br&gt;
主要是因为在重用组件中使用了这个守卫，因此在这里请求数据可以在组件复用是更新数据&lt;br&gt;
beforeRouteLeave 离开失活组件时执行的守卫，所以可以访问到失活组件的 this&lt;br&gt;
当导航守卫的队列都清空时，表示导航被确认，然后调用全局的 afterEach 钩子，然后触发 DOM 更新，然后再会执行 beforeRouteEnter 中的 next 方法中的回调函数。&lt;br&gt;
只要有 next 参数的，最后都要执行 next() 才能跳转到下一个守卫&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;$route 和 $router 的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;this.&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;是&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;访&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;问&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;路&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;由&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;器&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;router 是访问路由器
this.&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;是&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;访&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;问&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;路&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;由&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;器&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;route 是访问当前路由&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;this.$router.push会往history栈中添加一个新的记录。&lt;br&gt;
 &lt;br&gt;
this.$route相当于当前正在跳转的路由对象。可以从里面获取name,path,params,query等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何使用 vue-router&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1）import 进来，然后通过 Vue.use() 明确安装路由功能&lt;br&gt;
2）定义路由组件，或者引入单文件组件&lt;br&gt;
3）定义路由配置，配置是一个数组，元素是对象&lt;br&gt;
4）创建一个 vue-router 实例，new vueRouter({})&lt;br&gt;
5）创建 vue 根实例，将 router 作为配置参数传入&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;12-vue中v-if与v-show的区别以及使用场景&#34;&gt;12. vue中v-if与v-show的区别以及使用场景&lt;/h1&gt;
&lt;h2 id=&#34;区别&#34;&gt;区别&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;手段：v-if是通过控制dom节点的&lt;code&gt;存在&lt;/code&gt;与否来控制元素的显隐；v-show是通过设置DOM元素的&lt;code&gt;display样式&lt;/code&gt;，block为显示，none为隐藏；&lt;/li&gt;
&lt;li&gt;编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的&lt;code&gt;基于css切换&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;编译条件：v-if是&lt;code&gt;惰性&lt;/code&gt;的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；&lt;/li&gt;
&lt;li&gt;性能消耗：v-if有更高的&lt;code&gt;切换消耗&lt;/code&gt;；v-show有更高的初始&lt;code&gt;渲染消耗&lt;/code&gt;；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;换句话说，v-if 的表达式返回值，会直接触发到&lt;code&gt;当前组件 生命周期&lt;/code&gt;，并且事件监听器和子组件会被适当地被销毁和重建。 所以，可以理解为 v-if 是惰性的，他不会在页面初始化时，被无条件渲染，而是按需响应式地渲染。&lt;/p&gt;
&lt;p&gt;而 v-show ，这是无论表达式返回值是否是 true 都会在&lt;code&gt;create 生命周期&lt;/code&gt;，无条件消耗资源生成对应的 Virtual DOM，并挂载到HTML页面中，只是再根据表达式返回值，切换 display 这个 CSS 属性。&lt;/p&gt;
&lt;h2 id=&#34;使用场景&#34;&gt;使用场景&lt;/h2&gt;
&lt;p&gt;基于以上区别，因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;v-if判断是否加载，可以减轻服务器的压力，在需要时加载,但有更高的切换开销;v-show调整DOM元素的CSS的dispaly属性，可以使客户端操作更加流畅，但有更高的初始渲染开销。如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。&lt;/p&gt;
&lt;h1 id=&#34;13-vue项目中实现token验证&#34;&gt;13. Vue项目中实现token验证&lt;/h1&gt;
&lt;p&gt;在前后端完全分离的情况下，Vue项目中实现token验证大致思路如下：&lt;/p&gt;
&lt;p&gt;1、第一次登录的时候，前端调后端的登陆接口，发送用户名和密码&lt;br&gt;
2、后端收到请求，验证用户名和密码，验证成功，就给前端返回一个token&lt;br&gt;
3、前端拿到token，将token存储到localStorage和vuex中，并跳转路由页面&lt;br&gt;
4、前端每次跳转路由，就判断 localStroage 中有无 token ，没有就跳转到登录页面，有则跳转到对应路由页面&lt;br&gt;
5、每次调后端接口，都要在请求头中加token&lt;br&gt;
6、后端判断请求头中有无token，有token，就拿到token并验证token，验证成功就返回数据，验证失败（例如：token过期）就返回401，请求头中没有token也返回401&lt;br&gt;
7、如果前端拿到状态码为401，就清除token信息并跳转到登录页面&lt;/p&gt;
&lt;h1 id=&#34;14-vue插槽v-slot&#34;&gt;14. Vue插槽（v-slot）&lt;/h1&gt;
&lt;h2 id=&#34;匿名插槽&#34;&gt;匿名插槽&lt;/h2&gt;
&lt;p&gt;匿名插槽，我们也可以叫它单个插槽或者默认插槽。和具名插槽相对，它是不需要设置  name 属性的，它隐藏的name属性为default。&lt;/p&gt;
&lt;p&gt;在使用的时候还有一个问题要注意的 如果是有2个以上的匿名插槽是会child标签里面的内容全部都替换到每个slot；&lt;/p&gt;
&lt;h2 id=&#34;具名插槽&#34;&gt;具名插槽&lt;/h2&gt;
&lt;p&gt;顾名思义就是slot 是带有name的 ，定义：&amp;lt;slot name=&amp;quot;header&amp;quot; /&amp;gt;  或者使用简单缩写的定义 #header&lt;br&gt;
使用：要用一个 template标签包裹&lt;/p&gt;
&lt;p&gt;这里说一下多个具名插槽的使用 &lt;code&gt;多个具名插槽，插槽的位置不是使用插槽的位置而定的，是在定义的时候的位置来替换的&lt;/code&gt;&lt;/p&gt;
">【面】前端知识点梳理（Vue）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/mian-qian-duan-zhi-shi-dian-shu-li-fu-wu-duan-yu-wang-luo/"" data-c="
          &lt;h1 id=&#34;1-常见状态码&#34;&gt;1. 常见状态码&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;2XX 成功&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;200 OK，表示从客户端发来的请求在服务器端被正确处理&lt;/li&gt;
&lt;li&gt;204 No content，表示请求成功，但响应报文不含实体的主体部分&lt;/li&gt;
&lt;li&gt;206 Partial Content，进行范围请求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;3XX 重定向&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;301 moved permanently，永久性重定向，表示资源已被分配了新的 URL&lt;/li&gt;
&lt;li&gt;302 found，临时性重定向，表示资源临时被分配了新的 URL&lt;/li&gt;
&lt;li&gt;303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源&lt;/li&gt;
&lt;li&gt;304:该资源在上次请求之后没有任何修改(这通常用于浏览器的缓存机制，使用GET请求时尤其需要注意)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;4XX 客户端错误&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;400:无法找到请求的资源。&lt;/li&gt;
&lt;li&gt;401:访问资源的权限不够。&lt;/li&gt;
&lt;li&gt;403:没有权限访问资源。&lt;/li&gt;
&lt;li&gt;404:需要访问的资源不存在。&lt;/li&gt;
&lt;li&gt;405:需要访问的资源被禁止。&lt;/li&gt;
&lt;li&gt;407:访问的资源需要代理身份验证。&lt;/li&gt;
&lt;li&gt;414:请求的URL太长。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;5XX 服务器错误&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;500:服务器内部错误。&lt;/li&gt;
&lt;li&gt;503:表明服务器暂时处于超负载或正在停机维护，无法处理请求&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2-缓存&#34;&gt;2. 缓存&lt;/h1&gt;
&lt;h2 id=&#34;1-200-from-cache和200-ok&#34;&gt;1. 200 From cache和200 ok&lt;/h2&gt;
&lt;p&gt;为什么有的缓存是 200 OK (from cache)，有的缓存是 304 Not Modified 呢？很简单，看运维是否移除了 Entity Tag。移除了，就总是 200 OK (from cache)。没有移除，就两者交替出现。&lt;/p&gt;
&lt;p&gt;其实， 200 OK (from cache)  是浏览器没有跟服务器确认，直接用了浏览器缓存；而 304 Not Modified 是浏览器和服务器多确认了一次缓存有效性，再用的缓存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;它们都是在设置了缓存的情况下触发的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;200 OK (from cache) 是直接点击链接访问，输入网址按回车访问也能触发；而 304 Not Modified 是刷新页面时触发，或是设置了长缓存、但 Entity Tags 没有移除时触发。&lt;/p&gt;
&lt;h2 id=&#34;2-400401403状态码分别代表什么&#34;&gt;2. 400,401,403状态码分别代表什么&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;400 bad request，请求报文存在语法错误&lt;/li&gt;
&lt;li&gt;401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息&lt;/li&gt;
&lt;li&gt;403 forbidden，表示对请求资源的访问被服务器拒绝&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-浏览器缓存&#34;&gt;3. 浏览器缓存&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615443053998.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1-什么是浏览器缓存&#34;&gt;1. 什么是浏览器缓存&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615444453979.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
简单来说，浏览器缓存其实就是浏览器保存通过HTTP获取的所有资源，是浏览器将网络资源存储在本地的一种行为。&lt;/p&gt;
&lt;h3 id=&#34;2-缓存的资源去哪里了&#34;&gt;2. 缓存的资源去哪里了?&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;memory cache&lt;/strong&gt;&lt;br&gt;
MemoryCache顾名思义，就是将资源缓存到内存中，等待下次访问时不需要重新下载资源，而直接从内存中获取。&lt;br&gt;
&lt;strong&gt;disk cache&lt;/strong&gt;&lt;br&gt;
DiskCache顾名思义，就是将资源缓存到磁盘中，等待下次访问时不需要重新下载资源，而直接从磁盘中获取。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615444570064.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三级缓存原理 (访问缓存优先级)&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先在内存中查找,如果有,直接加载。&lt;/li&gt;
&lt;li&gt;如果内存中不存在,则在硬盘中查找,如果有直接加载。&lt;/li&gt;
&lt;li&gt;如果硬盘中也没有,那么就进行网络请求。&lt;/li&gt;
&lt;li&gt;请求获取的资源缓存到硬盘和内存。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;浏览器缓存的优点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;减少了冗余的数据传输&lt;/li&gt;
&lt;li&gt;减少了服务器的负担，大大提升了网站的性能&lt;/li&gt;
&lt;li&gt;加快了客户端加载网页的速度&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;3-cookie-session-token&#34;&gt;3. cookie, session, token&lt;/h1&gt;
&lt;h2 id=&#34;token&#34;&gt;Token&lt;/h2&gt;
&lt;p&gt;在Web领域基于Token的身份验证随处可见。在大多数使用Web API的互联网公司中，tokens 是多用户下处理认证的最佳方式。&lt;/p&gt;
&lt;p&gt;以下几点特性会让你在程序中使用基于Token的身份验证&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无状态、可扩展&lt;/li&gt;
&lt;li&gt;支持移动设备&lt;/li&gt;
&lt;li&gt;跨程序调用&lt;/li&gt;
&lt;li&gt;安全&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;基于token的身份验证的过程如下&#34;&gt;基于Token的身份验证的过程如下:&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;用户通过用户名和密码发送请求。&lt;/li&gt;
&lt;li&gt;程序验证。&lt;/li&gt;
&lt;li&gt;程序返回一个签名的token 给客户端。&lt;/li&gt;
&lt;li&gt;客户端储存token,并且每次用于每次发送请求。&lt;/li&gt;
&lt;li&gt;服务端验证token并返回数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615444886393.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;4-dns解析&#34;&gt;4. DNS解析&lt;/h1&gt;
&lt;p&gt;首先是域名解析(DNS解析)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先浏览器解析输入的域名，先查找&lt;code&gt;本地硬盘的host&lt;/code&gt;文件,看有没有和这个域名对应的ip，如果有，就直接使用这个ip&lt;/li&gt;
&lt;li&gt;如果没有，浏览器会发出一个DNS请求到本地&lt;code&gt;DNS(域名分布系统)服务器&lt;/code&gt;，本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动&lt;/li&gt;
&lt;li&gt;请求到达DNS服务器后，DNS服务器首先会查询他的缓存记录，如果有对应的ip地址，则返回，如果没有，本地DNS服务器向&lt;code&gt;DNS根服务器&lt;/code&gt;发送查询请求&lt;/li&gt;
&lt;li&gt;根服务器不会记录具体的域名和ip的对应关系，而是返回&lt;code&gt;域服务器&lt;/code&gt;的地址，本地服务器会继续向域服务器发起请求&lt;/li&gt;
&lt;li&gt;域服务器并没有记录域名和ip的对应关系，而是返回你的&lt;code&gt;域名的解析服务器&lt;/code&gt;的地址&lt;/li&gt;
&lt;li&gt;本地DNS服务器继续向域名解析服务器发出请求，这时会收到&lt;code&gt;域名对应的ip&lt;/code&gt;，本地DNS服务器将ip返回给浏览器，并将ip存入缓存，方便下次访问，加快访问速度&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615435439972.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;5-cdn内容分发网络&#34;&gt;5. cdn（内容分发网络）&lt;/h1&gt;
&lt;h2 id=&#34;1-cdn工作原理&#34;&gt;1. CDN工作原理&lt;/h2&gt;
&lt;p&gt;内容分发网络（Content Delivery Network，简称CDN）是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。&lt;/p&gt;
&lt;p&gt;CDN应用广泛，支持多种行业、多种场景内容加速，例如：图片小文件、大文件下载、视音频点播、直播流媒体、全站加速、安全加速。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615445467852.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;假设通过CDN加速的域名为&lt;code&gt;www.a.com&lt;/code&gt;，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当终端用户（北京）向www.a.com下的指定资源发起请求时，首先向LDNS（本地DNS）发起域名解析请求。&lt;/li&gt;
&lt;li&gt;LDNS检查缓存中是否有www.a.com的IP地址记录。如果有，则直接返回给终端用户；如果没有，则向授权DNS查询。&lt;/li&gt;
&lt;li&gt;当授权DNS解析www.a.com时，返回域名CNAME www.a.tbcdn.com对应IP地址。&lt;/li&gt;
&lt;li&gt;域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点IP地址。&lt;/li&gt;
&lt;li&gt;LDNS获取DNS返回的解析IP地址。&lt;/li&gt;
&lt;li&gt;用户获取解析IP地址。&lt;/li&gt;
&lt;li&gt;用户向获取的IP地址发起对该资源的访问请求。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;如果该IP地址对应的节点已缓存该资源，则会将数据直接返回给用户，例如，图中步骤7和8，请求结束。&lt;/li&gt;
&lt;li&gt;如果该IP地址对应的节点未缓存该资源，则节点向源站发起对该资源的请求。获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点，例如，图中的北京节点，并返回给用户，请求结束。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;从这个例子可以了解到：&lt;/strong&gt;&lt;br&gt;
（1）CDN的加速资源是跟域名绑定的。&lt;br&gt;
（2）通过域名访问资源，首先是通过DNS分查找离用户最近的CDN节点（边缘服务器）的IP&lt;br&gt;
（3）通过IP访问实际资源时，如果CDN上并没有缓存资源，则会到源站请求资源，并缓存到CDN节点上，这样，用户下一次访问时，该CDN节点就会有对应资源的缓存了。&lt;/p&gt;
&lt;h1 id=&#34;6-计算机网络的相关协议&#34;&gt;6. 计算机网络的相关协议&lt;/h1&gt;
&lt;h2 id=&#34;1-典型协议&#34;&gt;1. 典型协议：&lt;/h2&gt;
&lt;p&gt;传输层： 常见的协议有 TCP/UDP 协议&lt;br&gt;
应用层： 常见的协议有 HTTP，FTP 协议&lt;br&gt;
网络层： 常见的协议有 IP 协议，ICMP 协议，IGMP 协议&lt;br&gt;
网络接口层： 常见的协议有 ARP 协议，RARP 协议&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP 传输控协议（TransmissionControl Protocol）是一种面向连接的，可靠的，基于字节流的传输层通信协议&lt;/li&gt;
&lt;li&gt;UDP 用户数据包协议（UserDatagram Protocol）是 OSI 参考模型中一种无连接的传输层协议，提供面向事物的简单不可靠信息传送服务&lt;/li&gt;
&lt;li&gt;HTTP 超文本传输系协议（HyperText Transfer Protocol）是互联网上应用最为广泛的一种协议&lt;/li&gt;
&lt;li&gt;FTP 文件传输协议（File Transfer Protocol）&lt;/li&gt;
&lt;li&gt;IP 协议是英特网互联协议（Internet Protocol）&lt;/li&gt;
&lt;li&gt;ICMP 协议是 Internet 控制报文协议（Internet Control Message Protocol），它是 TCP/IP 协议族的一个子协议，用于在 IP 主机、路由器之间传递控制消息&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-tcp-和-udp区别&#34;&gt;2. TCP 和 UDP区别 ？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;TCP协议是有连接的，有连接的意思是开始传输实际数据之前TCP的客户端和服务器端必须通过三次握手建立连接，会话结束之后也要结束连接。而UDP是无连接的&lt;/li&gt;
&lt;li&gt;TCP协议保证数据按序发送，按序到达，提供超时重传来保证可靠性，但是UDP不保证按序到达，甚至不保证到达，只是努力交付，即便是按序发送的序列，也不保证按序送到。&lt;/li&gt;
&lt;li&gt;TCP协议所需资源多，TCP首部需20个字节（不算可选项），UDP首部字段只需8个字节。&lt;/li&gt;
&lt;li&gt;TCP有流量控制和拥塞控制，UDP没有，网络拥堵不会影响发送端的发送速率&lt;/li&gt;
&lt;li&gt;TCP是&lt;code&gt;一对一&lt;/code&gt;的连接，而UDP则可以支持一对一，&lt;code&gt;多对多&lt;/code&gt;，一对多的通信。&lt;/li&gt;
&lt;li&gt;TCP面向的是字节流的服务，UDP面向的是报文的服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;7-httphttpshttp20&#34;&gt;7. http/https/http2.0&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615448355999.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;HTTP是互联网上应用最为广泛的一种网络协议,设计最初的目的是为了提供一种发布和接收HTML页面的方法，万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）合作不断发展改进了HTTP,之后HTTP有了好几个版本。&lt;/li&gt;
&lt;li&gt;HTTP是基于TCP的，由HTTP客户端发起一个请求，会创建一个到服务器指定端口（默认80端口）的TCP连接，HTTP服务器会在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态（如&amp;quot;HTTP/1.1 200 OK&amp;quot;）以及返回的内容（如请求的文件、错误消息、或者其它信息）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;http的版本&#34;&gt;HTTP的版本&lt;/h2&gt;
&lt;p&gt;在不断的改进中，HTTP存在有以下几个版本：HTTP/0.9、HTTP/1.0、HTTP/1.1、HTTP/2。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0.9
已过时。只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持POST方法，因此客户端无法向服务器传递太多信息。

HTTP/1.0
这是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。

HTTP/1.1
持久连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式在同时发送多个请求，以便降低线路负载，提高传输速度。

HTTP/1.1相较于HTTP/1.0协议的区别主要体现在：

缓存处理
带宽优化及网络连接的使用
错误通知的管理
消息在网络中的发送
互联网地址的维护
安全性及完整性

HTTP/2
当前版本，于2015年5月作为互联网标准正式发布。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HTTP/0.9是HTTP的第一个版本，现在已经过时，为了改进协议，之后相继有了HTTP/1.0、HTTP/1.1。1.0和1.1并存了很长时间，HTTP/1.1是目前主流版本。2015年发布了HTTP/2.0,这个也是这两年讨论比较多的技术了，因为它相对于HTTP/1.x来说有非常大的进步，优化了HTTP/1.x很多问题，不过作为下一代的HTTP协议，需要很长一段的时间才会普及。&lt;/p&gt;
&lt;h2 id=&#34;https&#34;&gt;HTTPS&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;超文本传输安全协议&lt;/strong&gt;（英语：Hyper Text Transfer Protocol over Secure Socket Layer，缩写HTTPS。也被称为HTTP over TLS，HTTP over SSL或HTTP Secure）。&lt;/p&gt;
&lt;p&gt;简单来说HTTPS就是安全增强版的HTTP,是HTTP协议与加密协议的结合，使HTTP的协议数据在传输过程中更加安全。&lt;/p&gt;
&lt;p&gt;上面说到的加密协议叫SSL，是英文Secure Sockets Layer的缩写，中文叫“安全套接层”，也是由网景公司设计的，所以上面说HTTPS也被称为HTTP over SSL。&lt;/p&gt;
&lt;p&gt;HTTPS将HTTP协议数据包放到SSL/TSL层加密后，在TCP/IP层组成IP数据报去传输，以此保证传输数据的安全；而对于接收端，在SSL/TSL将接收的数据包解密之后，将数据传给HTTP协议层，就是普通的HTTP数据。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615449424117.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;https性能问题&#34;&gt;HTTPS性能问题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;HTTPS 降低用户访问速度。SSL握手，HTTPS 对速度会有一定程度的降低，但是只要经过合理优化和部署，HTTPS 对速度的影响完全可以接受。在很多场景下，HTTPS 速度完全不逊于 HTTP，如果使用 SPDY，HTTPS 的速度甚至还要比 HTTP 快。&lt;/li&gt;
&lt;li&gt;相对于HTTPS降低访问速度，其实更需要关心的是服务器端的CPU压力，HTTPS中大量的密钥算法计算，会消耗大量的CPU资源，只有足够的优化，HTTPS 的机器成本才不会明显增加。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;http2&#34;&gt;HTTP2&lt;/h2&gt;
&lt;p&gt;HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，主要是以下两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS&lt;/li&gt;
&lt;li&gt;HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;8-get-post区别&#34;&gt;8. get post区别&lt;/h1&gt;
&lt;h2 id=&#34;1-浏览器的get和post&#34;&gt;1. 浏览器的GET和POST&lt;/h2&gt;
&lt;p&gt;浏览器用GET请求来获取一个html页面/图片/css/js等资源；用POST来提交一个&lt;form&gt;表单，并得到一个结果的网页。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;“读取“一个资源。比如Get到一个html文件。反复读取不应该对访问的数据有副作用。比如”GET一下，用户就下单了，返回订单已受理“，这是不可接受的。没有副作用被称为“幂等“（Idempotent)。因为GET因为是读取，就可以对GET请求的数据做缓存。这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），或者做到server端（用Etag，至少可以减少带宽消耗）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在页面里&amp;lt;form&amp;gt; 标签会定义一个表单。点击其中的submit元素会发出一个POST请求让服务器做一件事。这件事往往是有副作用的，不幂等的。&lt;br&gt;
不幂等也就意味着不能随意多次执行。因此也就不能缓存。&lt;/p&gt;
&lt;h2 id=&#34;2-接口中的get和post&#34;&gt;2. 接口中的GET和POST&lt;/h2&gt;
&lt;p&gt;这里是指通过浏览器的Ajax api之类的工具发出来的GET和POST请求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以？分割URL和传输数据，参数之间以&amp;amp;相连&lt;/li&gt;
&lt;li&gt;POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为：(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击（CSRF,跨站请求伪造，也被称为：one click attack/session riding）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;9-ajax-axios库&#34;&gt;9. ajax、 axios库&lt;/h1&gt;
&lt;h2 id=&#34;1ajax&#34;&gt;1.ajax&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;创建XMLHttpRequest类型的对象&lt;/li&gt;
&lt;li&gt;准备发送，打开与网址之间的连接&lt;/li&gt;
&lt;li&gt;执行发送动作&lt;/li&gt;
&lt;li&gt;指定xhr状态变化事件处理函数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// 1.创建一个 XMLHttpRequest 类型的对象  --- 相当于打开了一个浏览器
var xhr = new XMLHttpRequest();
// 2.打开一个与网址之间的连接  --- 相当于在地址栏输入网址
xhr.open(&amp;quot;GET&amp;quot;,&amp;quot;https://jsonplaceholder.typicode.com/users&amp;quot;);
// 3.通过连接发送一次请求 --- 相当于点击回车或者超链接
xhr.send(null);
// 4.指定 xhr 状态变化事件处理函数   --- 相当于处理网页呈现后的操作
xhr.onreadystatechange = function () {
  // 通过判断 xhr 的 readyState ，确定此次请求是否完成
  if (this.readyState === 4) {
    console.log(this.responseText)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-axios-api&#34;&gt;2. Axios API&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可以通过向axios()传递相关配置来创建请求&lt;/li&gt;
&lt;li&gt;axios(config) config为对象格式的配置选项&lt;/li&gt;
&lt;li&gt;axios(url,config) config可选&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;常用配置选项&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;url 用于请求服务器的URL&lt;/li&gt;
&lt;li&gt;method 创建请求时使用的方法&lt;/li&gt;
&lt;li&gt;baseURL 传递相对URL前缀，将自动加在url前面&lt;/li&gt;
&lt;li&gt;headers 即将被发送的自定义请求头&lt;/li&gt;
&lt;li&gt;params 即将与请求一起发送的URL参数&lt;/li&gt;
&lt;li&gt;data 作为请求主体被发送的数据&lt;/li&gt;
&lt;li&gt;timeout 请求超时的毫秒数&lt;/li&gt;
&lt;li&gt;responseType 表示服务器响应的数据类型，默认json&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;axios({
  url: &amp;quot;/posts&amp;quot;,
  method: &amp;quot;get&amp;quot;,
  baseURL: &amp;quot;http://localhost:3000&amp;quot;,
  params: {
    id: 1
  }
}).then(function(res){
  console.log(res.data)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;10-跨域&#34;&gt;10. 跨域&lt;/h1&gt;
&lt;p&gt;因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败。&lt;/p&gt;
&lt;h2 id=&#34;1-同源策略限制下接口请求的正确打开方式&#34;&gt;1. 同源策略限制下接口请求的正确打开方式&lt;/h2&gt;
&lt;h3 id=&#34;1-jsonp&#34;&gt;1. JSONP&lt;/h3&gt;
&lt;p&gt;在HTML标签里，一些标签比如script、img这样的获取资源的标签是没有跨域限制的，通过&amp;lt;script&amp;gt;&lt;/script&gt; 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;http://domain/api?param1=a&amp;amp;param2=b&amp;amp;callback=jsonp&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    function jsonp(data) {
    	console.log(data)
	}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JSONP 使用简单且兼容性不错，但是只限于 &lt;code&gt;get&lt;/code&gt; 请求。&lt;/p&gt;
&lt;h3 id=&#34;2-cors&#34;&gt;2. CORS&lt;/h3&gt;
&lt;p&gt;CORS是一个W3C标准，全称是&amp;quot;跨域资源共享&amp;quot;（Cross-origin resource sharing）。看名字就知道这是处理跨域问题的标准做法。浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只要同时满足以下两大条件，就属于简单请求。&lt;/strong&gt;&lt;br&gt;
（1) 请求方法是以下三种方法之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HEAD&lt;/li&gt;
&lt;li&gt;GET&lt;/li&gt;
&lt;li&gt;POST&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（2）HTTP的头信息不超出以下几种字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Accept&lt;/li&gt;
&lt;li&gt;Accept-Language&lt;/li&gt;
&lt;li&gt;Content-Language&lt;/li&gt;
&lt;li&gt;Last-Event-ID&lt;/li&gt;
&lt;li&gt;Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前端什么也不用干，就是正常发请求就可以&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fetch(`http://localhost:9871/api/cors?msg=helloCors`).then(res =&amp;gt; {
  console.log(res)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;非简单请求&lt;/strong&gt;&lt;br&gt;
非简单请求会发出一次预检测请求，返回码是204，预检测通过才会真正发出请求，这才返回200。这里通过前端发请求的时候增加一个额外的headers来触发非简单请求。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615453729332.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
前端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fetch(`http://localhost:9871/api/cors?msg=helloCors`, {
  // 需要带上cookie
  credentials: &#39;include&#39;,
  // 这里添加额外的headers来触发非简单请求
  headers: {
    &#39;t&#39;: &#39;extra headers&#39;
  }
}).then(res =&amp;gt; {
  console.log(res)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-代理&#34;&gt;3. 代理&lt;/h3&gt;
&lt;p&gt;想一下，如果我们请求的时候还是用前端的域名，然后有个东西帮我们把这个请求转发到真正的后端域名上，不就避免跨域了吗？这时候，Nginx出场了。&lt;/p&gt;
&lt;p&gt;Nginx配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server{
    # 监听9099端口
    listen 9099;
    # 域名是localhost
    server_name localhost;
    #凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:9871 
    location ^~ /api {
        proxy_pass http://localhost:9871;
    }    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前端就不用干什么事情了，除了写接口，也没后端什么事情了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 请求的时候直接用回前端这边的域名http://localhost:9099，这就不会跨域，然后Nginx监听到凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:9871 
fetch(&#39;http://localhost:9099/api/iframePost&#39;, {
  method: &#39;POST&#39;,
  headers: {
    &#39;Accept&#39;: &#39;application/json&#39;,
    &#39;Content-Type&#39;: &#39;application/json&#39;
  },
  body: JSON.stringify({
    msg: &#39;helloIframePost&#39;
  })
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-同源策略限制下dom查询的正确打开方式&#34;&gt;2. 同源策略限制下Dom查询的正确打开方式&lt;/h2&gt;
&lt;h3 id=&#34;1postmessage&#34;&gt;1.postMessage&lt;/h3&gt;
&lt;p&gt;window.postMessage() 是HTML5的一个接口，专注实现不同窗口不同页面的跨域通讯。&lt;/p&gt;
&lt;h3 id=&#34;2documentdomain&#34;&gt;2.document.domain&lt;/h3&gt;
&lt;p&gt;这种方式只适合主域名相同，但子域名不同的iframe跨域。&lt;br&gt;
比如主域名是http://crossdomain.com:9099，子域名是http://child.crossdomain.com:9099，这种情况下给两个页面指定一下document.domain即document.domain = crossdomain.com就可以访问各自的window对象了。&lt;/p&gt;
&lt;h3 id=&#34;3canvas操作图片的跨域问题&#34;&gt;3.canvas操作图片的跨域问题&lt;/h3&gt;
&lt;p&gt;这个应该是一个比较冷门的跨域问题&lt;/p&gt;
&lt;h1 id=&#34;11-前端安全xss-csrf&#34;&gt;11. 前端安全XSS、CSRF&lt;/h1&gt;
&lt;h2 id=&#34;1-xss&#34;&gt;1. XSS&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;跨网站指令码（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程式的安全漏洞攻击，是代码注入的一种。它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及使用者端脚本语言。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;XSS 分为三种：&lt;strong&gt;反射型，存储型和 DOM-based&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;如何攻击&#34;&gt;如何攻击&lt;/h3&gt;
&lt;p&gt;XSS 通过修改 HTML 节点或者执行 JS 代码来攻击网站。&lt;/p&gt;
&lt;p&gt;例如通过 URL 获取某些参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- http://www.domain.com?name=&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt; --&amp;gt;
&amp;lt;div&amp;gt;{{name}}&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述 URL 输入可能会将 HTML 改为 &amp;lt;div&amp;gt;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&amp;lt;/div&amp;gt; ，这样页面中就凭空多了一段可执行脚本。这种攻击类型是反射型攻击，也可以说是 DOM-based 攻击。&lt;/p&gt;
&lt;p&gt;也有另一种场景，比如写了一篇包含攻击代码 &amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt; 的文章，那么可能浏览文章的用户都会被攻击到。这种攻击类型是存储型攻击，也可以说是 DOM-based 攻击，并且这种攻击打击面更广。&lt;/p&gt;
&lt;h3 id=&#34;如何防御&#34;&gt;如何防御&lt;/h3&gt;
&lt;p&gt;最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function escape(str) {
  str = str.replace(/&amp;amp;/g, &#39;&amp;amp;amp;&#39;)
  str = str.replace(/&amp;lt;/g, &#39;&amp;amp;lt;&#39;)
  str = str.replace(/&amp;gt;/g, &#39;&amp;amp;gt;&#39;)
  str = str.replace(/&amp;quot;/g, &#39;&amp;amp;quto;&#39;)
  str = str.replace(/&#39;/g, &#39;&amp;amp;#39;&#39;)
  str = str.replace(/`/g, &#39;&amp;amp;#96;&#39;)
  str = str.replace(/\//g, &#39;&amp;amp;#x2F;&#39;)
  return str
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过转义可以将攻击代码 &amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt; 变成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// -&amp;gt; &amp;amp;lt;script&amp;amp;gt;alert(1)&amp;amp;lt;&amp;amp;#x2F;script&amp;amp;gt;
escape(&#39;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var xss = require(&#39;xss&#39;)
var html = xss(&#39;&amp;lt;h1 id=&amp;quot;title&amp;quot;&amp;gt;XSS Demo&amp;lt;/h1&amp;gt;&amp;lt;script&amp;gt;alert(&amp;quot;xss&amp;quot;);&amp;lt;/script&amp;gt;&#39;)
// -&amp;gt; &amp;lt;h1&amp;gt;XSS Demo&amp;lt;/h1&amp;gt;&amp;amp;lt;script&amp;amp;gt;alert(&amp;quot;xss&amp;quot;);&amp;amp;lt;/script&amp;amp;gt;
console.log(html)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上示例使用了 js-xss 来实现。可以看到在输出中保留了 h1 标签且过滤了 script 标签&lt;/p&gt;
&lt;h2 id=&#34;2-csp&#34;&gt;2. CSP&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;内容安全策略 (CSP) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以通过 CSP 来尽量减少 XSS 攻击。CSP 本质上也是建立白名单，规定了浏览器只能够执行特定来源的代码。&lt;/p&gt;
&lt;p&gt;通常可以通过 &lt;code&gt;HTTP Header&lt;/code&gt; 中的 &lt;code&gt;Content-Security-Policy&lt;/code&gt; 来开启 CSP&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只允许加载本站资源&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Content-Security-Policy: default-src ‘self’
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;只允许加载 HTTPS 协议图片&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Content-Security-Policy: img-src https://*
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;允许加载任何来源框架&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Content-Security-Policy: child-src &#39;none&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-csrf&#34;&gt;3. CSRF&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。[1] 跟跨網站指令碼（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单点说：攻击者盗用了你的身份，以你的名义发送恶意请求，容易造成个人隐私泄露以及财产安全。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615455801140.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;如何攻击-2&#34;&gt;如何攻击&lt;/h3&gt;
&lt;p&gt;假设网站中有一个通过 Get 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;http://www.domain.com/xxx?comment=&#39;attack&#39;&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果接口是 Post 提交的，就相对麻烦点，需要用表单来提交接口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form action=&amp;quot;http://www.domain.com/xxx&amp;quot; id=&amp;quot;CSRF&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
  &amp;lt;input name=&amp;quot;comment&amp;quot; value=&amp;quot;attack&amp;quot; type=&amp;quot;hidden&amp;quot; /&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;如何防御-2&#34;&gt;如何防御&lt;/h3&gt;
&lt;p&gt;防范 CSRF 可以遵循以下几种规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Get 请求不对数据进行修改&lt;/li&gt;
&lt;li&gt;不让第三方网站访问到用户 Cookie&lt;/li&gt;
&lt;li&gt;阻止第三方网站请求接口&lt;/li&gt;
&lt;li&gt;请求时附带验证信息，比如验证码或者 token&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;SameSite&lt;/strong&gt;&lt;br&gt;
可以对 Cookie 设置 SameSite 属性。该属性设置 Cookie 不随着跨域请求发送，该属性可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;验证 Referer&lt;/strong&gt;&lt;br&gt;
对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Token&lt;/strong&gt;&lt;br&gt;
服务器下发一个随机 Token（算法不能复杂），每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。&lt;/p&gt;
&lt;h1 id=&#34;12-websocket&#34;&gt;12. websocket&lt;/h1&gt;
&lt;p&gt;webSocket是一项可以让服务器将数据主动推送给客户端的技术。&lt;/p&gt;
&lt;h2 id=&#34;1-什么是websocket&#34;&gt;1. 什么是WebSocket&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;WebSocket是一种通信协议，可在单个TCP连接上进行全双工通信。WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以建立持久性的连接，并进行双向数据传输。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，要明白WebSocket是一种通信协议，区别于HTTP协议，HTTP协议只能实现客户端请求，服务端响应的这种单项通信。&lt;/p&gt;
&lt;p&gt;而WebSocket可以实现客户端与服务端的双向通讯，说白了，最大也是最明显的区别就是可以做到服务端主动将消息推送给客户端。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;握手阶段采用 HTTP 协议。&lt;/li&gt;
&lt;li&gt;数据格式轻量，性能开销小。客户端与服务端进行数据交换时，服务端到客户端的数据包头只有2到10字节，客户端到服务端需要加上另外4字节的掩码。HTTP每次都需要携带完整头部。&lt;/li&gt;
&lt;li&gt;更好的二进制支持，可以发送文本，和二进制数据&lt;/li&gt;
&lt;li&gt;没有同源限制，客户端可以与任意服务器通信&lt;/li&gt;
&lt;li&gt;协议标识符是ws（如果加密，则是wss），请求的地址就是后端支持websocket的API。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;13-http请求中的keep-alive&#34;&gt;13. Http请求中的keep-alive&lt;/h1&gt;
&lt;h2 id=&#34;1-keep-alive模式&#34;&gt;1. Keep-Alive模式&lt;/h2&gt;
&lt;p&gt;我们都知道HTTP是基于TCP的，每一个HTTP请求都需要进行三步握手。如果一个页面对某一个域名有多个请求，就会进行频繁的建立连接和断开连接。所以HTTP 1.0中出现了&lt;code&gt;Connection: keep-alive&lt;/code&gt;，用于建立长连接，即我们所说的Keep-Alive模式。下图是普通模式和长连接模式的请求对比：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615457244881.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP/1.0中默认使用Connection: close。在HTTP/1.1中已经默认使用Connection: keep-alive。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过对比可以看出，Keep-Alive模式更加高效，因为避免了连接建立和释放的开销。但是，如果一个连接是不会断开的，那么多个请求之间如何进行区分呢？也就是说浏览器是如何知道当前请求已经完成了呢？为了解决这个问题，HTTP对header中又添加了一个Content-Length字段。&lt;/p&gt;
&lt;h2 id=&#34;2-content-length解决静态&#34;&gt;2. Content-Length(解决静态)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Content-Length&lt;/code&gt;表示实体内容的长度。浏览器通过这个字段来判断当前请求的数据是否已经全部接收。所以，当浏览器请求的是一个静态资源时，即服务器能明确知道返回内容的长度时，可以设置&lt;code&gt;Content-Length&lt;/code&gt;来控制请求的结束。但当服务器并不知道请求结果的长度时，如一个动态的页面或者数据，&lt;code&gt;Content-Length&lt;/code&gt;就无法解决上面的问题，这个时候就需要用到&lt;code&gt;Transfer-Encoding&lt;/code&gt;字段。&lt;/p&gt;
&lt;h2 id=&#34;3-transfer-encoding解决动态&#34;&gt;3. Transfer-Encoding(解决动态)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;是指传输编码，还有一个类似的字段叫做：&lt;code&gt;Content-Encoding&lt;/code&gt;。两者的区别是Content-Encoding用于对实体内容的&lt;code&gt;压缩编码&lt;/code&gt;，比如Content-Encoding: gzip；Transfer-Encoding则改变了&lt;code&gt;报文的格式&lt;/code&gt;，比如上面的问题中，当服务端无法知道实体内容的长度时，就可以通过指定&lt;code&gt;Transfer-Encoding: chunked&lt;/code&gt;来告知浏览器当前的编码是将数据分成一块一块传递的。当然, 还可以指定&lt;code&gt;Transfer-Encoding: gzip, chunked&lt;/code&gt;表明实体内容不仅是gzip压缩的，还是分块传递的。最后，当浏览器接收到一个长度为&lt;code&gt;0的chunked时&lt;/code&gt;， 知道当前请求内容已全部接收。&lt;/p&gt;
&lt;h1 id=&#34;14-网络分层&#34;&gt;14. 网络分层&lt;/h1&gt;
&lt;p&gt;有两套参考模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OSI参考模型（Open Systems Interconnection Reference Model，七层）：模型过于理想化，未能在因特网上进行广泛推广。&lt;/li&gt;
&lt;li&gt;TCP/IP参考模型(或TCP/IP协议，四层)：事实上的国际标准。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615458129735.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;网际层（internet layer）&lt;/strong&gt;&lt;br&gt;
在OSI模型中，网际层使用了一个更一般的名字，称为网络层（network layer）。网络层协议定义了数据位和字节如何组织为更大的分组，称为包，还定义了寻址机制，不同的计算机要按照这个寻址机制查找对方。网际协议（IP）是世界上使用最广发的网络层协议，也是Java唯一理解的网络层协议。实际上，这是两个协议：IPv4 和 IPv6。在 IPv4 和 IPv6 中，数据按包在网际层上传输，这些包称为数据报（datagram）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传输层&lt;/strong&gt;&lt;br&gt;
传输层（transport layer）负责确保各包已发送的顺序接收，并保证没有数据对视或破坏。如果丢包，传输层会请求发送方重换这个包。为实现这个目标，IP网络会给每个数据报添加一个附加首部，其中包含有更多信息。这一层上主要有两个协议。第一个是传输控制协议（Transmission Control Protocol，TCP）,这是一个开销很高的协议，支持对丢失或破坏的数据进行重换，并按照发送时的顺序进行传送。第二个协议是用户数据报协议（User Datagram Protocol，UDP），它允许接收方检测被破坏的包，但不保证这些包以正确的顺序传送（或者包有可能根本未传送）。但是 UDP 通常比TCP 快。TCP称为可靠的（reliable）协议；UDP 是不可靠的（unreliable）协议。后面我们将看到，不可靠的协议要比听起来有用得多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;&lt;br&gt;
向用户传送数据的层称为应用层（application layer）。它下面的三层定义了数据如何从一台计算机传输到另一台计算机。应用层确定了数据传输后的操作。例如，应用层协议如 HTTP（用于国际互联网）可以确保 Web 浏览器将图像显示为图片，而不是一长串数据。你的程序中的有关网络的部分大多都是在应用层花费时间。除了用户 Web 的 HTTP ，还有用于电子邮件的 SMTP ，POP ，IMAP；用于文件传输的 FTP、FSP 和 TFTP；用于文件访问的 NFS；用于文件共享的 Gnutella 和 BitTorrent；用于语音通信的会话启动协议（Session Initiation Protocol, SIP）和 Skype 等。此外，你的程序可以在必要时自定义自己的应用层协议。&lt;/p&gt;
&lt;h1 id=&#34;15-即时通信&#34;&gt;15. 即时通信&lt;/h1&gt;
&lt;h2 id=&#34;sse&#34;&gt;SSE&lt;/h2&gt;
&lt;p&gt;ajax和JSONP 都是 client-fetch的操作. 但是有时候, 我们更需要服务器主动给我们发信息. 比如，现在的APP应用，完全可以实现服务器发送, 然后Client再处理。而SSE就是帮助我们向webapp靠近&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SSE 全称就是 Server-Sent Events&lt;/strong&gt;，，中译为 &lt;code&gt;服务器推送&lt;/code&gt;&lt;br&gt;
他的技术并不是很难，和websocket不同，他依赖原生的HTTP，所以对于开发者来说更好理解。&lt;br&gt;
比如，在nodeJS， 只要我不执行res.end()，并且一定时间持续发送信息的话，那么该连接就会持续打开(keep-alive)&lt;br&gt;
其实通俗来说，就是一个长连接。 所以，以前我们通常使用ajax，iframe长轮询来代替他。但是这样有个缺点就是，可操控性弱， 错误率高。&lt;br&gt;
所以，正对于这点W3C, 觉得需要在客户端另外指定一个机制–能够保证服务器推送, 实现连接的keep-alive，操作简单… 在这样背景下SSE诞生了&lt;/p&gt;
&lt;h1 id=&#34;16-模块化commonjses6cmdamd&#34;&gt;16. 模块化，commonJS，es6，cmd，amd&lt;/h1&gt;
&lt;h2 id=&#34;1-es6-moudle&#34;&gt;1. ES6 Moudle&lt;/h2&gt;
&lt;p&gt;这个是目前前端小伙伴接触的最多的，是浏览器和服务端通用的模块化解决方案，主要命令为：export和import&lt;br&gt;
export用于导出本模块对外的接口，import用于导入某个模块的功能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;如果单独导出一个变量或方法则是往将要导出{}对象里面添加属性。&lt;br&gt;
2.如果导出的是{}，则和已生成的导出{}对象合并。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后说一下特例&lt;code&gt;export default&lt;/code&gt;，这个是在导出对象里面加一个&lt;code&gt;default&lt;/code&gt;属性，还有一点值得注意的是&lt;code&gt;export default&lt;/code&gt;后面不能跟变量表达式。&lt;/p&gt;
&lt;h2 id=&#34;2-commonjs&#34;&gt;2. CommonJS&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;CommonJS&lt;/code&gt;最主要的代表就是&lt;code&gt;Node.js&lt;/code&gt;，主要命令：&lt;code&gt;module、exports、require&lt;/code&gt;。其中有个令人疑惑的点是exports和module.exports，其实理解起来也很简单，就是在模块里面加了一句： &lt;code&gt;exports = module.exports = {};&lt;/code&gt; exports和module.exports指向同一个内存区域，只要在exports加了属性，则module.exports会跟着变化，但是最终导出对外的接口是以module.exports为准，所以不推荐直接使用exports。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;CommonJS&lt;/code&gt;规范来说，很重要的一点是&lt;code&gt;CommonJS&lt;/code&gt;输出的是一个值拷贝，并且是运行时加载。&lt;/p&gt;
&lt;h2 id=&#34;3-commonjs和es6-module的区别&#34;&gt;3. CommonJS和ES6 Module的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;引用方式：CommonJS模块输出是值的拷贝，ES6 Module模块输出的值是引用&lt;/li&gt;
&lt;li&gt;时机：CommonJS是运行时加载，ES6 Module是编译是输出&lt;/li&gt;
&lt;li&gt;前者支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案&lt;/li&gt;
&lt;li&gt;前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响&lt;/li&gt;
&lt;li&gt;前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化&lt;/li&gt;
&lt;li&gt;后者会编译成 require/exports 来执行的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-amd&#34;&gt;4. AMD&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;AMD&lt;/code&gt;规范是采用异步方式，依赖前置必须一开始就写好，所有的依赖加载完成后才会执行回调函数里的内容，模块的加载不影响它后面语句的运行。&lt;/p&gt;
&lt;p&gt;这里异步指的是不堵塞浏览器其他任务（dom构建，css渲染等），而加载内部是同步的（加载完模块后立即执行回调）。&lt;/p&gt;
&lt;p&gt;AMD也采用require命令加载模块，但是不同于CommonJS，它要求两个参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;require([module], callback);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cmd&#34;&gt;CMD&lt;/h2&gt;
&lt;p&gt;CMD推崇&lt;code&gt;依赖就近，延迟执行&lt;/code&gt;。可以把你的依赖写进代码的任意一行，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;define(factory)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;factory为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。factory 方法在执行时，默认会传入三个参数：require、exports 和 module.&lt;/p&gt;
">【面】前端知识点梳理（服务端与网络）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/mian-qian-duan-zhi-shi-dian-shu-li-liu-lan-qi/"" data-c="
          &lt;h1 id=&#34;1-输入url到展示页面过程发生了什么&#34;&gt;1. 输入url到展示页面过程发生了什么？&lt;/h1&gt;
&lt;h2 id=&#34;1首先是域名解析dns解析&#34;&gt;1.首先是域名解析(DNS解析)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;首先浏览器解析输入的域名，先查找&lt;code&gt;本地硬盘的host&lt;/code&gt;文件,看有没有和这个域名对应的ip，如果有，就直接使用这个ip&lt;/li&gt;
&lt;li&gt;如果没有，浏览器会发出一个DNS请求到本地&lt;code&gt;DNS(域名分布系统)服务器&lt;/code&gt;，本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动&lt;/li&gt;
&lt;li&gt;请求到达DNS服务器后，DNS服务器首先会查询他的缓存记录，如果有对应的ip地址，则返回，如果没有，本地DNS服务器向&lt;code&gt;DNS根服务器&lt;/code&gt;发送查询请求&lt;/li&gt;
&lt;li&gt;根服务器不会记录具体的域名和ip的对应关系，而是返回&lt;code&gt;域服务器&lt;/code&gt;的地址，本地服务器会继续向域服务器发起请求&lt;/li&gt;
&lt;li&gt;域服务器并没有记录域名和ip的对应关系，而是返回你的&lt;code&gt;域名的解析服务器&lt;/code&gt;的地址&lt;/li&gt;
&lt;li&gt;本地DNS服务器继续向域名解析服务器发出请求，这时会收到&lt;code&gt;域名对应的ip&lt;/code&gt;，本地DNS服务器将ip返回给浏览器，并将ip存入缓存，方便下次访问，加快访问速度&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615435439972.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-建立tcp链接&#34;&gt;2. 建立TCP链接&lt;/h2&gt;
&lt;p&gt;在拿到ip地址后，浏览器会向对应的web服务器(Nginx,Apache...)发起TCP连接请求，通过三次握手，建立TCP连接&lt;/p&gt;
&lt;h2 id=&#34;3-建立http请求&#34;&gt;3. 建立Http请求&lt;/h2&gt;
&lt;p&gt;建立TCP连接后，浏览器向web服务器发送Http请求&lt;/p&gt;
&lt;h2 id=&#34;4-服务器处理http请求&#34;&gt;4. 服务器处理Http请求&lt;/h2&gt;
&lt;p&gt;服务器在接收到请求后，解析用户请求，知道了要调度那些资源文件，再通过相应的资源文件，处理用户的请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615435586035.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;5-关闭tcp连接&#34;&gt;5. 关闭TCP连接&lt;/h2&gt;
&lt;p&gt;在这次数据传输完成后，为了避免服务器与客户端双方的资源占用和损耗，会经过四次挥手，关闭TCP连接&lt;/p&gt;
&lt;h2 id=&#34;6-浏览器解析资源&#34;&gt;6. 浏览器解析资源&lt;/h2&gt;
&lt;p&gt;在拿到html,css,js,图片等资源后，浏览器开始解析，通过解析HTML，生成DOM树，解析CSS，生成CSS规则树，然后通过DOM树和CSS规则树生成渲染树&lt;/p&gt;
&lt;p&gt;在解析CSS的同时，可以继续加载解析HTML，但在解析执行JS脚本时，会停止解析后续HTML，这就会出现阻塞问题&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615435666741.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;7-浏览器渲染页面&#34;&gt;7. 浏览器渲染页面&lt;/h2&gt;
&lt;p&gt;生成渲染树后，浏览器根据渲染树布局页面，同时计算css样式或js对Dom的动态样式改变，然后绘制出页面&lt;/p&gt;
&lt;h1 id=&#34;2-重绘与回流&#34;&gt;2. 重绘与回流&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;重绘(repaint)&lt;/code&gt;: 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行&lt;strong&gt;更新&lt;/strong&gt;，此时由于只需要UI层面的重新像素绘制，因此 &lt;strong&gt;损耗较少&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;回流(reflow)&lt;/code&gt;: 当元素的尺寸、结构或触发某些属性时，浏览器会&lt;strong&gt;重新渲染&lt;/strong&gt;页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;会触发回流的操作:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页面初次渲染&lt;/li&gt;
&lt;li&gt;浏览器窗口大小改变&lt;/li&gt;
&lt;li&gt;元素尺寸、位置、内容发生改变&lt;/li&gt;
&lt;li&gt;元素字体大小变化&lt;/li&gt;
&lt;li&gt;添加或者删除可见的 dom 元素&lt;/li&gt;
&lt;li&gt;激活 CSS 伪类（例如：:hover）&lt;/li&gt;
&lt;li&gt;查询某些属性或调用某些方法&lt;/li&gt;
&lt;li&gt;clientWidth、clientHeight、clientTop、clientLeft&lt;/li&gt;
&lt;li&gt;offsetWidth、offsetHeight、offsetTop、offsetLeft&lt;/li&gt;
&lt;li&gt;scrollWidth、scrollHeight、scrollTop、scrollLeft&lt;/li&gt;
&lt;li&gt;getComputedStyle()&lt;/li&gt;
&lt;li&gt;getBoundingClientRect()&lt;/li&gt;
&lt;li&gt;scrollTo()&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;3-防抖与节流&#34;&gt;3. 防抖与节流&lt;/h1&gt;
&lt;h2 id=&#34;1-防抖debounce&#34;&gt;1. 防抖(debounce)&lt;/h2&gt;
&lt;p&gt;基于上述场景，首先提出第一种思路：&lt;strong&gt;在第一次触发事件时，不立即执行函数，而是给出一个期限值&lt;/strong&gt;比如200ms，然后：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果在200ms内没有再次触发滚动事件，那么就执行函数&lt;/li&gt;
&lt;li&gt;如果在200ms内再次触发滚动事件，那么当前的计时取消，重新开始计时&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;效果&lt;/strong&gt;：如果短时间内大量触发同一事件，只会执行一次函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;：既然前面都提到了计时，那实现的关键就在于&lt;code&gt;setTimeout&lt;/code&gt;这个函数，由于还需要一个变量来保存计时，考虑维护全局纯净，可以借助闭包来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function debounce(fn,delay){
    let timer = null //借助闭包
    return function() {
        if(timer){
            clearTimeout(timer) 
        }
        timer = setTimeout(fn,delay) // 简化写法
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;对于短时间内连续触发的事件（上面的滚动事件），防抖的含义就是让某个时间期限（如上面的1000毫秒）内，事件处理函数只执行一次。&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-节流throttle&#34;&gt;2. 节流(throttle)&lt;/h2&gt;
&lt;p&gt;类似&lt;strong&gt;控制阀门一样定期开放的函数，也就是让函数执行一次后，在某个时间段内暂时失效，过了这段时间后再重新激活&lt;/strong&gt;（类似于技能冷却时间）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效果&lt;/strong&gt;：如果短时间内大量触发同一事件，&lt;strong&gt;那么在函数执行一次之后，该函数在指定的时间期限内不再工作&lt;/strong&gt;，直至过了这段时间才重新生效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt; 这里借助&lt;code&gt;setTimeout&lt;/code&gt;来做一个简单的实现，加上一个状态位&lt;code&gt;valid&lt;/code&gt;来表示当前函数是否处于工作状态：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function throttle(fn,delay){
    let valid = true
    return function() {
       if(!valid){
           //休息时间 暂不接客
           return false 
       }
       // 工作时间，执行函数并且在间隔期内把状态位设为无效
        valid = false
        setTimeout(() =&amp;gt; {
            fn()
            valid = true;
        }, delay)
    }
}
/* 请注意，节流函数并不止上面这种实现方案,
   例如可以完全不借助setTimeout，可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定。
   也可以直接将setTimeout的返回的标记当做判断条件-判断当前定时器是否存在，如果存在表示还在冷却，并且在执行fn之后消除定时器表示激活，原理都一样
    */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行以上代码的结果是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一直拖着滚动条进行滚动，那么会以1s的时间间隔，持续输出当前位置和顶部的距离&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-其他场景&#34;&gt;3. 其他场景&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;搜索框input事件，例如要支持输入实时搜索可以使用节流方案（间隔一段时间就必须查询相关内容），或者实现输入间隔大于某个值（如500ms），就当做用户输入完成，然后开始搜索，具体使用哪种方案要看业务需求。&lt;/li&gt;
&lt;li&gt;页面resize事件，常见于需要做页面适配的时候。需要根据最终呈现的页面情况进行dom渲染（这种情形一般是使用防抖，因为只需要判断最后一次的变化情况）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;4-前端持久化储存-cookies-session-sessionstorage-localstorage&#34;&gt;4. 前端持久化储存 cookies、session、sessionStorage、localStorage&lt;/h1&gt;
&lt;h2 id=&#34;1-cookie&#34;&gt;1. cookie&lt;/h2&gt;
&lt;p&gt;由于HTTP是一种&lt;strong&gt;无状态的协议&lt;/strong&gt;，服务器单从网络连接上是无法知道客户身份的。这时候服务器就需要给客户端颁发一个cookie，用来确认用户的身份。&lt;/p&gt;
&lt;h3 id=&#34;cookie的构成&#34;&gt;cookie的构成&lt;/h3&gt;
&lt;p&gt;服务器端向客户端发送Cookie是通过HTTP响应报文实现的，在Set-Cookie中设置需要向客户端发送的cookie，cookie格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Set-Cookie: &amp;quot;name=value;domain=.domain.com;path=/;expires=Sat, 11 Jun 2019 11:29:42 GMT;HttpOnly;secure&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中name=value是必选项，其它都是可选项。Cookie的主要构成如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;name:一个唯一确定的cookie&lt;code&gt;名称&lt;/code&gt;。通常来讲cookie的名称是不区分大小写的。&lt;/li&gt;
&lt;li&gt;value:存储在cookie中的&lt;code&gt;字符串值&lt;/code&gt;。&lt;strong&gt;最好为cookie的name和value进行url编码&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;domain:cookie对于哪个&lt;code&gt;域&lt;/code&gt;是有效的。所有向该域发送的请求中都会包含这个cookie信息。这个值可以包含子域(如：http://e.baidu.com)，也可以不包含它(如：.http://baidu.com，则对于http://baidu.com的所有子域都有效)。&lt;/li&gt;
&lt;li&gt;path: 表示这个cookie影响到的&lt;code&gt;路径&lt;/code&gt;，浏览器跟会根据这项配置，像指定域中匹配的路径发送cookie。&lt;/li&gt;
&lt;li&gt;expires:&lt;code&gt;失效时间&lt;/code&gt;，表示cookie何时应该被删除的时间戳(也就是，何时应该停止向服务器发送这个cookie)。如果不设置这个时间戳，浏览器会在页面关闭时即将删除所有cookie；不过也可以自己设置删除时间。这个值是GMT时间格式。如果客户端和服务器端时间不一致，使用expires就会存在偏差。并且如果给cookie设置一个过去的时间，浏览器会立即删除该cookie&lt;/li&gt;
&lt;li&gt;max-age: 与expires作用相同，用来告诉浏览器此cookie多久过期（单位是秒），而不是一个固定的时间点。正常情况下，max-age的&lt;code&gt;优先级高&lt;/code&gt;于expires。&lt;/li&gt;
&lt;li&gt;HttpOnly: 告知浏览器不允许通过脚本document.cookie去更改这个值，同样这个值在document.cookie中也不可见。但在http请求仍然会携带这个cookie。注意这个值虽然在脚本中不可获取，但仍然在浏览器安装目录中以文件形式存在。这项设置通常在&lt;code&gt;服务器端设置&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;secure: 安全标志，指定后，只有在使用&lt;code&gt;SSL链接&lt;/code&gt;时候才能发送到服务器，如果是http链接则不会传递该信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;cookie的不可跨域名性&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：修改、删除Cookie时，新建的Cookie除value、maxAge之外的所有属性，例如name、path、domain等，都要与原Cookie完全一样。否则，浏览器将视为两个不同的Cookie不予覆盖，导致修改、删除失败。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-session&#34;&gt;2. Session&lt;/h2&gt;
&lt;p&gt;Session是另一种记录客户状态的机制，不同的是Cookie保存在&lt;code&gt;客户端浏览器&lt;/code&gt;中，而Session保存在&lt;code&gt;服务器上&lt;/code&gt;。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。&lt;/p&gt;
&lt;p&gt;Session 之所以可以识别不同的用户，依靠的就是Cookie，所以说&lt;strong&gt;session是基于cookie的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该Cookie是服务器自动颁发给浏览器的，不用我们手工创建的。该Cookie的&lt;code&gt;maxAge值默认是-1&lt;/code&gt;，也就是说仅当前浏览器使用，不将该Cookie存在硬盘中，并且各浏览器窗口间不共享，关闭浏览器就会失效。&lt;/p&gt;
&lt;h3 id=&#34;工作步骤&#34;&gt;工作步骤：&lt;/h3&gt;
&lt;p&gt;将客户端称为 client，服务端称为 server&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;产生 sessionID：session 是基于 cookie 的一种方案，所以，首先要产生 cookie。client 第一次访问 server，server 生成一个随机数，命名为 sessionID，并将其放在响应头里，以 cookie 的形式返回给 client，client 以处理其他 cookie 的方式处理这段 cookie。大概是这样：cookie：sessionID=135165432165&lt;/li&gt;
&lt;li&gt;保存 sessionID： server 将要保存的数据保存在相对应的 sessionID 之下，再将 sessionID 保存到服务器端的特定的保存 session 的内存中（如 一个叫 session 的哈希表）&lt;/li&gt;
&lt;li&gt;使用 session： client 再次访问 server，会带上首次访问时获得的 值为 sessionID 的cookie，server 读取 cookie 中的 sessionID，根据 sessionID 到保存 session 的内存寻找与 sessionID 匹配的数据，若寻找成功就将数据返回给 client。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;session有效期&#34;&gt;Session有效期&lt;/h3&gt;
&lt;p&gt;Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。用户每访问服务器一次，无论是否读写Session，服务器都认为该用户的Session“活跃（active）”了一次。&lt;/p&gt;
&lt;p&gt;由于会有越来越多的用户访问服务器，因此Session也会越来越多。为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了。&lt;/p&gt;
&lt;h2 id=&#34;3-cookie与session的区别&#34;&gt;3. cookie与session的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Cookie数据存放在客户端，Session数据放在服务器端&lt;/li&gt;
&lt;li&gt;Cookie的安全性一般，他人可通过分析存放在本地的Cookie并进行Cookie欺骗。在安全性第一的前提下，选择Session更优。重要交互信息比如权限等就要放在Session中，一般的信息记录放Cookie中&lt;/li&gt;
&lt;li&gt;单个Cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个Cookie，而Session原则上没有限制&lt;/li&gt;
&lt;li&gt;Session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用Cookie。&lt;/li&gt;
&lt;li&gt;Session 的运行依赖Session ID，而 Session ID 是存在 Cookie 中的，也就是说，如果浏览器禁用了 Cookie，Session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 Session ID，也就是地址重写）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-localstorage&#34;&gt;4. localStorage&lt;/h2&gt;
&lt;p&gt;localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。&lt;/p&gt;
&lt;p&gt;并且不会因为刷新而释放，所以，&lt;strong&gt;可以使用 localStorage 来实现变量的持久化存储&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;localStorage的特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;localStorage 与 HTTP 没有任何关系，所以在HTTP请求时不会带上 localStorage 的值&lt;/li&gt;
&lt;li&gt;只有相同域名的页面才能互相读取 localStorage，同源策略与 cookie 一致&lt;/li&gt;
&lt;li&gt;不同的浏览器，对每个域名 localStorage 的最大存储量的规定不一样，超出存储量会被拒绝。最大存5M 超过5M的数据就会丢失。而 Chrome 10MB 左右&lt;/li&gt;
&lt;li&gt;常用来记录一些不敏感的信息&lt;/li&gt;
&lt;li&gt;localStorage 理论上永久有效，除非用户清理缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-sessionstorage&#34;&gt;5. sessionStorage&lt;/h2&gt;
&lt;p&gt;sessionStorage 的所有性质基本上与 localStorage 一致，唯一的不同区别在于：&lt;/p&gt;
&lt;p&gt;sessionStorage 的有效期是页面会话持续，如果页面&lt;code&gt;会话（session）结束&lt;/code&gt;（关闭窗口或标签页），sessionStorage 就会&lt;code&gt;消失&lt;/code&gt;。而 localStorage 则会一直存在。&lt;/p&gt;
&lt;h2 id=&#34;6-localstorage与sessionstorage的区别&#34;&gt;6. localStorage与sessionStorage的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;localStorage生命周期是永久的，除非被清除，否则永久保存，而sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;5-浏览器内核&#34;&gt;5. 浏览器内核&lt;/h1&gt;
&lt;p&gt;浏览器内核可以分为两部分：&lt;code&gt;渲染引擎&lt;/code&gt;（Layout Engine或Rendering Engine）和&lt;code&gt;JS引擎&lt;/code&gt;。由于JS引擎越来越独立，内核就倾向于只指渲染引擎。&lt;/p&gt;
&lt;h2 id=&#34;1-浏览器构成&#34;&gt;1. 浏览器构成&lt;/h2&gt;
&lt;p&gt;浏览器一般由七个模块组成，User Interface（用户界面）、Browser engine（浏览器引擎）、Rendering engine（渲染引擎）、Networking（网络）、JavaScript Interpreter（js解释器）、UI Backend（UI 后端）、Date Persistence（数据持久化存储）&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615442013118.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户界面 －包括地址栏、后退/前进按钮、书签目录等，也就是你-所看到的除了页面显示窗口之外的其他部分&lt;/li&gt;
&lt;li&gt;浏览器引擎 －可以在用户界面和渲染引擎之间传送指令或在客户端本地缓存中读写数据等，是浏览器中各个部分之间相互通信的核心&lt;/li&gt;
&lt;li&gt;渲染引擎 －解析DOM文档和CSS规则并将内容排版到浏览器中显示有样式的界面，也有人称之为排版引擎，我们常说的浏览器内核主要指的就是渲染引擎&lt;/li&gt;
&lt;li&gt;网络 －用来完成网络调用或资源下载的模块&lt;/li&gt;
&lt;li&gt;UI 后端 －用来绘制基本的浏览器窗口内控件，如输入框、按钮、单选按钮等，根据浏览器不同绘制的视觉效果也不同，但功能都是一样的。&lt;/li&gt;
&lt;li&gt;JS解释器 －用来解释执行JS脚本的模块，如 V8 引擎、JavaScriptCore&lt;/li&gt;
&lt;li&gt;数据存储 －浏览器在硬盘中保存 cookie、localStorage等各种数据，可通过浏览器引擎提供的API进行调用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-主流浏览器的内核&#34;&gt;2. 主流浏览器的内核&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;IE内核(Trident)&lt;/strong&gt;&lt;br&gt;
Trident内核代表产品Internet Explorer，又称其为IE内核。Trident（又称为MSHTML），是微软开发的一种排版引擎。国内很多的双核浏览器其中之一就是Trident，美名其曰“兼容模式”。&lt;br&gt;
代表：IE、傲游、世界之窗浏览器、Avant、猎豹安全浏览器、360极速浏览器、百度浏览器等。&lt;br&gt;
Window10发布后，IE将其内置浏览器命名为Edge（原名斯巴达），使用了新内核Edge引擎。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Firefox（Gecko）&lt;/strong&gt;&lt;br&gt;
Gecko内核代表作品Mozilla FirefoxGecko是一套开放源代码的、以C++编写的网页排版引擎。Gecko是最流行的排版引擎之一，仅次于Trident。使用它的最著名浏览器有Firefox、Netscape6至9。可惜这几年已经没落了，比如打开速度慢、升级频繁、猪一样的队友flash、神一样的对手Chrome。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Safari（Webkit）&lt;/strong&gt;&lt;br&gt;
苹果公司自己的内核，也是苹果的Safari浏览器使用的内核。&lt;br&gt;
WebKit内核代表作品Safari、Chromewebkit 是一个开源项目，包含了来自KDE项目和苹果公司的一些组件，主要用于Mac OS系统，它的特点在于源码结构清晰、渲染速度极快。缺点是对网页代码的兼容性不高，导致一些编写不标准的网页无法正常显示。主要代表作品有Safari和Google的浏览器Chrome。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Chrome（Blink）&lt;/strong&gt;&lt;br&gt;
有Google和Opera Software开发的浏览器排版引擎，2013年4月发布，现在Chrome内核是Blink。Blink其实是webkit的分支，大部分国产浏览器最新版都采用Blink内核。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Opera（Presto）&lt;/strong&gt;&lt;br&gt;
Presto内核代表作品OperaPresto是由Opera Software开发的浏览器排版引擎，供Opera 7.0及以上使用。它取代了旧版Opera 4至6版本使用的Elektra排版引擎，包括加入动态功能，例如网页或其部分可随着DOM及Script语法的事件而重新排版。在13年之后，Opera宣布加入谷歌阵营，弃用了Presto。&lt;/p&gt;
&lt;h1 id=&#34;6-算法的时间与空间复杂度&#34;&gt;6. 算法的时间与空间复杂度&lt;/h1&gt;
&lt;p&gt;主要还是从算法所占用的「时间」和「空间」两个维度去考量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。&lt;/li&gt;
&lt;li&gt;空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-时间复杂度&#34;&gt;1. 时间复杂度&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;「 大O符号表示法 」，即 T(n) = O(f(n))&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常见的时间复杂度量级有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常数阶O(1)：&lt;code&gt;没有循环&lt;/code&gt;等复杂结构&lt;/li&gt;
&lt;li&gt;对数阶O(logN)：在&lt;code&gt;while&lt;/code&gt;循环里面，每次都&lt;code&gt;将 i 乘以 2&lt;/code&gt;，乘完之后，i 距离 n 就越来越近了。&lt;/li&gt;
&lt;li&gt;线性阶O(n)：&lt;code&gt;for循环里面&lt;/code&gt;的代码会执行n遍&lt;/li&gt;
&lt;li&gt;线性对数阶O(nlogN)：将时间复杂度为O(logn)的代码循环N遍&lt;/li&gt;
&lt;li&gt;平方阶O(n²)：如果把 O(n) 的代码&lt;code&gt;再嵌套循环一遍&lt;/code&gt;，它的时间复杂度就是 O(n²)&lt;/li&gt;
&lt;li&gt;立方阶O(n³)&lt;/li&gt;
&lt;li&gt;K次方阶O(n^k)&lt;/li&gt;
&lt;li&gt;指数阶(2^n)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-空间复杂度&#34;&gt;2. 空间复杂度&lt;/h2&gt;
&lt;p&gt;空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。&lt;/p&gt;
&lt;p&gt;空间复杂度比较常用的有：O(1)、O(n)、O(n²)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;空间复杂度 O(1)&lt;br&gt;
如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空间复杂度 O(n)&lt;br&gt;
第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">【面】前端知识点梳理（浏览器+复杂度）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/mian-qian-duan-zhi-shi-dian-shu-li-es6/"" data-c="
          &lt;h1 id=&#34;1-声明-let-const&#34;&gt;1. 声明 let、const&lt;/h1&gt;
&lt;h2 id=&#34;1-let声明变量的特点&#34;&gt;1. let声明变量的特点:&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;变量不能重复声明&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;每个循环每执行一次都有一个大括号{}，{}内的代码属于一个代码块，let声明的变量属于块级作用域，所以看上去能重复声明。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (let i = 0; i &amp;lt; 10; i++) {
        let s = &amp;quot;a&amp;quot;;
        console.log(s);    //这里会输出10个a
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;定义的变量可以被修改&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let c = 1;
c++;
console.log(c); //2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;定义的变量是块级作用域的变量&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;必须先声明后使用&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-const-声明常量的特点&#34;&gt;2. const 声明常量的特点：&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;常量不能重复声明，同let&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;常量不能被修改&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const p  = 1;
p=2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;上面的代码浏览器会报错&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;必须先声明后使用&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;2-解构赋值&#34;&gt;2. 解构赋值&lt;/h1&gt;
&lt;h2 id=&#34;1-解构赋值的定义&#34;&gt;1. 解构赋值的定义&lt;/h2&gt;
&lt;p&gt;ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构，本质是一种模式匹配。&lt;/p&gt;
&lt;h2 id=&#34;2-数组的解构赋值&#34;&gt;2. 数组的解构赋值&lt;/h2&gt;
&lt;p&gt;按照对应位置，对变量赋值，如果解构不成功，变量的值就等于undefined。&lt;br&gt;
同时解构赋值允许指定默认值。只有当一个数组成员严格等于undefined，默认值才会生效。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let [a, b, c] = [1, 2, 3];   //a=1,b=2,c=3
let [x, , y] = [1, 2, 3];    //x=1,y=3
let [foo] = [];              //foo=undefined
let [foo = 1] = [];      //foo=1
let [foo = 1] = [null];  //foo=null
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-对象的解构赋值&#34;&gt;3. 对象的解构赋值&lt;/h2&gt;
&lt;p&gt;对象的解构是按照属性来进行解构赋值的。如果解构不成功，变量的值就等于undefined。&lt;br&gt;
对象的解构也可以指定默认值。默认值生效的条件是，对象的属性值严格等于undefined。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let { a: foo, b: bar } = { a: &amp;quot;123&amp;quot;, b: &amp;quot;456&amp;quot; }    //foo=123  bar =456
let { a: a, b: b } = { a: &amp;quot;123&amp;quot;, b: &amp;quot;456&amp;quot; }       //a=123 b=456
let { a, b } = { a: &amp;quot;123&amp;quot;, b: &amp;quot;456&amp;quot; }      //a=123 b=456   
//第三种写法等于第二种，因为es6中可以在对象中直接写入变量
let { a, c } = { a: &amp;quot;123&amp;quot;, b: &amp;quot;456&amp;quot; }     //a=123  c=undefined
let { a, c = 3 } = { a: &amp;quot;123&amp;quot;, b: &amp;quot;456&amp;quot; }    //a=123  c=3
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-其他的解构赋值&#34;&gt;4. 其他的解构赋值&lt;/h2&gt;
&lt;p&gt;解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let  { toString: s } = 123      //s是对象的toString方法
let  { toString: s } = true;     //s是对象的toString方法
let { prop: x } = undefined;   //报错
let { prop: y } = null;      //  报错
const [a, b, c, d, e] = &amp;quot;hello&amp;quot;   // a=h b=e ...
const { 0: a, 1: b, 2: c, 3: d, 4: e } = &amp;quot;hello&amp;quot;    //a=h b=e ...
//字符串被转为类数组对象，故可以使用数组和对象解构赋值
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-解构赋值的用途&#34;&gt;5. 解构赋值的用途&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;交换变量的值&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt; let x = 1
 let y = 2
 [x, y] = [y, x]
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;方便取值&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;let obj = {
  a:1,
  b:2,
  c: function(){return 1}
}
 let {a,b} = obj  //代替以前  let a= obj.a, b=obj.b 的写法
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;输入模块的指定方法&lt;/li&gt;
&lt;li&gt;遍历 Map 结构&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;3-声明类与继承class-extend&#34;&gt;3. 声明类与继承：class、extend&lt;/h1&gt;
&lt;h2 id=&#34;1-类class&#34;&gt;1. 类（Class）&lt;/h2&gt;
&lt;p&gt;基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//定义类
class Point {
  constructor(x, y) {  //constructor 构造方法
    this.x = x;
    this.y = y;
  }
  toString() {
    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
  }
}
var p = new Point(1, 2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都还是定义在类的prototype属性上面。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constructor方法&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。&lt;/p&gt;
&lt;h2 id=&#34;2-继承extends&#34;&gt;2. 继承（Extends）&lt;/h2&gt;
&lt;p&gt;Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ColorPoint extends Point {
  constructor(x, y, color) {
    super(x, y); // 调用父类的constructor(x, y)
    this.color = color;
  }
  toString() {
    return this.color + &#39; &#39; + super.toString(); // 调用父类的toString()
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。&lt;/p&gt;
&lt;p&gt;子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。&lt;/p&gt;
&lt;h2 id=&#34;3-原生构造函数继承&#34;&gt;3. 原生构造函数继承&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boolean()&lt;/li&gt;
&lt;li&gt;Number()&lt;/li&gt;
&lt;li&gt;String()&lt;/li&gt;
&lt;li&gt;Array()&lt;/li&gt;
&lt;li&gt;Date()&lt;/li&gt;
&lt;li&gt;Function()&lt;/li&gt;
&lt;li&gt;RegExp()&lt;/li&gt;
&lt;li&gt;Error()&lt;/li&gt;
&lt;li&gt;Object()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这意味着，ES6可以自定义原生数据结构（比如Array、String等）的子类，这是ES5无法做到的。&lt;/p&gt;
&lt;h2 id=&#34;4-class的generator方法&#34;&gt;4. Class的Generator方法&lt;/h2&gt;
&lt;p&gt;如果某个方法之前加上星号（*），就表示该方法是一个Generator函数。&lt;/p&gt;
&lt;h2 id=&#34;5-class的静态方法&#34;&gt;5. Class的静态方法&lt;/h2&gt;
&lt;p&gt;类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Foo {
  static classMethod() {
    return &#39;hello&#39;;
  }
}
Foo.classMethod() // &#39;hello&#39;
var foo = new Foo();
foo.classMethod()
// TypeError: foo.classMethod is not a function
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。&lt;/p&gt;
&lt;h1 id=&#34;4-promise的使用与实现&#34;&gt;4. Promise的使用与实现&lt;/h1&gt;
&lt;p&gt;Promise 是 ES6 新增的语法，解决了回调地狱的问题。&lt;/p&gt;
&lt;p&gt;可以把 Promise 看成一个状态机。初始是 &lt;code&gt;pending&lt;/code&gt; 状态，可以通过函数 &lt;code&gt;resolve&lt;/code&gt; 和 &lt;code&gt;reject&lt;/code&gt; ，将状态转变为 &lt;code&gt;resolved&lt;/code&gt;或者&lt;code&gt;rejected&lt;/code&gt; 状态，状态一旦改变就不能再次变化。&lt;/p&gt;
&lt;h2 id=&#34;1-promise的使用及原理&#34;&gt;1. Promise的使用及原理&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;基本形式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;newPromise(resolve=&amp;gt;{
    ajax(&amp;quot;/pay/post&amp;quot;, data=&amp;gt;resolve() );
}).then(resolve=&amp;gt;{
    ajax(&amp;quot;/order/fix&amp;quot;, data=&amp;gt;{
        //处理数据   
    })
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;链式调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一旦A执行完，B开始后，这次承诺也就兑现了，Promise对象也就失效了&lt;br&gt;
那如果还有C呢？ 我们就必须在函数B中，&lt;br&gt;
重新创建新的Promise对象，来完成下一个承诺，具体的写法就像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new Promise(函数1(resolve){
    ajaxA(&amp;quot;xxxx&amp;quot;, function(){
        resolve();//通知Promise该任务结束
    })    
}).then(函数2(){
    //在函数2开始运行后，第一次创建的Promise对象完成使命，已经不能再继续工作。
    //此时，我们创建并返回了新的Promise对象
    return new Promise(function(resolve){
        ajaxB(&amp;quot;xxxx&amp;quot;, function(){
            resolve();//通知新的Promise对象该任务结束
        })    
    })
}).then(函数3(){ //尽管这里使用了链式调用，但负责执行函数3的，已经是新的Promise对象了
    // 如果，我们还有ajaxD需要顺序调用
    // 那就必须在这里重新new Promise()对象了
    ajaxC(&amp;quot;xxx&amp;quot;, function(){     })
})   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我有 A,B,C 三个异步任务，ABC同时开始执行&lt;br&gt;
当&lt;code&gt;A,B,C三个任务全部都结束&lt;/code&gt;时，执任务D，&lt;br&gt;
传统方法实现起来就比较复杂，Promise就非常简单，就像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Promise.all([new Promise(A), new Promise(B), new Promise(C)])
.then(function(){
    D();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那如果我希望A,B,C 其中&lt;code&gt;任意一个&lt;/code&gt;任务完成，&lt;br&gt;
就马上开始任务D，该怎么做？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Promise.race([new Promise(A), new Promise(B), new Promise(C)])
.then(function(){
   D();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-promisea-方案&#34;&gt;2. Promise/A+ 方案&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;promise 有三个状态 pending、fulfilled、rejected，只能由 pending 向 fulfilled 、rejected 两种状态发生改变。&lt;/li&gt;
&lt;li&gt;promise 需要提供一个 then 方法，then 方法接收 (onFulfilled,onRejected) 两个函数作为参数。&lt;/li&gt;
&lt;li&gt;onFulfilled、onRejected 须在 promise 完成后后（状态扭转）后调用，且只能调用一次。&lt;/li&gt;
&lt;li&gt;onFulfilled、onRejected 仅仅作为函数进行调用，不能够将 this 指向调用它的 promise。&lt;/li&gt;
&lt;li&gt;onFulfilled、onRejected 必须在&lt;strong&gt;执行上下文栈&lt;/strong&gt;只包含&lt;strong&gt;平台代码&lt;/strong&gt;后才能执行。平台代码指 引擎，环境，Promise 实现代码。（PS:这处规范要求 onFulfilled、onRejected 函数的执行必须在 then 被调用的那个事件循环之后的事件循环。但是规范并没有要求是把它们作为一个微任务或是宏任务去执行，只是各平台的实现均把 Promise 的 onFulfilled、onRejected 放到微任务队列中去执行了)&lt;/li&gt;
&lt;li&gt;onFulfilled、onRejected 必须是个函数，否则忽略。&lt;/li&gt;
&lt;li&gt;then 方法可以被一个 promise 多次调用。&lt;/li&gt;
&lt;li&gt;then 方法需要返回一个 promise。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;5-generator异步编程-yield-next-await-async&#34;&gt;5. Generator（异步编程、yield、next()、await 、async）&lt;/h1&gt;
&lt;h2 id=&#34;1-generator&#34;&gt;1. Generator&lt;/h2&gt;
&lt;p&gt;Generator是一个函数，可以在函数内部通过&lt;code&gt;yield&lt;/code&gt;返回一个值（此时，Generator函数的执行会暂定，直到下次触发&lt;code&gt;.next()&lt;/code&gt;）&lt;br&gt;
创建一个&lt;code&gt;Generator函数&lt;/code&gt;的方法是在&lt;code&gt;function&lt;/code&gt;关键字后添加&lt;code&gt;*&lt;/code&gt;标识。&lt;/p&gt;
&lt;p&gt;在调用一个Generator函数后，并不会立即执行其中的代码，函数会返回一个&lt;code&gt;Generator&lt;/code&gt;对象，通过调用对象的&lt;code&gt;next&lt;/code&gt;函数，可以获得&lt;code&gt;yield/return&lt;/code&gt;的返回值。&lt;br&gt;
无论是触发了&lt;code&gt;yield&lt;/code&gt;还是&lt;code&gt;return&lt;/code&gt;，&lt;code&gt;next()&lt;/code&gt;函数总会返回一个带有&lt;code&gt;value&lt;/code&gt;和&lt;code&gt;done&lt;/code&gt;属性的对象。&lt;br&gt;
&lt;code&gt;value&lt;/code&gt;为返回值，&lt;code&gt;done&lt;/code&gt;则是一个Boolean对象，用来标识Generator是否还能继续提供返回值。&lt;br&gt;
P.S. Generator函数的执行时惰性的，yield后的代码只在&lt;code&gt;触发next&lt;/code&gt;时才会执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function * oddGenerator () {
  yield 1
  yield 3

  return 5
}

let iterator = oddGenerator()

let first = iterator.next()  // { value: 1, done: false }
let second = iterator.next() // { value: 3, done: false }
let third = iterator.next()  // { value: 5, done: true  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-next的参数传递&#34;&gt;2. next的参数传递&lt;/h2&gt;
&lt;p&gt;我们可以在调用&lt;code&gt;next()&lt;/code&gt;的时候传递一个参数，可以在上次&lt;code&gt;yield&lt;/code&gt;前接收到这个参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function * outputGenerator () {
  let ret1 = yield 1
  console.log(`got ret1: ${ret1}`)
  let ret2 = yield 2
  console.log(`got ret2: ${ret2}`)
}

let iterator = outputGenerator()

iterator.next(1)
iterator.next(2) // got ret1: 2
iterator.next(3) // got ret2: 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一眼看上去可能会有些诡异，为什么第一条&lt;code&gt;log&lt;/code&gt;是在第二次调用&lt;code&gt;next&lt;/code&gt;时才进行输出的&lt;br&gt;
这就又要说到上边的&lt;code&gt;Generator&lt;/code&gt;的实现了，上边说到了，&lt;code&gt;yield&lt;/code&gt;与&lt;code&gt;return&lt;/code&gt;都是用来返回值的语法。 函数在执行时遇到这两个关键字后就会暂停执行，等待下次激活。&lt;br&gt;
然后&lt;code&gt;let ret1 = yield 1&lt;/code&gt;，这是一个赋值表达式，也就是说会先执行&lt;code&gt;=右边&lt;/code&gt;的部分，在=右边执行的过程中遇到了yield关键字，函数也就在此处&lt;code&gt;暂停&lt;/code&gt;了，在下次触发&lt;code&gt;next()&lt;/code&gt;时才被激活，此时，我们继续进行上次未完成的赋值语句&lt;code&gt;let ret1 = XXX&lt;/code&gt;，并在再次遇到yield时&lt;code&gt;暂停&lt;/code&gt;。&lt;br&gt;
这也就解释了为什么&lt;strong&gt;第二次调用next()的参数会被第一次yield赋值的变量接收到&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-用作迭代器使用for-of&#34;&gt;3. 用作迭代器使用(for of)&lt;/h2&gt;
&lt;p&gt;但是要注意的是，用作迭代器中的使用，则只会作用于yield&lt;br&gt;
return的返回值不计入迭代&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function * oddGenerator () {
  yield 1
  yield 3
  yield 5

  return &#39;won\&#39;t be iterate&#39;
}

for (let value of oddGenerator()) {
  console.log(value)
}
//  1
//  3
//  5
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-generator函数内部的generator&#34;&gt;4. Generator函数内部的Generator&lt;/h2&gt;
&lt;p&gt;除了&lt;code&gt;yield&lt;/code&gt;语法以外，其实还有一个&lt;code&gt;yield*&lt;/code&gt;语法，可以粗略的理解为是&lt;code&gt;Generator&lt;/code&gt;函数版的&lt;code&gt;[...]&lt;/code&gt;&lt;br&gt;
用来展开Generator迭代器的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function * gen1 () {
  yield 1
  yield* gen2()
  yield 5
}

function * gen2 () {
  yield 2
  yield 3
  yield 4
  return &#39;won\&#39;t be iterate&#39;
}

for (let value of gen1()) {
  console.log(value)
}
//  1
//  2
//  3
//  4
//  5
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-async和await&#34;&gt;5. async和await&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;async函数是Generator函数的语法糖，将Generator的&lt;code&gt;星号&lt;/code&gt;换成&lt;code&gt;async&lt;/code&gt;将&lt;code&gt;yield&lt;/code&gt;换成&lt;code&gt;await&lt;/code&gt;，async函数比Generator函数更好用。&lt;code&gt;async&lt;/code&gt; 表示函数里有异步操作，&lt;code&gt;await&lt;/code&gt; 表示紧跟在后面的表达式需要等待结果。&lt;/li&gt;
&lt;li&gt;await 只能出现在 async 函数中&lt;/li&gt;
&lt;li&gt;async 函数返回的是一个 Promise 对象&lt;/li&gt;
&lt;li&gt;如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。&lt;br&gt;
如果它等到的是一个 Promise 对象，await 就会阻塞后面的代码，等着 Promise 对象 resolve或者reject方法，然后得到 resolve的值，作为 await 表达式的运算结果。&lt;/li&gt;
&lt;li&gt;一般await都会用try/catch包起来&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;6-箭头函数this指向问题-拓展运算符&#34;&gt;6. 箭头函数this指向问题、拓展运算符&lt;/h1&gt;
&lt;h2 id=&#34;1-箭头函数this指向&#34;&gt;1. 箭头函数this指向&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;箭头函数中的this指向的是定义时的this，而不是执行时的this。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//定义一个对象
    var obj = {
        x:100,//属性x
        show(){
            //延迟500毫秒，输出x的值
            setTimeout(
               //不同处：箭头函数
               () =&amp;gt; { console.log(this.x)},
               500
            );
        }
    };
    obj.show();//打印结果：100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当定义obj的show( )方法的时候，我们在箭头函数编写this.x，此时的this是指的obj，所以this.x指的是obj.x。而在show()被调用的时候，this依然指向的是被定义时候所指向的对象，也就是obj对象，故打印出：100。&lt;/p&gt;
&lt;h2 id=&#34;2-拓展运算符&#34;&gt;2. 拓展运算符&lt;/h2&gt;
&lt;p&gt;拓展运算符允许一个可迭代的对象（数组、类数组对象、字符串、ES6中的Set、Map等拥有默认迭代器Symbol(Symbol.iterator)属性，可以被for...of遍历的对象）去拓展函数调用的参数、数组的元素，同时也允许以Object键值对的形式去拓展另一个对象&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;化参数为数组&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;var showLambdaArgs = (...foo)=&amp;gt;{
  return foo
}
showLambdaArgs(1,2,3,4,5,6)//[1,2,3,4,5,6]

//在普通函数中也能使用，注意与arguments的区别
function showArgs(...foo){
    console.log(arguments instanceof Array)// false
    console.log(foo instanceof Array)// true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;code&gt;化数组为参数&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;function introduce(){
   console.log(arguments)//对象
   console.log(arguments.length)//参数个数
}
introduce(1,2,3,...[8,9,0])// arguments对象 和 6
introduce(4,5,...&amp;quot;abcde&amp;quot;)// arguments对象 和 7
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;code&gt;化可迭代对象为数组&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;//解构赋值也可以这么用
var [a,b,c] = [...&#39;123&#39;]//a = 1;b = 2;c = 3
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;//一行去重数组ver2:
[...new Set([1,1,2,3,3,4,4,4])] //1 , 2 , 3 ,4
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;//倒序参数
function reverseArgs(){
  return [...arguments].reverse()//现在可以调用数组方法了
}
reverseArgs(1,2,3,4,5)//[5, 4, 3, 2, 1]
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;code&gt;扩展对象&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对象的拷贝方法五花八门，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有JSON.parse(JSON.stringify(obj))的&lt;/li&gt;
&lt;li&gt;有for(var i in obj){}赋值的&lt;/li&gt;
&lt;li&gt;使用ES6的Object.assign()可能是大多数使用ES6开发者的选择：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;var o = {a:1,b:2}
var p = Object.assign({},o)
console.log(o === p) //false
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;7map和set数组去重map数据结构有什么优点&#34;&gt;7.map和set数组去重，map数据结构有什么优点？&lt;/h1&gt;
&lt;h2 id=&#34;1-set数组去重&#34;&gt;1. set数组去重&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;et arr = [1, 2, 2, 3, 4]
function unique (arr) {
    return [...new Set(arr)]
}
console.log(unique(arr)) // [1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-map数组去重&#34;&gt;2. map数组去重&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;function unique(arr) {
    const res = new Map()
    return arr.filter( item =&amp;gt; !res.has(JSON.stringify(item)) &amp;amp;&amp;amp; res.set(JSON.stringify(item), 1))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3map数据结构优点&#34;&gt;3.map数据结构优点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。&lt;/li&gt;
&lt;li&gt;任何具有 Iterator接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数。&lt;/li&gt;
&lt;li&gt;Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;8-es6怎么编译成es5css-loader原理-过程&#34;&gt;8. ES6怎么编译成ES5？css-loader原理、过程&lt;/h1&gt;
&lt;h2 id=&#34;1-es6怎么编译成es5&#34;&gt;1. ES6怎么编译成ES5&lt;/h2&gt;
&lt;p&gt;Babel是一个广泛使用的转码器，babel可以将ES6代码完美地转换为ES5代码&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化项目&lt;/li&gt;
&lt;li&gt;全局安装babel工具&lt;/li&gt;
&lt;li&gt;新建.babelrc&lt;br&gt;
在项目根目录新建(.babelrc)文件输入如图所示代码：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;presets&amp;quot;:[
        &amp;quot;es2015&amp;quot;
    ],
    &amp;quot;plugins&amp;quot;:[]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-css-loader&#34;&gt;2. css-loader&lt;/h2&gt;
&lt;p&gt;webpack的一个loader，用于解释@import 和 url()，并通过import后进行解析，通常和style-loader结合使用&lt;/p&gt;
&lt;h1 id=&#34;9-使用es5模拟实现es6的class&#34;&gt;9. 使用ES5模拟实现ES6的class&lt;/h1&gt;
&lt;h2 id=&#34;1new操作符检查函数&#34;&gt;1.new操作符检查函数&lt;/h2&gt;
&lt;p&gt;解决问题：&lt;br&gt;
类必须使用new调用，否则会报错。ES的构造函数是可以当成普通函数使用的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function _checkType (obj, constructor) {
    if (!(obj instanceof constructor)) {
        throw new TypeError(&#39;Cannot call a class as a function&#39;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2内部方法不可枚举&#34;&gt;2.内部方法不可枚举&lt;/h2&gt;
&lt;p&gt;解决问题：&lt;br&gt;
类的内部所有定义的方法，都是不可枚举的。（包括内部定义的静态方法）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 修改构造函数描述符
function defineProperties (target, descriptors) {
    for (let descriptor of descriptors) {
        descriptor.enumerable = descriptor.enumerable || false

        descriptor.configurable = true
        if (&#39;value&#39; in descriptor) {
            descriptor.writable = true
        }

        Object.defineProperty(target, descriptor.key, descriptor)
    }
}

// 构造class
// constructor 表示类对应的constructor对象
// protoDesc 表示class内部定义的方法
// staticDesc 表示class内部定义的静态方法
function _createClass (constructor, protoDesc, staticDesc) {
    protoDesc &amp;amp;&amp;amp; defineProperties(constructor.prototype, protoDesc)
    staticDesc &amp;amp;&amp;amp; defineProperties(constructor, staticDesc)
    return constructor
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-真正的创建class&#34;&gt;3. 真正的创建class&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const Foo = function () {
    function Foo(name) {
        _checkType(this, Foo) // 先检查是不是new调用的

        this.name = name
    }

    _createClass (Foo, [ // 表示在class内部定义的方法
        {
            key: &#39;say&#39;,
            value: function () {
                console.log(this.name)
            }
        }
    ], [ // 表示在class内部定义的静态方法
        {
            key: &#39;say&#39;,
            value: function () {
                console.log(&#39;static say&#39;)
                console.log(this.name)
            }
        }
    ])

    return Foo
}()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;10-settimeout和setinterval的区别&#34;&gt;10. setTimeout和setInterval的区别&lt;/h1&gt;
&lt;p&gt;1.setTimeout和setInterval都属于JS中的定时器，可以规定延迟时间再执行某个操作，不同的是setTimeout在规定时间后执行完某个操作就停止了，而setInterval则可以一直循环下去。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function fun(){
  alert(&#39;hello&#39;);
}
  setTimeout(fun,1000);//参数是函数名
  setTimeout(&#39;fun()&#39;,1000);//参数是字符串
  setInterval(fun,1000);
  setInterval(&#39;fun(),1000&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上述代码中，无论是setTimeout还是setInterval，在使用函数名作为调用句柄时不能带参数，使用字符串调用时可以带参数。例如：setTimeout(‘fun(name)’,1000);&lt;/p&gt;
&lt;p&gt;2.不再单独再定义一个函数，直接将函数调用放在一个函数里面，可以使用函数名作为调用调用句柄。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function fun(name){
  alert(&#39;hello&#39;+&#39; &#39;+name);
}
setTimeout (function(){
  fun(&#39;Tom&#39;);
},1000);//参数是函数名
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上述代码中，setTimeout和setInterval的区别就是setTimeout延迟一秒弹出’hello’,之后便不再运行；而setInterval则会隔一秒弹出’hello’,直至用clear来清除定时器的语法。&lt;/p&gt;
">【面】前端知识点梳理（ES6）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/js-zhong-he-qu-bie/"" data-c="
          &lt;p&gt;简单来说： == 代表相同， ===代表严格相同, 为啥这么说呢，&lt;/p&gt;
&lt;p&gt;这么理解： 当进行双等号比较时候： 先检查两个操作数数据类型，如果相同， 则进行===比较， 如果不同， 则愿意为你进行一次类型转换， 转换成相同类型后再进行比较， 而===比较时， 如果类型不同，直接就是false.&lt;/p&gt;
&lt;p&gt;操作数1 == 操作数2，  操作数1 === 操作数2&lt;/p&gt;
&lt;p&gt;比较过程：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;双等号&lt;/strong&gt;&lt;code&gt;==&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;（1）如果两个值类型相同，再进行三个等号(===)的比较&lt;/p&gt;
&lt;p&gt;（2）如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换在比较：&lt;/p&gt;
&lt;p&gt;1）如果一个是null，一个是undefined，那么相等&lt;/p&gt;
&lt;p&gt;2）如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三等号&lt;/strong&gt;&lt;code&gt;===&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;（1）如果类型不同，就一定不相等&lt;/p&gt;
&lt;p&gt;（2）如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是NaN，那么不相等。（判断一个值是否是NaN，只能使用isNaN( ) 来判断）&lt;/p&gt;
&lt;p&gt;（3）如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等。&lt;/p&gt;
&lt;p&gt;（4）如果两个值都是true，或是false，那么相等&lt;/p&gt;
&lt;p&gt;（5）如果两个值都引用同一个对象或是函数，那么相等，否则不相等&lt;/p&gt;
&lt;p&gt;（6）如果两个值都是null，或是undefined，那么相等&lt;/p&gt;
">js中==和===区别</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/mian-qian-duan-zhi-shi-dian-shu-li-js-xia/"" data-c="
          &lt;h1 id=&#34;17-window的onload事件和domcontentloaded&#34;&gt;17. window的onload事件和domcontentloaded&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;DOMContentLoaded方法是当DOM加载完成，不包括样式表，图片，flash触发的事件&lt;/li&gt;
&lt;li&gt;onload事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了，用于检测一个加载完全的页面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开发中我们经常需要给一些元素的事件绑定处理函数。但问题是，如果那个元素还没有加载到页面上，但是绑定事件已经执行完了，是没有效果的。这两个事件大致就是用来避免这样一种情况，将绑定的函数放在这两个事件的回调中，保证能在页面的某些元素加载完毕之后再绑定事件的函数。&lt;/p&gt;
&lt;p&gt;当然DOMContentLoaded机制更加合理，因为我们可以容忍图片，flash延迟加载，却不可以容忍看见内容后页面不可交互。&lt;/p&gt;
&lt;h1 id=&#34;18-forin迭代和forof有什么区别&#34;&gt;18. for...in迭代和for...of有什么区别&lt;/h1&gt;
&lt;h2 id=&#34;1-forin&#34;&gt;1. for…in&lt;/h2&gt;
&lt;p&gt;for…in 循环返回的值是数据的结构的&lt;strong&gt;key&lt;/strong&gt;(类比键值名)&lt;br&gt;
&lt;code&gt;遍历对象&lt;/code&gt;返回的对象&lt;code&gt;key&lt;/code&gt;值，&lt;code&gt;遍历数组&lt;/code&gt;返回的数组的&lt;code&gt;下标&lt;/code&gt;（key）&lt;br&gt;
for…in 不仅可以遍历数字 键名，还会遍历原型上的值和手动添加其他的键&lt;br&gt;
for…in 循环出的是（key）&lt;br&gt;
总结：&lt;br&gt;
for…in 循环特别适合遍历对象&lt;/p&gt;
&lt;h2 id=&#34;2-forof&#34;&gt;2. for…of&lt;/h2&gt;
&lt;p&gt;for…of 是ES6新引入的特性。修复了ES5引入的for…in的不足支持set().map()&lt;br&gt;
for…of不能循环普通的对象，需要通过和OBject.Keys()搭配使用&lt;br&gt;
for…of不同与forEach&lt;br&gt;
它可以与break.continue和return 配合使用&lt;br&gt;
for…of 循环可以随时推出循环&lt;br&gt;
for…of 循环出的是（&lt;strong&gt;value&lt;/strong&gt;）&lt;br&gt;
总结：&lt;br&gt;
for…of 循环特别适合&lt;code&gt;遍历数组&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;19-函数柯里化-和-高阶函数&#34;&gt;19. 函数柯里化 和 高阶函数&lt;/h1&gt;
&lt;h2 id=&#34;1-函数柯里化&#34;&gt;1. 函数柯里化&lt;/h2&gt;
&lt;p&gt;柯里化，是函数式编程的一个重要概念。它既能减少代码冗余，也能增加可读性。&lt;br&gt;
&lt;strong&gt;定义&lt;/strong&gt;：在数学和计算机科学中，柯里化是一种将使用&lt;strong&gt;多个参数&lt;/strong&gt;的一个函数转换成一系列使用&lt;strong&gt;一个参数&lt;/strong&gt;的函数的技术。&lt;br&gt;
&lt;code&gt;简单版：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function add(a) {
  function sum(b) { // 使用闭包
      a = a + b; // 累加
      return sum;
   }
   sum.toString = function() { // 重写toString()方法
      return a;
  }
   return sum; // 返回一个函数
}

add(1); // 1
add(1)(2);  // 3
add(1)(2)(3) // 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;完整版：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function add() {
  // 第一次执行时，定义一个数组专门用来存储所有的参数
  var _args = [].slice.call(arguments);

  // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值
  var adder = function () {
      var _adder = function() {
          _args.push(...arguments);
          return _adder;
      };

      // 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回
      _adder.toString = function () {
          return _args.reduce(function (a, b) {
              return a + b;
          });
      }

      return _adder;
  }
  return adder(..._args);
}

var a = add(1)(2)(3)(4);   // f 10
var b = add(1, 2, 3, 4);   // f 10
var c = add(1, 2)(3, 4);   // f 10
var d = add(1, 2, 3)(4);   // f 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数的柯里化，是 Javascript 中函数式编程的一个重要概念。&lt;code&gt;它返回的，是一个函数的函数&lt;/code&gt;。其实现方式，需要依赖&lt;code&gt;参数以及递归&lt;/code&gt;，通过&lt;code&gt;拆分参数&lt;/code&gt;的方式，来调用一个多参数的函数方法，以达到减少代码冗余，增加可读性的目的。&lt;/p&gt;
&lt;h2 id=&#34;2-高阶函数&#34;&gt;2. 高阶函数&lt;/h2&gt;
&lt;h3 id=&#34;1-arrayprototypemap&#34;&gt;1. Array.prototype.map&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;map()&lt;/code&gt;(映射)方法最后生成一个新数组，不改变原始数组的值。其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array.map(callback,[ thisObject]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;callback(回调函数)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[].map(function(currentValue, index, array) {
    // ...
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传递给&lt;code&gt;map&lt;/code&gt;的回调函数（&lt;code&gt;callback&lt;/code&gt;）接受三个参数，分别是&lt;code&gt;currentValue&lt;/code&gt;——正在遍历的元素；&lt;code&gt;index&lt;/code&gt;（可选）——元素索引；&lt;code&gt;array&lt;/code&gt;（可选）——原数组本身，除了 callback 之外还可以接受 this 值（可选），用于执行 callback 函数时使用的this 值。&lt;/p&gt;
&lt;p&gt;来个简单的例子方便理解，现在有一个数组[1,2,3,4]，我们想要生成一个新数组，其每个元素皆是之前数组的两倍&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const arr1 = [1, 2, 3, 4];
const arr2 = arr1.map(item =&amp;gt; item * 2);

console.log( arr2 );
// [2, 4, 6, 8]
console.log( arr1 );
// [1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;map高阶函数注意点&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;callback需要有return值，否则会出现所有项映射为undefind；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;].map(parseInt);
//输出结果为  [1,NaN,NaN]

[&amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;3&amp;quot;].map(x=&amp;gt;parseInt(x));
//输出结果为  [1,2,3]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-arrayprototypereduce&#34;&gt;2. Array.prototype.reduce&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;reduce()&lt;/code&gt;方法对数组中的每个元素执行一个提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值。传递给 reduce 的回调函数（callback）接受四个参数，分别是累加器 &lt;code&gt;accumulator&lt;/code&gt;；&lt;code&gt;currentValue&lt;/code&gt;——正在操作的元素；&lt;code&gt;currentIndex&lt;/code&gt;（可选）——元素索引，但是它的开始会有特殊说明；&lt;code&gt;array&lt;/code&gt;（可选）——原始数组本身，除了 callback 之外还可以接受初始值 initialValue 值（可选）。&lt;/p&gt;
&lt;p&gt;例子，现在有一个数组 [0, 1, 2, 3, 4]，需要计算数组元素的和，需求比较简单，来看下代码实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const arr = [0, 1, 2, 3, 4];
let sum = arr.reduce((accumulator, currentValue, currentIndex, array) =&amp;gt; {
  return accumulator + currentValue;
});

console.log( sum );
// 10
console.log( arr );
// [0, 1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615256323803.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;3-arrayprototypefilter&#34;&gt;3. Array.prototype.filter&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;filter&lt;/code&gt;(过滤，筛选) 方法创建一个新数组,原始数组不发生改变。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array.filter(callback,[ thisObject]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接收的参数和 map 是一样的，filter的&lt;code&gt;callback&lt;/code&gt;函数需要返回布尔值true或false. 如果为true则表示通过啦！如果为false则失败，其返回值是一个新数组，由通过测试为true的所有元素组成，如果没有任何数组元素通过测试，则返回空数组。&lt;/p&gt;
&lt;p&gt;来个例子介绍下，现在有一个数组 [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]，我们想要生成一个新数组，这个数组要求没有重复的内容，即为去重。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const arr1 = [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4];
const arr2 = arr1.filter( (element, index, self) =&amp;gt; {
    return self.indexOf( element ) === index;
});

console.log( arr2 );
// [1, 2, 3, 5, 4]
console.log( arr1 );
// [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;20-call-与-apply区别原生实现bind&#34;&gt;20.  call 与 apply区别，原生实现bind&lt;/h1&gt;
&lt;h2 id=&#34;1-call-和-apply-的共同点&#34;&gt;1. call 和 apply 的共同点&lt;/h2&gt;
&lt;p&gt;它们的共同点是，都能够&lt;strong&gt;改变函数执行时的上下文&lt;/strong&gt;，将一个对象的方法交给另一个对象来执行，并且是立即执行的。&lt;/p&gt;
&lt;p&gt;为何要改变执行上下文？举一个生活中的小例子：平时没时间做饭的我，周末想给孩子炖个腌笃鲜尝尝。但是没有适合的锅，而我又不想出去买。所以就问邻居借了一个锅来用，这样既达到了目的，又节省了开支，一举两得。&lt;/p&gt;
&lt;p&gt;改变执行上下文也是一样的，A 对象有一个方法，而 B 对象因为某种原因，也需要用到同样的方法，那么这时候我们是单独为 B 对象扩展一个方法呢，还是借用一下 A 对象的方法呢？当然是借用 A 对象的啦，既完成了需求，又减少了内存的占用。&lt;/p&gt;
&lt;p&gt;另外，它们的写法也很类似，&lt;strong&gt;调用 call 和 apply 的对象，必须是一个函数 Function&lt;/strong&gt;。接下来，就会说到具体的写法，那也是它们区别的主要体现。&lt;/p&gt;
&lt;h2 id=&#34;2-call-和-apply-的区别&#34;&gt;2. call 和 apply 的区别&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;call 的写法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Function.call(obj,[param1[,param2[,…[,paramN]]]])
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;调用 call 的对象，必须是个函数 Function。&lt;/li&gt;
&lt;li&gt;call 的第一个参数，是一个对象。 Function 的调用者，将会指向这个对象。如果不传，则默认为全局对象 window。&lt;/li&gt;
&lt;li&gt;第二个参数开始，可以接收任意个参数。每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;function func (a,b,c) {}

func.call(obj, 1,2,3)
// func 接收到的参数实际上是 1,2,3

func.call(obj, [1,2,3])
// func 接收到的参数实际上是 [1,2,3],undefined,undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;apply 的写法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Function.apply(obj[,argArray])
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;它的调用者必须是函数 Function，并且只接收两个参数，第一个参数的规则与 call 一致。&lt;/li&gt;
&lt;li&gt;第二个参数，必须是数组或者类数组，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。这也是 call 和 apply 之间，很重要的一个区别。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;func.apply(obj, [1,2,3])
// func 接收到的参数实际上是 1,2,3

func.apply(obj, {
    0: 1,
    1: 2,
    2: 3,
    length: 3
})
// func 接收到的参数实际上是 1,2,3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;类数组无法使用 forEach、splice、push 等数组原型链上的方法&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-call-和-apply-的用途&#34;&gt;3 call 和 apply 的用途&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;call 的使用场景&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;对象的继承&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;function superClass () {
    this.a = 1;
    this.print = function () {
        console.log(this.a);
    }
}

function subClass () {
    superClass.call(this);
    this.print();
}

subClass();
// 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;subClass 通过 call 方法，继承了 superClass 的 print 方法和 a 变量。此外，subClass 还可以扩展自己的其他方法。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;借用方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;let domNodes = Array.prototype.slice.call(document.getElementsByTagName(&amp;quot;*&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;apply 的一些妙用&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Math.max&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;let max = Math.max.apply(null, array);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同理，要获取数组中最小的一项，可以这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let min = Math.min.apply(null, array);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;实现两个数组合并&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];

Array.prototype.push.apply(arr1, arr2);
console.log(arr1); // [1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-bind-的使用&#34;&gt;4. bind 的使用&lt;/h2&gt;
&lt;p&gt;bind() 方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。&lt;/p&gt;
&lt;p&gt;它的语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Function.bind(thisArg[, arg1[, arg2[, ...]]])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bind 方法 与 apply 和 call 比较类似，也能改变函数体内的 this 指向。不同的是，&lt;code&gt;bind 方法的返回值是函数，并且需要稍后调用，才会执行&lt;/code&gt;。而 apply 和 call 则是&lt;code&gt;立即调用&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;来看下面这个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function add (a, b) {
    return a + b;
}

function sub (a, b) {
    return a - b;
}

add.bind(sub, 5, 3); // 这时，并不会返回 8
add.bind(sub, 5, 3)(); // 调用后，返回 8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果 bind 的第一个参数是 null 或者 undefined，this 就指向全局对象 window。&lt;/p&gt;
&lt;h2 id=&#34;5-总结&#34;&gt;5. 总结&lt;/h2&gt;
&lt;p&gt;call 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。&lt;/p&gt;
&lt;p&gt;bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;原生实现bind函数&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 原生js实现bind函数
// 所有的函数都要有bind方法，所以要定义在Function的原型对象上
Function.prototype.myBind = function(objThis,...params){
    // objThis是要绑定的this对象，...params是因为参数数量不确定才用解构语法
    const thisFn = this;//当前调用的函数，例如fn.myBind()就把fn保存到thisFn
    let funcForBind = function(...secondParams){ // 要返回的函数
        // 判断函数是否是用new function生成的
        const isNew = this instanceof funcForBind
        const thisArg = isNew?this:objThis //this的指向
        // 绑定好this和参数返回到外层，暂时用call绑定，call也可以原生实现
        return thisFn.call(thisArg,...params,...secondParams)
    }
    // 绑定原型
    funcForBind.prototype = Object.create(thisFn)
    return funcForBind //返回绑定好的函数
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;21-async-和-await&#34;&gt;21. async 和 await&lt;/h1&gt;
&lt;h2 id=&#34;1-作用&#34;&gt;1. 作用&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt;和&lt;code&gt;await&lt;/code&gt;是用来处理异步的。即你需要异步像同步一样执行，需要异步返回结果之后，再往下依据结果继续执行。&lt;br&gt;
&lt;code&gt;async&lt;/code&gt; 是“异步”的简写，而 &lt;code&gt;await&lt;/code&gt; 可以认为是 &lt;code&gt;async wait&lt;/code&gt; 的简写。&lt;br&gt;
&lt;code&gt;async&lt;/code&gt; 用于申明一个 &lt;code&gt;function&lt;/code&gt; 是异步的，而 &lt;code&gt;await&lt;/code&gt; 用于等待一个异步方法执行完成。&lt;/p&gt;
&lt;h2 id=&#34;2-async&#34;&gt;2. async&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;async function testAsync() {
    return &amp;quot;hello async&amp;quot;;
}

const result = testAsync();
console.log(result);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打印输出的是一个&lt;code&gt;Promise&lt;/code&gt; 对象，&lt;code&gt;async&lt;/code&gt; 函数会返回一个 &lt;code&gt;Promise&lt;/code&gt; 对象。&lt;br&gt;
在最外层不能用 &lt;code&gt;await&lt;/code&gt; 获取其返回值的情况下，使用 &lt;code&gt;then()&lt;/code&gt; 链来处理这个 &lt;code&gt;Promise&lt;/code&gt; 对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;testAsync().then(v =&amp;gt; {
    console.log(v);    // 输出 hello async
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当 &lt;code&gt;async&lt;/code&gt; 函数没有返回值时，返回 &lt;code&gt;Promise.resolve(undefined)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-awit&#34;&gt;3. awit&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;await&lt;/code&gt;只能放在&lt;code&gt;async&lt;/code&gt;函数内部使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;await&lt;/code&gt; 用于一个异步操作之前，表示要“等待”这个异步操作的返回值。&lt;br&gt;
&lt;code&gt;await&lt;/code&gt; 也可以用于一个同步的值。&lt;/p&gt;
&lt;p&gt;如果它等到的不是一个 &lt;code&gt;Promise&lt;/code&gt; 对象，那 &lt;code&gt;await&lt;/code&gt; 表达式的运算结果就是它等到的东西。&lt;br&gt;
如果它等到的是一个 &lt;code&gt;Promise&lt;/code&gt; 对象，&lt;code&gt;await&lt;/code&gt; 就会阻塞后面的代码，等着 &lt;code&gt;Promise&lt;/code&gt; 对象 &lt;code&gt;resolve&lt;/code&gt;，然后得到 &lt;code&gt;resolve&lt;/code&gt; 的值，作为 &lt;code&gt;await&lt;/code&gt; 表达式的运算结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 2s 之后返回双倍的值
function doubleAfter2seconds(num) {
    return new Promise((resolve, reject) =&amp;gt; {
        setTimeout(() =&amp;gt; {
            resolve(2 * num)
        }, 2000);
    })
}

async function testResult () {
    let result = await doubleAfter2seconds(30);
    console.log(result);
}

testResult();
// 2s 之后，输出了60. 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-执行顺序&#34;&gt;4. 执行顺序&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 2s 之后返回双倍的值
function doubleAfter2seconds(num) {
    return new Promise((resolve, reject) =&amp;gt; {
        setTimeout(() =&amp;gt; {
            resolve(2 * num)
        }, 2000);
    })
}

async function testResult () {
    console.log(&#39;内部调用前&#39;) // 2
    let result = await doubleAfter2seconds(30);
    console.log(result); // 4
    console.log(&#39;内部调用后&#39;) // 5
}

console.log(&#39;外部调用前&#39;) // 1
testResult();
console.log(&#39;外部调用后&#39;) // 3
// --- 依次输出
// 外部调用前
// 内部调用前
// 外部调用后
// --- 2s 之后输出
// 60
// 内部调用后
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析一下上面的执行顺序：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先打印输出&lt;code&gt;外部调用前&lt;/code&gt;，同步代码，顺序执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后调用方法&lt;code&gt;testResult()&lt;/code&gt;，打印输出&lt;code&gt;内部调用前&lt;/code&gt;，同步代码，顺序执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再执行异步方法&lt;code&gt;doubleAfter2seconds&lt;/code&gt;，&lt;br&gt;
　1&amp;gt;如果没用&lt;code&gt;await&lt;/code&gt;关键字，此后的执行顺序应该是&lt;br&gt;
　　&lt;code&gt;内部调用后，外部调用后，2s 之后输出60&lt;/code&gt;&lt;br&gt;
　　因为异步方法不阻塞其他代码的执行，最后再输出&lt;code&gt;60&lt;/code&gt;&lt;br&gt;
　2&amp;gt;这里使用了&lt;code&gt;await&lt;/code&gt;关键字，所以到这里后会等待异步返回结果，再往下执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当&lt;code&gt;testResult&lt;/code&gt;函数内部&lt;code&gt;await&lt;/code&gt;阻塞执行后，不会影响到&lt;code&gt;testResult&lt;/code&gt;函数外面&lt;/p&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt; &lt;strong&gt;函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，在调用&lt;code&gt;testResult&lt;/code&gt;函数后，会继续向下执行，打印输出外部调用后&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当2s之后，异步函数&lt;code&gt;doubleAfter2seconds&lt;/code&gt;执行完成，返回结果，&lt;br&gt;
打印输出&lt;code&gt;60&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为&lt;code&gt;await&lt;/code&gt;将异步变成同步，所以在输出&lt;code&gt;60&lt;/code&gt;后，同步执行，再输出&lt;code&gt;内部调用后&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-错误处理&#34;&gt;5. 错误处理&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 2s 之后返回双倍的值
function doubleAfter2seconds(num) {
    return new Promise((resolve, reject) =&amp;gt; {
        setTimeout(() =&amp;gt; {
            resolve(2 * num)
        }, 2000);
    })
}

async function testResult () {
    let first = await doubleAfter2seconds(10);
    let second = await doubleAfter2seconds(20);    
    let res = first + second;
    return res;
}

testResult().then(res =&amp;gt; {
    console.log(res);      
}).catch(error =&amp;gt; {
    console.log(error);     
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6在接口中使用axios&#34;&gt;6.在接口中使用(axios)&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;created () {
    this.init()
},
methods: {
    async init () {
      try {
          let first = await this.getOne();
          let second = await this.getTwo();    
          let res = first + second;
          console.log(res);
      } catch (error) {
          console.log(error);
      }        
    },
    getOne () {
        const params = {name: &#39;one&#39;}
        return new Promise((resolve, reject) =&amp;gt; {
            axios.get(&#39;/one&#39;, { params}).then((res) =&amp;gt; {
                if (res.status === 200) {
                    resolve(res)
                }
            }).catch((err) =&amp;gt; {
                reject(err)
            })
        })
    },
    getTwo () {
        const params = {name: &#39;two&#39;}
        return new Promise((resolve, reject) =&amp;gt; {
            axios.get(&#39;/two&#39;, { params}).then((res) =&amp;gt; {
                if (res.status === 200) {
                    resolve(res)
                }
            }).catch((err) =&amp;gt; {
                reject(err)
            })
        })
    },
},
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;22-立即执行函数和使用场景与闭包结合&#34;&gt;22. 立即执行函数和使用场景（与闭包结合）&lt;/h1&gt;
&lt;h2 id=&#34;1-什么是立即执行函数&#34;&gt;1. 什么是立即执行函数？&lt;/h2&gt;
&lt;p&gt;声明一个函数，并马上调用这个匿名函数就叫做立即执行函数；也可以说立即执行函数是一种语法，让你的函数在定义以后立即执行；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615271995138.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-立即执行函数的写法&#34;&gt;2. 立即执行函数的写法：&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;(function(){
//code
}())

(function (){
//code
})()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上边的两种写法，都是以圆括号开头，引擎会意味后面跟的是表达式，而不是一个函数定义语句，所以就避免了错误，这就叫做&amp;quot;立即调用的函数表达式&amp;quot;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(function () {alert(&amp;quot;我是匿名函数&amp;quot;)}())   //用括号把整个表达式包起来
(function () {alert(&amp;quot;我是匿名函数&amp;quot;)})()  //用括号把函数包起来
!function () {alert(&amp;quot;我是匿名函数&amp;quot;)}()  //求反，我们不在意值是多少，只想通过语法检查
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-立即执行函数的作用&#34;&gt;3. 立即执行函数的作用：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不必为函数命名，避免了污染全局变量&lt;/li&gt;
&lt;li&gt;立即执行函数内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量&lt;/li&gt;
&lt;li&gt;封装变量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总而言之：&lt;strong&gt;立即执行函数会形成一个单独的作用域，我们可以封装一些临时变量或者局部变量，避免污染全局变量&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-使用场景&#34;&gt;4. 使用场景&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;怎样使以下alert的结果为0,1,2：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;ul id=&amp;quot;list&amp;quot;&amp;gt;
        &amp;lt;li&amp;gt;公司简介&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;联系我们&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;营销网络&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
    &amp;lt;script&amp;gt;
       var list = document.getElementById(&amp;quot;list&amp;quot;);
      var li = list.children;
      for(var i = 0 ;i&amp;lt;li.length;i++){
       ( function(j){
            li[j].onclick = function(){
              alert(j);
          })(i); //把实参i赋值给形参j
        }
      }
     &amp;lt;/script&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结合闭包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (var i = 1; i &amp;lt;= 5; i++) {
  (function(j) {
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })(i);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;如何避免了污染全局变量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;某些代码只需要执行一次，比如只需要显示一个时间，但是这些代码也需要一些临时的变量，但是初始化过程结束之后，就再也不会被用到，如果将这些变量作为全局变量，不是一个好的主意，我们可以用立即执行函数——去将我们所有的代码包裹在它的局部作用域中，不会让任何变量泄露成全局变量，看如下代码：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615273235393.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
比如上面的代码，如果没有被包裹在立即执行函数中，而是直接以非函数的形式直接写在&amp;lt;script&amp;gt;&lt;/script&gt;标签里面，虽然也会立即执行，但是临时变量todaydom,days,today,year,month,date,day,msg都将成为全局变量（初始化代码遗留的产物）。&lt;br&gt;
而用立即执行函数之后，这些变量都不会在全局变量中存在，以后也不会其他地方使用，有效的避免了污染全局变量。&lt;/p&gt;
&lt;h1 id=&#34;23-设计模式要求说出如何实现应用优缺点单例模式实现&#34;&gt;23. 设计模式(要求说出如何实现,应用,优缺点)/单例模式实现&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615273736555.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1-创建型模式&#34;&gt;1. 创建型模式&lt;/h2&gt;
&lt;h3 id=&#34;1-工厂模式&#34;&gt;1. 工厂模式&lt;/h3&gt;
&lt;p&gt;工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象，用工厂方法代替new操作的一种模式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Animal(opts){
    var obj = new Object();
    obj.color = opts.color;
    obj.name= opts.name;
    obj.getInfo = function(){
        return &#39;名称：&#39;+ onj.name+&#39;， 颜色：&#39;+ obj.color;
    }
    return obj;
}
var cat = Animal({name: &#39;波斯猫&#39;, color: &#39;白色&#39;});
cat.getInfo();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;小结:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造函数和创建者分离，对new操作进行封装&lt;/li&gt;
&lt;li&gt;符合开放封闭原则&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-单例模式&#34;&gt;2. 单例模式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615274155679.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var Single = (function(){
    var instance;
    function init() {
        // 定义私有方法和属性
        // 操作逻辑
        return {
           // 定义公共方法和属性
        };
    }
    return {
        // 获取实例
        getInstance:function(){
            if(!instance){
                instance = init();
            }
            return instance;
        }
    }
})();

var obj1 = Single.getInstance();
var obj2 = Single.getInstance();
console.log(obj1 === obj2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;小结:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单例模式的主要思想就是，实例如果已经创建，则直接返回&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;function creatSingleton() {
    var obj = null
    // 实例如已经创建过，直接返回
    if (!obj) {
        obj = xxx
    }
    return obj
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;符合开放封闭原则&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-原型模式&#34;&gt;3. 原型模式&lt;/h3&gt;
&lt;p&gt;用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。&lt;/p&gt;
&lt;p&gt;在JavaScript中，实现原型模式是在ECMAScript5中，提出的Object.create方法，使用现有的对象来提供新创建的对象的__proto__。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var prototype = {
    name: &#39;Jack&#39;,
    getName: function() {
        return this.name
    }
}

var obj = Object.create(prototype, {
    job: {
        value: &#39;IT&#39;
    }
})

console.log(obj.getName())  // Jack
console.log(obj.job)  // IT
console.log(obj.__proto__ === prototype)  //true
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-结构型模式&#34;&gt;2. 结构型模式&lt;/h2&gt;
&lt;h3 id=&#34;1-适配器模式&#34;&gt;1. 适配器模式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615274391311.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;class GooleMap {
    show() {
        console.log(&#39;渲染谷歌地图&#39;)
    }
}

class BaiduMap {
    display() {
        console.log(&#39;渲染百度地图&#39;)
    }
}


// 定义适配器类, 对BaiduMap类进行封装
class BaiduMapAdapter {
    show() {
        var baiduMap = new BaiduMap()
        return baiduMap.display() 
    }
}

function render(map) {
    if (map.show instanceof Function) {
        map.show()
    }
}

render(new GooleMap())         // 渲染谷歌地图
render(new BaiduMapAdapter())  // 渲染百度地图
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;小结:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;适配器模式主要解决两个接口之间不匹配的问题，不会改变原有的接口，而是由一个对象对另一个对象的包装。&lt;/li&gt;
&lt;li&gt;适配器模式符合开放封闭原则&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-行为型模式&#34;&gt;3. 行为型模式&lt;/h2&gt;
&lt;h3 id=&#34;1-观察者模式订阅-发布模式&#34;&gt;1. 观察者模式(订阅-发布模式)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615274507790.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;发布者发出通知 =&amp;gt;主题对象收到通知并推送给订阅者 =&amp;gt; 订阅者执行相应的操作。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; // 一个发布者 publisher，功能就是负责发布消息 - publish
        var pub = {
            publish: function () {
                dep.notify();
            }
        }
        // 多个订阅者 subscribers， 在发布者发布消息之后执行函数
        var sub1 = { 
            update: function () {
                console.log(1);
            }
        }
        var sub2 = { 
            update: function () {
                console.log(2);
            }
        }
        var sub3 = { 
            update: function () {
                console.log(3);
            }
        }
        // 一个主题对象
        function Dep() {
            this.subs = [sub1, sub2, sub3];
        }
        Dep.prototype.notify = function () {
            this.subs.forEach(function (sub) {
                sub.update();
            });
        }

        // 发布者发布消息， 主题对象执行notify方法，进而触发订阅者执行Update方法
        var dep = new Dep();
        pub.publish();
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;24-iframe的缺点有哪些&#34;&gt;24. iframe的缺点有哪些&lt;/h1&gt;
&lt;h1 id=&#34;1-iframe的优点&#34;&gt;1. iframe的优点：&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;iframe能够原封不动的把嵌入的网页展现出来。&lt;/li&gt;
&lt;li&gt;如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。&lt;/li&gt;
&lt;li&gt;网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。&lt;/li&gt;
&lt;li&gt;如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;2-iframe的缺点&#34;&gt;2. iframe的缺点：&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;会产生很多页面，&lt;code&gt;不容易管理&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，&lt;code&gt;用户体验度差&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会&lt;code&gt;不利于搜索引擎优化&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;很多的移动设备（PDA手机）无法完全显示框架，&lt;code&gt;设备兼容性差&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;iframe框架页面会&lt;code&gt;增加服务器的http请求&lt;/code&gt;，对于大型网站是不可取的。&lt;br&gt;
分析了这么多，现在基本上都是用&lt;code&gt;Ajax来代替iframe&lt;/code&gt;，所以iframe已经渐渐的退出了前端开发。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;25-数组问题&#34;&gt;25. 数组问题&lt;/h1&gt;
&lt;h2 id=&#34;1-数组去重&#34;&gt;1. 数组去重&lt;/h2&gt;
&lt;h3 id=&#34;1-利用es6-set去重es6中最常用&#34;&gt;1. 利用ES6 Set去重（ES6中最常用）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function unique (arr) {
  return Array.from(new Set(arr))
}
var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,{},{}];
console.log(unique(arr))
 //[1, &amp;quot;true&amp;quot;, true, 15, false, undefined, null, NaN, &amp;quot;NaN&amp;quot;, 0, &amp;quot;a&amp;quot;, {}, {}]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不考虑兼容性，这种去重的方法代码最少。这种方法还无法去掉“{}”空对象，后面的高阶方法会添加去掉重复“{}”的方法。&lt;/p&gt;
&lt;h3 id=&#34;2-利用for嵌套for然后splice去重es5中最常用&#34;&gt;2. 利用for嵌套for，然后splice去重（ES5中最常用）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function unique(arr){            
  for(var i=0; i&amp;lt;arr.length; i++){
      for(var j=i+1; j&amp;lt;arr.length; j++){
          if(arr[i]===arr[j]){         //第一个等同于第二个，splice方法删除第二个
              arr.splice(j,1);
              j--;
          }
      }
  }
return arr;
}
var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,{},{}];
console.log(unique(arr))
//  [1, &#39;true&#39;,true, 15,false,undefined,null, NaN,NaN, &#39;NaN&#39;,0, &#39;a&#39;,{}, {}]  //NaN和{}没有去重
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。&lt;/p&gt;
&lt;h3 id=&#34;3-利用indexof去重&#34;&gt;3. 利用indexOf去重&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function unique(arr) {
  if (!Array.isArray(arr)) {
      console.log(&#39;type error!&#39;)
      return
  }
  var array = [];
  for (var i = 0; i &amp;lt; arr.length; i++) {
      if (array .indexOf(arr[i]) === -1) {
          array .push(arr[i])
      }
  }
  return array;
}
var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,{},{}];
console.log(unique(arr))
 // [1, &amp;quot;true&amp;quot;, true, 15, false, undefined, null, NaN, NaN, &amp;quot;NaN&amp;quot;, 0, &amp;quot;a&amp;quot;, {…}, {…}]  //NaN、{}没有去重
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组。&lt;/p&gt;
&lt;h3 id=&#34;4-利用sort&#34;&gt;4. 利用sort()&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function unique(arr) {
  if (!Array.isArray(arr)) {
      console.log(&#39;type error!&#39;)
      return;
  }
  arr = arr.sort()
  var arrry= [arr[0]];
  for (var i = 1; i &amp;lt; arr.length; i++) {
      if (arr[i] !== arr[i-1]) {
          arrry.push(arr[i]);
      }
  }
  return arrry;
}
   var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,{},{}];
      console.log(unique(arr))
// [0, 1, 15, &amp;quot;NaN&amp;quot;, NaN, NaN, {…}, {…}, &amp;quot;a&amp;quot;, false, null, true, &amp;quot;true&amp;quot;, undefined]      //NaN、{}没有去重
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对。&lt;/p&gt;
&lt;h3 id=&#34;5-利用includes&#34;&gt;5. 利用includes&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log(&#39;type error!&#39;)
        return
    }
    var array =[];
    for(var i = 0; i &amp;lt; arr.length; i++) {
            if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值
                    array.push(arr[i]);
              }
    }
    return array
}
var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,{},{}];
    console.log(unique(arr))
    //[1, &amp;quot;true&amp;quot;, true, 15, false, undefined, null, NaN, &amp;quot;NaN&amp;quot;, 0, &amp;quot;a&amp;quot;, {…}, {…}]     //{}没有去重
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6-利用filter&#34;&gt;6. 利用filter&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function unique(arr) {
  return arr.filter(function(item, index, arr) {
    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素
    return arr.indexOf(item, 0) === index;
  });
}
    var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,{},{}];
        console.log(unique(arr))
//[1, &amp;quot;true&amp;quot;, true, 15, false, undefined, null, &amp;quot;NaN&amp;quot;, 0, &amp;quot;a&amp;quot;, {…}, {…}]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;7-利用map数据结构去重&#34;&gt;7. 利用Map数据结构去重&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function arrayNonRepeatfy(arr) {
  let map = new Map();
  let array = new Array();  // 数组用于返回结果
  for (let i = 0; i &amp;lt; arr.length; i++) {
    if(map.has(arr[i])) {  // 如果有该key值
      map.set(arr[i], true); 
    } else { 
      map.set(arr[i], false);   // 如果没有该key值
      array.push(arr[i]);
    }
  } 
  return array ;
}
 var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,{},{}];
    console.log(arrayNonRepeatfy(arr))
//[1, &amp;quot;a&amp;quot;, &amp;quot;true&amp;quot;, true, 15, false, 1, {…}, null, NaN, NaN, &amp;quot;NaN&amp;quot;, 0, &amp;quot;a&amp;quot;, {…}, undefined]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-数组常用方法&#34;&gt;2. 数组常用方法&lt;/h2&gt;
&lt;h3 id=&#34;1-arraymap&#34;&gt;1. Array.map()&lt;/h3&gt;
&lt;p&gt;此方法是将数组中的每个元素调用一个提供的函数，结果作为一个新的数组返回，并&lt;code&gt;没有改变原来的数组&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5]
    let newArr = arr.map(x =&amp;gt; x*2)
    //arr= [1, 2, 3, 4, 5]   原数组保持不变
    //newArr = [2, 4, 6, 8, 10] 返回新数组
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-arrayforeach&#34;&gt;2. Array.forEach()&lt;/h3&gt;
&lt;p&gt;此方法是将数组中的每个元素执行传进提供的函数，没有返回值，&lt;code&gt;改变原数组&lt;/code&gt;，注意和map方法区分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5]
   num.forEach(x =&amp;gt; x*2)
   // arr = [1, 2, 3, 4, 5]  数组改变,注意和map区分
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-arrayfilter&#34;&gt;3. Array.filter()&lt;/h3&gt;
&lt;p&gt;此方法是将所有元素进行判断，将满足条件的元素作为一个新的数组返回&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5]
    const isBigEnough = value =&amp;gt; value &amp;gt;= 3
    let newArr = arr.filter(isBigEnough )
    //newNum = [3, 4, 5] 满足条件的元素返回为一个新的数组
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-arrayevery&#34;&gt;4. Array.every()&lt;/h3&gt;
&lt;p&gt;此方法是将所有元素进行判断返回一个布尔值，如果&lt;code&gt;所有元素&lt;/code&gt;都满足判断条件，则返回true，否则为false：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5]
    const isLessThan4 = value =&amp;gt; value &amp;lt; 4
    const isLessThan6 =&amp;gt; value =&amp;gt; value &amp;lt; 6
    arr.every(isLessThan4 ) //false
    arr.every(isLessThan6 ) //true
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-arraysome&#34;&gt;5. Array.some()&lt;/h3&gt;
&lt;p&gt;此方法是将所有元素进行判断返回一个布尔值，如果&lt;code&gt;存在&lt;/code&gt;元素都满足判断条件，则返回true，若所有元素都不满足判断条件，则返回false：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr= [1, 2, 3, 4, 5]
    const isLessThan4 = value =&amp;gt; value &amp;lt; 4
    const isLessThan6 = value =&amp;gt; value &amp;gt; 6
    arr.some(isLessThan4 ) //true
    arr.some(isLessThan6 ) //false
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6-arrayreduce&#34;&gt;6. Array.reduce()&lt;/h3&gt;
&lt;p&gt;此方法是所有元素调用返回函数，返回值为最后结果,传入的值必须是函数类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5]
   const add = (a, b) =&amp;gt; a + b
   let sum = arr.reduce(add)
   //sum = 15  相当于累加的效果
   与之相对应的还有一个 Array.reduceRight() 方法，区别是这个是从右向左操作的
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;7-arraypush&#34;&gt;7. Array.push()&lt;/h3&gt;
&lt;p&gt;此方法是在数组的后面添加新加元素，此方法改变了数组的长度：&lt;/p&gt;
&lt;h3 id=&#34;8-arraypop&#34;&gt;8. Array.pop()&lt;/h3&gt;
&lt;p&gt;此方法在数组后面删除&lt;code&gt;最后一个元素&lt;/code&gt;，并返回数组，此方法改变了数组的长度：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5]
    arr.pop()
    console.log(arr) //[1, 2, 3, 4]
    console.log(arr.length) //4
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;9-arrayshift&#34;&gt;9. Array.shift()&lt;/h3&gt;
&lt;p&gt;此方法在数组后面删除&lt;code&gt;第一个元素&lt;/code&gt;，并返回数组，此方法改变了数组的长度：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5]
    arr.shift()
    console.log(arr) //[2, 3, 4, 5]
    console.log(arr.length) //4 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;10-arrayunshift&#34;&gt;10. Array.unshift()&lt;/h3&gt;
&lt;p&gt;此方法是将一个或多个元素添加到数组的开头，并返回新数组的长度：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5]
    arr.unshift(6, 7)
    console.log(arr) //[6, 7, 1, 2, 3, 4, 5]
    console.log(arr.length) //7 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;11-arrayisarray&#34;&gt;11. Array.isArray()&lt;/h3&gt;
&lt;p&gt;判断一个对象是不是数组，返回的是布尔值&lt;/p&gt;
&lt;h3 id=&#34;12-arrayconcat&#34;&gt;12. Array.concat()&lt;/h3&gt;
&lt;p&gt;此方法是一个可以将多个数组拼接成一个数组：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr1 = [1, 2, 3]
      arr2 = [4, 5]
  let arr = arr1.concat(arr2)
  console.log(arr)//[1, 2, 3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;13-arraytostring&#34;&gt;13. Array.toString()&lt;/h3&gt;
&lt;p&gt;此方法将数组转化为字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5];
   let str = arr.toString()
   console.log(str)// 1,2,3,4,5
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;14-arrayjoin&#34;&gt;14. Array.join()&lt;/h3&gt;
&lt;p&gt;此方法也是将数组转化为字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5];
  let str1 = arr.join()
  let str2 = arr.join(&#39;,&#39;)
  let str3 = arr.join(&#39;##&#39;)
  console.log(str1)// 1,2,3,4,5
  console.log(str2)// 1,2,3,4,5
  console.log(str3)// 1##2##3##4##5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;可以设置元素之间的间隔&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;15-arraysplice开始位置-删除的个数元素&#34;&gt;15. Array.splice(开始位置， 删除的个数，元素)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;万能方法，可以实现增删改：&lt;/strong&gt;&lt;code&gt;0增，3删，1改&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5];
     let arr1 = arr.splice(2, 0 &#39;haha&#39;)
     let arr2 = arr.splice(2, 3)
     let arr1 = arr.splice(2, 1 &#39;haha&#39;)
     console.log(arr1) //[1, 2, &#39;haha&#39;, 3, 4, 5]新增一个元素
     console.log(arr2) //[1, 2] 删除三个元素
     console.log(arr3) //[1, 2, &#39;haha&#39;, 4, 5] 替换一个元素
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-查找数组重复项&#34;&gt;3. 查找数组重复项&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;let arr= [1,2,3,4,5,1,2];
let rep = [];
arr.forEach((item,index)=&amp;gt;{
	if(arr.indexOf(item)!=index){ // 匹配数组元素第一个item位置和当前循环的index
        let obj = {};
        obj.key = (arr.indexOf(item) + 1) + &#39;|&#39; + (index + 1); // 用&#39;|&#39;分隔两个重复项的下标   
		obj.value = item;
        rep.push(obj);
	}
});
console.log(rep)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-扁平化数组flatten&#34;&gt;4. 扁平化数组（flatten）&lt;/h2&gt;
&lt;p&gt;扁平化就是将嵌套的数组变成一维数组的过程。&lt;/p&gt;
&lt;p&gt;通常有几种方法可以实现扁平化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;迭代递归法&lt;/li&gt;
&lt;li&gt;曲线救国法&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-迭代递归&#34;&gt;1. 迭代递归&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;var array = [[1,2,3],4,5,6,[[7]],[]]
var result = flatten(array)

console.log(result)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;for...of 实现&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function flatten(arr, result = []) {
    for (let item of arr) {
        if (Array.isArray(item))
            flatten(item, result)
        else
            result.push(item)
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们使用 result 变量存储结果，然后迭代当前数组，如果值也是数组则继续扁平化，否则将值放入 result 里。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;生成器实现&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;迭代器的升级版就是生成器（Generator），其实这种扁平化最适合用生成器来做了，因为我们的目的就是生成一个个的值，然后把它们组织成一维数组：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function* flat(arr) {
    for (let item of arr) {
        if (Array.isArray(item))
            yield* flat(item)
        else
            yield item
    }
}

function flatten(arr) {
    let result = []
    for (let val of flat(arr)) {
        result.push(val)
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里有两点需要注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;嵌套 yield 需要再加一个星号，这被称为生成器委托。&lt;/li&gt;
&lt;li&gt;不能使用 forEach 代替 for...of 但可以用 for 循环，因为 for 循环和for...of 可以中断迭代去执行 yield，forEach 不行&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;reduce 三句实现法&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function flatten(arr) {
  return arr.reduce((flat, toFlatten) =&amp;gt; {
    return flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten);
  }, []);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-曲线救国法&#34;&gt;2. 曲线救国法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;降维打击法&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function flatten(arr){
    let str = arr.toString()
    return str.split(&#39;,&#39;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;转成字符串，之后再复原成数组，不过这个方法有个缺点，就是原来的空数组转的空字符串也会被放入新生成的数组里去。&lt;/p&gt;
&lt;h1 id=&#34;26-dom和bom相关&#34;&gt;26. DOM和BOM相关&lt;/h1&gt;
&lt;h2 id=&#34;1dom&#34;&gt;1.DOM&lt;/h2&gt;
&lt;h3 id=&#34;1-dom是什么&#34;&gt;1. DOM是什么：&lt;/h3&gt;
&lt;p&gt;DOM（Document Object Model）&lt;code&gt;文档对象模型&lt;/code&gt;，是&lt;strong&gt;处理可扩展标志语言&lt;/strong&gt;的标准编程接口。&lt;/p&gt;
&lt;p&gt;DOM 是 &lt;strong&gt;W3C&lt;/strong&gt; 的标准&lt;/p&gt;
&lt;h3 id=&#34;2-dom0级和dom2级有什么区别&#34;&gt;2. DOM0级和DOM2级有什么区别：&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;DOM0&lt;/code&gt;级中为某个dom元素绑定多个事件时，只有最后一个事件有效。&lt;code&gt;onclick&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DOM2&lt;/code&gt;级中可以为单个元素绑定多个事件，每个事件都可以被触发。&lt;code&gt;addEventListener&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-textcontent-innertext-innnerhtml-value的区别&#34;&gt;3. textContent、innerText、innnerHTML、value的区别：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;textContent用来获取和设置文本内容，与innerText的差别是:&lt;code&gt;textContent&lt;/code&gt;获取到的内容包括了元素中的&lt;code&gt;style标签&lt;/code&gt;和&lt;code&gt;script标签&lt;/code&gt;的内容。&lt;/li&gt;
&lt;li&gt;innerText只能获取和设置&lt;code&gt;文本&lt;/code&gt;内容，不能获取和设置html代码&lt;/li&gt;
&lt;li&gt;innerHTML可以获取和设置&lt;code&gt;html&lt;/code&gt;代码&lt;/li&gt;
&lt;li&gt;value获取的是&lt;code&gt;表单元素&lt;/code&gt;的值&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-关于dom的api有什么&#34;&gt;4. 关于dom的api有什么：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;节点创建型api：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;document.createElement()&lt;/li&gt;
&lt;li&gt;document.createTextNode()&lt;/li&gt;
&lt;li&gt;parent.cloneNode(true)&lt;/li&gt;
&lt;li&gt;document.createDocumentFragment() &lt;code&gt;创建文档片段,解决大量添加节点造成的回流问题&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;页面修改型API：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;parent.appendChild(child)&lt;/li&gt;
&lt;li&gt;parent.insertBefore(newNode,referenceNode) &lt;code&gt;将新元素添加到父元素中指定的子元素前面&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;parent.removeChild(child)&lt;/li&gt;
&lt;li&gt;parent.replcaeChild(newChild,oldChild)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;节点查询型API：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;document.getElementById()&lt;/li&gt;
&lt;li&gt;document.getElementsByTagName() 返回的是一个即时的HTMLCollection类型&lt;/li&gt;
&lt;li&gt;document.getElementsByName() 根据指定的name属性获取元素,返回的是一个即时的NodeList&lt;/li&gt;
&lt;li&gt;document.getElementsByClassName() 返回的是一个即时的HTMLCollection&lt;/li&gt;
&lt;li&gt;document.querySelector() 获取匹配到的第一个元素，采用的是深度优先搜索。&lt;/li&gt;
&lt;li&gt;docuemnt.querySelectorAll()&lt;br&gt;
返回的是一个非即时的NodeList，也就是说结果不会随着文档树的变化而变化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;节点关系型api：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;父关系型：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;node.parentNode()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;兄弟关系型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;node.previouSibling() 返回节点的前一个节点（包括元素节点，文本节点，注释节点）&lt;/li&gt;
&lt;li&gt;node.previousElementSibling() 返回前一个元素节点&lt;/li&gt;
&lt;li&gt;node.nextSibling() 返回下一个节点&lt;/li&gt;
&lt;li&gt;node.nextElementSibling() 返回下一个元素节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;子关系型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;parent.childNodes() 返回一个即时的NodeList，包括了文本节点和注释节点&lt;/li&gt;
&lt;li&gt;parent.children() 一个即时的HTMLCollection，子节点都是Element&lt;/li&gt;
&lt;li&gt;parent.firsrtNode()&lt;/li&gt;
&lt;li&gt;parent.lastNode()&lt;/li&gt;
&lt;li&gt;hasChildNodes()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;元素属性型api：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;element.setAttribute(“name”,“value”) 为元素添加属性&lt;/li&gt;
&lt;li&gt;element.getAtrribute(“name”) 获取元素的属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;元素样式型api：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;window.getComputedStyle(element) 返回一个CSSStyleDeclaration,可以从中访问元素的任意样式属性。&lt;/li&gt;
&lt;li&gt;element.getBoundingClientRect() 返回一个DOMRect对象，里面&lt;strong&gt;包括了元素相对于可视区的位置top,left&lt;/strong&gt;,以及元素的大小,单位为纯数字。可用于判断某元素是否出现在了可视区域。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5什么是事件监听&#34;&gt;5.什么是事件监听:&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;addEventListener()方法&lt;/code&gt;，用于向指定元素添加事件句柄，它可以更简单的控制事件，语法为&lt;/p&gt;
&lt;p&gt;element.addEventListener(event, function, useCapture);&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个参数是事件的类型(如 “click” 或 “mousedown”).&lt;/li&gt;
&lt;li&gt;第二个参数是事件触发后调用的函数。&lt;/li&gt;
&lt;li&gt;第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事件传递有两种方式，&lt;code&gt;冒泡&lt;/code&gt;和&lt;code&gt;捕获&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;事件传递定义了元素事件触发的顺序，如果你将P元素插入到div元素中，用户点击P元素，&lt;/p&gt;
&lt;p&gt;在冒泡中，内部元素先被触发，然后再触发外部元素，&lt;br&gt;
捕获中，外部元素先被触发，在触发内部元素，&lt;/p&gt;
&lt;h3 id=&#34;6-说说前端中的事件流&#34;&gt;6. 说说前端中的事件流&lt;/h3&gt;
&lt;p&gt;事件发生时会在元素节点之间按照特定的顺序传播，整个过程分为&lt;code&gt;捕获阶段，目标阶段和冒泡阶段&lt;/code&gt;，这个&lt;code&gt;传播过程&lt;/code&gt;叫做Dom事件流。&lt;/p&gt;
&lt;p&gt;事件冒泡：从事件源逐级向上传播到DOM最顶层节点的过程。&lt;/p&gt;
&lt;p&gt;事件捕获：从DOM最顶层节点逐级向下传播到事件源的过程。&lt;/p&gt;
&lt;p&gt;addEventListener用于指定事件处理程序，共接收三个参数。分别是触发事件，事件处理程序函数以及一个布尔值。第三个参数默认为false，表示在该事件的处理函数会在冒泡阶段被调用。若改为true，则表示事件处理函数会在捕获阶段被调用。&lt;/p&gt;
&lt;h3 id=&#34;7-如何让事件先冒泡后捕获&#34;&gt;7. 如何让事件先冒泡后捕获&lt;/h3&gt;
&lt;p&gt;对于&lt;code&gt;目标元素&lt;/code&gt;来说，如果DOM节点通过addEventListener同时绑定了两个事件监听函数，一个用于捕获，一个用于冒泡，那么两个事件的执行顺序是按照代码添加的顺序执行的。所以，先绑定冒泡的函数，再绑定捕获的函数，即可实现。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;非目标元素&lt;/code&gt;来说，可以给捕获事件的处理程序添加一个定时器，将处理程序推入下一个宏任务执行。&lt;/p&gt;
&lt;h3 id=&#34;8-说一下事件代理&#34;&gt;8. 说一下事件代理：&lt;/h3&gt;
&lt;p&gt;事件委托是指 不在子节点单独设置事件监听器，而将事件&lt;code&gt;监听器设置在父节点上&lt;/code&gt;，再利用&lt;code&gt;冒泡原理&lt;/code&gt;使每一个子节点都能触发该事件。&lt;/p&gt;
&lt;p&gt;事件委托的优点：只操作一次Dom，提高了程序的性能。&lt;/p&gt;
&lt;p&gt;常用于&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ul和li标签的事件监听，一般采用事件委托机制将事件监听器绑定在ul上。&lt;/li&gt;
&lt;li&gt;还适合动态元素的绑定，新添加的子元素不需单独添加事件处理程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;（1）了解事件代理吗，这样做有什么好处&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事件代理就是说我们将事件添加到本来要添加的事件的父节点，将事件委托给父节点来触发处理函数，这通常会使用在大量的同级元素需要添加同一类事件的时候，比如一个动态的非常多的列表，需要为每个列表项都添加点击事件，这时就可以使用事件代理，通过判断e.target.nodeName来判断发生的具体元素，这样做的好处是减少事件绑定，同事动态的DOM结构任然可以监听，事件代理发生在冒泡阶段&lt;/p&gt;
&lt;p&gt;** （2）事件代理在捕获阶段的实际应用：**&lt;/p&gt;
&lt;p&gt;可以在父元素层面阻止事件向子元素传播，也可代替子元素执行某些操作。&lt;/p&gt;
&lt;h3 id=&#34;9-事件类型相关&#34;&gt;9. 事件类型相关：&lt;/h3&gt;
&lt;p&gt;（1）&lt;code&gt;mouseover和mouseenter的区别&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移出事件是mouseout。&lt;/li&gt;
&lt;li&gt;mouseenter：鼠标移入子元素时不会再次触发mouseenter事件，对应的移出事件是mouseleave。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（2）&lt;code&gt;三种键盘事件的区别：&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;keyup: 松开键盘触发&lt;/li&gt;
&lt;li&gt;keydown:按下键盘触发&lt;/li&gt;
&lt;li&gt;keypress:不能识别功能键，比如ctrl,alt,shift,左右箭头。可以区分大小写。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在输入框中按下一个键的全过程：触发keydown/keypress事件-&amp;gt;文字键入输入框中-&amp;gt;触发keyup事件&lt;/p&gt;
&lt;p&gt;按下按键后&lt;code&gt;自动对焦&lt;/code&gt;输入框，应该使用&lt;code&gt;keyup&lt;/code&gt;，不应该使用keydown/keypress,因为后者会使按键落入输入框中,对于回车键的话还不能使用keypress。&lt;/p&gt;
&lt;h3 id=&#34;10-静态绑定事件与动态绑定事件的区别&#34;&gt;10. 静态绑定事件与动态绑定事件的区别：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;静态绑定&lt;/strong&gt;事件是指直接在Html标签上通过οnclick=&amp;quot;hide()&amp;quot;来绑定事件。&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;html和js文件存在耦合，不符合结构和行为分离的原则。&lt;/li&gt;
&lt;li&gt;可能存在引发错误，如果js代码还没加载就触发该事件则会抛出错误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;动态绑定&lt;/strong&gt;事件是指通过js动态绑定事件，element.onclick() element.addEventListener()。&lt;/p&gt;
&lt;h3 id=&#34;11-元素的位置和大小&#34;&gt;11. 元素的位置和大小&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;① offset系列：&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;offsetTop（获取元素位置）: 相对于带有‘定位’的父元素的偏移量&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;offsetHeight: content+padding+border&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;② cilent系列：&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;clientHeight(获取元素宽高): content+padding,不包含border&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;③ scroll系列：&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;scrollTop（获取滚动的距离）&lt;/strong&gt;: 向下滚动后，上面被卷去的距离，即隐藏的高度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;④ document.clientWidth与document.style.width的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;区别1：前者可以获取任意样式表中的width样式值，包括行内样式的，内嵌样式的，外部样式的；后者只能获取行内的样式。&lt;/li&gt;
&lt;li&gt;区别2：clientWidth获取的是数字型的，style获取的带有px后缀&lt;/li&gt;
&lt;li&gt;区别3：clientWidth包含了padding,而style.width只包含content。&lt;/li&gt;
&lt;li&gt;区别4：clientWidth是只读属性，所以一般用于获取元素的大小；而style.width是可读可写的，可用于获取，也可用于修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;⑤ 判断一个元素是否已经出现在了可视区域：(此问题可应用在懒加载中)&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;使用element.getBoundingClientRect().top获取在可视区的位置。&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;window.addEventListener(&amp;quot;scroll&amp;quot;, function () {
    let viewPortHeight = window.pageYOffset;
    let offset = box2.getBoundingClientRect().top;
    if (offset &amp;lt; viewPortHeight) {
        if (offset + box2.offsetHeight &amp;lt; 0) {
            console.log(&amp;quot;他走了&amp;quot;);
        } else {
            console.log(&amp;quot;他来啦他来啦&amp;quot;);
        }
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;12-js拖动及拖拽功能的实现&#34;&gt;12. js拖动及拖拽功能的实现&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;（1）拖动功能的实现：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;前置条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;拖动事件的三个过程：鼠标按下mousedown,鼠标移动mousemove,鼠标松开mouseup&lt;br&gt;
鼠标按下后执行mousemove事件。&lt;/li&gt;
&lt;li&gt;盒子采用绝对定位，通过left和top属性来修改位置。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;方法一：（直接根据鼠标移动的距离确定元素移动的距离）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;鼠标的坐标通过clientX,clientY获取：&lt;/li&gt;
&lt;li&gt;盒子的定位信息：鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的offetLeft.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;（2）拖拽功能的实现：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用html5提供的拖拽API（Drag 和 drop）&lt;/p&gt;
&lt;h2 id=&#34;2-bom浏览器对象模型&#34;&gt;2. (BOM)浏览器对象模型：&lt;/h2&gt;
&lt;h3 id=&#34;1-实用的bom属性对象方法&#34;&gt;1. 实用的BOM属性对象方法：&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;location对象&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;location.href– 返回或设置当前文档的URL&lt;/li&gt;
&lt;li&gt;location.search – 返回URL中的查询字符串部分。例如 http://www.dreamdu.com/dreamdu.php?id=5&amp;amp;name=dreamdu 返回包括(?)后面的内容?id=5&amp;amp;name=dreamdu&lt;/li&gt;
&lt;li&gt;location.hash – 返回URL#后面的内容，如果没有#，返回空&lt;/li&gt;
&lt;li&gt;location. – 返回URL中的域名部分，例如www.dreamdu.com&lt;/li&gt;
&lt;li&gt;location.hostname – 返回URL中的主域名部分，例如dreamdu.com&lt;/li&gt;
&lt;li&gt;location.pathname – 返回URL的域名后的部分。例如 http://www.dreamdu.com/xhtml/ 返回/xhtml/&lt;/li&gt;
&lt;li&gt;location.port – 返回URL中的端口部分。例如 http://www.dreamdu.com:8080/xhtml/ 返回8080&lt;/li&gt;
&lt;li&gt;location.protocol – 返回URL中的协议部分。例如 http://www.dreamdu.com:8080/xhtml/ 返回(//)前面的内容http:&lt;/li&gt;
&lt;li&gt;location.assign() – 重定向页面，与location.href一样，会记录历史，能后退页面&lt;/li&gt;
&lt;li&gt;location.replace() – 设置当前文档的URL，不记录历史，不能后退页面&lt;/li&gt;
&lt;li&gt;location.reload() – 重载当前页面,相当于F5。添加参数true则表示强制刷新，直接从服务器获取数据，不从浏览器缓存中取数据，相当于Ctrl+F5&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;history对象&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;history.go(n) – 前进或后退指定的页面数;&lt;/li&gt;
&lt;li&gt;history.back() – 后退一页&lt;/li&gt;
&lt;li&gt;history.forward() – 前进一页&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;navigator对象&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;navigator包含了用户浏览器的信息&lt;/li&gt;
&lt;li&gt;navigator.userAgent – 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)&lt;/li&gt;
&lt;li&gt;navigator.cookieEnabled – 返回浏览器是否支持(启用)cookie&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-settimeoutfn100100毫秒是如何权衡的&#34;&gt;2. setTimeout(fn,100);100毫秒是如何权衡的：&lt;/h3&gt;
&lt;p&gt;100ms指的是将回调函数加入到任务队列所花的时间。至于具体什么时候执行，需要看主线程的执行栈中是否还有任务在执行。&lt;/p&gt;
&lt;h3 id=&#34;3-requestanimationframe&#34;&gt;3. requestAnimationFrame&lt;/h3&gt;
&lt;p&gt;特点：requestAnimationFrame采用系统时间间隔，保证了最佳的绘制效率。&lt;/p&gt;
&lt;p&gt;使用方法：requestAnimationFrame接收一个回调函数，这个回调函数会在下一次浏览器重绘之前调用。&lt;/p&gt;
&lt;h3 id=&#34;4-分别用setintervalsettimeoutrequestanimationframe制作有个简单的进度条效果&#34;&gt;4. 分别用setInterval,setTimeout,requestAnimationFrame制作有个简单的进度条效果：&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;setInterval:&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div
     style=&amp;quot;width: 0; height: 20px; background-color: orange&amp;quot;
     id=&amp;quot;div&amp;quot;
     &amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
    let timer = setInterval(() =&amp;gt; {
        if (parseInt(div.style.width) &amp;gt;= 500) {
            return clearInterval(timer);
        }
        console.log(div.style.width);
        div.style.width = parseInt(div.style.width) + 5 + &amp;quot;px&amp;quot;;
        div.innerHTML = parseInt(div.style.width) / 5 + &amp;quot;%&amp;quot;;
    }, 16);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;setTimeout:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div
     style=&amp;quot;width: 0; height: 20px; background-color: orange&amp;quot;
     id=&amp;quot;div&amp;quot;
     &amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
    let timer = setTimeout(function fn() {
        if (parseInt(div.style.width) &amp;lt; 500) {
            div.style.width = parseInt(div.style.width) + 5 + &amp;quot;px&amp;quot;;
            div.innerHTML = parseInt(div.style.width) / 5 + &amp;quot;%&amp;quot;;
            timer = setTimeout(fn, 16);
        } else {
            clearTimeout(timer);
        }
    }, 16);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;requestAnimationFrame:类似于setTimeout,需要一次次的调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div
     style=&amp;quot;width: 0; height: 20px; background-color: orange&amp;quot;
     id=&amp;quot;div&amp;quot;
     &amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
    let timer = requestAnimationFrame(function fn() {
        if (parseInt(div.style.width) &amp;lt; 500) {
            div.style.width = parseInt(div.style.width) + 5 + &amp;quot;px&amp;quot;;
            div.innerHTML = parseInt(div.style.width) / 5 + &amp;quot;%&amp;quot;;
            requestAnimationFrame(fn);
        } else {
            cancelAnimationFrame(timer);
        }
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-js中的轮播实现原理假如一个页面上有两个轮播你会怎么实现&#34;&gt;5. js中的轮播实现原理？假如一个页面上有两个轮播，你会怎么实现？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;让图片存在一个数组中，然后将最后一张图片重复添加在数组的头部，将第一张图片重复添加在数组的最后。&lt;/li&gt;
&lt;li&gt;然后准备一个只能显示一张图片的盒子，对盒子做溢出隐藏处理。&lt;/li&gt;
&lt;li&gt;通过定时器增减索引，显示对应的图片，实现轮播功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果有两个轮播，可封装一个轮播组件，将需要轮播的图片作为参数传递。&lt;/p&gt;
&lt;h1 id=&#34;27-服务端渲染server-side-render&#34;&gt;27. 服务端渲染（server side render）&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;服务端渲染(SSR)&lt;/code&gt;：页面上的内容是由服务器上的代码决定的。即，页面上的内容在服务器上已经生成好了，服务器把这个内容给到浏览器，浏览器拿到这个内容直接显示在页面上即可。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;客户端渲染(CSR)&lt;/code&gt; ：一个网页是由JS文件渲染出来的，而不是服务器直接返回回来的。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615364099956.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-ssr的优势&#34;&gt;1. SSR的优势&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;更利于SEO&lt;br&gt;
服务端渲染返回给客户端的是已经获取了异步数据并执行JavaScript脚本的最终HTML，网络爬中就可以抓取到完整页面的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更利于首屏渲染&lt;br&gt;
首屏的渲染是node发送过来的html字符串，并不依赖于js文件了，这就会使用户更快的看到页面的内容。尤其是针对大型单页应用，打包后文件体积比较大，普通客户端渲染加载所有所需文件时间较长，首页就会有一个很长的白屏等待时间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-ssr的劣势&#34;&gt;2. SSR的劣势&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;服务端压力较大&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开发条件受限&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;学习成本相对较高&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;28-js-垃圾回收机制&#34;&gt;28.  JS 垃圾回收机制&lt;/h1&gt;
&lt;h2 id=&#34;1-垃圾回收&#34;&gt;1. 垃圾回收&lt;/h2&gt;
&lt;p&gt;JavaScript 中的内存管理是自动执行的，而且是不可见的。我们创建基本类型、对象、函数……所有这些都需要内存。&lt;/p&gt;
&lt;h2 id=&#34;2-可达性&#34;&gt;2. 可达性&lt;/h2&gt;
&lt;p&gt;JavaScript 中内存管理的主要概念是可达性。&lt;/p&gt;
&lt;p&gt;简单地说，“可达性” 值就是那些以某种方式&lt;code&gt;可访问&lt;/code&gt;或&lt;code&gt;可用&lt;/code&gt;的值，它们被保证存储在内存中。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有一组基本的固有可达值，由于显而易见的原因无法删除。例如:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;本地函数的局部变量和参数&lt;/li&gt;
&lt;li&gt;当前嵌套调用链上的其他函数的变量和参数&lt;/li&gt;
&lt;li&gt;全局变量&lt;/li&gt;
&lt;li&gt;还有一些其他的，内部的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;这些值称为根。&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;如果局部变量中有对象，并且该对象具有引用另一个对象的属性，则该对象被视为&lt;strong&gt;可达性&lt;/strong&gt;， 它引用的那些也是可以访问的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;下面是最简单的例子:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// user 具有对象的引用
let user = {
  name: &amp;quot;John&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615366337580.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里箭头表示一个对象引用。全局变量&lt;code&gt;“user”&lt;/code&gt;引用对象 &lt;code&gt;{name:“John”}&lt;/code&gt;(为了简洁起见，我们将其命名为John)。John 的 &lt;code&gt;“name”&lt;/code&gt;属性存储一个基本类型，因此它被绘制在对象中。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;user&lt;/code&gt; 的值被覆盖，则引用丢失:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user = null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615366388527.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
现在 John 变成不可达的状态，没有办法访问它，没有对它的引用。垃圾回收器将丢弃 John 数据并释放内存。&lt;/p&gt;
&lt;h2 id=&#34;3两个引用&#34;&gt;3.两个引用&lt;/h2&gt;
&lt;p&gt;现在让我们假设我们将引用从 &lt;code&gt;user&lt;/code&gt;复制到 &lt;code&gt;admin&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// user具有对象的引用
let user = {
  name: &amp;quot;John&amp;quot;
};
let admin = user;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615366454334.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
现在如果我们做同样的事情:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user = null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该对象仍然可以通过 &lt;code&gt;admin&lt;/code&gt; 全局变量访问，所以它在内存中。如果我们也覆盖&lt;code&gt;admin&lt;/code&gt;，那么它可以被释放。&lt;/p&gt;
&lt;h2 id=&#34;4-相互关联的对象&#34;&gt;4. 相互关联的对象&lt;/h2&gt;
&lt;p&gt;现在来看一个更复杂的例子， family 对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function marry (man, woman) {
  woman.husban = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman
  }
}

let family = marry({
  name: &amp;quot;John&amp;quot;
}, {
  name: &amp;quot;Ann&amp;quot;
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;产生的内存结构:&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615366611256.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
现在让我们删除两个引用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;delete family.father;
delete family.mother.husband;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615366634406.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
仅仅删除这两个引用中的一个是不够的，因为所有对象仍然是可访问的。&lt;/p&gt;
&lt;p&gt;但是如果我们把这两个都删除，那么我们可以看到 John 不再有传入的引用:&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615366651083.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
输出引用无关紧要。只有传入的对象才能使对象可访问，因此，John 现在是不可访问的，并将从内存中删除所有不可访问的数据。&lt;/p&gt;
&lt;p&gt;垃圾回收之后：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615366668995.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;5-内部算法&#34;&gt;5. 内部算法&lt;/h2&gt;
&lt;p&gt;基本的垃圾回收算法称为“&lt;strong&gt;标记-清除&lt;/strong&gt;”，定期执行以下“垃圾回收”步骤:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;垃圾回收器获取根并“&lt;strong&gt;标记&lt;/strong&gt;”(记住)它们。&lt;/li&gt;
&lt;li&gt;然后它访问并“标记”所有来自它们的引用。&lt;/li&gt;
&lt;li&gt;然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。&lt;/li&gt;
&lt;li&gt;以此类推，直到有未访问的引用(可以从根访问)为止。&lt;/li&gt;
&lt;li&gt;除标记的对象外，所有对象都被删除。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如，对象结构如下:&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615366772644.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
我们可以清楚地看到右边有一个“不可到达的块”。现在让我们看看“&lt;strong&gt;标记并清除&lt;/strong&gt;”垃圾回收器如何处理它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步标记根&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615367324843.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;然后标记他们的引用&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615367344647.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;以及子孙代的引用:&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615367365917.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
现在进程中不能访问的对象被认为是不可访问的，将被删除:&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615367388777.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;这就是垃圾收集的工作原理。JavaScript引擎应用了许多优化，使其运行得更快，并且不影响执行。&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;6面试怎么回答&#34;&gt;6.面试怎么回答&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1）问什么是垃圾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般来说没有被引用的对象就是垃圾，就是要被清除， 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）如何检垃圾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一种算法是标记 标记-清除 算法&lt;/p&gt;
&lt;h1 id=&#34;29-eventloop&#34;&gt;29. eventloop&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Event Loop&lt;/code&gt;即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用&lt;strong&gt;异步&lt;/strong&gt;的原理。&lt;/p&gt;
&lt;h2 id=&#34;1-进程和线程&#34;&gt;1. 进程和线程&lt;/h2&gt;
&lt;p&gt;线程，是程序执行流的最小单位。线程可与同属一个进程的其他线程共享所拥有的全部资源，同一进程中的多个线程之间可以并发执行。线程有&lt;code&gt;就绪&lt;/code&gt;，&lt;code&gt;阻塞&lt;/code&gt;，&lt;code&gt;运行&lt;/code&gt;三种基本状态。&lt;/p&gt;
&lt;p&gt;阮一峰大神针对进程和线程的类比，很是形象：&lt;code&gt;计算机的核心CPU&lt;/code&gt;，是个工厂，时刻运转着，工厂里有很多个车间（进程），一个车间开工其他车间不能开工，就是说：&lt;code&gt;单核CPU一次只能运行一个进程。任何时候，CPU总是运行一个进程&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;而一个车间里面有很多工人（线程），协同完成一个任务。所以：&lt;code&gt;一个进程可以包括多个线程&lt;/code&gt;。车间空间是工人共享的，&lt;code&gt;一个进程中的内存空间是所有线程共享的&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是房间大小不同个，容纳量不同，有些线程进去了，其他线程就不能再进去使用了。这就是：&lt;code&gt;一个线程使用某些共享内存时，其他线程得等它结束后才能使用共享内存&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;内存可以上锁，防止其他线程进来，【互斥锁】也就是防止多个线程读写同一块内存区域。&lt;/p&gt;
&lt;p&gt;还有些共享内存比较大，可以容纳多个线程，但是也是有限的，只能容纳固定数目的线程使用。如何保证多个线程不冲突呢？内存门口有个钥匙架，如果发现钥匙架空了，那就不能再进去了【信号量】。&lt;/p&gt;
&lt;h2 id=&#34;2事件循环event-loop&#34;&gt;2.事件循环（Event Loop）&lt;/h2&gt;
&lt;p&gt;JavaScript是单线程的，单线程意味着需要一个任务队列来管理任务事件，任务分为两种：&lt;code&gt;同步任务&lt;/code&gt;和&lt;code&gt;异步任务&lt;/code&gt;。同步任务是在主线程上面排队执行的任务，只有前面任务完成，下一个任务才能执行。异步任务是不进入主线程，而是进入任务队列中，只有通知主线程某个异步任务可以执行了，该任务方可执行。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615368575238.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们的同步任务在主线程上运行会形成一个执行栈&lt;/li&gt;
&lt;li&gt;如果碰到异步任务，比如setTimeout、onClick等等的一些操作，我们会将他的执行结果放入队列，此期间主线程不阻塞&lt;/li&gt;
&lt;li&gt;等到主线程中的所有同步任务执行完毕，就会通过event loop在队列里面从头开始取，在执行栈中执行&lt;/li&gt;
&lt;li&gt;event loop永远不会断&lt;/li&gt;
&lt;li&gt;以上的这一整个流程就是Event Loop（事件循环机制）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-任务队列&#34;&gt;3. 任务队列&lt;/h2&gt;
&lt;p&gt;同步任务在主线程执行形成一个执行栈，主线程之外有个任务队列（鼠标点击事件，键盘点击事件，网络请求），只要异步任务触发，在任务队列中放置一个事件，等执行栈中同步任务完成后，系统才会读取任务队列执行异步任务。主线程会重复去任务队列中读取任务并执行——事件循环。&lt;/p&gt;
&lt;p&gt;任务队列是“先进先出”的数据结构，先来的优先被主线程读取。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615368924655.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
主线程运行产生堆heap和栈stack，栈里面是各种同步方法，栈里面代码执行完毕主线程会读取任务队列，依次执行事件的回调函数。&lt;/p&gt;
&lt;p&gt;所以，栈里面的同步任务总是在任务队列之前执行。&lt;/p&gt;
&lt;h1 id=&#34;30-如何快速让字符串变成以千为精度的数字&#34;&gt;30. 如何快速让字符串变成以千为精度的数字&lt;/h1&gt;
&lt;h2 id=&#34;1-字符串转换成数字的三种方法&#34;&gt;1. 字符串转换成数字的三种方法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;转换函数、强制类型转换、利用js变量弱类型转换&lt;/code&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;转换函数：&lt;br&gt;
js提供了parseInt()和parseFloat()两个转换函数。前者把值转换成整数，后者把值转换成浮点数。只有对String类型调用这些方法，这两个函数才能正确运行；对其他类型返回的都是NaN(Not a Number)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;parseInt()方法还有基模式，可以把二进制、八进制、十六进制或其他任何进制的字符串转换成整数。基是由parseInt()方法的第二个参数指定的，示例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;parseInt(&amp;quot;AF&amp;quot;,   16);   //returns   175
parseInt(&amp;quot;10&amp;quot;,   2);   //returns   2
parseInt(&amp;quot;10&amp;quot;,   8);   //returns   8
parseInt(&amp;quot;10&amp;quot;,   10);   //returns   10
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;强制类型转换&lt;br&gt;
ECMAScript中可用的3种强制类型转换如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Boolean(value)——把给定的值转换成Boolean型；&lt;/li&gt;
&lt;li&gt;Number(value)——把给定的值转换成数字（可以是整数或浮点数）；&lt;/li&gt;
&lt;li&gt;String(value)——把给定的值转换成字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;利用js变量弱类型转换&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-数字千位符格式化&#34;&gt;2. 数字千位符格式化&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;function toThousands(num) {
    var result = &#39;&#39;, counter = 0;
    num = (num || 0).toString();
    for (var i = num.length - 1; i &amp;gt;= 0; i--) {
        counter++;
        result = num.charAt(i) + result;
        if (!(counter % 3) &amp;amp;&amp;amp; i != 0) { result = &#39;,&#39; + result; }
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;
">【面】前端知识点梳理（JS下）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/mian-qian-duan-zhi-shi-dian-shu-li-js-shang/"" data-c="
          &lt;h1 id=&#34;1-原型原型链构造函数实例继承&#34;&gt;1. 原型/原型链/构造函数/实例/继承&lt;/h1&gt;
&lt;h2 id=&#34;11-创建对象的几种方法&#34;&gt;1.1 创建对象的几种方法&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot; charset=&amp;quot;utf-8&amp;quot;&amp;gt;
		//创建对象的几种方式
		//1.字面量
		var obj1 = {name: &#39;solo obj1&#39;};
		//2.new Object
		var obj2 = new Object({name: &#39;solo obj2&#39;})
		//3.构造函数创建
		var M = function(name){
			this.name = name;
		}
		var obj3 = new M(&#39;solo obj3&#39;);
		//4.Object.create
		var p = {name: &#39;p&#39;};
		var obj4 = Object.create(p);
	&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;12-原型-构造函数-实例-原型链&#34;&gt;1.2 原型、构造函数、实例、原型链&lt;/h2&gt;
&lt;p&gt;构造函数、原型对象、实例的关系可以参照下图：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614923904668.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;构造函数.prototype.constructor === 构造函数&lt;br&gt;
M.prototype.constructor === M 的结果为 true&lt;/p&gt;
&lt;p&gt;构造函数.prototype === 实例对象. proto&lt;br&gt;
M.prototype === obj3._ proto _ 的结果为 true&lt;/p&gt;
&lt;h2 id=&#34;13-instanceof-的原理&#34;&gt;1.3 instanceof 的原理&lt;/h2&gt;
&lt;p&gt;instanceof 的原理是判断&lt;strong&gt;实例对象的&lt;/strong&gt; &lt;strong&gt;proto&lt;/strong&gt; 是否与&lt;strong&gt;构造函数的prototype&lt;/strong&gt;指向同一个引用。&lt;/p&gt;
&lt;h2 id=&#34;14-instanceof-和-typeof-的区别&#34;&gt;1.4 instanceof 和 typeof 的区别&lt;/h2&gt;
&lt;p&gt;typeof 对于基本数据类型（&lt;code&gt;null, undefined, string, number, boolean, symbol&lt;/code&gt;），除了 null 都会返回正确的类型。null 会返回 object。&lt;/p&gt;
&lt;p&gt;typeof 对于对象类型，除了函数会返回 function，其他的都返回 object。&lt;/p&gt;
&lt;h2 id=&#34;15-原型链&#34;&gt;1.5 原型链&lt;/h2&gt;
&lt;p&gt;当访问 p 中的一个非自有属性的时候，就会通过 &lt;strong&gt;proto&lt;/strong&gt; 作为桥梁连接起来的一系列原型、原型的原型、原型的原型的原型直到 Object 构造函数为止。&lt;/p&gt;
&lt;p&gt;这个搜索的过程形成的链状关系就是原型链&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614924650255.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;例子&#34;&gt;例子&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;function F(){} var f = new F(); // 构造器 
F.prototype.constructor === F; // true 
F.__proto__ === Function.prototype; // true 
Function.prototype.__proto__ === Object.prototype; // true Object.prototype.__proto__ === null; // true // 实例
f.__proto__ === F.prototype; // true 
F.prototype.__proto__ === Object.prototype; // true Object.prototype.__proto__ === null;// true
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614925004509.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;2-有几种方式可以实现继承&#34;&gt;2. 有几种方式可以实现继承&lt;/h1&gt;
&lt;p&gt;ES5实现继承有6种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原型链继承&lt;/li&gt;
&lt;li&gt;借用构造函数继承&lt;/li&gt;
&lt;li&gt;组合继承&lt;/li&gt;
&lt;li&gt;原型式继承&lt;/li&gt;
&lt;li&gt;寄生式继承&lt;/li&gt;
&lt;li&gt;寄生组合式继承&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;寄生组合式&lt;/strong&gt;继承是大家公认的最好的实现引用类型继承的方法。&lt;/p&gt;
&lt;p&gt;ES6新增class和extends语法，用来定义类和实现继承，底层也是采用了寄生组合式继承。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614925710279.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614925713288.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-用原型实现继承有什么缺点怎么解决&#34;&gt;3. 用原型实现继承有什么缺点，怎么解决&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;原型继承&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Human(){
this.name=&amp;quot;teacher&amp;quot;;
this,age=39;
}
function Man(){
}
Man.prototype=new Human();
var m=new Man();
/*此时Man.name=teacher;Man.age=39；*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;br&gt;
可以继承构造函数属性，也可继承原型属性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;br&gt;
1，在创建子类实例化时，不能向超类型的构造函数中传参&lt;br&gt;
2，子类型继承了父类型原型中的所有属性和方法，但对于引用类型属性值所有实例共享，故不能在不改变其他实例情况下改变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方式&lt;/strong&gt;&lt;br&gt;
使用混合继承。&lt;/p&gt;
&lt;h1 id=&#34;4-arguments&#34;&gt;4. arguments&lt;/h1&gt;
&lt;p&gt;arguments 是一个&lt;strong&gt;类似数组&lt;/strong&gt;的对象, 对应于传递给函数的&lt;strong&gt;参数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;arguments对象是所有函数中可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;arguments[0]
arguments[1]
arguments[2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;arguments对象不是一个 Array 。它类似于数组，但除了 长度之外没有任何数组属性。&lt;/p&gt;
&lt;p&gt;可以使用 Array.from()方法或 spread 运算符将 arguments 转换为真正的数组：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let args = Array.from(arguments);
let args = [...arguments];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你调用一个函数，当这个函数的参数数量比它显式声明的参数数量更多的时候，你就可以使用 arguments 对象。你可以用 arguments.length 来得到参数的数量，然后可以用 arguments object 来对每个参数进行处理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;arguments.callee：指向当前执行的函数。&lt;/li&gt;
&lt;li&gt;arguments.caller **：指向调用当前函数的函数。&lt;/li&gt;
&lt;li&gt;arguments.length：指向传递给当前函数的参数数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;模拟函数重载&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function add(num1, num2, num3) {
if (arguments.length === 2) {
    console.log(&amp;quot;Result is &amp;quot; + (num1 + num2));
     }
else if (arguments.length === 3) {
    console.log(&amp;quot;Result is &amp;quot; + (num1 + num2 + num3));
     }
｝
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;add(1, 2);&lt;br&gt;
add(1, 2, 3)&lt;/p&gt;
&lt;p&gt;执行结果如下：&lt;br&gt;
Result is 3&lt;br&gt;
Result is 6&lt;/p&gt;
&lt;h1 id=&#34;5-数据类型判断&#34;&gt;5. 数据类型判断&lt;/h1&gt;
&lt;h2 id=&#34;51-javascript-数据类型&#34;&gt;5.1 JavaScript 数据类型&lt;/h2&gt;
&lt;p&gt;JavaScript 数据类型有两种，分别是基本数据类型和引用数据类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基本数据类型&lt;br&gt;
Number&lt;br&gt;
String&lt;br&gt;
Boolean&lt;br&gt;
Undefined&lt;br&gt;
Null&lt;br&gt;
Symbol (ES6 新增，表示独一无二的值)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引用数据类型&lt;br&gt;
Object&lt;br&gt;
Function&lt;br&gt;
Array&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;52-检验数据类型&#34;&gt;5.2 检验数据类型&lt;/h2&gt;
&lt;h3 id=&#34;521-typeof&#34;&gt;5.2.1 typeof&lt;/h3&gt;
&lt;p&gt;它返回一个表示数据类型的字符串，返回结果包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;number&lt;/li&gt;
&lt;li&gt;boolean&lt;/li&gt;
&lt;li&gt;string&lt;/li&gt;
&lt;li&gt;symbol&lt;/li&gt;
&lt;li&gt;object&lt;/li&gt;
&lt;li&gt;undefined&lt;/li&gt;
&lt;li&gt;function&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;br&gt;
除 function 以外的对象都会被识别成 object ，这样显然是不合理的，这时就需要 instanceof 来进行判断。&lt;/p&gt;
&lt;h3 id=&#34;522-instanceof&#34;&gt;5.2.2 instanceof&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上&lt;/strong&gt;&lt;br&gt;
简单来说就是 instanceof 是用来判断 A 是否为 B 的实例，表达式为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A  (object)  instanceof  B  (constructor)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果A是B的实例，则返回true,否则返回 false。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;br&gt;
1.&lt;strong&gt;是否处于原型链上的判断方法不严谨&lt;/strong&gt;&lt;br&gt;
instanceof 方法判断的是是否处于原型链上，而不是是不是处于原型链最后一位&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;无法判断字面量方式创建的基本数据类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;无法检测 null 和 undefined&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;523-objectprototypetostringcall&#34;&gt;5.2.3 Object.prototype.toString.call()&lt;/h3&gt;
&lt;p&gt;在 Number、String，Boolean，Array，RegExp、Date、Function 等对象上 toString() 方法都是被重写过了的，会按照一定的规则返回字符串。但是在 object 对象上，这个方式是返回当前方法执行的主体（方法中的this）所属类的详细信息即&amp;quot;[object Object]&amp;quot;,其中第一个object代表当前实例是对象数据类型的(这个是固定的 onject)，第二个Object代表的是this所属的类型。&lt;/p&gt;
&lt;p&gt;为了每个对象都能通过 Object.prototype.toString() 来检测，需要以 Function.prototype.call() 或者 Function.prototype.apply() 的形式来调用，传递要检查的对象作为第一个参数，称为 thisArg。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object.prototype.toString.call(&#39;&#39;) ;   // [object String]
Object.prototype.toString.call(1) ;    // [object Number]
Object.prototype.toString.call(true) ; // [object Boolean]
Object.prototype.toString.call(undefined) ; // [object Undefined]
Object.prototype.toString.call(null) ; // [object Null]
Object.prototype.toString.call(new Function()) ; // [object Function]
Object.prototype.toString.call(new Date()) ; // [object Date]
Object.prototype.toString.call([]) ; // [object Array]
Object.prototype.toString.call(new RegExp()) ; // [object RegExp]
Object.prototype.toString.call(new Error()) ; // [object Error]
Object.prototype.toString.call(document) ; // [object HTMLDocument]
Object.prototype.toString.call(window) ; //[object global] window是全局对象global的引用
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;6-作用域-作用域链和闭包的理解&#34;&gt;6. 作用域、作用域链和闭包的理解&lt;/h1&gt;
&lt;h2 id=&#34;61-作用域&#34;&gt;6.1 作用域&lt;/h2&gt;
&lt;p&gt;变量的作用域无非就是两种：&lt;strong&gt;全局变量&lt;/strong&gt;和&lt;strong&gt;局部变量&lt;/strong&gt;。&lt;br&gt;
&lt;code&gt;全局作用域&lt;/code&gt;：&lt;br&gt;
最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是可以访问的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
      var outerVar = &amp;quot;outer&amp;quot;;
      function fn(){
         console.log(outerVar);
      }
      fn();//result:outer
   &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;局部作用域&lt;/code&gt;：&lt;br&gt;
和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无法访问的，最常见的例如函数内部&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
      function fn(){
         var innerVar = &amp;quot;inner&amp;quot;;
      }
      fn();
      console.log(innerVar);// ReferenceError: innerVar is not defined
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;只要函数内定义了一个局部变量，函数在解析的时候都会将这个变量“提前声明”：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
      var scope = &amp;quot;global&amp;quot;;
      function fn(){
         var scope;//提前声明了局部变量
         console.log(scope);//result:undefined
         scope = &amp;quot;local&amp;quot;;
         console.log(scope);//result:local;
      }
      fn();
   &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;62-作用域链scope-chain&#34;&gt;6.2 作用域链（Scope Chain）&lt;/h2&gt;
&lt;p&gt;作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。&lt;/p&gt;
&lt;h3 id=&#34;621-执行环境execution-context&#34;&gt;6.2.1 执行环境（execution context）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;js为每一个执行环境关联了一个变量对象。环境中定义的所有变量和函数都保存在这个对象中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;全局执行环境是最外围的执行环境，全局执行环境被认为是window对象，因此所有的全局变量和函数都作为window对象的属性和方法创建的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;script&amp;gt;
      var scope = &amp;quot;global&amp;quot;; 
      function fn1(){
         return scope; 
      }
      function fn2(){
         return scope;
      }
      fn1();
      fn2();
   &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码执行情况演示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614938134873.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;622-作用域链&#34;&gt;6.2.2 作用域链&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
name=&amp;quot;lwy&amp;quot;;
function t(){
    var name=&amp;quot;tlwy&amp;quot;;
    function s(){
        var name=&amp;quot;slwy&amp;quot;;
        console.log(name);
    }
    function ss(){
        console.log(name);
    }
    s();
    ss();
}
t();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当执行s时，将创建函数s的执行环境(调用对象),并将该对象置于链表开头，然后将函数t的调用对象链接在之后，最后是全局对象。然后从链表开头寻找变量name,很明显name是&amp;quot;slwy&amp;quot;。&lt;/p&gt;
&lt;p&gt;但执行ss()时，作用域链是： ss()-&amp;gt;t()-&amp;gt;window,所以name是”tlwy&amp;quot;&lt;/p&gt;
&lt;h2 id=&#34;63-闭包&#34;&gt;6.3 闭包&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614941970240.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
闭包有两个作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个就是可以读取自身函数外部的变量（沿着作用域链寻找）&lt;/li&gt;
&lt;li&gt;第二个就是让这些外部变量始终保存在内存中&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
      function outer(){
         var result = new Array();
         for(var i = 0; i &amp;lt; 2; i++){//注：i是outer()的局部变量
            result[i] = function(){
               return i;
            }
         }
         return result;//返回一个函数对象数组
         //这个时候会初始化result.length个关于内部函数的作用域链
      }
      var fn = outer();
      console.log(fn[0]());//result：2
      console.log(fn[1]());//result：2
   &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;js函数内的变量值不是在编译的时候就确定的，而是等在运行时期再去寻找的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;定义&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一个函数对其周围状态(变量)的&lt;strong&gt;引用&lt;/strong&gt;并&lt;strong&gt;保存&lt;/strong&gt;周围变量，乃至函数执行完成后仍然可以访问的现象称之为闭包。&lt;/p&gt;
&lt;p&gt;闭包让外部访问函数内部的变量成为可能（私有属性），因为被引用的数据常驻内存，可能会造成内存泄露（一块内存长期被变量占据而不进行释放），闭包可以让你在一个内层函数中访问到其外层函数的作用域的状态并保存，在js中每当创建一个函数，闭包环境就在函数创建时产生，闭包环境相互独立，如果闭包环境引用外部函数作用域的一个变量a，即使当外部函数作用域的变量被销毁释放内存，但变量a不会被删除。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; function outer(){
         var result = new Array();
         for(var i = 0; i &amp;lt; 2; i++){
            //定义一个带参函数
            result[i] = function(num){
               function innerarg(){
                  return num;
               }
               return innerarg;
            }(i);//预先执行函数写法
            //把i当成参数传进去
         }
         return result;
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;7-ajax的原生写法&#34;&gt;7. Ajax的原生写法&lt;/h1&gt;
&lt;h2 id=&#34;71-ajax-是什么&#34;&gt;7.1 Ajax 是什么？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;全称Asynchronous JavaScript and XML；&lt;/li&gt;
&lt;li&gt;异步的 JavaScript 和 XML；&lt;/li&gt;
&lt;li&gt;可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页内容；&lt;/li&gt;
&lt;li&gt;能够实现局部刷新，大大降低了资源的浪费；&lt;/li&gt;
&lt;li&gt;不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;72-ajax的使用&#34;&gt;7.2 Ajax的使用&lt;/h2&gt;
&lt;p&gt;Ajax的使用分为四部分：&lt;br&gt;
1.） 创建一个XMLHttpRequest对象；&lt;/p&gt;
&lt;p&gt;2.） 配置请求信息；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求的方式；&lt;/li&gt;
&lt;li&gt;请求文件的路径；&lt;/li&gt;
&lt;li&gt;是否异步，默认为true；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.）发送请求；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;get与post的区别；&lt;/li&gt;
&lt;li&gt;get与post的使用场景；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4.） 监听状态变化，执行相应回调函数；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;http状态码都有哪些？&lt;/li&gt;
&lt;li&gt;不同状态码代表的含义？&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;721-创建xmlhttprequest对象&#34;&gt;7.2.1 创建XMLHttpRequest对象&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;var xhr = new XMLHttpRequest()&lt;/code&gt;;&lt;/p&gt;
&lt;h3 id=&#34;722-连接服务器&#34;&gt;7.2.2 连接服务器&lt;/h3&gt;
&lt;p&gt;使用 XMLHttpRequest 对象的open() 方法：&lt;/p&gt;
&lt;h3 id=&#34;723-向服务器发送请求&#34;&gt;7.2.3 向服务器发送请求&lt;/h3&gt;
&lt;p&gt;使用 XMLHttpRequest 对象的send() 方法：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614951772130.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;724-监听事件变化&#34;&gt;7.2.4 监听事件变化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如果是同步请求的话，不需要写监听事件变化函数；&lt;/li&gt;
&lt;li&gt;一般默认都是异步请求，才写监听函数；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0: 请求未初始化&lt;/li&gt;
&lt;li&gt;1: 服务器连接已建立&lt;/li&gt;
&lt;li&gt;2: 请求已接收&lt;/li&gt;
&lt;li&gt;3: 请求处理中&lt;/li&gt;
&lt;li&gt;4: 请求已完成，且响应已就绪&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;73-ajax原生写法&#34;&gt;7.3 Ajax原生写法&lt;/h2&gt;
&lt;h3 id=&#34;731-get请求&#34;&gt;7.3.1 Get请求&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;const xhr = new XMLHttpRequest()
        xhr.open(&amp;quot;GET&amp;quot;, &amp;quot;http://localhost:3000/users?id=1&amp;quot;)
        xhr.send(null)

        xhr.onreadystatechange = function () {
            if (this.readyState === 4) {
                console.log(this.responseText);
            }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;732-post请求&#34;&gt;7.3.2 Post请求&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;const xhr = new XMLHttpRequest()
        xhr.open(&amp;quot;POST&amp;quot;, &amp;quot;http://localhost:3000/users&amp;quot;)
        xhr.setRequestHeader(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)
        // 转换为json传递
        xhr.send(JSON.stringify({
            &amp;quot;name&amp;quot;: &amp;quot;luke&amp;quot;,
            &amp;quot;age&amp;quot; : 19,
            &amp;quot;class&amp;quot;: 2
        }))

        xhr.onreadystatechange = function () {
            if (this.readyState === 4) {
                console.log(this.responseText);
            }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;8-对象深拷贝-浅拷贝&#34;&gt;8. 对象深拷贝、浅拷贝&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;let a = {
    age: 1
}
let b = a
a.age = 2
console.log(b.age) // 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上述例子中我们可以发现，如果给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。&lt;/p&gt;
&lt;h2 id=&#34;81-浅拷贝&#34;&gt;8.1 浅拷贝&lt;/h2&gt;
&lt;p&gt;首先可以通过 &lt;code&gt;Object.assign&lt;/code&gt; 来解决这个问题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a = {
    age: 1
}
let b = Object.assign({}, a)
a.age = 2
console.log(b.age) // 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然我们也可以通过展开运算符&lt;code&gt;（…）&lt;/code&gt;来解决&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a = {
    age: 1
}
let b = {...a}
a.age = 2
console.log(b.age) // 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就需要使用到深拷贝了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a = {
    age: 1,
    jobs: {
        first: &#39;FE&#39;
    }
}
let b = {...a}
a.jobs.first = &#39;native&#39;
console.log(b.jobs.first) // native
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到刚开始的话题了，两者享有相同的引用。要解决这个问题，我们需要引入深拷贝。&lt;/p&gt;
&lt;h2 id=&#34;82-深拷贝&#34;&gt;8.2 深拷贝&lt;/h2&gt;
&lt;p&gt;这个问题通常可以通过 &lt;code&gt;JSON.parse(JSON.stringify(object))&lt;/code&gt; 来解决。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a = {
    age: 1,
    jobs: {
        first: &#39;FE&#39;
    }
}
let b = JSON.parse(JSON.stringify(a))
a.jobs.first = &#39;native&#39;
console.log(b.jobs.first) // FE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是该方法也是有局限性的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会忽略 undefined&lt;/li&gt;
&lt;li&gt;会忽略 symbol&lt;/li&gt;
&lt;li&gt;不能序列化函数&lt;/li&gt;
&lt;li&gt;不能解决循环引用的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;9-图片懒加载-预加载&#34;&gt;9. 图片懒加载、预加载&lt;/h1&gt;
&lt;h2 id=&#34;91-懒加载&#34;&gt;9.1 懒加载&lt;/h2&gt;
&lt;h3 id=&#34;911-什么是懒加载&#34;&gt;9.1.1 什么是懒加载&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;懒加载又称延迟加载&lt;/strong&gt;。当访问一个页面的时候，需要先把img元素或者其他元素的背景图先用一张默认的图片代替（占位图），这样浏览器渲染页面的时候就只需请求一次。当图片出现在浏览器可视区域的时候，才设置图片的真实路径，把图片显示出来。&lt;/p&gt;
&lt;h3 id=&#34;912-为什么要使用图片懒加载&#34;&gt;9.1.2 为什么要使用图片懒加载？&lt;/h3&gt;
&lt;p&gt;当页面中图片的数量多到一定数量的时候，并且图片大小比较大，比如各种商场网站，图片素材网等等。如果在页面一加载的时候就加载全部图片，显然会影响网站加载速度和加大服务器负担，而且用户体验也必然不好，那么这时候可以采用懒加载。&lt;/p&gt;
&lt;h3 id=&#34;913-懒加载具体实现原理&#34;&gt;9.1.3 懒加载具体实现原理&lt;/h3&gt;
&lt;p&gt;页面中的img元素之所以会发送http请求的原因是设置了src属性，否则浏览器就不会发送请求去下载这个图片。&lt;br&gt;
首先在页面中把所有的图片用一张占位图进行占位，并且在元素下设置data-src自定义属性，存放图片的真实路径，当需要用到的时候取出该真实路径动态添加给src。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;懒加载具体实现方式&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离便开始加载，这样能保证用户拉下时正好能看到图片。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;92-预加载&#34;&gt;9.2 预加载&lt;/h2&gt;
&lt;h3 id=&#34;921-什么是预加载&#34;&gt;9.2.1 什么是预加载&lt;/h3&gt;
&lt;p&gt;预加载就是提前加载图片，当用户需要查看时可直接从本地缓存中渲染。&lt;/p&gt;
&lt;h3 id=&#34;922-为什么要使用图片预加载&#34;&gt;9.2.2 为什么要使用图片预加载？&lt;/h3&gt;
&lt;p&gt;当页面中图片比较大的时候，页面加载的时候会出现该区域空白的效果或者看到图片正在慢慢地加载出来，为了提高用户体验，需要把这些图片提前加载到缓存中，当用户一打开页面的时候，这些图片就会快速的呈现出来，获得更好的用户体验效果。&lt;/p&gt;
&lt;h3 id=&#34;923-实现方式有哪些&#34;&gt;9.2.3 实现方式有哪些？&lt;/h3&gt;
&lt;p&gt;方法1：使用css和JavaScript实现预加载&lt;br&gt;
方法2：只使用JavaScript实现预加载&lt;br&gt;
方法3：使用ajax实现预加载&lt;/p&gt;
&lt;p&gt;常用的是&lt;code&gt;new Image()&lt;/code&gt;;设置其src来实现预载，再使用onload方法回调预载完成事件。只要浏览器把图片下载到本地，同样的src就会使用缓存，这是最基本也是最实用的预载方法。当Image下载完图片头后，会得到宽和高，因此可以在预载前得到图片的大小(方法是用记时器轮循宽高变化。)&lt;/p&gt;
&lt;h1 id=&#34;10-实现页面加载进度条&#34;&gt;10. 实现页面加载进度条&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615011309891.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;101-html结构&#34;&gt;10.1 html结构：&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;div id=&amp;quot;progressBox&amp;quot;&amp;gt;
        &amp;lt;div id=&amp;quot;progressBar&amp;quot;&amp;gt;0%&amp;lt;/div&amp;gt;
        &amp;lt;!-- 设定第二个层以便当进度超过文字的时候，修改文字的颜色 --&amp;gt;
        &amp;lt;div id=&amp;quot;progressText&amp;quot;&amp;gt;0%&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;102-css结构&#34;&gt;10.2 CSS结构：&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
        #progressBox {
            width: 300px;
            height: 40px;
            border: 1px solid #C8C8C8;
            background: white;
            position: relative;
            margin: 0 auto;
            margin-top: 100px;
        }
 
        #progressBar {
            position: absolute;
            left: 0;
            top: 0;
            z-index: 2;
            height: 40px;
            width: 100%;
            line-height: 40px;
            color: white;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            font-family: Georgia;
            clip: rect(0px, 0, 40px, 0px);
            background: #00A1F5;
        }
 
        #progressText {
            position: absolute;
            left: 0;
            top: 0;
            z-index: 1;
            width: 100%;
            height: 40px;
            line-height: 40px;
            color: black;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            font-family: Georgia;
        }
    &amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;103-javascript-部分&#34;&gt;10.3 JavaScript 部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
        window.onload = function () {
            // 设定当前起始状态值,
            // 真实情况中用html5的onprogress和onload来完成
            // 还可以跟后台配合，通过ajax实时的返回数据
            var iNow = 0;
            // 设定定时器
            var timer = setInterval(function () {
                // 如果当前的值为100
                if (iNow == 100) {
                    // 清除定时器
                    clearInterval(timer);
                }else {
                    // 将当前状态值累加1
                    iNow += 1;
                    // 调用执行状态的函数,传入状态值
                    progressFn(iNow);
                }
 
            }, 30);
 
 
            function progressFn(cent) {
                // 获取最外层的div
                var oDiv1 = document.getElementById(&#39;progressBox&#39;);
                // 获取内层进度条的div
                var oDiv2 = document.getElementById(&#39;progressBar&#39;);
                // 获取内层文字发生变化时的div
                var oDiv3 = document.getElementById(&#39;progressText&#39;);
 
                // 获取总进度条的宽度
                var allWidth = parseInt(getStyle(oDiv1, &#39;width&#39;));
 
                // 设定内层两个div的文字内容一样
                oDiv2.innerHTML = cent + &#39;%&#39;;
                oDiv3.innerHTML = cent + &#39;%&#39;;
 
                // 修改clip的的宽度值
                oDiv2.style.clip = &#39;rect(0px, &#39; + cent / 100 * allWidth + &#39;px, 40px, 0px)&#39;;
 
                // 获取当前元素的属性值
                function getStyle(obj, attr) {
                    // 兼容IE
                    if (obj.currentStyle) {
                        return obj.currentStyle[attr];
                    }else {
                        // 第二个参数为false是通用的写法，目的是为了兼容老版本
                        return getComputedStyle(obj, false)[attr];
                    }
                }
            }
        };
    &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;11-this关键字&#34;&gt;11. this关键字&lt;/h1&gt;
&lt;p&gt;首先我们需要得出一个非常重要一定要牢记于心的结论，&lt;code&gt;this的指向，是在函数被调用的时候确定的&lt;/code&gt;。也就是执行上下文被创建时确定的。因此，一个函数中的this指向，可以是非常灵活的。比如下面的例子中，同一个函数由于调用方式的不同，this指向了不一样的对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = 10;
var obj = {
    a: 20
}
function fn () {
    console.log(this.a);
}
fn(); // 10
fn.call(obj); // 20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除此之外，&lt;code&gt;在函数执行过程中，this一旦被确定，就不可更改了。&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;111-全局对象中的this&#34;&gt;11.1 全局对象中的this&lt;/h2&gt;
&lt;p&gt;关于全局对象的this，我之前在总结变量对象的时候提到过，它是一个比较特殊的存在。全局环境中的this，指向它本身。&lt;/p&gt;
&lt;h2 id=&#34;112-函数中的this&#34;&gt;11.2 函数中的this&lt;/h2&gt;
&lt;p&gt;在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。&lt;strong&gt;如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined&lt;/strong&gt;。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = 20;
var foo = {
    a: 10,
    getA: function () {
        return this.a;
    }
}
console.log(foo.getA()); // 10

var test = foo.getA;
console.log(test());  // 20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;foo.getA()&lt;/code&gt;中，getA是调用者，他不是独立调用，被对象foo所拥有，因此它的this指向了foo。而&lt;code&gt;test()&lt;/code&gt;作为调用者，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined，在非严格模式，自动转向全局window。&lt;/p&gt;
&lt;h2 id=&#34;113-使用callapply显示指定this&#34;&gt;11.3 使用call，apply显示指定this&lt;/h2&gt;
&lt;p&gt;JavaScript内部提供了一种机制，让我们可以自行手动设置this的指向。它们就是call与apply。所有的函数都具有着两个方法。它们除了参数略有不同，其功能完全一样。它们的第一个参数都为this将要指向的对象。&lt;/p&gt;
&lt;p&gt;而call与applay后面的参数，都是向将要执行的函数传递参数。其中call以一个一个的形式传递，apply以数组的形式传递。这是他们唯一的不同。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function fn(num1, num2) {
    console.log(this.a + num1 + num2);
}
var obj = {
    a: 20
}

fn.call(obj, 100, 10); // 130
fn.apply(obj, [20, 10]); // 50
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;114-构造函数与原型方法上的this&#34;&gt;11.4 构造函数与原型方法上的this&lt;/h2&gt;
&lt;p&gt;通过new操作符调用构造函数，会经历以下4个阶段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个新的对象；&lt;/li&gt;
&lt;li&gt;将构造函数的this指向这个新对象；&lt;/li&gt;
&lt;li&gt;指向构造函数的代码，为这个对象添加属性，方法等；&lt;/li&gt;
&lt;li&gt;返回新对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;function Person(name, age) {

    // 这里的this指向了谁?
    this.name = name;
    this.age = age;   
}

Person.prototype.getName = function() {

    // 这里的this又指向了谁？
    return this.name;
}

// 上面的2个this，是同一个吗，他们是否指向了原型对象？

var p1 = new Person(&#39;Nick&#39;, 20);
p1.getName();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因此，当new操作符调用构造函数时，this其实指向的是这个新创建的对象，最后又将新的对象返回出来，被实例对象p1接收。因此，我们可以说，这个时候，构造函数的this，指向了新的实例对象，p1。&lt;/p&gt;
&lt;h1 id=&#34;12-函数式编程&#34;&gt;12. 函数式编程&lt;/h1&gt;
&lt;p&gt;函数式编程是一种编程范式，是一种构建计算机程序结构和元素的风格，它把计算看作是对数学函数的评估，&lt;strong&gt;避免了状态的变化和数据的可变&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;纯函数&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果给定相同的参数，则返回相同的结果(也称为确定性)。&lt;/li&gt;
&lt;li&gt;它不会引起任何副作用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;函数是一等公民&lt;/li&gt;
&lt;li&gt;只用表达式不用语句&lt;/li&gt;
&lt;li&gt;没有副作用(side effect)&lt;/li&gt;
&lt;li&gt;不修改状态&lt;/li&gt;
&lt;li&gt;引用透明&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;优势&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代码简洁，开发快速&lt;/li&gt;
&lt;li&gt;接近自然语言，易于理解&lt;/li&gt;
&lt;li&gt;更方便的代码管理&lt;/li&gt;
&lt;li&gt;易于&amp;quot;并发编程&amp;quot;&lt;/li&gt;
&lt;li&gt;代码的热升级&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;13-手动实现parseint&#34;&gt;13. 手动实现parseInt&lt;/h1&gt;
&lt;p&gt;主要用到的ES5中的&lt;code&gt;map&lt;/code&gt;函数和&lt;code&gt;reduce&lt;/code&gt;函数，还有利用了javascript是弱类型转换的特点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function str2num(str) {
  var strArr = str.split(&#39;&#39;)
  var strArrNum = strArr.map(function (str) {
    return +str
  })
  var num = strArrNum.reduce(function (x, y) {
    return x * 10 + y
  })
  return num
}
str2num(&#39;123&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;14-为什么会有同源策略&#34;&gt;14. 为什么会有同源策略&lt;/h1&gt;
&lt;h2 id=&#34;141-什么是同源策略&#34;&gt;14.1 什么是同源策略&lt;/h2&gt;
&lt;p&gt;两个页面地址中的协议，域名，端口号一致，则表示同源&lt;/p&gt;
&lt;h2 id=&#34;142-为什么浏览器要使用同源策略&#34;&gt;14.2 为什么浏览器要使用同源策略&lt;/h2&gt;
&lt;p&gt;设置同源策略的主要目的是为了安全，如果没有同源限制，在浏览器中的cookie等其他数据可以任意读取，不同域下的DOM任意操作，ajax任意请求其他网站的数据，包括隐私数据。&lt;/p&gt;
&lt;h1 id=&#34;15-怎么判断两个对象是否相等&#34;&gt;15. 怎么判断两个对象是否相等&lt;/h1&gt;
&lt;p&gt;方法一：通过&lt;code&gt;JSON.stringify(obj)&lt;/code&gt;来判断两个对象转后的字符串是否相等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：用法简单，对于顺序相同的两个对象可以快速进行比较得到结果&lt;/li&gt;
&lt;li&gt;缺点：这种方法有限制就是当两个对比的对象中key的顺序不是完全相同时会比较出错&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方法二：&lt;code&gt;getOwnPropertyNames&lt;/code&gt;该方法可以将Object对象的第一层key获取到并返回一个由第一层key组成的数组。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：相对方法一进行了优化，可以应对不同顺序的Object进行比较，不用担心顺序不同而对比出错&lt;/li&gt;
&lt;li&gt;缺点：从方法中可以看到只能获取到第一层的key组成的数组，当对象是复合对象时无法进行多层对象的比较&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// 对Object扩展一个方法chargeObjectEqual
Object.prototype.chargeObjectEqual = function(obj){
    // 当前Object对象
    var propsCurr = Object.getOwnPropertyNames(this);
    // 要比较的另外一个Object对象
    var propsCompare = Object.getOwnPropertyNames(obj);
    if (propsCurr.length != propsCompare.length) {
        return false;
    }
    for (var i = 0,max = propsCurr.length; i &amp;lt; max; i++) {
        var propName = propsCurr[i];
        if (this[propName] !== obj[propName]) {
            return false;
        }
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;16-事件模型&#34;&gt;16. 事件模型&lt;/h1&gt;
&lt;h2 id=&#34;161-事件委托-代理&#34;&gt;16.1 事件委托、代理&lt;/h2&gt;
&lt;h3 id=&#34;1基本概念&#34;&gt;1.基本概念&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;事件代理&lt;/strong&gt;（Event Delegation），又称之为事件委托。是JavaScript中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定在子元素的响应事件（click、keydown......）委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。&lt;/p&gt;
&lt;h3 id=&#34;2-事件冒泡&#34;&gt;2. 事件冒泡&lt;/h3&gt;
&lt;p&gt;一个事件触发后，会在子元素和父元素之间&lt;strong&gt;传播&lt;/strong&gt;（propagation）。这种传播分成三个阶段&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615169023216.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如上图所示，事件传播分成三个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;捕获阶段：从window对象传导到目标节点（上层传到底层）称为“捕获阶段”（capture phase），捕获阶段不会响应任何事件；&lt;/li&gt;
&lt;li&gt;目标阶段：在目标节点上触发，称为“目标阶段”&lt;/li&gt;
&lt;li&gt;冒泡阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。&lt;strong&gt;事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-事件委托的优点&#34;&gt;3. 事件委托的优点&lt;/h3&gt;
&lt;p&gt;【1】&lt;strong&gt;可以大量节省内存占用，减少事件注册，比如在ul上代理所有li的click事件就非常棒&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ul id=&amp;quot;list&amp;quot;&amp;gt;
  &amp;lt;li&amp;gt;item 1&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;item 2&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;item 3&amp;lt;/li&amp;gt;
  ......
  &amp;lt;li&amp;gt;item n&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如上面代码所示，如果给每个li列表项都绑定一个函数，那对内存的消耗是非常大的，因此较好的解决办法就是将li元素的点击事件绑定到它的父元素ul身上，执行事件的时候再去匹配判断目标元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【2】可以实现当新增子对象时无需再次对其绑定（动态绑定事件）&lt;/strong&gt;&lt;br&gt;
假设上述的例子中列表项li就几个，我们给每个列表项都绑定了事件；&lt;/p&gt;
&lt;p&gt;在很多时候，我们需要通过 AJAX 或者用户操作动态的增加或者删除列表项li元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；&lt;/p&gt;
&lt;p&gt;如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的；所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的。&lt;/p&gt;
&lt;h3 id=&#34;3-基本实现&#34;&gt;3. 基本实现&lt;/h3&gt;
&lt;p&gt;【1】JavaScript原生实现事件委托&lt;/p&gt;
&lt;p&gt;比如我们有这样的一个 HTML 片段：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ul id=&amp;quot;myLinks&amp;quot;&amp;gt;
  &amp;lt;li id=&amp;quot;goSomewhere&amp;quot;&amp;gt;Go somewhere&amp;lt;/li&amp;gt;
  &amp;lt;li id=&amp;quot;doSomething&amp;quot;&amp;gt;Do something&amp;lt;/li&amp;gt;
  &amp;lt;li id=&amp;quot;sayHi&amp;quot;&amp;gt;Say hi&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用事件委托，只需在 DOM 树中尽量最高的层次上添加一个事件处理程序，如下面的例子所示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    var item1 = document.getElementById(&amp;quot;goSomewhere&amp;quot;);
    var item2 = document.getElementById(&amp;quot;doSomething&amp;quot;);
    var item3 = document.getElementById(&amp;quot;sayHi&amp;quot;);
 
    document.addEventListener(&amp;quot;click&amp;quot;, function (event) {
      var target = event.target;
      switch (target.id) {
        case &amp;quot;doSomething&amp;quot;:
          document.title = &amp;quot;事件委托&amp;quot;;
          break;
        case &amp;quot;goSomewhere&amp;quot;:
          location.href = &amp;quot;http://www.baidu.com&amp;quot;;
          break;
        case &amp;quot;sayHi&amp;quot;: alert(&amp;quot;hi&amp;quot;);
          break;
      }
    })
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【2】jQuery事件delegate()实现事件委托&lt;/p&gt;
&lt;p&gt;delegate() 方法为指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;格式：$(selector).delegate(childSelector, event, data, function)&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;childSelector&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必需，规定要附加事件处理程序的一个或多个子元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;event&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必需，规定附加到元素的一个或多个事件。由空格分隔多个事件值。必须是有效的事件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;data&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选，规定传递到函数的额外数据。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;function&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;必需，规定当事件发生时运行的函数。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
  &amp;lt;ul id=&amp;quot;myLinks&amp;quot;&amp;gt;
    &amp;lt;li id=&amp;quot;goSomewhere&amp;quot;&amp;gt;Go somewhere&amp;lt;/li&amp;gt;
    &amp;lt;li id=&amp;quot;doSomething&amp;quot;&amp;gt;Do something&amp;lt;/li&amp;gt;
    &amp;lt;li id=&amp;quot;sayHi&amp;quot;&amp;gt;Say hi&amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
 
  &amp;lt;script&amp;gt;
    $(document).ready(function () {
      $(&amp;quot;#myLinks&amp;quot;).delegate(&amp;quot;#goSomewhere&amp;quot;, &amp;quot;click&amp;quot;, function () {
        location.href = &amp;quot;http://www.baidu.com&amp;quot;;
      });
    });
  &amp;lt;/script&amp;gt;
 
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-使用事件委托注意事项&#34;&gt;4. 使用事件委托注意事项&lt;/h3&gt;
&lt;p&gt;使用“事件委托”时，并不是说把事件委托给的元素越靠近顶层就越好。事件冒泡的过程也需要耗时，越靠近顶层，事件的”事件传播链”越长，也就越耗时。如果DOM嵌套结构很深，事件冒泡通过大量祖先元素会导致性能损失。&lt;/p&gt;
&lt;h2 id=&#34;162-如何让事件先冒泡后捕获&#34;&gt;16.2 如何让事件先冒泡后捕获&lt;/h2&gt;
&lt;p&gt;若要实现先冒泡后捕获，给一个元素绑定两个addEventListener，其中一个第三个参数设置为false（即冒泡），另一个第三个参数设置为true（即捕获），调整它们的代码顺序，将设置为false的监听事件放在设置为true的监听事件前面即可。&lt;/p&gt;
&lt;h1 id=&#34;16补-js遍历dom树&#34;&gt;16补. js遍历dom树&lt;/h1&gt;
&lt;h2 id=&#34;1-遍历dom树&#34;&gt;1. 遍历dom树&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
  &amp;lt;title&amp;gt;遍历DOM树&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;遍历 DOM 树&amp;lt;/h1&amp;gt;
&amp;lt;p style=&amp;quot;color: green;&amp;quot;&amp;gt;Tip: 可以在遍历的回调函数中任意定制需求&amp;lt;/p&amp;gt;
&amp;lt;div&amp;gt;
  &amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;123&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;456&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;789&amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;div&amp;gt;
      &amp;lt;span&amp;gt;haha&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;demo_node&amp;quot;&amp;gt;
  &amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;123&amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
  &amp;lt;p&amp;gt;hello&amp;lt;/p&amp;gt;
  &amp;lt;h2&amp;gt;world&amp;lt;/h2&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;dsa&amp;lt;/p&amp;gt;
    &amp;lt;h3&amp;gt;
      &amp;lt;span&amp;gt;dsads&amp;lt;/span&amp;gt;
    &amp;lt;/h3&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;

  //获取页面中的根节点--根标签
  var root=document.documentElement;//html
  //函数遍历DOM树
  //根据根节点,调用fn的函数,显示的是根节点的名字
  function forDOM(root1) {
    //调用f1,显示的是节点的名字
   // f1(root1);
    //获取根节点中所有的子节点
    var children=root1.children;
    //调用遍历所有子节点的函数
    forChildren(children);
  }
  //给我所有的子节点,我把这个子节点中的所有的子节点显示出来
  function forChildren(children) {
    //遍历所有的子节点
    for(var i=0;i&amp;lt;children.length;i++){
      //每个子节点
      var child=children[i];
      //显示每个子节点的名字
      f1(child);
      //判断child下面有没有子节点,如果还有子节点,那么就继续的遍历
      child.children&amp;amp;&amp;amp;forDOM(child);
    }
  }
  //函数调用,传入根节点
  forDOM(root);
  function f1(node) {
    console.log(&amp;quot;节点的名字:&amp;quot;+node.nodeName);
  }
  //节点:nodeName,nodeType,nodeValue

&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-多叉-dom-树的遍历&#34;&gt;2. 多叉 DOM 树的遍历&lt;/h2&gt;
&lt;h3 id=&#34;1-广度优先遍历&#34;&gt;1. 广度优先遍历&lt;/h3&gt;
&lt;p&gt;首先遍历根节点，然后访问第一层节点，第二层节点，....,直到访问到最后一层。&lt;br&gt;
借助于队列，用非递归的方式对多叉树进行遍历&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Tree.prototype.BFSearch =  function(node,callback){  
    var queue=[];  
    while(node!=null){          
           callback(node);  
       if(node.children.length!=0){  
        for (var i=0;i&amp;lt;node.children.length;i++){  
            queue.push(node.children[i]);//借助于队列,暂存当前节点的所有子节点  
        }   
        }  
            node=queue.shift();//先入先出，借助于数据结构：队列  
    }         
};  
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-深度优先遍历&#34;&gt;2. 深度优先遍历&lt;/h3&gt;
&lt;p&gt;首先遍历根节点，然后沿着一条路径遍历到最深的一层，最后在逐层返回。&lt;br&gt;
借助于栈,实现多叉 DOM树 的深度优先遍历。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Tree.prototype.DFSearch =  function(node,callback){  
        var stack=[];         
        while(node!=null){  
        callback(node);  
        if(node.children.length!=0){  
        for (var i=node.children.length-1;i&amp;gt;=0;i--){//按照相反的子节点顺序压入栈  
            stack.push(node.children[i]);//将该节点的所有子节点压入栈  
        }  
        }  
            node = stack.pop();//弹出栈的子节点顺序就是原来的正确顺序(因为栈是先入后出的)        
    }     
};  
&lt;/code&gt;&lt;/pre&gt;
">【面】前端知识点梳理（JS上）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/mian-23-tiao-qian-duan-xing-neng-you-hua/"" data-c="
          &lt;h1 id=&#34;1-减少http请求次数&#34;&gt;1. 减少HTTP请求次数&lt;/h1&gt;
&lt;p&gt;尽量合并图片、CSS、JS。比如加载一个页面，如果有5个css文件的话，那么会发出5次http请求，这样会让用户第一次访问你的页面的时候会长时间等待。而如果把这个5个文件合成一个的话，就只需要发出一次http请求，节省网络请求时间，加快页面的加载。&lt;/p&gt;
&lt;h1 id=&#34;2-使用cdn&#34;&gt;2. 使用CDN&lt;/h1&gt;
&lt;p&gt;网站上静态资源即css、js全都使用cdn分发，图片亦然。&lt;/p&gt;
&lt;h1 id=&#34;3-避免空的src和href&#34;&gt;3. 避免空的src和href&lt;/h1&gt;
&lt;p&gt;当link标签的href属性为空、script标签的src属性为空的时候，浏览器渲染的时候会把当前页面的URL作为它们的属性值，从而把页面的内容加载进来作为它们的值。所以要避免犯这样的疏忽。&lt;/p&gt;
&lt;h1 id=&#34;4-为文件头指定expires&#34;&gt;4. 为文件头指定Expires&lt;/h1&gt;
&lt;p&gt;Expires是用来设置文件的过期时间的，一般对css、js、图片资源有效。 他可以使内容具有缓存性，这样下回再访问同样的资源时就通过浏览器缓存区读取，不需要再发出http请求。如下例子：&lt;/p&gt;
&lt;p&gt;新浪微博的这个css文件的Expires时间是2016-5-04 09:14:14.&lt;/p&gt;
&lt;h1 id=&#34;5-使用gzip压缩内容&#34;&gt;5. 使用gzip压缩内容&lt;/h1&gt;
&lt;p&gt;gzip能够压缩任何一个文本类型的响应，包括html，xml，json。大大缩小请求返回的数据量。&lt;/p&gt;
&lt;h1 id=&#34;6-把css放到顶部&#34;&gt;6. 把CSS放到顶部&lt;/h1&gt;
&lt;p&gt;网页上的资源加载时从上网下顺序加载的，所以css放在页面的顶部能够优先渲染页面，让用户感觉页面加载很快。&lt;/p&gt;
&lt;h1 id=&#34;7-把js放到底部&#34;&gt;7. 把JS放到底部&lt;/h1&gt;
&lt;p&gt;加载js时会对后续的资源造成阻塞，必须得等js加载完才去加载后续的文件 ，所以就把js放在页面底部最后加载。&lt;/p&gt;
&lt;h1 id=&#34;8-避免使用css表达式&#34;&gt;8. 避免使用CSS表达式&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;font-color: expression( (new Date()).getHours()%3 ? “#FFFFFF&amp;quot; : “#AAAAAA&amp;quot; );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个表达式会持续的在页面上计算样式，影响页面的性能。并且css表达式只被IE支持。&lt;/p&gt;
&lt;h1 id=&#34;9-将css和js放到外部文件中&#34;&gt;9. 将CSS和JS放到外部文件中&lt;/h1&gt;
&lt;p&gt;目的是缓存文件，可以参考原则4。 但有时候为了减少请求，也会直接写到页面里，需根据PV和IP的比例权衡。&lt;/p&gt;
&lt;h1 id=&#34;10-权衡dns查找次数&#34;&gt;10. 权衡DNS查找次数&lt;/h1&gt;
&lt;p&gt;减少主机名可以节省响应时间。但同时，需要注意，减少主机会减少页面中并行下载的数量。&lt;/p&gt;
&lt;p&gt;IE浏览器在同一时刻只能从同一域名下载两个文件。当在一个页面显示多张图片时，IE 用户的图片下载速度就会受到影响。所以新浪会搞N个二级域名来放图片。&lt;/p&gt;
&lt;p&gt;下面是新浪微博的图片域名，我们可以看到他有多个域名，这样可以保证这些不同域名能够同时去下载图片，而不用排队。不过如果当使用的域名过多时，响应时间就会慢，因为不用响应域名时间不一致。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614914780547.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;11-精简css和js&#34;&gt;11.  精简CSS和JS&lt;/h1&gt;
&lt;p&gt;这里就涉及到css和js的压缩了。比如下面的新浪的一个css文件，把空格回车全部去掉，减少文件的大小。现在的压缩工具有很多，基本主流的前端构建工具都能进行css和js文件的压缩，如grunt，glup等。&lt;/p&gt;
&lt;h1 id=&#34;12-避免跳转&#34;&gt;12. 避免跳转&lt;/h1&gt;
&lt;p&gt;有种现象会比较坑爹，看起来没什么差别，其实多次了一次页面跳转。比如当URL本该有斜杠（/）却被忽略掉时。例如，当我们要访问 http://baidu.com 时，实际上返回的是一个包含301代码的跳转，它指向的是 http://baidu.com/（注意末尾的斜杠）。在&lt;code&gt;nginx服务器&lt;/code&gt;可以使用rewrite；&lt;code&gt;Apache服务器&lt;/code&gt;中可以使用Alias 或者 mod_rewrite或者the DirectorySlash来避免。&lt;/p&gt;
&lt;p&gt;另一种是不用域名之间的跳转， 比如访问 http://baidu.com/bbs 跳转到http://bbs.baidu.com/。那么可以通过使用Alias或者mod_rewirte建立CNAME（保存一个域名和另外一个域名之间关系的DNS记录）来替代。&lt;/p&gt;
&lt;h1 id=&#34;13-删除重复的js和css&#34;&gt;13. 删除重复的JS和CSS&lt;/h1&gt;
&lt;p&gt;重复调用脚本，除了增加额外的HTTP请求外，多次运算也会浪费时间。在IE和Firefox中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。&lt;/p&gt;
&lt;h1 id=&#34;14-配置etags&#34;&gt;14. 配置ETags&lt;/h1&gt;
&lt;p&gt;它用来判断浏览器缓存里的元素是否和原来服务器上的一致。比last-modified date更具有弹性，例如某个文件在1秒内修改了10次，Etag可以综合Inode(文件的索引节点(inode)数)，MTime(修改时间)和Size来精准的进行判断，避开UNIX记录MTime只能精确到秒的问题。 服务器集群使用，可取后两个参数。使用ETags减少Web应用带宽和负载&lt;/p&gt;
&lt;h1 id=&#34;15-可缓存的ajax&#34;&gt;15. 可缓存的AJAX&lt;/h1&gt;
&lt;p&gt;异步请求同样的造成用户等待，所以使用ajax请求时，要主动告诉浏览器如果该请求有缓存就去请求缓存内容。如下代码片段, cache:true就是显式的要求如果当前请求有缓存的话，直接使用缓存&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614914923304.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;16-使用get来完成ajax请求&#34;&gt;16. 使用GET来完成AJAX请求&lt;/h1&gt;
&lt;p&gt;当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数据。因此使用GET获取数据时更加有意义。&lt;/p&gt;
&lt;h1 id=&#34;17-减少dom元素数量&#34;&gt;17. 减少DOM元素数量&lt;/h1&gt;
&lt;p&gt;这是一门大学问，这里可以引申出一堆优化的细节。想要具体研究的可以看后面推荐书籍。总之大原则减少DOM数量，就会减少浏览器的解析负担。&lt;/p&gt;
&lt;h1 id=&#34;18-避免404&#34;&gt;18. 避免404&lt;/h1&gt;
&lt;p&gt;比如外链的css、js文件出现问题返回404时，会破坏浏览器的并行加载。&lt;/p&gt;
&lt;h1 id=&#34;19-减少cookie的大小&#34;&gt;19. 减少Cookie的大小&lt;/h1&gt;
&lt;p&gt;Cookie里面别塞那么多东西，因为每个请求都得带着他跑。&lt;/p&gt;
&lt;h1 id=&#34;20-使用无cookie的域&#34;&gt;20. 使用无cookie的域&lt;/h1&gt;
&lt;p&gt;比如CSS、js、图片等，客户端请求静态文件的时候，减少了 Cookie 的反复传输对主域名的影响。&lt;/p&gt;
&lt;h1 id=&#34;21-不要使用滤镜&#34;&gt;21. 不要使用滤镜&lt;/h1&gt;
&lt;p&gt;IE独有属性AlphaImageLoader用于修正7.0以下版本中显示PNG图片的半透明效果。这个滤镜的问题在于浏览器加载图片时它会终止内容的呈现并且冻结浏览器。在每一个元素（不仅仅是图片）它都会运算一次，增加了内存开支，因此它的问题是多方面的。&lt;/p&gt;
&lt;p&gt;完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。&lt;/p&gt;
&lt;h1 id=&#34;22-不要在html中缩放图片&#34;&gt;22. 不要在HTML中缩放图片&lt;/h1&gt;
&lt;p&gt;比如你需要的图片尺寸是50* 50&lt;/p&gt;
&lt;p&gt;那就不用用一张500*500的大尺寸图片，影响加载&lt;/p&gt;
&lt;h1 id=&#34;23-缩小faviconico并缓存&#34;&gt;23. 缩小favicon.ico并缓存&lt;/h1&gt;
">【面】23条前端性能优化</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/mian-qian-duan-zhi-shi-dian-shu-li-html/"" data-c="
          &lt;h1 id=&#34;1-语义化&#34;&gt;1. 语义化&lt;/h1&gt;
&lt;h2 id=&#34;11-语义化作用&#34;&gt;1.1 语义化作用&lt;/h2&gt;
&lt;p&gt;见标签知其意，让代码结构清晰，方便阅读，有利于其他设备解析。&lt;/p&gt;
&lt;p&gt;循W3规范以语义化标签渲染网页更利于搜索引擎的优化（SEO），网络不佳时（无样式），网页也更具可读性。&lt;/p&gt;
&lt;h2 id=&#34;12-常见语义化标签&#34;&gt;1.2 常见语义化标签&lt;/h2&gt;
&lt;p&gt;&amp;lt;title&amp;gt;：页面主体内容。&lt;/p&gt;
&lt;p&gt;&amp;lt;hn&amp;gt;：h1~h6，分级标题，&amp;lt;h1&amp;gt; 与 &amp;lt;title&amp;gt; 协调有利于搜索引擎优化。&lt;/p&gt;
&lt;p&gt;&amp;lt;ul&amp;gt;：无序列表。&lt;/p&gt;
&lt;p&gt;&amp;lt;ol&amp;gt;：有序列表。&lt;/p&gt;
&lt;p&gt;&amp;lt;header&amp;gt;：页眉通常包括网站标志、主导航、全站链接以及搜索框。&lt;/p&gt;
&lt;p&gt;&amp;lt;nav&amp;gt;：标记导航，仅对文档中重要的链接群使用。&lt;/p&gt;
&lt;p&gt;&amp;lt;main&amp;gt;：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。&lt;/p&gt;
&lt;p&gt;&amp;lt;article&amp;gt;：定义外部的内容，其中的内容独立于文档的其余部分。&lt;/p&gt;
&lt;p&gt;&amp;lt;section&amp;gt;：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。&lt;/p&gt;
&lt;h2 id=&#34;13-html对seo的优化&#34;&gt;1.3 html对SEO的优化&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;meta标签，这个是重中之重&lt;/li&gt;
&lt;li&gt;img标签，img标签增加alt属性&lt;/li&gt;
&lt;li&gt;页面结构清晰，使用语义化标签比如header、footer、content、section，js、css使用外部文件&lt;/li&gt;
&lt;li&gt;增加外部链接&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;2-html新特性新标签&#34;&gt;2. Html新特性新标签&lt;/h1&gt;
&lt;h2 id=&#34;21-新特性&#34;&gt;2.1 新特性&lt;/h2&gt;
&lt;p&gt;1）语义化&lt;br&gt;
2）本地存储&lt;br&gt;
3）设备兼容&lt;br&gt;
4）连接特性，能够帮助我们将数据推送到客户端&lt;br&gt;
5）网页多媒体特性&lt;br&gt;
6）三维、图形及特效特性&lt;br&gt;
7）性能与集成特性&lt;br&gt;
8）css3特性&lt;/p&gt;
&lt;h2 id=&#34;22-新标签&#34;&gt;2.2 新标签&lt;/h2&gt;
&lt;p&gt;1）结构标签&lt;br&gt;
&amp;lt;head&amp;gt;定义页面或者区域头部&lt;br&gt;
&amp;lt;main&amp;gt;规定文档主要内容&lt;br&gt;
&amp;lt;footer&amp;gt;定义页面或者区域底部&lt;br&gt;
&amp;lt;article&amp;gt;定义一篇文章&lt;br&gt;
&amp;lt;nav&amp;gt;定义导航链接&lt;br&gt;
&amp;lt;scetion&amp;gt;定义一个区域&lt;br&gt;
&amp;lt;aside&amp;gt;定义页面内容部分侧边栏&lt;br&gt;
&amp;lt;hgroup&amp;gt;用于对网页或者区域段的标题组合&lt;br&gt;
&amp;lt;figure&amp;gt;定义一组媒体内容以及标题&lt;br&gt;
&amp;lt;figcaption&amp;gt;定义figure元素标题&lt;br&gt;
&amp;lt;address&amp;gt;定义文章拥有者的联系信息&lt;br&gt;
2）行标记&lt;br&gt;
&amp;lt;time&amp;gt;定义时间、日期&lt;br&gt;
&amp;lt;mark&amp;gt;高亮显示文字&lt;br&gt;
3）多媒体交互标签&lt;br&gt;
&amp;lt;video&amp;gt;定义一个视频&lt;br&gt;
&amp;lt;audio&amp;gt;定义一个音频&lt;br&gt;
&amp;lt;source&amp;gt;定义媒体资源标签&lt;br&gt;
&amp;lt;canvas&amp;gt;定义图形&lt;br&gt;
&amp;lt;embed&amp;gt;定义可交互的内容或者插件&lt;br&gt;
4）web应用标签&lt;br&gt;
&amp;lt;progress&amp;gt;状态标签、进度条&lt;br&gt;
&amp;lt;mark&amp;gt;定义有标记的文本（默认是黄色选中内容）&lt;br&gt;
&amp;lt;output&amp;gt;定义一些输出内容，计算表单结果配合oninput事件&lt;br&gt;
&amp;lt;datalist&amp;gt;为input标记定义一个下拉option&lt;/p&gt;
&lt;h1 id=&#34;3-input和textarea的区别&#34;&gt;3. input和textarea的区别&lt;/h1&gt;
&lt;p&gt;&amp;lt;input&amp;gt;是&lt;code&gt;单行文本框&lt;/code&gt;，不会换行。通过size属性指定显示字符的长度，注意：当使用css限定了宽高，那么size属性就不再起作用。&lt;br&gt;
value属性指定初始值，Maxlength属性指定文本框可以输入的最长长度。可以通过width和height设置宽高，但是也不会增加行数。&lt;/p&gt;
&lt;p&gt;&amp;lt;textarea&amp;gt;是&lt;code&gt;多行文本输入框&lt;/code&gt;，文本区中可容纳无限数量的文本，无value属性，其中的文本的默认字体是等宽字体（通常是Courier） ，可以通 过 cols 和 rows 属性来规定 textarea 的尺寸，不过更好的办法是使用 CSS 的 height 和 width 属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
	input:&amp;lt;input value=&amp;quot;啦啦啦啦啦&amp;quot; style=&amp;quot;height:200px;width: 500px;&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div style=&amp;quot;margin-top: 20px;&amp;quot;&amp;gt;
	textarea:&amp;lt;/textarea&amp;gt;&amp;lt;textarea  value=&amp;quot;嘻嘻嘻&amp;quot; style=&amp;quot;height:200px;width: 500px;&amp;quot;&amp;gt; 
   &amp;lt;/textarea&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到：textarea中设置的value并没有显示，同时input文本依然只有一行，并且居中显示。&lt;/p&gt;
&lt;h1 id=&#34;4-用div模拟textarea&#34;&gt;4. 用div模拟textarea&lt;/h1&gt;
&lt;p&gt;作为多行文本域功能来讲，textarea满足了我们大部分的需求。然而，textarea有一个不足就是不能像普通div标签一样高度可以跟随内容自适应。textarea总是很自信地显摆它的滚动条，高度固执地岿然不动。&lt;/p&gt;
&lt;p&gt;要解决这个问题很简单，一个普通的block元素上加个&lt;code&gt;contenteditable=&amp;quot;true&amp;quot;&lt;/code&gt;就ok了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div contenteditable=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614862550654.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
给div设置了一个最小高度，当超过最小高度但不超过最大高度时，div的高度根据文本自适应，当超过最大高度时，出现滚动条。&lt;/p&gt;
&lt;h1 id=&#34;5-移动设备忽略将页面中的数字识别为电话号码的方法&#34;&gt;5. 移动设备忽略将页面中的数字识别为电话号码的方法&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;标准的电话号码格式是这样的:&amp;lt;a  href=&amp;quot;tel:1-408-555-5555&amp;quot;&amp;gt;1-408-555-5555&amp;lt;/a&amp;gt;，点击后会自动打开电话功能；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但有时候不是电话号码的数字也会被浏览器自动解析为电话号码, 并把数字的颜色和样式都改了；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果忽略页面中的数字识别为电话号码, 只要把这个默认行为关闭就行，只要一行代码:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta name = &amp;quot;format-detection&amp;quot; content = &amp;quot;telephone=no&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;这个关闭不会影响真正电话号码的识别；&lt;/li&gt;
&lt;/ol&gt;
">【面】前端知识点梳理（Html）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/shi-shi/"" data-c="
          &lt;h1 id=&#34;11display哪些取值&#34;&gt;11.display哪些取值&lt;/h1&gt;
&lt;h2 id=&#34;111-none-此元素不会被显示&#34;&gt;11.1 none ：此元素不会被显示&lt;/h2&gt;
&lt;p&gt;（1） none此单词的意思是没有一个、毫无的意思；所以当display的属性值设置为none的时候，表示的是没有框类型，没有框类型的元素，是无法在浏览器中显示的，就实现隐藏元素的作用了；&lt;br&gt;
（2）有很多标签，display的属性值默认是none，比如 &lt;code&gt;head&lt;/code&gt; &lt;code&gt;meta&lt;/code&gt; &lt;code&gt;style&lt;/code&gt; &lt;code&gt;link&lt;/code&gt;等等；&lt;br&gt;
（3）项目应用中，做二级导航效果或者鼠标悬停效果动态时，会经常用到这个属性值，下次我们写一个好玩的二级效果再来展示这个属性值的作用；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614838389050.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;112-block此元素将显示为块级元素此元素前后会带有换行符&#34;&gt;11.2 block：此元素将显示为块级元素，此元素前后会带有换行符。&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614838392829.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;113-inline-默认此元素会被显示为内联元素元素前后没有换行符&#34;&gt;11.3 inline 默认此元素会被显示为内联元素，元素前后没有换行符。&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614838421481.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;114-inline-block-行内块元素css21-新增的值&#34;&gt;11.4 inline-block 行内块元素（CSS2.1 新增的值）&lt;/h2&gt;
&lt;p&gt;说明：行内块元素既具备行内元素的特性也具备块状元素的特性，具备行内元素前后没有换行符可以在一行内并列显示的特性，具备块状元素可以正确解释盒模型属性的特性。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614838503882.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;115-list-item-此元素会作为列表显示&#34;&gt;11.5 list-item 此元素会作为列表显示。&lt;/h2&gt;
&lt;p&gt;(1) 此属性值表示将元素显示为列表项标签，li标签默认的display的属性值是list-item，display的属性值为list-item的标签也属于块状元素；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614838546316.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
(2) li标签作为列表项标签，前面会有列表项标记，下面给div标签设置为list-item，div也会有列表项标记&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614838588128.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;116-run-in-此元素会根据上下文作为块级元素或内联元素显示&#34;&gt;11.6 run-in 此元素会根据上下文作为块级元素或内联元素显示。&lt;/h2&gt;
&lt;h2 id=&#34;117-table-此元素会作为块级表格来显示表格前后带有换行符&#34;&gt;11.7 table 此元素会作为块级表格来显示，表格前后带有换行符。&lt;/h2&gt;
&lt;p&gt;（1）table标签默认的元素类型是table，显示为块级表格，可以设置大小并且单独占据一行；&lt;br&gt;
（2）当table标签的元素类型是table时，并且设置宽度和高度之后，后代td标签的宽度和高度，默认是由table根据内容的多少去分配的；&lt;br&gt;
(3) table属于块状元素，但是对比别的块状元素，有自己的特点， table会单独占据一行，但是在没有设置width的情况下，不会与父元素同宽，而是根据内容而定；&lt;br&gt;
(4) 其他标签设置display的属性值为table，也不会具有表格的特性；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;总结&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过以上的测试，可以总结出：&lt;br&gt;
display的属性值为&lt;strong&gt;block，table&lt;/strong&gt;的标签都为&lt;code&gt;块状元素&lt;/code&gt;；&lt;br&gt;
display的属性值为&lt;strong&gt;inline，inline-table，inline-block&lt;/strong&gt;的标签为&lt;code&gt;行内级元素&lt;/code&gt;；&lt;/p&gt;
&lt;h1 id=&#34;12-相邻的两个inline-block节点为什么会出现间隔该如何解决&#34;&gt;12. 相邻的两个inline-block节点为什么会出现间隔，该如何解决&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614841169302.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;121-原因&#34;&gt;12.1 原因&lt;/h2&gt;
&lt;p&gt;其实，html的原因。我们回顾一下这段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;看这里➡️&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;⬅️看这里➡️&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;⬅️看这里&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们不仅看到元素节点，属性节点还有文本节点，问题就是处在文本节点的渲染导致3px(chrome)的间隔。那如何解决它？&lt;/p&gt;
&lt;h2 id=&#34;122-解决办法&#34;&gt;12.2 解决办法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;方法一、删除空白节点&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;看这里➡️&amp;lt;/div
&amp;gt;&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;⬅️看这里➡️&amp;lt;/div
&amp;gt;&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;⬅️看这里&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上的这些方法，无一列外破坏了代码的可读性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法二、负的marigin值&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.box {
    margin: -3px; /*左右缩小3px*/
    display: inline-block;
    width: 100px;
    height: 50px;
    background-color: #ddd;
    text-align: center;
    line-height: 50px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样的方式，可以解决chrome下面的问题。但是不建议使用。因为在某些游览器上面，这个文本节点可能设置成4px的间隔。因为解决问题，引入了新的问题，那就尴尬！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法三、font-size: 0&lt;/strong&gt;&lt;br&gt;
既然是文本节点导致的，那我们就把文本节点设置成0不就ok?顺着这个思路，我们这些写： 我们先给div加一个父级节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;wrapper&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;看这里➡️&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;⬅️看这里➡️&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;⬅️看这里&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.wrapper{
    font-size: 0;
}
.box {
    font-size: 14px;
    display: inline-block;
    width: 100px;
    height: 50px;
    background-color: #ddd;
    text-align: center;
    line-height: 50px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主要： 因为font-size是默认继承的属性。所以父级给了0，子级要重新设置font-size： 14px。&lt;/p&gt;
&lt;h1 id=&#34;13-meta-viewport-移动端适配&#34;&gt;13. meta viewport 移动端适配&lt;/h1&gt;
&lt;h2 id=&#34;131-什么是viewport&#34;&gt;13.1 什么是Viewport?&lt;/h2&gt;
&lt;p&gt;手机浏览器会把页面放入到一个虚拟的“视口”（viewpoint）中，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域大，也可能比浏览器的可视区域小。通常这个虚拟的“视口”（viewport）比屏幕宽，会把网页挤到一个很小的窗口。&lt;br&gt;
如果不显示地设置viewport，那么浏览器就会把width默认设置为980。但后果是浏览器出现横向滚动条，因为浏览器可视区域的宽度比默认的viewport的宽度小。&lt;br&gt;
然后浏览器引进了 viewport 这个 meta tag，让网页开发者来控制 viewport 的大小和缩放。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;132-meta-viewport-的6个属性&#34;&gt;13.2 meta viewport 的6个属性：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;width ： 设置viewport 的宽度&lt;/li&gt;
&lt;li&gt;height： 设置viewport 的高度&lt;/li&gt;
&lt;li&gt;initial-scale ： 设置页面的初始缩放值&lt;/li&gt;
&lt;li&gt;minimum-scale ：允许用户的最小缩放值&lt;/li&gt;
&lt;li&gt;maximum-scale：允许用户的最大缩放值&lt;/li&gt;
&lt;li&gt;user-scalable： 是否允许用户进行缩放，值为&amp;quot;no&amp;quot;或&amp;quot;yes&amp;quot;, no 代表不允许，yes代表允许&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;133-3个viewport&#34;&gt;13.3 3个viewport：&lt;/h2&gt;
&lt;p&gt;（1）&lt;strong&gt;布局视口 layout viewport&lt;/strong&gt;&lt;br&gt;
如果把移动设备上浏览器的可视区域设为viewport的话，某些网站会因为viewport太窄而显示错乱，所以这些浏览器就默认会把viewport设为一个较宽的值，比如980px，使得即使是那些为PC浏览器设计的网站也能在移动设备浏览器上正常显示。这个浏览器默认的viewport叫做 layout viewport。layout viewport的宽度可以通过 document.documentElement.clientWidth来获取。&lt;/p&gt;
&lt;p&gt;（2）&lt;strong&gt;视觉视口 visual viewport&lt;/strong&gt;&lt;br&gt;
layout viewport的宽度是大于浏览器可视区域的宽度的，所以还需要一个viewport来代表浏览器可视区域的大小，这个viewport叫做 visual viewport。visual viewport的宽度可以通过 document.documentElement.innerWidth来获取。&lt;/p&gt;
&lt;p&gt;（3）&lt;strong&gt;理想视口 ideal viewport&lt;/strong&gt;&lt;br&gt;
ideal viewport是一个能完美适配移动设备的viewport。首先，不需要缩放和横向滚动条就能正常查看网站的所有内容；其次，显示的文字、图片大小合适，如14px的文字不会因为在一个高密度像素的屏幕里显示得太小而无法看清，无论是在何种密度屏幕，何种分辨率下，显示出来的大小都差不多。这个viewport叫做 ideal viewport。&lt;/p&gt;
&lt;p&gt;ideal viewport并没有一个固定的尺寸，不同的设备有不同的ideal viewport。例如，所有的iphone的ideal viewport宽度都是320px，无论它的屏幕宽度是320还是640。&lt;br&gt;
ideal viewport 的意义在于，无论在何种分辨率的屏幕下，针对ideal viewport 而设计的网站，不需要缩放和横向滚动条都可以完美地呈现给用户。&lt;/p&gt;
&lt;h2 id=&#34;134-终极方案&#34;&gt;13.4  终极方案：&lt;/h2&gt;
&lt;p&gt;将&lt;code&gt;meta:vp&lt;/code&gt;标签的属性值设置为&lt;code&gt;width=device-width, initial-scale=1&lt;/code&gt;就不仅能够将页面的布局视口自动设置为各个移动设备的理想视口，还能够同时兼容iphone、ipad的Safari以及WP7 IE浏览器的横屏问题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;14-css实现宽度自适应100宽高169的比例的矩形&#34;&gt;14 CSS实现宽度自适应100%，宽高16:9的比例的矩形&lt;/h1&gt;
&lt;p&gt;第一步先计算高度，假设宽100%，那么高为h=9/16=56.25%&lt;/p&gt;
&lt;p&gt;第二步利用之前所说设置padding-bottom方法实现矩形&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;scale&amp;quot;&amp;gt;
      &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
   .box {
        width: 20%;
    }
    .scale {
        width: 100%;
        height: 0px;
        /* scale 用来实现宽高等比例 1:1 padding-bottom:100%; 4:3 padding-bottom:75%; 16:9 padding-bottom:56.25%; */
        padding-bottom: 56.25%;
        position: relative;
        background-color: pink;
    }
  &amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;15-rem布局的优缺点&#34;&gt;15 rem布局的优缺点&lt;/h1&gt;
&lt;h2 id=&#34;151-rem布局原理&#34;&gt;15.1 Rem布局原理&lt;/h2&gt;
&lt;p&gt;rem布局的本质是什么？这是我问过很多人的一个问题，但得到的回答都差强人意。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其实rem布局的本质是等比缩放，一般是基于宽度&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;152-rem布局优点&#34;&gt;15.2 Rem布局优点&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;rem的优点就是可以通过修改html里的文字大小来改变页面中元素的大小，可以整体进行控制。&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;153-rem布局缺点&#34;&gt;15.3 Rem布局缺点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;目前ie不支持 对pc页面来讲使用次数不多；&lt;/li&gt;
&lt;li&gt;数据量大：所有的图片，盒子都需要我们去给一个准确的值；才能保证不同机型的适配；&lt;/li&gt;
&lt;li&gt;字体的问题：字体的大小和字体宽度，并不成线性关系，所以字体大小不能使用rem&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;16-css画一个三角形&#34;&gt;16. CSS画一个三角形&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;CSS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
        /* css3绘制三角形 */
        .triangle{
            width: 0px;                           /*设置宽高为0，所以div的内容为空，从才能形成三角形尖角*/
            height: 0px;
            border-bottom: 200px solid #00a3af;
            border-left: 200px solid transparent;    /*transparent 表示透明*/
            border-right: 200px solid transparent;
        }
    &amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Html&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;div class=&amp;quot;triangle&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614860077842.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;17-1像素边框问题&#34;&gt;17. 1像素边框问题&lt;/h1&gt;
&lt;h2 id=&#34;171-为什么1px变粗了&#34;&gt;17.1 为什么1px变粗了？&lt;/h2&gt;
&lt;p&gt;UI设计师要求的1px是指设备的物理像素1px，而CSS里记录的像素是逻辑像素，它们之间存在一个比例关系，可以用javascript中的window.devicePixelRatio来获取&lt;/p&gt;
&lt;p&gt;移动端开发常需要在html的header里添加如下一句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这句话定义了本页面的viewport的宽度为设备宽度，初始缩放值和最大缩放值都为1，并禁止了用户缩放。&lt;/p&gt;
&lt;h2 id=&#34;172-修改方案&#34;&gt;17.2 修改方案&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;viewport + rem 方案&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;该方案是对上述方案的优化，整体思路就是利用viewport + rem + js 动态的修改页面的缩放比例，实现小于1像素的显示。在页面初始化时，在头部引入原始默认状态如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html;charset=UTF-8&amp;quot;&amp;gt;  
&amp;lt;meta name=&amp;quot;viewport&amp;quot; id=&amp;quot;WebViewport&amp;quot; content=&amp;quot;initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&amp;quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来的任务就是js的动态修改缩放比 以及 实现rem根元素字体大小的设置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var viewport = document.querySelector(&amp;quot;meta[name=viewport]&amp;quot;)
if (window.devicePixelRatio == 1) {
    viewport.setAttribute(&#39;content&#39;, &#39;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&#39;)
} 
if (window.devicePixelRatio == 2) {
    viewport.setAttribute(&#39;content&#39;, &#39;width=device-width, initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&#39;)
} 
if (window.devicePixelRatio == 3) {
    viewport.setAttribute(&#39;content&#39;, &#39;width=device-width, initial-scale=0.333333333, maximum-scale=0.333333333, minimum-scale=0.333333333, user-scalable=no&#39;)
} 

var docEl = document.documentElement;
var fontsize = 10 * (docEl.clientWidth / 320) + &#39;px&#39;;
docEl.style.fontSize = fontsize;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;transform: scale(0.5) 方案 - 推荐: 很灵活&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置height: 1px，根据媒体查询结合&lt;code&gt;transform&lt;/code&gt;缩放为相应尺寸。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;div {
    height:1px;
    background:#000;
    -webkit-transform: scaleY(0.5);
    -webkit-transform-origin:0 0;
    overflow: hidden;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;用&lt;code&gt;::after&lt;/code&gt;和&lt;code&gt;::befor&lt;/code&gt;,设置&lt;code&gt;border-bottom：1px solid #000&lt;/code&gt;,然后在缩放&lt;code&gt;-webkit-transform: scaleY(0.5)&lt;/code&gt;;可以实现两根边线的需求&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;div::after{
    content:&#39;&#39;;width:100%;
    border-bottom:1px solid #000;
    transform: scaleY(0.5);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;用&lt;code&gt;::after&lt;/code&gt;设置&lt;code&gt;border：1px solid #000; width:200%; height:200%&lt;/code&gt;,然后再缩放&lt;code&gt;scaleY(0.5)&lt;/code&gt;; 优点可以实现圆角，京东就是这么实现的，缺点是按钮添加active比较麻烦。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;.div::after {
    content: &#39;&#39;;
    width: 200%;
    height: 200%;
    position: absolute;
    top: 0;
    left: 0;
    border: 1px solid #bfbfbf;
    border-radius: 4px;
    -webkit-transform: scale(0.5,0.5);
    transform: scale(0.5,0.5);
    -webkit-transform-origin: top left;
}
&lt;/code&gt;&lt;/pre&gt;
">【面】前端知识点梳理（CSS下）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/mian-qian-duan-zhi-shi-dian-shu-li-css-xia/"" data-c="
          &lt;h1 id=&#34;1盒模型box-model&#34;&gt;1.盒模型（box model）&lt;/h1&gt;
&lt;h2 id=&#34;1基本概念&#34;&gt;1.基本概念&lt;/h2&gt;
&lt;p&gt;盒子模型，个人的理解，就是一个来装html标签的矩形容器，由四部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内容区（content）&lt;/li&gt;
&lt;li&gt;内边距（padding）&lt;/li&gt;
&lt;li&gt;外框（border）&lt;/li&gt;
&lt;li&gt;外边距（margin）&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614738716059.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2标准模型与ie模型的区别&#34;&gt;2.标准模型与IE模型的区别&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;标准模型&lt;/strong&gt;与** IE 模型**的区别在于宽高的计算方式不同。&lt;br&gt;
标准模型计算元素的宽高只算 content 的宽高，IE模型是 content + padding + border 的总尺寸。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614739310471.jfif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
从上图可以看到标准 &lt;code&gt;W3C 盒子模型的范围包括 margin、border、padding、content，并且 content 部分不包含其他部分。&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614739313417.jfif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
从上图可以看到&lt;code&gt;IE 盒子模型的范围也包括 margin、border、padding、content，和标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 pading。&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-如何设置这两种模型&#34;&gt;3、如何设置这两种模型&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;//设置标准模型
box-sizing: content-box;
//设置IE模型
box-sizing: border-box;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2flex布局&#34;&gt;2.flex布局&lt;/h1&gt;
&lt;p&gt;flex，即弹性布局。一个由css3引入，为我们的盒子属性带来灵活性的一种布局方式。一旦父级采用了flex布局，里边的子控件将收flex布局限制，部分原本的样式（如float:left）也会失效。&lt;/p&gt;
&lt;p&gt;特别注意： flex:0 0 30%的意义： 等于flex-grow=0（默认不放大）+flex-shrink=0（不缩小）+flex-basis=30%（ 项目占据主轴的空间）&lt;/p&gt;
&lt;h2 id=&#34;1flex布局使用&#34;&gt;1.flex布局使用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;任何一个容器都可以指定为 Flex 布局。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.box{
  display: flex;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;行内元素也可以使用 Flex 布局。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.box{
  display: inline-flex;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，设为 Flex 布局以后，子元素的&lt;code&gt;float&lt;/code&gt;、&lt;code&gt;clear&lt;/code&gt;和&lt;code&gt;vertical-align&lt;/code&gt;属性将失效。&lt;/p&gt;
&lt;h2 id=&#34;2基本概念&#34;&gt;2.基本概念&lt;/h2&gt;
&lt;p&gt;采用 Flex 布局的元素，称为 Flex 容器（flex container），简称&amp;quot;容器&amp;quot;。它的所有&lt;strong&gt;子元素&lt;/strong&gt;自动成为容器成员，称为 Flex 项目（flex item），简称&amp;quot;项目&amp;quot;。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614742656456.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做&lt;code&gt;main start&lt;/code&gt;，结束位置叫做&lt;code&gt;main end&lt;/code&gt;；交叉轴的开始位置叫做&lt;code&gt;cross start&lt;/code&gt;，结束位置叫做&lt;code&gt;cross end&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;项目默认沿主轴排列。单个项目占据的主轴空间叫做&lt;code&gt;main size&lt;/code&gt;，占据的交叉轴空间叫做&lt;code&gt;cross size&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;3容器的属性&#34;&gt;3.容器的属性&lt;/h2&gt;
&lt;h3 id=&#34;31-主轴的方向flex-direction&#34;&gt;3.1 &lt;strong&gt;主轴的方向(flex-direction)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;flex-direction&lt;/code&gt;: row | row-reverse | column | column-reverse;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;row（默认值）：主轴为水平方向，起点在左端。&lt;/li&gt;
&lt;li&gt;row-reverse：主轴为水平方向，起点在右端。&lt;/li&gt;
&lt;li&gt;column：主轴为垂直方向，起点在上沿。&lt;/li&gt;
&lt;li&gt;column-reverse：主轴为垂直方向，起点在下沿。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614742821013.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-换行属性flex-wrap&#34;&gt;3.2 &lt;strong&gt;换行属性(flex-wrap)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;flex-wrap&lt;/code&gt;: nowrap | wrap | wrap-reverse;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nowrap（默认）：不换行。&lt;/li&gt;
&lt;li&gt;wrap：换行，第一行在上方。&lt;/li&gt;
&lt;li&gt;wrap-reverse：换行，第一行在下方。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;简写&lt;/code&gt;：&lt;strong&gt;方向 + 换行&lt;/strong&gt;&lt;br&gt;
flex-flow: &lt;code&gt;&amp;lt;flex-direction&amp;gt;&lt;/code&gt; || &lt;code&gt;&amp;lt;flex-wrap&amp;gt;&lt;/code&gt;;&lt;/p&gt;
&lt;h3 id=&#34;33-主轴对齐方式justify-content&#34;&gt;3.3 &lt;strong&gt;主轴对齐方式(justify-content)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;justify-content&lt;/code&gt;: flex-start | flex-end | center | space-between | space-around;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex-start（默认值）：左对齐&lt;/li&gt;
&lt;li&gt;flex-end：右对齐&lt;/li&gt;
&lt;li&gt;center： 居中&lt;/li&gt;
&lt;li&gt;space-between：两端对齐，项目之间的间隔都相等。&lt;/li&gt;
&lt;li&gt;space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614743145091.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;34-交叉轴对齐方式align-items&#34;&gt;3.4 &lt;strong&gt;交叉轴对齐方式(align-items)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;align-items&lt;/code&gt;: flex-start | flex-end | center | baseline | stretch;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex-start：交叉轴的起点对齐。&lt;/li&gt;
&lt;li&gt;flex-end：交叉轴的终点对齐。&lt;/li&gt;
&lt;li&gt;center：交叉轴的中点对齐。&lt;/li&gt;
&lt;li&gt;baseline: 项目的第一行文字的基线对齐。&lt;/li&gt;
&lt;li&gt;stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614743221850.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;35-多根轴线对齐方式align-content&#34;&gt;3.5 &lt;strong&gt;多根轴线对齐方式(align-content)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;align-content&lt;/code&gt;: flex-start | flex-end | center | space-between | space-around | stretch;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex-start：与交叉轴的起点对齐。&lt;/li&gt;
&lt;li&gt;flex-end：与交叉轴的终点对齐。&lt;/li&gt;
&lt;li&gt;center：与交叉轴的中点对齐。&lt;/li&gt;
&lt;li&gt;space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。&lt;/li&gt;
&lt;li&gt;space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。&lt;/li&gt;
&lt;li&gt;stretch（默认值）：轴线占满整个交叉轴。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614743313971.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4项目的属性&#34;&gt;4.项目的属性&lt;/h2&gt;
&lt;p&gt;排列顺序，数值越小，排列越靠前，默认为0。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;order: &amp;lt;integer&amp;gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;项目的放大比例,默认为0，即如果存在剩余空间，也不放大。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex-grow: &amp;lt;number&amp;gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;项目的缩小比例,默认为1，即如果空间不足，该项目将缩小。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex-shrink: &amp;lt;number&amp;gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;项目占据的空间,默认值为auto，即项目的本来大小&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex-basis: &amp;lt;length&amp;gt; | auto;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;简写flex:&lt;/code&gt;：&lt;strong&gt;flex-grow, flex-shrink 和 flex-basis&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;flex&lt;/code&gt;属性是&lt;code&gt;flex-grow&lt;/code&gt;, &lt;code&gt;flex-shrink&lt;/code&gt; 和&lt;code&gt;flex-basis&lt;/code&gt;的简写，默认值为&lt;code&gt;0 1 auto&lt;/code&gt;。后两个属性可选。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;独立的对齐方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;align-self: auto | flex-start | flex-end | center | baseline | stretch;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614743733611.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;3css单位&#34;&gt;3.CSS单位&lt;/h1&gt;
&lt;p&gt;CSS 有几个不同的单位用于表示长度。&lt;/p&gt;
&lt;p&gt;一些设置 CSS 长度的属性有 width, margin, padding, font-size, border-width, 等。&lt;/p&gt;
&lt;p&gt;长度有一个数字和单位组成如 10px, 2em, 等。&lt;/p&gt;
&lt;p&gt;数字与单位之间不能出现空格。如果长度值为 0，则可以省略单位。&lt;/p&gt;
&lt;p&gt;对于一些 CSS 属性，长度可以是负数。&lt;/p&gt;
&lt;p&gt;有两种类型的长度单位：&lt;strong&gt;相对和绝对&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;31-相对长度&#34;&gt;3.1 相对长度&lt;/h2&gt;
&lt;p&gt;相对长度单位指定了一个长度相对于另一个长度的属性。对于&lt;strong&gt;不同的设备&lt;/strong&gt;相对长度更适用。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;单位&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;em&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;它是描述相对于应用在当前元素的字体尺寸，所以它也是相对长度单位。一般浏览器字体大小默认为16px，则2em == 32px；&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ex&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;依赖于英文字母小 x 的高度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ch&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数字 0 的宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;rem&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;rem 是根 em（root em）的缩写，rem作用于非根元素时，相对于根元素字体大小；rem作用于根元素字体大小时，相对于其出初始字体大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;vw&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;viewpoint width，视窗宽度，1vw=视窗宽度的1%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;vh&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;viewpoint height，视窗高度，1vh=视窗高度的1%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;vmin&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;vw和vh中较小的那个。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;vmax&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;vw和vh中较大的那个。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;提示: rem与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-绝对长度&#34;&gt;3.2 绝对长度&lt;/h2&gt;
&lt;p&gt;绝对长度单位是一个固定的值，它反应一个真实的物理尺寸。绝对长度单位视输出介质而定，不依赖于环境（显示器、分辨率、操作系统等）。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;单位&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;cm&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;厘米&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;mm&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;毫米&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;in&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;英寸 (1in = 96px = 2.54cm)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;px&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;像素 (1px = 1/96th of 1in)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pt&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;point，大约1/72英寸； (1pt = 1/72in)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pc&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pica，大约 12pt，1/6英寸； (1pc = 12 pt)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;4css选择器&#34;&gt;4.css选择器&lt;/h1&gt;
&lt;h2 id=&#34;41基础选择器&#34;&gt;4.1基础选择器&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614746568376.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
“选择器”指明了{}中的“样式”的作用对象，也就是“样式”作用于网页中的哪些元素&lt;br&gt;
1.&lt;strong&gt;通配选择器&lt;/strong&gt; *: 所有的标签都变色&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;标签(元素)选择器&lt;/strong&gt;：匹配所有使用p标签的样式 p{color:red}&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;id选择器&lt;/strong&gt;：匹配指定的标签  #p2{color:red}&lt;/p&gt;
&lt;p&gt;4.&lt;strong&gt;class类选择器&lt;/strong&gt;：谁指定class谁的变色，可选多个  .c1{color:red} 或者 div.c1{color:red}&lt;/p&gt;
&lt;h2 id=&#34;42-复合选择器&#34;&gt;4.2 复合选择器&lt;/h2&gt;
&lt;p&gt;1.&lt;strong&gt;交集选择器&lt;/strong&gt;（合着写）&lt;br&gt;
&lt;strong&gt;作用&lt;/strong&gt;：选中同时复合多个条件的元素&lt;br&gt;
&lt;strong&gt;语法&lt;/strong&gt;：选择器1选择器2选择器3选择器n{}&lt;br&gt;
&lt;strong&gt;注意点&lt;/strong&gt;：交集选择器中如果有元素选择器，必须使用元素选择器开头&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;并集选择器&lt;/strong&gt;（逗号隔开）&lt;br&gt;
&lt;strong&gt;作用&lt;/strong&gt;：同时选择多个选择器对应的元素&lt;br&gt;
&lt;strong&gt;语法&lt;/strong&gt;：选择器1,选择器2,选择器3,选择器n{}&lt;br&gt;
&lt;strong&gt;例子&lt;/strong&gt;：#b1,.p1,h1,span,div.red{}&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;关系选择器&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;(1)子元素选择器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用：选中指定父元素的指定子元素&lt;/li&gt;
&lt;li&gt;语法：父元素 &amp;gt; 子元素&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;div.box &amp;gt; span{
        color: orange;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;(2)后代元素选择器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用：选中指定元素内的指定后代元素&lt;/li&gt;
&lt;li&gt;语法：祖先 后代&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;div span{
      color: skyblue
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;(3)兄弟元素选择器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择下一个兄弟&lt;br&gt;
语法：前一个 + 下一个&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;p + span{
     color: red;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;选择下边所有的兄弟&lt;br&gt;
语法：兄 ~ 弟&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt; p ~ span{
      color: red;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.&lt;strong&gt;属性选择器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[属性名] 选择含有指定属性的元素&lt;/li&gt;
&lt;li&gt;[属性名=属性值] 选择含有指定属性和属性值的元素&lt;/li&gt;
&lt;li&gt;[属性名^=属性值] 选择属性值以指定值开头的元素&lt;/li&gt;
&lt;li&gt;[属性名$=属性值] 选择属性值以指定值结尾的元素&lt;/li&gt;
&lt;li&gt;[属性名*=属性值] 选择属性值中含有某值的元素的元素&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt; p[title*=e]{
      color: orange;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.&lt;strong&gt;伪类选择器&lt;/strong&gt;&lt;br&gt;
伪类一般情况下都是使用&lt;code&gt;:&lt;/code&gt;开头&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;:first-child 第一个子元素&lt;/li&gt;
&lt;li&gt;:last-child 最后一个子元素&lt;/li&gt;
&lt;li&gt;:nth-child() 选中第n个子元素&lt;/li&gt;
&lt;li&gt;:first-of-type&lt;/li&gt;
&lt;li&gt;:last-of-type&lt;/li&gt;
&lt;li&gt;:nth-of-type()          - 他们是在同类型元素中进行排序&lt;/li&gt;
&lt;li&gt;:not() 否定伪类        - 将符合条件的元素从选择器中去除&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;ul &amp;gt; li:nth-child(2n+1){
      color: red;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5bfc-清除浮动&#34;&gt;5.bfc 清除浮动&lt;/h1&gt;
&lt;p&gt;BFC(Block Formatting Context) 块级格式化环境&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;BFC是一个CSS中的一个隐含的属性，可以为一个元素开启BFC&lt;br&gt;
开启BFC该元素会变成一个独立的布局区域&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;元素开启BFC后的特点：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;开启BFC的元素不会被浮动元素所覆盖&lt;/li&gt;
&lt;li&gt;开启BFC的元素子元素和父元素外边距不会重叠&lt;/li&gt;
&lt;li&gt;开启BFC的元素可以包含浮动的子元素&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;可以通过一些特殊方式来开启元素的BFC：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;设置元素的浮动（不推荐）&lt;/li&gt;
&lt;li&gt;将元素设置为行内块元素（不推荐）&lt;/li&gt;
&lt;li&gt;将元素的overflow设置为一个非visible的值&lt;br&gt;
&lt;code&gt;常用的方式 为元素设置 overflow:hidden 开启其BFC&lt;/code&gt; 以使其可以包含浮动元素&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，除了BFC，还有IFC、GFC、FFC的概念。我们简单了解一下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GFC：可简单理解为grid布局&lt;/li&gt;
&lt;li&gt;FFC：可简单理解为flex布局。&lt;/li&gt;
&lt;li&gt;IFC:内联格式化上下文，简单理解为：inline-block。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;水平方向上的 margin，border 和 padding在框之间得到保留。框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐。包含那些框的长方形区域，会形成一行，叫做行框。 inline-block的元素的内部是一个BFC，但是它本身可以和其它inline元素一起形成IFC。&lt;/p&gt;
&lt;h1 id=&#34;6层叠上下文&#34;&gt;6.层叠上下文&lt;/h1&gt;
&lt;h2 id=&#34;1层叠上下文stacking-context&#34;&gt;1.层叠上下文(Stacking Context)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614762081794.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
层叠上下文1 (Stacking Context 1)是由文档根元素形成的， 层叠上下文2和3 (Stacking Context 2, 3) 都是层叠上下文1 (Stacking Context 1) 上的层叠层。 他们各自也都形成了新的层叠上下文，其中包含着新的层叠层。&lt;/p&gt;
&lt;p&gt;在层叠上下文中，其子元素按照上面解释的规则进行层叠。形成层叠上下文的方法有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根元素 &amp;lt;html&amp;gt;&amp;lt;/html&amp;gt;&lt;/li&gt;
&lt;li&gt;position值为 absolute|relative，且 z-index值不为 auto&lt;/li&gt;
&lt;li&gt;position 值为 fixed|sticky&lt;/li&gt;
&lt;li&gt;z-index 值不为 auto 的flex元素，即：父元素 display:flex|inline-flex&lt;/li&gt;
&lt;li&gt;opacity 属性值小于 1 的元素&lt;/li&gt;
&lt;li&gt;transform 属性值不为 none的元素&lt;/li&gt;
&lt;li&gt;mix-blend-mode 属性值不为 normal 的元素&lt;/li&gt;
&lt;li&gt;filter、 perspective、 clip-path、 mask、 mask-image、 mask-border、 motion-path 值不为none 的元素&lt;/li&gt;
&lt;li&gt;perspective 值不为 none 的元素&lt;/li&gt;
&lt;li&gt;isolation 属性被设置为 isolate 的元素&lt;/li&gt;
&lt;li&gt;will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值&lt;/li&gt;
&lt;li&gt;-webkit-overflow-scrolling 属性被设置 touch的元素&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总结:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;层叠上下文可以包含在其他层叠上下文中，并且一起组建了一个有层级的层叠上下文&lt;/li&gt;
&lt;li&gt;每个层叠上下文完全独立于它的兄弟元素，当处理层叠时只考虑子元素，这里类似于BFC&lt;/li&gt;
&lt;li&gt;每个层叠上下文是自包含的：当元素的内容发生层叠后，整个该元素将会&lt;strong&gt;在父级叠上下文&lt;/strong&gt;中按顺序进行层叠&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-层叠等级-stacking-level&#34;&gt;2. 层叠等级 (Stacking Level)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;层叠等级&lt;/strong&gt; (层叠水平, Stacking Level) 决定了同一个层叠上下文中元素在z轴上的显示顺序的&lt;strong&gt;概念&lt;/strong&gt;；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通元素的层叠等级优先由其所在的层叠上下文决定&lt;/li&gt;
&lt;li&gt;层叠等级的比较只有在同一个层叠上下文元素中才有意义&lt;/li&gt;
&lt;li&gt;在同一个层叠上下文中，层叠等级描述定义的是该层叠上下文中的元素在Z轴上的上下顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;，层叠等级并不一定由 z-index 决定，只有定位元素的层叠等级才由 z-index 决定，其他类型元素的层叠等级由层叠顺序、他们在HTML中出现的顺序、他们的父级以上元素的层叠等级一同决定，详细的规则见下面层叠顺序的介绍。&lt;/p&gt;
&lt;h2 id=&#34;3-z-index&#34;&gt;3. z-index&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在 CSS 2.1 中, 所有的盒模型元素都处于三维坐标系中。 除了我们常用的横坐标和纵坐标， 盒模型元素还可以沿着&amp;quot;z 轴&amp;quot;层叠摆放， 当他们相互覆盖时， z 轴顺序就变得十分重要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;z-index 只适用于定位的元素，对非定位元素无效，它可以被设置为正整数、负整数、0、auto，如果一个定位元素没有设置 z-index，那么默认为auto；&lt;/p&gt;
&lt;p&gt;元素的 z-index 值只在同一个层叠上下文中有意义。如果父级层叠上下文的层叠等级低于另一个层叠上下文的，那么它 z-index 设的再高也没用。所以如果你遇到 z-index 值设了很大，但是不起作用的话，就去看看它的父级层叠上下文是否被其他层叠上下文盖住了。&lt;/p&gt;
&lt;h2 id=&#34;4-层叠顺序-stacking-order&#34;&gt;4. 层叠顺序 (Stacking Order)&lt;/h2&gt;
&lt;p&gt;这里其实是涉及了所谓的层叠水平（stacking level)，有一张图可以很好的诠释：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614774762413.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;形成堆叠上下文环境的元素的背景与边框&lt;/li&gt;
&lt;li&gt;拥有负 z-index 的子堆叠上下文元素 （负的越高越堆叠层级越低）&lt;/li&gt;
&lt;li&gt;正常流式布局，非 inline-block，无 position 定位（static除外）的子元素&lt;/li&gt;
&lt;li&gt;无 position 定位（static除外）的 float 浮动元素&lt;/li&gt;
&lt;li&gt;正常流式布局， inline-block元素，无 position 定位（static除外）的子元素（包括 display:table 和 display:inline ）&lt;/li&gt;
&lt;li&gt;拥有 z-index:0 的子堆叠上下文元素&lt;/li&gt;
&lt;li&gt;拥有正 z-index: 的子堆叠上下文元素（正的越低越堆叠层级越低）&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;7常见页面布局&#34;&gt;7.常见页面布局&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;三栏布局&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目：假设高度已知，请写出三栏布局，其中左栏、右栏宽度各为 300px，中间自适应。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解答：可以有很多种布局方式，这里列出五种：float布局，absolute布局，flex布局，table布局，grid布局，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
	&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
	&amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=edge&amp;quot;&amp;gt;
	&amp;lt;title&amp;gt;三栏布局&amp;lt;/title&amp;gt;
	&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;&amp;quot;&amp;gt;
	&amp;lt;style type=&amp;quot;text/css&amp;quot; media=&amp;quot;screen&amp;quot;&amp;gt;
		html *{
			margin: 0;
			padding: 0;
		}
	&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
	&amp;lt;section class=&amp;quot;layout float&amp;quot;&amp;gt;
		&amp;lt;style type=&amp;quot;text/css&amp;quot; media=&amp;quot;screen&amp;quot;&amp;gt;
			.layout.float .wrapper&amp;gt;div{
				min-height: 100px;
			}
			.layout.float .left{
				float: left;
				width: 300px;
				background: red;
			}
			.layout.float .center{
				background: yellow;
			}
			.layout.float .right{
				float: right;
				width: 300px;
				background: blue;
			}
			
		&amp;lt;/style&amp;gt;
		&amp;lt;article class=&amp;quot;wrapper&amp;quot;&amp;gt;
			&amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt;
				&amp;lt;h1&amp;gt;float布局&amp;lt;/h1&amp;gt;
				1.我是float布局的中间部分
				2.我是float布局的中间部分
			&amp;lt;/div&amp;gt;
		&amp;lt;/article&amp;gt;
	&amp;lt;/section&amp;gt;


	&amp;lt;section class=&amp;quot;layout absolute&amp;quot;&amp;gt;
		&amp;lt;style type=&amp;quot;text/css&amp;quot; media=&amp;quot;screen&amp;quot;&amp;gt;
			.layout.absolute .wrapper{
				width: 100%;
				margin-top: 20px;
			}
			.layout.absolute .wrapper&amp;gt;div{
				min-height: 100px;
			}
			.layout.absolute .left{
				position: absolute;
				left: 0;
				width: 300px;
				background: red;
			}
			.layout.absolute .center{
				position: absolute;
				left: 300px;
				right: 300px;
				background: yellow;
			}
			.layout.absolute .right{
				position: absolute;
				right: 0;
				width: 300px;
				background: blue;
			}
		&amp;lt;/style&amp;gt;
		&amp;lt;article class=&amp;quot;wrapper&amp;quot;&amp;gt;
			&amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt;
				&amp;lt;h1&amp;gt;absolute布局&amp;lt;/h1&amp;gt;
				1.我是absolute布局的中间部分
				2.我是absolute布局的中间部分
			&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
		&amp;lt;/article&amp;gt;
	&amp;lt;/section&amp;gt;


	&amp;lt;section class=&amp;quot;layout flex&amp;quot;&amp;gt;
		&amp;lt;style type=&amp;quot;text/css&amp;quot; media=&amp;quot;screen&amp;quot;&amp;gt;
			.layout.flex .wrapper{
				width: 100%;
				min-height: 100px;
				display: flex;
				margin-top: 140px;
			}
			.layout.flex .left{
				width: 300px;
				background: red;
			}
			.layout.flex .center{
				flex: 1;
				background: yellow;
			}
			.layout.flex .right{
				width: 300px;
				background: blue;
			}
		&amp;lt;/style&amp;gt;
		&amp;lt;article class=&amp;quot;wrapper&amp;quot;&amp;gt;
			&amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt;
				&amp;lt;h1&amp;gt;flex布局&amp;lt;/h1&amp;gt;
				1.我是flex布局的中间部分
				2.我是flex布局的中间部分
			&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
		&amp;lt;/article&amp;gt;
	&amp;lt;/section&amp;gt;


	&amp;lt;section class=&amp;quot;layout table&amp;quot;&amp;gt;
		&amp;lt;style type=&amp;quot;text/css&amp;quot; media=&amp;quot;screen&amp;quot;&amp;gt;
			.layout.table .wrapper{
				display: table;
				width: 100%;
				min-height: 100px;
				margin-top: 20px;
			}
			.layout.table .left{
				display: table-cell;
				width: 300px;
				background: red;
			}
			.layout.table .center{
				display: table-cell;
				background: yellow;
			}
			.layout.table .right{
				display: table-cell;
				width: 300px;
				background: blue;
			}
			
		&amp;lt;/style&amp;gt;
		&amp;lt;article class=&amp;quot;wrapper&amp;quot;&amp;gt;
			&amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt;
				&amp;lt;h1&amp;gt;table布局&amp;lt;/h1&amp;gt;
				1.我是table布局的中间部分
				2.我是table布局的中间部分
			&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
		&amp;lt;/article&amp;gt;
	&amp;lt;/section&amp;gt;


	&amp;lt;section class=&amp;quot;layout grid&amp;quot;&amp;gt;
		&amp;lt;style type=&amp;quot;text/css&amp;quot; media=&amp;quot;screen&amp;quot;&amp;gt;
			.layout.grid .wrapper{
				display: grid;
				grid-template-columns: 300px auto 300px;
				grid-template-rows: 100px;
				width: 100%;
				margin-top: 20px;
			}
			.layout.grid .left{
				background: red;
			}
			.layout.grid .center{
				background: yellow;
			}
			.layout.grid .right{
				background: blue;
			}
			
		&amp;lt;/style&amp;gt;
		&amp;lt;article class=&amp;quot;wrapper&amp;quot;&amp;gt;
			&amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt;
				&amp;lt;h1&amp;gt;grid布局&amp;lt;/h1&amp;gt;
				1.我是grid布局的中间部分
				2.我是grid布局的中间部分
			&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
		&amp;lt;/article&amp;gt;
	&amp;lt;/section&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;71-每种布局的优缺点&#34;&gt;7.1 每种布局的优缺点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;float 布局&lt;/code&gt;&lt;br&gt;
优点： 比较简单，兼容性也比较好。只要清除浮动做的好，是没有什么问题的&lt;br&gt;
缺点：浮动元素是脱离文档流，要做清除浮动，这个处理不好的话，会带来很多问题，比如高度塌陷等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;绝对布局&lt;/code&gt;&lt;br&gt;
优点：很快捷，设置很方便，而且也不容易出问题&lt;br&gt;
缺点：绝对定位是脱离文档流的，意味着下面的所有子元素也会脱离文档流，这就导致了这种方法的有效性和可使用性是比较差的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;flex 布局&lt;/code&gt;&lt;br&gt;
优点：简单快捷&lt;br&gt;
缺点：不支持 IE8 及以下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;table布局&lt;/code&gt;&lt;br&gt;
优点：实现简单，代码少&lt;br&gt;
缺点：当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的，而有时候这种效果不是我们想要的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;grid布局&lt;/code&gt;&lt;br&gt;
跟 flex 相似。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;72-水平垂直居中&#34;&gt;7.2 水平垂直居中&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;absolute + 负margin&lt;/strong&gt;&lt;br&gt;
这种方式比较好理解，兼容性也很好，缺点是需要知道子元素的宽高&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;out&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;inner&amp;quot;&amp;gt;12345&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
  .out{
    position: relative;
    width: 300px;
    height: 300px;
    background: red;
  }

  .inner{
    position: absolute;
    width: 100px;
    height: 100px;
    background: yellow;
    left: 50%;
    top: 50%;
    margin-left: -50px;
    margin-top: -50px;
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;absolute + auto margin&lt;/strong&gt;&lt;br&gt;
这种方法兼容性也很好，缺点是需要知道子元素的宽高&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
  .out{
    position: relative;
    width: 300px;
    height: 300px;
    background: red;
  }

  .inner{
    position: absolute;
    width: 100px;
    height: 100px;
    background: yellow;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    margin: auto;
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;absolute + calc&lt;/strong&gt;&lt;br&gt;
这种方法的兼容性依赖于 calc，且也需要知道宽高&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
  .out{
    position: relative;
    width: 300px;
    height: 300px;
    background: red;
  }

  .inner{
    position: absolute;
    width: 100px;
    height: 100px;
    background: yellow;
    left: calc(50% - 50px);
    top: calc(50% - 50px);
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;absolute + transform&lt;/strong&gt;&lt;br&gt;
兼容性依赖 translate，不需要知道子元素宽高&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
  .out{
    position: relative;
    width: 300px;
    height: 300px;
    background: red;
  }

  .inner{
    position: absolute;
    background: yellow;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;table&lt;/strong&gt;&lt;br&gt;
css新增的table属性，可以让我们把普通元素，变为table元素的显示效果，通过这个特性也可以实现水平垂直居中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种方法兼容性也不错。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
  .out{
    display: table-cell;
    width: 300px;
    height: 300px;
    text-align: center;
    vertical-align: middle;
    background: red;
  }

  .inner{
    display: inline-block;
    background: yellow;
    width: 100px;
    height: 100px;
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;strong&gt;flex&lt;/strong&gt;&lt;br&gt;
flex 实现起来比较简单，三行代码即可搞定。可通过父元素指定子元素的对齐方式，也可通过 子元素自己指定自己的对齐方式来实现。第二种方式见 grid 布局。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
  .out{
    display: flex;
    justify-content: center;
    align-items: center;
    width: 300px;
    height: 300px;
    background: red;
  }

  .inner{
    background: yellow;
    width: 100px;
    height: 100px;
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;&lt;strong&gt;grid&lt;/strong&gt;&lt;br&gt;
grid 布局也很强大，大体上属性跟 flex 差不多。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
  .out{
    display: grid;
    width: 300px;
    height: 300px;
    background: red;
  }

  .inner{
    background: yellow;
    width: 100px;
    height: 100px;
    align-self: center;
    justify-self: center;
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;页面布局小结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语义化掌握到位&lt;/li&gt;
&lt;li&gt;页面布局理解深刻&lt;/li&gt;
&lt;li&gt;CSS基础知识扎实&lt;/li&gt;
&lt;li&gt;思维灵活且积极上进&lt;/li&gt;
&lt;li&gt;代码书写规范&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;8-响应式布局&#34;&gt;8. 响应式布局&lt;/h1&gt;
&lt;p&gt;响应式设计与自适应设计的区别：响应式开发一套界面，通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容；自适应需要开发多套界面，通过检测视口分辨率，来判断当前访问的设备是pc端、平板、手机，从而请求服务层，返回不同的页面。&lt;/p&gt;
&lt;h2 id=&#34;81-媒体查询&#34;&gt;8.1 媒体查询&lt;/h2&gt;
&lt;p&gt;CSS3媒体查询可以让我们针对不同的媒体类型定义不同的样式，当重置浏览器窗口大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。&lt;/p&gt;
&lt;p&gt;不管是移动优先还是PC优先，都是依据当随着屏幕宽度增大或减小的时候，后面的样式会覆盖前面的样式。因此，移动端优先首先使用的是min-width，PC端优先使用的max-width。&lt;/p&gt;
&lt;h2 id=&#34;82-百分比布局&#34;&gt;8.2 百分比布局&lt;/h2&gt;
&lt;p&gt;通过百分比单位，可以使得浏览器中组件的宽和高随着浏览器的高度的变化而变化，从而实现响应式的效果。Bootstrap里面的栅格系统就是利用百分比来定义元素的宽高，CSS3支持最大最小高，可以将百分比和max(min)一起结合使用来定义元素在不同设备下的宽高。&lt;/p&gt;
&lt;p&gt;计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。&lt;/p&gt;
&lt;p&gt;各个属性中如果使用百分比，相对父元素的属性并不是唯一的。比如width和height相对于父元素的width和height，而margin、padding不管垂直还是水平方向都相对比父元素的宽度、border-radius则是相对于元素自身等等，造成我们使用百分比单位容易使布局问题变得复杂。&lt;/p&gt;
&lt;h2 id=&#34;83-rem布局&#34;&gt;8.3 rem布局&lt;/h2&gt;
&lt;p&gt;REM是CSS3新增的单位，并且移动端的支持度很高，Android2.x+,ios5+都支持。rem单位都是相对于根元素html的font-size来决定大小的,根元素的font-size相当于提供了一个基准，当页面的size发生变化时，只需要改变font-size的值，那么以rem为固定单位的元素的大小也会发生响应的变化。 因此，如果通过rem来实现响应式的布局，只需要根据视图容器的大小，动态的改变font-size即可（而em是相对于父元素的）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rem响应式的布局思想：&lt;/strong&gt;&lt;br&gt;
一般不要给元素设置具体的宽度，但是对于一些小图标可以设定具体宽度值&lt;/p&gt;
&lt;p&gt;高度值可以设置固定值，设计稿有多大，我们就严格有多大&lt;/p&gt;
&lt;p&gt;所有设置的固定值都用rem做单位（首先在HTML总设置一个基准值：px和rem的对应比例，然后在效果图上获取px值，布局的时候转化为rem值)&lt;/p&gt;
&lt;p&gt;js获取真实屏幕的宽度，让其除以设计稿的宽度，算出比例，把之前的基准值按照比例进行重新的设定，这样项目就可以在移动端自适应了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rem布局的缺点：&lt;/strong&gt;&lt;br&gt;
在响应式布局中，必须通过js来动态控制根元素font-size的大小，也就是说css样式和js代码有一定的耦合性，且必须将改变font-size的代码放在css样式之前&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;REM布局也是目前多屏幕适配的最佳方式&lt;/strong&gt;。默认情况下我们html标签的font-size为16px,我们利用媒体查询，设置在不同设备下的字体大小。&lt;/p&gt;
&lt;h2 id=&#34;84-视口单位&#34;&gt;8.4 视口单位&lt;/h2&gt;
&lt;p&gt;css3中引入了一个新的单位vw/vh，与视图窗口有关，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。各个单位具体的含义如下：&lt;/p&gt;
&lt;p&gt;用视口单位度量，视口宽度为100vw，高度为100vh（左侧为竖屏情况，右侧为横屏情况）。例如，在桌面端浏览器视口尺寸为650px，那么 1vw = 650 * 1% = 6.5px（这是理论推算的出，如果浏览器不支持0.5px，那么实际渲染结果可能是7px）。&lt;/p&gt;
&lt;p&gt;使用视口单位来实现响应式有两种做法：&lt;/p&gt;
&lt;p&gt;1.仅使用vw作为CSS单位&lt;br&gt;
2.搭配vw和rem&lt;/p&gt;
&lt;h2 id=&#34;85-图片响应式&#34;&gt;8.5 图片响应式&lt;/h2&gt;
&lt;p&gt;这里的图片响应式包括两个方面，一个就是大小自适应，这样能够保证图片在不同的屏幕分辨率下出现压缩、拉伸的情况；一个就是根据不同的屏幕分辨率和设备像素比来尽可能选择高分辨率的图片，也就是当在小屏幕上不需要高清图或大图，这样我们用小图代替，就可以减少网络带宽了。&lt;/p&gt;
&lt;p&gt;1.使用max-width（图片自适应）:&lt;br&gt;
图片自适应意思就是图片能随着容器的大小进行缩放&lt;/p&gt;
&lt;p&gt;2.使用srcset    &amp;lt;img srcset=&amp;quot;photo_w350.jpg 1x, photo_w640.jpg 2x&amp;quot; src=&amp;quot;photo_w350.jpg&amp;quot; alt=&amp;quot;&amp;quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;3.使用background-image&lt;/p&gt;
&lt;p&gt;4.使用picture标签&lt;/p&gt;
&lt;h2 id=&#34;86响应式布局的要点&#34;&gt;8.6响应式布局的要点&lt;/h2&gt;
&lt;p&gt;在实际项目中，我们可能需要综合上面的方案，比如用rem来做字体的适配，用srcset来做图片的响应式，宽度可以用rem，flex，栅格系统等来实现响应式，然后可能还需要利用媒体查询来作为响应式布局的基础，因此综合上面的实现方案，项目中实现响应式布局需要注意下面几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置viewport&lt;/li&gt;
&lt;li&gt;媒体查询&lt;/li&gt;
&lt;li&gt;字体的适配（字体单位）&lt;/li&gt;
&lt;li&gt;百分比布局&lt;/li&gt;
&lt;li&gt;图片的适配（图片的响应式）&lt;/li&gt;
&lt;li&gt;结合flex，grid，BFC，栅格系统等已经成型的方案&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;9-css预处理后处理&#34;&gt;9. css预处理，后处理&lt;/h1&gt;
&lt;h2 id=&#34;91-css-预处理器&#34;&gt;9.1 CSS 预处理器&lt;/h2&gt;
&lt;p&gt;CSS 预处理器用一种专门的编程语言，进行 Web 页面样式设计，然后再编译成正常的 CSS 文件，以供项目使用。&lt;strong&gt;CSS 预处理器为 CSS 增加一些编程的特性，无需考虑浏览器的兼容性问题。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CSS语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器；&lt;/li&gt;
&lt;li&gt;没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Sass、LESS、Stylus 是目前最主流的 CSS 预处理器。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现原理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取到 &lt;strong&gt;DSL&lt;/strong&gt; 源代码 的 &lt;strong&gt;分析树&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将含有 &lt;strong&gt;动态生成&lt;/strong&gt; 相关节点的 &lt;strong&gt;分析树&lt;/strong&gt; 转换为 &lt;strong&gt;静态分析树&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将 &lt;strong&gt;静态分析树&lt;/strong&gt; 转换为 CSS 的 &lt;strong&gt;静态分析树&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将 CSS 的** 静态分析树** 转换为 &lt;strong&gt;CSS 代码&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现实中的 &lt;strong&gt;CSS 预处理器&lt;/strong&gt; 更复杂一点儿，因为大多功能要同时支持 &lt;strong&gt;特有 DSL 与 原生 CSS&lt;/strong&gt;，一件事情要同时考虑两种情况下的处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：语言级逻辑处理，动态特性，改善项目结构&lt;/li&gt;
&lt;li&gt;缺点：采用特殊语法，框架耦合度高，复杂度高&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;92-css-后处理器&#34;&gt;9.2 CSS 后处理器&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;CSS 后处理器&lt;/strong&gt; 是对 CSS 进行处理，并最终生成 CSS 的 &lt;code&gt;预处理器&lt;/code&gt;，它属于广义上的 &lt;strong&gt;CSS 预处理器&lt;/strong&gt;。 我们很久以前就在用 &lt;strong&gt;CSS 后处理器&lt;/strong&gt; 了，最典型的例子是 &lt;strong&gt;CSS 压缩工具&lt;/strong&gt;（如 &lt;code&gt;clean-css&lt;/code&gt;），只不过以前没单独拿出来说过。 还有最近比较火的 &lt;code&gt;Autoprefixer&lt;/code&gt;，以 Can I Use 上的 &lt;strong&gt;浏览器支持数据&lt;/strong&gt;为基础，自动处理兼容性问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现原理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 &lt;strong&gt;源代码&lt;/strong&gt; 做为 &lt;strong&gt;CSS&lt;/strong&gt; 解析，获得 &lt;strong&gt;分析树&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;对 &lt;strong&gt;CSS&lt;/strong&gt; 的 &lt;strong&gt;分析树&lt;/strong&gt; 进行 &lt;strong&gt;后处理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将 &lt;strong&gt;CSS&lt;/strong&gt; 的 &lt;strong&gt;分析树&lt;/strong&gt; 转换为 &lt;strong&gt;CSS 代码&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;优缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：使用 CSS 语法，容易进行模块化，贴近 CSS 的未来标准&lt;/li&gt;
&lt;li&gt;缺点：逻辑处理能力有限&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;10-css3新特性&#34;&gt;10. css3新特性&lt;/h1&gt;
&lt;h2 id=&#34;1-transition的属性&#34;&gt;1. transition的属性&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;CSS3的过渡功能就像是一种黄油，可以让CSS的一些变化变得平滑。因为原生的CSS过渡在客户端需要处理的资源要比用JavaScript和Flash少的多，所以才会更平滑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614826493004.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;transition-property&lt;br&gt;
不是所有属性都能过渡，只有属性具有一个中间点值才具备过渡效果。&lt;/li&gt;
&lt;li&gt;transition-duration&lt;br&gt;
指定从一个属性到另一个属性过渡所要花费的时间。默认值为0，为0时，表示变化是瞬时的，看不到过渡效果。&lt;/li&gt;
&lt;li&gt;transiton-timing-function&lt;br&gt;
过渡函数，有如下几种：&lt;br&gt;
liner ：匀速&lt;br&gt;
ease-in：减速&lt;br&gt;
ease-out：加速&lt;br&gt;
ease-in-out：先加速再减速&lt;br&gt;
cubic-bezier：三次贝塞尔曲线&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;触发过渡&lt;/code&gt;&lt;br&gt;
单纯的代码不会触发任何过渡操作，需要通过用户的行为（如点击，悬浮等）触发，可触发的方式有：&lt;br&gt;
&lt;strong&gt;:hoever :focus :checked 媒体查询触发 JavaScript触发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;局限性&lt;/code&gt;&lt;br&gt;
transition的优点在于简单易用，但是它有几个很大的局限。 &lt;br&gt;
（1）transition需要事件触发，所以没法在网页加载时自动发生。 &lt;br&gt;
（2）transition是一次性的，不能重复发生，除非一再触发。 &lt;br&gt;
（3）transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。 &lt;br&gt;
（4）一条transition规则，只能定义一个属性的变化，不能涉及多个属性。 &lt;br&gt;
CSS Animation就是为了解决这些问题而提出的。&lt;/p&gt;
&lt;h2 id=&#34;2-animation的属性&#34;&gt;2. animation的属性&lt;/h2&gt;
&lt;p&gt;CSS3的animation属性可以像Flash制作动画一样，通过控制关键帧来控制动画的每一步，实现更为复杂的动画效果。ainimation实现动画效果主要由两部分组成：&lt;br&gt;
1）通过类似Flash动画中的帧来声明一个动画；&lt;br&gt;
2）在animation属性中调用关键帧声明的动画。&lt;br&gt;
&lt;code&gt;动画属性&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614826993212.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
（1）animation-name：none为默认值，将没有任何动画效果，其可以用来覆盖任何动画 &lt;br&gt;
（2）animation-duration：默认值为0，意味着动画周期为0，也就是没有任何动画效果 &lt;br&gt;
（3）animation-timing-function：与transition-timing-function一样 &lt;br&gt;
（4）animation-delay：在开始执行动画时需要等待的时间 &lt;br&gt;
（5）animation-iteration-count：定义动画的播放次数，默认为1，如果为infinite，则无限次循环播放 &lt;br&gt;
（6）animation-direction：默认为nomal，每次循环都是向前播放，（0-100），另一个值为alternate，动画播放为偶数次则向前播放，如果为基数词就反方向播放 &lt;br&gt;
（7）animation-state：默认为running，播放，paused，暂停 &lt;br&gt;
（8）animation-fill-mode：定义动画开始之前和结束之后发生的操作，默认值为none，动画结束时回到动画没开始时的状态；forwards，动画结束后继续应用最后关键帧的位置，即保存在结束状态；backwards，让动画回到第一帧的状态；both：轮流应用forwards和backwards规则。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@keyframes&lt;/code&gt;&lt;br&gt;
CSS3的animation制作动画效果主要包括两部分：1. 用关键帧声明一个动画，2.在animation调用关键帧声明的的动画。&lt;/p&gt;
&lt;h2 id=&#34;3区别&#34;&gt;3.区别&lt;/h2&gt;
&lt;p&gt;animation属性类似于transition，他们都是随着时间改变元素的属性值，其主要区别在于：transition需要触发一个事件才会随着时间改变其CSS属性；animation在不需要触发任何事件的情况下，也可以显式的随时间变化来改变元素CSS属性，达到一种动画的效果。&lt;/p&gt;
">【面】前端知识点梳理（CSS上）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/javascript-shi-xian-pai-xu-suan-fa/"" data-c="
          &lt;h1 id=&#34;1大o表示法&#34;&gt;1.大O表示法&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;大O表示法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在计算机中采用&lt;strong&gt;粗略的度量&lt;/strong&gt;来描述计算机算法的&lt;strong&gt;效率&lt;/strong&gt;，这种方法被称为**“大O”表示法**&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;数据项个数&lt;/strong&gt;发生改变时，&lt;strong&gt;算法的效率&lt;/strong&gt;也会跟着改变。所以说算法A比算法B快两倍，这样的比较是&lt;strong&gt;没有意义&lt;/strong&gt;的。&lt;/li&gt;
&lt;li&gt;因此我们通常使用&lt;strong&gt;算法的速度&lt;/strong&gt;随着&lt;strong&gt;数据量的变化&lt;/strong&gt;会如何变化的方式来表示算法的效率，大O表示法就是方式之一。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;常见的大O表示形式&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;符号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;名称&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;O(1)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;常数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;O(log(n))&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;O(n)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;线性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;O(nlog(n))&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;线性和对数乘积&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;O(n²)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;平方&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;O(2n)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;指数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;不同大O形式的时间复杂度：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614691100516.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到效率从大到小分别是：O(1)&amp;gt;O(logn)&amp;gt; O(n)&amp;gt; O(nlog(n))&amp;gt;O(n²)&amp;gt;O(2^n)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推导大O表示法的三条规则：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;规则一&lt;/strong&gt;：用常量1取代运行时间中所有的加法常量。如7 + 8 = 15，用1表示运算结果15，大O表示法表示为O（1）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规则二&lt;/strong&gt;：运算中只保留最高阶项。如N^3 + 3n +1，大O表示法表示为：O（N^3）;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规则三&lt;/strong&gt;：若最高阶项的常数不为1，可将其省略。如4N&lt;sup&gt;2，大O表示法表示为：O（N&lt;/sup&gt;2）;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2排序算法&#34;&gt;2.排序算法&lt;/h1&gt;
&lt;p&gt;这里主要介绍几种简单排序和高级排序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;简单排序&lt;/strong&gt;：冒泡排序、选择排序、插入排序；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高级排序&lt;/strong&gt;：希尔排序、快速排序；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此处创建一个列表类ArrayList并添加一些属性和方法，用于存放这些排序方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //创建列表类
    function ArrayList() {
      //属性
      this.array = []

      //方法
      //封装将数据插入到数组中方法
      ArrayList.prototype.insert = function(item){
        this.array.push(item)
      }

      //toString方法
      ArrayList.prototype.toString = function(){
        return this.array.join(&#39;-&#39;)
      }

      //交换两个位置的数据
      ArrayList.prototype.swap = function(m, n){
        let temp  = this.array[m]
        this.array[m] = this.array[n]
        this.array[n] = temp
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;21冒泡排序&#34;&gt;2.1.冒泡排序&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;冒泡排序的思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对未排序的各元素&lt;strong&gt;从头到尾&lt;/strong&gt;依次比较&lt;strong&gt;相邻的两个元素&lt;/strong&gt;大小关系；&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;左边的人员高&lt;/strong&gt;，则将两人&lt;strong&gt;交换位置&lt;/strong&gt;。比如1比2矮，不交换位置；&lt;/li&gt;
&lt;li&gt;向&lt;strong&gt;右移动一位&lt;/strong&gt;，继续比较2和3，最后比较 length - 1 和 length - 2这两个数据；&lt;/li&gt;
&lt;li&gt;当到达&lt;strong&gt;最右端&lt;/strong&gt;时，&lt;strong&gt;最高的人&lt;/strong&gt;一定被放在了&lt;strong&gt;最右边&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;按照这个思路，从最左端重新开始时，只需要走到&lt;strong&gt;倒数第二个位置&lt;/strong&gt;即可；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614691535117.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两层循环：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外层循环控制冒泡趟数：&lt;br&gt;
- 第一次：j = length - 1，比较到倒数第一个位置 ；&lt;br&gt;
- 第二次：j = length - 2，比较到倒数第二个位置 ；&lt;/li&gt;
&lt;li&gt;内层循环控制每趟比较的次数：&lt;br&gt;
- 第一次比较： i = 0，比较 0 和 1 位置的两个数据；&lt;br&gt;
- 最后一次比较：i = length - 2,比较length - 2和 length - 1两个数据；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详细过程如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614691654684.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
动态过程：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614691678173.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; //冒泡排序
      ArrayList.prototype.bubblesor = function(){
        //1.获取数组的长度
        let length = this.array.length

        //外层循环控制冒泡趟数
        for(let j = length - 1; j &amp;gt;= 0; j--){
          //内层循环控制每趟比较的次数
          for(let i = 0; i &amp;lt; j; i++){
          if (this.array[i] &amp;gt; this.array[i+1]) {
            //交换两个数据
            let temp  = this.array[i]
        	this.array[i] = this.array[i+1]
        	this.array[i+1] = temp
          }
        }
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; //测试类
    let list = new ArrayList()

    //插入元素
    list.insert(66)
    list.insert(88)
    list.insert(12)
    list.insert(87)
    list.insert(100)
    list.insert(5)
    list.insert(566)
    list.insert(23)
    
    //验证冒泡排序
    list.bubblesor()
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614691724569.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;冒泡排序的效率：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上面所讲的对于7个数据项，比较次数为：6 + 5 + 4 + 3 + 2 + 1;&lt;/li&gt;
&lt;li&gt;对于N个数据项，&lt;strong&gt;比较次数&lt;/strong&gt;为：(N - 1) + (N - 2) + (N - 3) + ... + 1 = N * (N - 1) / 2；如果两次比较交换一次，那么&lt;strong&gt;交换次数&lt;/strong&gt;为：N * (N - 1) / 4；&lt;/li&gt;
&lt;li&gt;使用大O表示法表示比较次数和交换次数分别为：O（ N * (N - 1) / 2）和O（ N * (N - 1) / 4），根据大O表示法的三条规则都化简为：&lt;strong&gt;O（N^2）&lt;/strong&gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;22选择排序&#34;&gt;2.2.选择排序&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;选择排序改进了冒泡排序：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将&lt;strong&gt;交换次数&lt;/strong&gt;由&lt;strong&gt;O（N^2）&lt;strong&gt;减小到&lt;/strong&gt;O（N）&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;但是&lt;strong&gt;比较次数&lt;/strong&gt;依然是&lt;strong&gt;O（N^2）&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;选择排序的思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选定&lt;strong&gt;第一个索引的位置&lt;/strong&gt;比如1，然后依次和后面的元素&lt;strong&gt;依次进行比较&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;如果后面的元素，&lt;strong&gt;小于&lt;/strong&gt;索引1位置的元素，则&lt;strong&gt;交换位置&lt;/strong&gt;到索引1处；&lt;/li&gt;
&lt;li&gt;经过一轮的比较之后，可以确定一开始指定的索引1位置的元素是&lt;strong&gt;最小的&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;随后使用同样的方法除索引1以外&lt;strong&gt;逐个比较剩下的元素&lt;/strong&gt;即可；&lt;/li&gt;
&lt;li&gt;可以看出选择排序，&lt;strong&gt;第一轮&lt;/strong&gt;会选出&lt;strong&gt;最小值&lt;/strong&gt;，&lt;strong&gt;第二轮&lt;/strong&gt;会选出&lt;strong&gt;第二小的值&lt;/strong&gt;，直到完成排序。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614691924469.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两层循环：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外层循环控制指定的索引：&lt;br&gt;
- 第一次：j = 0，指定第一个元素 ；&lt;br&gt;
- 最后一次：j = length - 1，指定最后一个元素 ；&lt;/li&gt;
&lt;li&gt;内层循环负责将指定索引（i）的元素与剩下（i - 1）的元素进行比较；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;动态过程：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614691958714.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; //选择排序
      ArrayList.prototype.selectionSort = function(){
        //1.获取数组的长度
        let length = this.array.length

        //2.外层循环：从0开始获取元素
        for(let j = 0; j &amp;lt; length - 1; j++){
          let min = j
          //内层循环：从i+1位置开始，和后面的元素进行比较
        for(let i = min + 1; i &amp;lt; length; i++){
          if (this.array[min] &amp;gt; this.array[i]) {
            min = i
          }
        }
        this.swap(min, j)
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  //测试类
    let list = new ArrayList()

    //插入元素
    list.insert(66)
    list.insert(88)
    list.insert(12)
    list.insert(87)
    list.insert(100)
    list.insert(5)
    list.insert(566)
    list.insert(23)
    
    //验证选择排序
    list.selectionSort()
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614691999487.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;选择排序的效率：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择排序的&lt;strong&gt;比较次数&lt;/strong&gt;为：N * (N - 1) / 2，用大O表示法表示为：&lt;strong&gt;O（N^2）&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;选择排序的&lt;strong&gt;交换次数&lt;/strong&gt;为：(N - 1) / 2，用大O表示法表示为：&lt;strong&gt;O（N）&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;所以选择排序的效率高于冒泡排序；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;23插入排序&#34;&gt;2.3.插入排序&lt;/h2&gt;
&lt;p&gt;插入排序是简单排序中效率最高的一种排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;插入排序的思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入排序思想的核心是&lt;strong&gt;局部有序&lt;/strong&gt;。如图所示，X左边的人称为&lt;strong&gt;局部有序&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;首先指定一数据X（从第一个数据开始），并将数据X的左边变成局部有序状态；&lt;/li&gt;
&lt;li&gt;随后将X右移一位，再次达到局部有序之后，继续右移一位，重复前面的操作直至X移至最后一个元素。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692091547.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
插入排序的详细过程：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692103001.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
动态过程：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692113197.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;   //插入排序
      ArrayList.prototype.insertionSort = function(){
        //1.获取数组的长度
        let length = this.array.length

        //2.外层循环:从第二个数据开始，向左边的已经局部有序数据进行插入
        for(let i = 1; i &amp;lt; length; i++){
          //3.内层循环：获取i位置的元素，使用while循环(重点)与左边的局部有序数据依次进行比较
          let temp = this.array[i]
          let j = i
          while(this.array[j - 1] &amp;gt; temp &amp;amp;&amp;amp; j &amp;gt; 0){
            this.array[j] = this.array[j - 1]//大的数据右移
            j--
          }
          //4.while循环结束后，index = j左边的数据变为局部有序且array[j]最大。此时将array[j]重置为排序前的数据array[i]，方便下一次for循环
          this.array[j] = temp
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试类
    let list = new ArrayList()

    //插入元素
    list.insert(66)
    list.insert(88)
    list.insert(12)
    list.insert(87)
    list.insert(100)
    list.insert(5)
    list.insert(566)
    list.insert(23)
    // console.log(list);

    //验证插入排序
    list.insertionSort()
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692171244.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;插入排序的效率：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;比较次数&lt;/strong&gt;：第一趟时，需要的最大次数为1；第二次最大为2；以此类推，最后一趟最大为N-1；所以，插入排序的总比较次数为N * (N - 1) / 2；但是，实际上每趟发现插入点之前，平均只有全体数据项的一半需要进行比较，所以比较次数为：&lt;strong&gt;N * (N - 1) / 4&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;交换次数&lt;/strong&gt;：指定第一个数据为X时交换0次，指定第二个数据为X最多需要交换1次，以此类推，指定第N个数据为X时最多需要交换N - 1次，所以一共需要交换N * (N - 1) / 2次，平均次数为&lt;strong&gt;N * (N - 1) / 2&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;虽然用大O表示法表示插入排序的效率也是&lt;strong&gt;O（N^2）&lt;/strong&gt;，但是插入排序整体操作次数更少，因此，在简单排序中，插入排序&lt;strong&gt;效率最高&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;24希尔排序&#34;&gt;2.4.希尔排序&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;希尔排序&lt;/strong&gt;是&lt;strong&gt;插入排序&lt;/strong&gt;的一种高效的&lt;strong&gt;改进版&lt;/strong&gt;，效率比插入排序要高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;希尔排序的历史背景：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;希尔排序按其设计者希尔（Donald Shell）的名字命名，该算法由&lt;strong&gt;1959年公布&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;希尔算法首次突破了计算机界一直认为的**算法的时间复杂度都是O（N^2）**的大关，为了纪念该算法里程碑式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;意义，用&lt;strong&gt;Shell&lt;/strong&gt;来命名该算法；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;插入排序的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设一个&lt;strong&gt;很小的数据项&lt;/strong&gt;在&lt;strong&gt;很靠近右端的位置&lt;/strong&gt;上，这里本应该是&lt;strong&gt;较大的数据项的位置&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;将这个&lt;strong&gt;小数据项移动到左边&lt;/strong&gt;的正确位置，所有的&lt;strong&gt;中间数据项都必须向右移动一位&lt;/strong&gt;，这样效率非常低；&lt;/li&gt;
&lt;li&gt;如果通过&lt;strong&gt;某种方式&lt;/strong&gt;，不需要&lt;strong&gt;一个个移动所有中间的数据项&lt;/strong&gt;，就能把较小的数据项移到左边，那么这个算法的执行速度就会有很大的改进。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;希尔排序的实现思路&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;希尔排序主要通过对数据进行&lt;strong&gt;分组&lt;/strong&gt;实现快速排序；&lt;/li&gt;
&lt;li&gt;根据设定的增量（gap）将数据分为gap个组（&lt;strong&gt;组数等于gap&lt;/strong&gt;），再在每个分组中进行局部排序；&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;假如有数组有10个数据，第1个数据为黑色，增量为5。那么第二个为黑色的数据index=5，第3个数据为黑色的数据index = 10（不存在）。所以黑色的数据每组只有2个，10 / 2 = 5一共可分5组，即&lt;strong&gt;组数等于增量gap&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;排序之后，减小增量，继续分组，再次进行局部排序，直到增量gap=1为止。随后只需进行微调就可完成数组的排序；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;具体过程如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排序之前的，储存10个数据的原始数组为：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692424549.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;设初始增量gap = length / 2 = 5，即数组被分为了5组，如图所示分别为：[8, 3]、[9, 5]、[1, 4]、[7, 6]、[2, 0]：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692441093.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;随后分别在每组中对数据进行局部排序，5组的顺序如图所示，变为：[3, 8]、[5, 9]、[1, 4]、[6, 7]、[0, 2]：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692472580.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;然后缩小增量gap = 5 / 2 = 2，即数组被分为了2组，如图所示分别为：[3，1，0，9，7]、[5，6，8，4，2]：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692484750.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;随后分别在每组中对数据进行局部排序，两组的顺序如图所示，变为：[0，1，3，7，9]、[2，4，5，6，8]：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692502384.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;然后然后缩小增量gap = 2 / 1 = 1，即数组被分为了1组，如图所示为：[0，2，1，4，3，5，7，6，9，8]：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692651803.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;最后只需要对该组数据进行插入排序即可完成整个数组的排序：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692674191.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
动态过程：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692702587.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
图中d表示增量gap。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;增量的选择：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原稿&lt;/strong&gt;中希尔建议的初始间距为&lt;strong&gt;N / 2&lt;/strong&gt;，比如对于N = 100的数组，增量序列为：50，25，12，6，3，1，可以发现不能整除时向下取整。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hibbard增量序列&lt;/strong&gt;：增量序列算法为：2^k - 1，即1，3，5，7... ...等；这种情况的最坏复杂度为O（N&lt;sup&gt;3/2）**,平均复杂度为**O（N&lt;/sup&gt;5/4）但未被证明；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sedgewcik增量序列&lt;/strong&gt;：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692851848.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下代码实现中采用希尔排序原稿中建议的增量即&lt;strong&gt;N / 2&lt;/strong&gt; 。&lt;br&gt;
&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   //希尔排序
      ArrayList.prototype.shellSort = function(){
        //1.获取数组的长度
        let length = this.array.length

        //2.初始化增量
        let gap = Math.floor(length / 2)

        //3.第一层循环：while循环(使gap不断减小)
        while(gap &amp;gt;= 1 ){
          //4.第二层循环：以gap为增量，进行分组，对分组进行插入排序
          //重点为：将index = gap作为选中的第一个数据
          for(let i = gap; i &amp;lt; length; i++){
            let temp = this.array[i]
            let j = i
            //5.第三层循环:寻找正确的插入位置
            while(this.array[j - gap] &amp;gt; temp &amp;amp;&amp;amp; j &amp;gt; gap - 1){
              this.array[j] = this.array[j - gap]
              j -= gap
            }
          //6.将j位置的元素设置为temp
          this.array[j] = temp
          }

          gap = Math.floor(gap / 2)
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里解释一下上述代码中的三层循环：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第一层循环&lt;/strong&gt;：while循环，控制gap递减到1；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二层循环&lt;/strong&gt;：分别取出根据g增量gap分成的gap组数据：将index = gap的数据作为选中的第一个数据，如下图所示，gap=5，则index = gap的数据为3，index = gap - 1的数据为8，两个数据为一组。随后gap不断加1右移，直到gap &amp;lt; length，此时实现了将数组分为5组。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692920473.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三层循环&lt;/strong&gt;：对每一组数据进行插入排序；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; //测试类
    let list = new ArrayList()

    //插入元素
    list.insert(66)
    list.insert(88)
    list.insert(12)
    list.insert(87)
    list.insert(100)
    list.insert(5)
    list.insert(566)
    list.insert(23)
    // console.log(list);

    //验证希尔排序
    list.shellSort()
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692964709.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;希尔排序的效率：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;希尔排序的效率和增量有直接关系，即使使用原稿中的增量效率都高于简单排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;25快速排序&#34;&gt;2.5.快速排序&lt;/h2&gt;
&lt;p&gt;快速排序的介绍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;快速排序&lt;/strong&gt;可以说是&lt;strong&gt;目前所有排序算法&lt;/strong&gt;中，&lt;strong&gt;最快&lt;/strong&gt;的一种排序算法。当然，没有任何一种算法是在任意情况下都是最优的。但是，大多数情况下快速排序是比较好的选择。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;快速排序&lt;/strong&gt;其实是&lt;strong&gt;冒泡排序&lt;/strong&gt;的升级版；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;快速排序的核心思想是&lt;strong&gt;分而治之&lt;/strong&gt;，先选出一个数据（比如65），将比其小的数据都放在它的左边，将比它大的数据都放在它的右边。这个数据称为&lt;strong&gt;枢纽&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和冒泡排序的不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们选择的65可以一次性将它放在最正确的位置，之后就不需要做任何移动；&lt;/li&gt;
&lt;li&gt;而冒泡排序即使已经找到最大值，也需要继续移动最大值，直到将它移动到最右边；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614693046918.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;快速排序的枢纽：&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第一种方案&lt;/strong&gt;：直接选择第一个元素作为枢纽。但是，当第一个元素就是最小值的情况下，效率不高；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二种方案&lt;/strong&gt;：使用随机数。随机数本身十分消耗性能，不推荐；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优秀的解决方法&lt;/strong&gt;：取index为头、中、位的三个数据排序后的中位数；如下图所示，按下标值取出的三个数据为：92，31，0，经排序后变为：0，31，92，取其中的中位数31作为&lt;strong&gt;枢纽&lt;/strong&gt;（当（length-1）/2不整除时可向下或向上取整）：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614693609653.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现枢纽选择：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//交换两个位置的数据
let swap = function(arr, m, n){
    let temp  = arr[m]
    arr[m] = arr[n]
    arr[n] = temp
}

//快速排序
//1.选择枢纽
let median = function(arr){
  //1.取出中间的位置
  let center = Math.floor(arr.length / 2)
  let right = arr.length - 1 
  let left = 0

  //2.判断大小并进行交换
  if (arr[left] &amp;gt; arr[center]) {
    swap(arr, left, center)
  }
  if (arr[center] &amp;gt; arr[right]){
    swap(arr, center, right)
  }
  if (arr[left] &amp;gt; arr[right]) {
    swap(arr, left, right)
  }
  //3.返回枢纽
  return center
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组经过获取枢纽函数操作之后，选出的3个下标值对应的数据位置变为：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614693640946.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;动态过程：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614693653899.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;快速排序代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//2.快速排序
let QuickSort = function(arr){
  if (arr.length == 0) {
    return []
  }
  let center = median(arr)
  let c = arr.splice(center, 1)
  let l = []
  let r = []

  for (let i = 0; i &amp;lt; arr.length; i++) {
      if (arr[i] &amp;lt; c) {
        l.push(arr[i])
      }else{
        r.push(arr[i])
      }        
  }
  return QuickSort(l).concat(c, QuickSort(r))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;算法的巧妙之处在于通过:&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;QuickSort(l).concat(c, QuickSort(r))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;递归调用&lt;code&gt;QuickSort&lt;/code&gt;函数实现了枢纽&lt;code&gt;Center&lt;/code&gt;左边数据&lt;code&gt;l&lt;/code&gt;和右边数据&lt;code&gt;r&lt;/code&gt;的排序；&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [0, 13, 81, 43, 31, 27, 56, 92]
console.log(QuickSort(arr));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614693906304.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快速排序的效率：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快速排序最坏情况下的效率：每次选择的枢纽都是最左边或最右边的数据，此时效率等同于冒泡排序，时间复杂度为&lt;strong&gt;O(n^2)&lt;/strong&gt;。可根据不同的枢纽选择避免这一情况；&lt;/li&gt;
&lt;li&gt;快速排序的平均效率：为&lt;strong&gt;O(N*logN)&lt;/strong&gt;，虽然其他算法效率也可达到O(N*logN)，但是其中快速排序是&lt;strong&gt;最好的&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av86801505?from=search&amp;amp;seid=4967761411915016256&#34;&gt;参考资料：JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现排序算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/javascript-shi-xian-tu-jie-gou/"" data-c="
          &lt;h1 id=&#34;1图论&#34;&gt;1.图论&lt;/h1&gt;
&lt;h2 id=&#34;11图的简介&#34;&gt;1.1.图的简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;什么是图？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;图结构&lt;/strong&gt;是一种与&lt;strong&gt;树结构&lt;/strong&gt;有些相似的数据结构；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;图论&lt;/strong&gt;是数学的一个分支，并且，在数学中，树是图的一种；&lt;/li&gt;
&lt;li&gt;图论以图为研究对象，研究&lt;strong&gt;顶点&lt;/strong&gt;和&lt;strong&gt;边&lt;/strong&gt;组成的&lt;strong&gt;图形&lt;/strong&gt;的数学理论和方法；&lt;/li&gt;
&lt;li&gt;主要的研究目的为：&lt;strong&gt;事物之间的联系&lt;/strong&gt;，&lt;strong&gt;顶点&lt;/strong&gt;代表&lt;strong&gt;事物&lt;/strong&gt;，&lt;strong&gt;边&lt;/strong&gt;代表两个事物间的&lt;strong&gt;关系&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;图的特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一组顶点&lt;/strong&gt;：通常用**V **（Vertex）表示顶点的集合；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一组边&lt;/strong&gt;：通常用 **E **（Edge）表示边的集合；&lt;br&gt;
1. 边是顶点和顶点之间的连线；&lt;br&gt;
2. 边可以是有向的，也可以是无向的。比如A----B表示无向，A ---&amp;gt; B 表示有向；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;图的常用术语：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;顶点&lt;/strong&gt;：表示图中的一个&lt;strong&gt;节点&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;边&lt;/strong&gt;：表示&lt;strong&gt;顶点和顶点&lt;/strong&gt;给之间的&lt;strong&gt;连线&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;相邻顶点&lt;/strong&gt;：由一条边连接在一起的顶点称为&lt;strong&gt;相邻顶点&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;度&lt;/strong&gt;：一个顶点的&lt;strong&gt;度&lt;/strong&gt;是&lt;strong&gt;相邻顶点的数量&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路径&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;简单路径：简单路径要求不包含重复的顶点；&lt;/li&gt;
&lt;li&gt;回路：第一个顶点和最后一个顶点&lt;strong&gt;相同&lt;/strong&gt;的路径称为回路；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无向图&lt;/strong&gt;：图中的所有边都是&lt;strong&gt;没有&lt;/strong&gt;方向的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有向图&lt;/strong&gt;：图中的所有边都是&lt;strong&gt;有&lt;/strong&gt;方向的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无权图&lt;/strong&gt;：无权图中的边没有任何权重意义；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;带权图&lt;/strong&gt;：带权图中的边有一定的权重含义；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12图的表示&#34;&gt;1.2.图的表示&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;邻接矩阵&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;表示图的常用方式为：&lt;strong&gt;邻接矩阵&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以使用二维数组来表示邻接矩阵；&lt;/li&gt;
&lt;li&gt;邻接矩阵让&lt;strong&gt;每个节点&lt;/strong&gt;和&lt;strong&gt;一个整数相关联&lt;/strong&gt;，该&lt;strong&gt;整数作为数组的下标值&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;使用一个&lt;strong&gt;二维数组&lt;/strong&gt;来表示顶点之间的&lt;strong&gt;连接&lt;/strong&gt;；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614605612152.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如上图所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二维数组中的0表示没有连线，1表示有连线；&lt;/li&gt;
&lt;li&gt;如：A[ 0 ] [ 3 ] = 1，表示 A 和 C 之间有连接；&lt;/li&gt;
&lt;li&gt;邻接矩阵的对角线上的值都为0，表示A - A ，B - B，等自回路都没有连接（自己与自己之间没有连接）；&lt;/li&gt;
&lt;li&gt;若为无向图，则邻接矩阵应为对角线上元素全为0的对称矩阵；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;邻接矩阵的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果图是一个&lt;strong&gt;稀疏图&lt;/strong&gt;，那么邻接矩阵中将存在&lt;strong&gt;大量的 0&lt;/strong&gt;，造成存储空间的浪费；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;邻接表&lt;/code&gt;&lt;br&gt;
另外一种表示图的常用方式为：&lt;strong&gt;邻接表。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邻接表由图中&lt;strong&gt;每个顶点&lt;/strong&gt;以及&lt;strong&gt;和顶点相邻的顶点列表&lt;/strong&gt;组成；&lt;/li&gt;
&lt;li&gt;这个列表可用多种方式存储，比如：**数组/链表/字典（哈希表）**等都可以；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614605685712.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如上图所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图中可清楚看到&lt;strong&gt;A&lt;/strong&gt;与&lt;strong&gt;B、C、D&lt;/strong&gt;相邻，假如要表示这些与A顶点相邻的顶点（边），可以通过将它们作为A的值（value）存入到对应的&lt;strong&gt;数组/链表/字典&lt;/strong&gt;中。&lt;/li&gt;
&lt;li&gt;之后，通过键（key）A可以十分方便地取出对应的数据；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;邻接表的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邻接表可以简单地得出&lt;strong&gt;出度&lt;/strong&gt;，即某一顶点指向其他顶点的个数；&lt;/li&gt;
&lt;li&gt;但是，邻接表计算&lt;strong&gt;入度&lt;/strong&gt;（指向某一顶点的其他顶点的个数称为该顶点的入度）十分困难。此时需要构造&lt;strong&gt;逆邻接表&lt;/strong&gt;才能有效计算入度；&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2封装图结构&#34;&gt;2.封装图结构&lt;/h1&gt;
&lt;p&gt;在实现过程中采用&lt;strong&gt;邻接表&lt;/strong&gt;的方式来表示边，使用&lt;strong&gt;字典类&lt;/strong&gt;来存储邻接表。&lt;/p&gt;
&lt;h2 id=&#34;21添加字典类和队列类&#34;&gt;2.1.添加字典类和队列类&lt;/h2&gt;
&lt;p&gt;首先需要引入之前实现的，之后会用到的字典类和队列类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//封装字典类
function Dictionary(){
  //字典属性
  this.items = {}

  //字典操作方法
  //一.在字典中添加键值对
  Dictionary.prototype.set = function(key, value){
    this.items[key] = value
  }

  //二.判断字典中是否有某个key
  Dictionary.prototype.has = function(key){
    return this.items.hasOwnProperty(key)
  }

  //三.从字典中移除元素
  Dictionary.prototype.remove = function(key){
    //1.判断字典中是否有这个key
    if(!this.has(key)) return false

    //2.从字典中删除key
    delete this.items[key]
    return true
  }

  //四.根据key获取value
  Dictionary.prototype.get = function(key){
    return this.has(key) ? this.items[key] : undefined
  }

  //五.获取所有keys
  Dictionary.prototype.keys = function(){
    return Object.keys(this.items)
  }

  //六.size方法
  Dictionary.prototype.keys = function(){
    return this.keys().length
  }

  //七.clear方法
  Dictionary.prototype.clear = function(){
    this.items = {}
  }
}

   // 基于数组封装队列类
    function Queue() {
    // 属性
      this.items = []
    // 方法
    // 1.将元素加入到队列中
    Queue.prototype.enqueue = element =&amp;gt; {
      this.items.push(element)
    }

    // 2.从队列中删除前端元素
    Queue.prototype.dequeue = () =&amp;gt; {
      return this.items.shift()
    }

    // 3.查看前端的元素
    Queue.prototype.front = () =&amp;gt; {
      return this.items[0]
    }

    // 4.查看队列是否为空
    Queue.prototype.isEmpty = () =&amp;gt; {
      return this.items.length == 0;
    }

    // 5.查看队列中元素的个数
    Queue.prototype.size = () =&amp;gt; {
      return this.items.length
    }

    // 6.toString方法
    Queue.prototype.toString = () =&amp;gt; {
      let resultString = &#39;&#39;
        for (let i of this.items){
          resultString += i + &#39; &#39;
        }
        return resultString
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;22创建图类&#34;&gt;2.2.创建图类&lt;/h2&gt;
&lt;p&gt;先创建图类Graph，并添加基本属性，再实现图类的常用方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //封装图类
    function Graph (){
      //属性：顶点(数组)/边(字典)
      this.vertexes = []  //顶点
      this.edges = new Dictionary() //边
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;23添加顶点与边&#34;&gt;2.3.添加顶点与边&lt;/h2&gt;
&lt;p&gt;如图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614685887261.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;创建一个数组对象vertexes存储图的顶点；创建一个字典对象edges存储图的边，其中key为顶点，value为存储key顶点相邻顶点的数组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     //添加方法
      //一.添加顶点
      Graph.prototype.addVertex = function(v){
        this.vertexes.push(v)
        this.edges.set(v, []) //将边添加到字典中，新增的顶点作为键，对应的值为一个存储边的空数组
      }
      //二.添加边
      Graph.prototype.addEdge = function(v1, v2){//传入两个顶点为它们添加边
        this.edges.get(v1).push(v2)//取出字典对象edges中存储边的数组，并添加关联顶点
        this.edges.get(v2).push(v1)//表示的是无向表，故要添加互相指向的两条边
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;24转换为字符串输出&#34;&gt;2.4.转换为字符串输出&lt;/h2&gt;
&lt;p&gt;为图类Graph添加toString方法，实现以邻接表的形式输出图中各顶点。&lt;br&gt;
&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; //三.实现toString方法:转换为邻接表形式
      Graph.prototype.toString = function (){
        //1.定义字符串，保存最终结果
        let resultString = &amp;quot;&amp;quot;

        //2.遍历所有的顶点以及顶点对应的边
        for (let i = 0; i &amp;lt; this.vertexes.length; i++) {//遍历所有顶点
          resultString += this.vertexes[i] + &#39;--&amp;gt;&#39;
          let vEdges = this.edges.get(this.vertexes[i])
          for (let j = 0; j &amp;lt; vEdges.length; j++) {//遍历字典中每个顶点对应的数组
            resultString += vEdges[j] + &#39;  &#39;;
          }
          resultString += &#39;\n&#39;
        }
        return resultString
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试代码
    //1.创建图结构
    let graph = new Graph()

    //2.添加顶点
    let myVertexes = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;]
    for (let i = 0; i &amp;lt; myVertexes.length; i++) {
      graph.addVertex(myVertexes[i])
    }

    //3.添加边
    graph.addEdge(&#39;A&#39;, &#39;B&#39;)
    graph.addEdge(&#39;A&#39;, &#39;C&#39;)
    graph.addEdge(&#39;A&#39;, &#39;D&#39;)
    graph.addEdge(&#39;C&#39;, &#39;D&#39;)
    graph.addEdge(&#39;C&#39;, &#39;G&#39;)
    graph.addEdge(&#39;D&#39;, &#39;G&#39;)
    graph.addEdge(&#39;D&#39;, &#39;H&#39;)
    graph.addEdge(&#39;B&#39;, &#39;E&#39;)
    graph.addEdge(&#39;B&#39;, &#39;F&#39;)
    graph.addEdge(&#39;E&#39;, &#39;I&#39;)

    //4.输出结果
    console.log(graph.toString());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614686639566.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;25图的遍历&#34;&gt;2.5.图的遍历&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;图的遍历思想：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图的遍历思想与树的遍历思想一样，意味着需要将图中&lt;strong&gt;所有的顶点&lt;/strong&gt;都访问一遍，并且不能有&lt;strong&gt;重复的访问&lt;/strong&gt;（上面的toString方法会重复访问）；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;遍历图的两种算法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;广度优先搜索（Breadth - First Search，简称&lt;strong&gt;BFS&lt;/strong&gt;）;&lt;/li&gt;
&lt;li&gt;深度优先搜索（Depth - First Search，简称&lt;strong&gt;DFS&lt;/strong&gt;）;&lt;/li&gt;
&lt;li&gt;两种遍历算法都需要指定&lt;strong&gt;第一个被访问的顶点&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了记录顶点是否被访问过，使用&lt;strong&gt;三种颜色&lt;/strong&gt;来表示它们的状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;白色&lt;/strong&gt;：表示该顶点还没有被访问过；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;灰色&lt;/strong&gt;：表示该顶点被访问过，但其相邻顶点并未完全被访问过；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;黑色&lt;/strong&gt;：表示该顶点被访问过，且其所有相邻顶点都被访问过；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先封装initializeColor方法将图中的所有顶点初始化为白色，代码实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //四.初始化状态颜色
      Graph.prototype.initializeColor = function(){
        let colors = []
        for (let i = 0; i &amp;lt; this.vertexes.length; i++) {
           colors[this.vertexes[i]] = &#39;white&#39;;
        }
        return colors
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;广度优先搜索&lt;/code&gt;&lt;br&gt;
广度优先搜索算法的思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻顶点，就像一次访问图的一层；&lt;/li&gt;
&lt;li&gt;也可以说是&lt;strong&gt;先宽后深&lt;/strong&gt;地遍历图中的各个顶点；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614686757512.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于&lt;strong&gt;队列&lt;/strong&gt;可以简单地实现广度优先搜索算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先创建一个队列Q（尾部进，首部出）；&lt;/li&gt;
&lt;li&gt;调用封装的initializeColor方法将所有顶点初始化为白色；&lt;/li&gt;
&lt;li&gt;指定第一个顶点A，将A标注为灰色（被访问过的节点），并将A放入队列Q中；&lt;/li&gt;
&lt;li&gt;循环遍历队列中的元素，只要队列Q非空，就执行以下操作：&lt;br&gt;
1. 先将灰色的A从Q的首部取出；&lt;br&gt;
2. 取出A后，将A的所有未被访问过（白色）的相邻顶点依次从队列Q的尾部加入队列，并变为灰色。以此保证，灰色的相邻顶点不重复加入队列；&lt;br&gt;
3. A的全部相邻节点加入Q后，A变为黑色，在下一次循环中被移除Q外；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;       //五.实现广度搜索(BFS)
      //传入指定的第一个顶点和处理结果的函数
      Graph.prototype.bfs = function(initV, handler){
        //1.初始化颜色
        let colors = this.initializeColor()

        //2.创建队列
        let que = new Queue()

        //3.将顶点加入到队列中
        que.enqueue(initV)

        //4.循环从队列中取出元素，队列为空才停止
        while(!que.isEmpty()){
          //4.1.从队列首部取出一个顶点
          let v = que.dequeue()

          //4.2.从字典对象edges中获取和该顶点相邻的其他顶点组成的数组
          let vNeighbours = this.edges.get(v)

          //4.3.将v的颜色变为灰色
          colors[v] = &#39;gray&#39;

          //4.4.遍历v所有相邻的顶点vNeighbours,并且加入队列中
          for (let i = 0; i &amp;lt; vNeighbours.length; i++) {
            const a = vNeighbours[i];
            //判断相邻顶点是否被探测过，被探测过则不加入队列中；并且加入队列后变为灰色，表示被探测过
            if (colors[a] == &#39;white&#39;) {
              colors[a] = &#39;gray&#39;
              que.enqueue(a)
            }
          }

          //4.5.处理顶点v
          handler(v)

          //4.6.顶点v所有白色的相邻顶点都加入队列后，将顶点v设置为黑色。此时黑色顶点v位于队列最前面，进入下一次while循环时会被取出
          colors[v] = &#39;black&#39;
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下为指定的第一个顶点为A时的遍历过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如 a 图所示，将在字典edges中取出的与A相邻的且未被访问过的白色顶点B、C、D放入队列que中并变为灰色，随后将A变为黑色并移出队列；&lt;/li&gt;
&lt;li&gt;接着，如图 b 所示，将在字典edges中取出的与B相邻的且未被访问过的白色顶点E、F放入队列que中并变为灰色，随后将B变为黑色并移出队列；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614686915234.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;如 c 图所示，将在字典edges中取出的与C相邻的且未被访问过的白色顶点G（A，D也相邻不过已变为灰色，所以不加入队列）放入队列que中并变为灰色，随后将C变为黑色并移出队列；&lt;/li&gt;
&lt;li&gt;接着，如图 d 所示，将在字典edges中取出的与D相邻的且未被访问过的白色顶点H放入队列que中并变为灰色，随后将D变为黑色并移出队列。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614686933411.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如此循环直到队列中元素为0，即所有顶点都变黑并移出队列后才停止，此时图中顶点已被全部遍历。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   //测试代码
    //1.创建图结构
    let graph = new Graph()

    //2.添加顶点
    let myVertexes = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;]
    for (let i = 0; i &amp;lt; myVertexes.length; i++) {
      graph.addVertex(myVertexes[i])
    }

    //3.添加边
    graph.addEdge(&#39;A&#39;, &#39;B&#39;)
    graph.addEdge(&#39;A&#39;, &#39;C&#39;)
    graph.addEdge(&#39;A&#39;, &#39;D&#39;)
    graph.addEdge(&#39;C&#39;, &#39;D&#39;)
    graph.addEdge(&#39;C&#39;, &#39;G&#39;)
    graph.addEdge(&#39;D&#39;, &#39;G&#39;)
    graph.addEdge(&#39;D&#39;, &#39;H&#39;)
    graph.addEdge(&#39;B&#39;, &#39;E&#39;)
    graph.addEdge(&#39;B&#39;, &#39;F&#39;)
    graph.addEdge(&#39;E&#39;, &#39;I&#39;)
    
    //4.测试bfs遍历方法
    let result = &amp;quot;&amp;quot;
    graph.bfs(graph.vertexes[0], function(v){
      result += v + &amp;quot;-&amp;quot;
    })
    console.log(result);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614686966585.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可见，安装了广度优先搜索的顺序&lt;strong&gt;不重复&lt;/strong&gt;地遍历了&lt;strong&gt;所有&lt;/strong&gt;顶点。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;深度优先搜索&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;广度优先算法的思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;深度优先搜索算法将会从指定的第一个顶点开始遍历图，沿着一条路径遍历直到该路径的最后一个顶点都被访问过为止；&lt;/li&gt;
&lt;li&gt;接着沿原来路径回退并探索下一条路径，即&lt;strong&gt;先深后宽&lt;/strong&gt;地遍历图中的各个顶点；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614687004548.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以使用&lt;strong&gt;栈&lt;/strong&gt;结构来实现深度优先搜索算法；&lt;/li&gt;
&lt;li&gt;深度优先搜索算法的遍历顺序与二叉搜索树中的先序遍历较为相似，同样可以使用&lt;strong&gt;递归&lt;/strong&gt;来实现（递归的本质就是&lt;strong&gt;函数栈&lt;/strong&gt;的调用）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于递归实现深度优先搜索算法：定义dfs方法用于调用递归方法dfsVisit，定义dfsVisit方法用于递归访问图中的各个顶点。&lt;/p&gt;
&lt;p&gt;在dfs方法中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，调用initializeColor方法将所有顶点初始化为白色；&lt;/li&gt;
&lt;li&gt;然后，调用dfsVisit方法遍历图的顶点；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在dfsVisit方法中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，将传入的指定节点v标注为&lt;strong&gt;灰色&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;接着，处理顶点V；&lt;/li&gt;
&lt;li&gt;然后，访问V的相邻顶点；&lt;/li&gt;
&lt;li&gt;最后，将顶点v标注为黑色；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     //六.实现深度搜索(DFS)
      Graph.prototype.dfs = function(initV, handler){
        //1.初始化顶点颜色
        let colors = this.initializeColor()

        //2.从某个顶点开始依次递归访问
        this.dfsVisit(initV, colors, handler)
      }

      //为了方便递归调用，封装访问顶点的函数，传入三个参数分别表示：指定的第一个顶点、颜色、处理函数
      Graph.prototype.dfsVisit = function(v, colors, handler){
        //1.将颜色设置为灰色
        colors[v] = &#39;gray&#39;

        //2.处理v顶点
        handler(v)

        //3.访问V的相邻顶点
        let vNeighbours = this.edges.get(v)
        for (let i = 0; i &amp;lt; vNeighbours.length; i++) {
          let a = vNeighbours[i];
          //判断相邻顶点是否为白色，若为白色，递归调用函数继续访问
          if (colors[a] == &#39;white&#39;) {
            this.dfsVisit(a, colors, handler)
          }
          
        }

        //4.将v设置为黑色
        colors[v] = &#39;black&#39;
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里主要解释一下代码中的第3步操作：访问指定顶点的相邻顶点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以指定顶点A为例，先从储存顶点及其对应相邻顶点的字典对象edges中取出由顶点A的相邻顶点组成的数组：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614687096873.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第一步&lt;/strong&gt;：A顶点变为灰色，随后进入第一个for循环，遍历A白色的相邻顶点：B、C、D；在该for循环的第1次循环中（执行B），B顶点满足：colors == &amp;quot;white&amp;quot;，触发递归，重新调用该方法；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二步&lt;/strong&gt;：B顶点变为灰色，随后进入第二个for循环，遍历B白色的相邻顶点：E、F；在该for循环的第1次循环中（执行E），E顶点满足：colors == &amp;quot;white&amp;quot;，触发递归，重新调用该方法；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三步&lt;/strong&gt;：E顶点变为灰色，随后进入第三个for循环，遍历E白色的相邻顶点：I；在该for循环的第1次循环中（执行I），I顶点满足：colors == &amp;quot;white&amp;quot;，触发递归，重新调用该方法；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第四步&lt;/strong&gt;：I顶点变为灰色，随后进入第四个for循环，由于顶点I的相邻顶点E不满足：colors == &amp;quot;white&amp;quot;，停止递归调用。过程如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614687132186.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第五步&lt;/strong&gt;：递归结束后一路向上返回，首先回到第三个for循环中继续执行其中的第2、3...次循环，每次循环的执行过程与上面的同理，直到递归再次结束后，再返回到第二个for循环中继续执行其中的第2、3...次循环....以此类推直到将图的所有顶点访问完为止。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图为遍历图中各顶点的完整过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;发现&lt;/strong&gt;表示访问了该顶点，状态变为&lt;strong&gt;灰色&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;探索&lt;/strong&gt;表示既访问了该顶点，也访问了该顶点的全部相邻顶点，状态变为&lt;strong&gt;黑色&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;由于在顶点变为灰色后就调用了处理函数handler，所以handler方法的输出顺序为发现顶点的顺序即：A、B、E、I、F、C、D、G、H 。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614687185004.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   //测试代码
    //1.创建图结构
    let graph = new Graph()

    //2.添加顶点
    let myVertexes = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;]
    for (let i = 0; i &amp;lt; myVertexes.length; i++) {
      graph.addVertex(myVertexes[i])
    }

    //3.添加边
    graph.addEdge(&#39;A&#39;, &#39;B&#39;)
    graph.addEdge(&#39;A&#39;, &#39;C&#39;)
    graph.addEdge(&#39;A&#39;, &#39;D&#39;)
    graph.addEdge(&#39;C&#39;, &#39;D&#39;)
    graph.addEdge(&#39;C&#39;, &#39;G&#39;)
    graph.addEdge(&#39;D&#39;, &#39;G&#39;)
    graph.addEdge(&#39;D&#39;, &#39;H&#39;)
    graph.addEdge(&#39;B&#39;, &#39;E&#39;)
    graph.addEdge(&#39;B&#39;, &#39;F&#39;)
    graph.addEdge(&#39;E&#39;, &#39;I&#39;)
    
    //4.测试dfs遍历顶点
    let result = &amp;quot;&amp;quot;
    graph.dfs(graph.vertexes[0], function(v){
      result += v + &amp;quot;-&amp;quot;
    })
    console.log(result);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614687223502.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;26完整实现&#34;&gt;2.6.完整实现&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;    //封装图结构
    function Graph (){
      //属性：顶点(数组)/边(字典)
      this.vertexes = []  //顶点
      this.edges = new Dictionary() //边

      //方法
      //添加方法
      //一.添加顶点
      Graph.prototype.addVertex = function(v){
        this.vertexes.push(v)
        this.edges.set(v, []) //将边添加到字典中，新增的顶点作为键，对应的值为一个存储边的空数组
      }
      //二.添加边
      Graph.prototype.addEdge = function(v1, v2){//传入两个顶点为它们添加边
        this.edges.get(v1).push(v2)//取出字典对象edges中存储边的数组，并添加关联顶点
        this.edges.get(v2).push(v1)//表示的是无向表，故要添加互相指向的两条边
      }

      //三.实现toString方法:转换为邻接表形式
      Graph.prototype.toString = function (){
        //1.定义字符串，保存最终结果
        let resultString = &amp;quot;&amp;quot;

        //2.遍历所有的顶点以及顶点对应的边
        for (let i = 0; i &amp;lt; this.vertexes.length; i++) {//遍历所有顶点
          resultString += this.vertexes[i] + &#39;--&amp;gt;&#39;
          let vEdges = this.edges.get(this.vertexes[i])
          for (let j = 0; j &amp;lt; vEdges.length; j++) {//遍历字典中每个顶点对应的数组
            resultString += vEdges[j] + &#39;  &#39;;
          }
          resultString += &#39;\n&#39;
        }
        return resultString
      }

      //四.初始化状态颜色
      Graph.prototype.initializeColor = function(){
        let colors = []
        for (let i = 0; i &amp;lt; this.vertexes.length; i++) {
           colors[this.vertexes[i]] = &#39;white&#39;;
        }
        return colors
      }

      //五.实现广度搜索(BFS)
      //传入指定的第一个顶点和处理结果的函数
      Graph.prototype.bfs = function(initV, handler){
        //1.初始化颜色
        let colors = this.initializeColor()

        //2.创建队列
        let que = new Queue()

        //3.将顶点加入到队列中
        que.enqueue(initV)

        //4.循环从队列中取出元素
        while(!que.isEmpty()){
          //4.1.从队列中取出一个顶点
          let v = que.dequeue()

          //4.2.获取和顶点相相邻的其他顶点
          let vNeighbours = this.edges.get(v)

          //4.3.将v的颜色变为灰色
          colors[v] = &#39;gray&#39;

          //4.4.遍历v所有相邻的顶点vNeighbours,并且加入队列中
          for (let i = 0; i &amp;lt; vNeighbours.length; i++) {
            const a = vNeighbours[i];
            //判断相邻顶点是否被探测过，被探测过则不加入队列中；并且加入队列后变为灰色，表示被探测过
            if (colors[a] == &#39;white&#39;) {
              colors[a] = &#39;gray&#39;
              que.enqueue(a)
            }
          }

          //4.5.处理顶点v
          handler(v)

          //4.6.顶点v所有白色的相邻顶点都加入队列后，将顶点v设置为黑色。此时黑色顶点v位于队列最前面，进入下一次while循环时会被取出
          colors[v] = &#39;black&#39;
        }
      }

      //六.实现深度搜索(DFS)
      Graph.prototype.dfs = function(initV, handler){
        //1.初始化顶点颜色
        let colors = this.initializeColor()

        //2.从某个顶点开始依次递归访问
        this.dfsVisit(initV, colors, handler)
      }

      //为了方便递归调用，封装访问顶点的函数，传入三个参数分别表示：指定的第一个顶点、颜色、处理函数
      Graph.prototype.dfsVisit = function(v, colors, handler){
        //1.将颜色设置为灰色
        colors[v] = &#39;gray&#39;

        //2.处理v顶点
        handler(v)

        //3.访问v相连的其他顶点
        let vNeighbours = this.edges.get(v)
        for (let i = 0; i &amp;lt; vNeighbours.length; i++) {
          let a = vNeighbours[i];
          //判断相邻顶点是否为白色，若为白色，递归调用函数继续访问
          if (colors[a] == &#39;white&#39;) {
            this.dfsVisit(a, colors, handler)
          }
          
        }

        //4.将v设置为黑色
        colors[v] = &#39;black&#39;
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1x7411L7Q7?from=search&amp;amp;seid=3912456004602554239&#34;&gt;参考资料:JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现图结构</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/javascript-shi-xian-hong-hei-shu/"" data-c="
          &lt;h1 id=&#34;1红黑树的五条规则&#34;&gt;1.红黑树的五条规则&lt;/h1&gt;
&lt;p&gt;红黑树除了符合二叉搜索树的基本规则外，还添加了以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;规则1：节点是红色或黑色的&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规则2：根节点是黑色的；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规则3：每个叶子节点都是黑色的空节点（NIL节点）；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规则4：每个红色节点的两个子节点都是黑色的（从每个叶子到根的所有路径上不可能有两个连续的红色节点）；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规则5：从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点；&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614602841856.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;红黑树的相对平衡&lt;/strong&gt;&lt;br&gt;
前面5条规则的约束确保了以下红黑树的关键特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从&lt;strong&gt;根到叶子节点&lt;/strong&gt;的&lt;strong&gt;最长路径&lt;/strong&gt;，不会超过&lt;strong&gt;最短路径&lt;/strong&gt;的&lt;strong&gt;两倍&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;结果就是这棵树&lt;strong&gt;基本&lt;/strong&gt;是平衡的；&lt;/li&gt;
&lt;li&gt;虽然没有做到绝对的平衡，但是可以保证在最坏的情况下，该树依然是高效的；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么可以做到&lt;strong&gt;最长路径不超过最短路径的两倍&lt;/strong&gt;呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;性质4&lt;/strong&gt;决定了路径上不能有两个相连的红色节点；&lt;/li&gt;
&lt;li&gt;所以，最长路径一定是红色节点和黑色节点交替而成的；&lt;/li&gt;
&lt;li&gt;由于根节点和叶子节点都是黑色的，最短路径可能都是黑色节点，并且最长路径中一定是黑色节点多于红色节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性质5&lt;/strong&gt;决定了所有路径上都有相同数目的黑色节点；&lt;/li&gt;
&lt;li&gt;这就表明了没有路径能多于其他任何路径两倍长。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2红黑树的三种变换&#34;&gt;2.红黑树的三种变换&lt;/h1&gt;
&lt;p&gt;插入一个新节点时，有可能树不再平衡，可以通过三种方式的变换使树保持平衡：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;变色&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;左旋转&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;右旋转&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;21变色&#34;&gt;2.1.变色&lt;/h2&gt;
&lt;p&gt;为了重新符合红黑树的规则，需要把&lt;strong&gt;红色&lt;/strong&gt;节点变为&lt;strong&gt;黑色&lt;/strong&gt;，或者把&lt;strong&gt;黑色&lt;/strong&gt;节点变为&lt;strong&gt;红色&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;插入的&lt;strong&gt;新节点&lt;/strong&gt;通常都是&lt;strong&gt;红色节点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当插入的节点为&lt;strong&gt;红色&lt;/strong&gt;的时候，大多数情况&lt;strong&gt;不违反&lt;/strong&gt;红黑树的任何规则；&lt;/li&gt;
&lt;li&gt;而&lt;strong&gt;插入黑色节点&lt;/strong&gt;，必然会导致一条路径上多了一个&lt;strong&gt;黑色节点&lt;/strong&gt;，这是很难调整的；&lt;/li&gt;
&lt;li&gt;红色节点虽然可能导致&lt;strong&gt;红红相连&lt;/strong&gt;的情况，但是这种情况可以通过&lt;strong&gt;颜色调换&lt;/strong&gt;和&lt;strong&gt;旋转&lt;/strong&gt;来调整；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;22左旋转&#34;&gt;2.2.左旋转&lt;/h2&gt;
&lt;p&gt;以节点X为根&lt;strong&gt;逆时针&lt;/strong&gt;旋转二叉搜索树，使得父节点原来的位置被自己的右子节点替代，左子节点的位置被父节点替代；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604172318.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;详解：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，左旋转之后：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点X取代了节点a原来的位置；&lt;/li&gt;
&lt;li&gt;节点Y取代了节点X原来的位置；&lt;/li&gt;
&lt;li&gt;节点X的&lt;strong&gt;左子树&lt;/strong&gt; a 仍然是节点X的&lt;strong&gt;左子树&lt;/strong&gt;（这里X的左子树只有一个节点，有多个节点时同样适用，以下同理）；&lt;/li&gt;
&lt;li&gt;节点Y的&lt;strong&gt;右子树 &lt;strong&gt;c 仍然是节点Y的&lt;/strong&gt;右子树&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;节点Y的&lt;strong&gt;左子树&lt;/strong&gt; b 向&lt;strong&gt;左平移&lt;/strong&gt;成为了节点X的&lt;strong&gt;右子树&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外，二叉搜索树左旋转之后仍为二叉搜索树：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604239227.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;23右旋转&#34;&gt;2.3.右旋转&lt;/h2&gt;
&lt;p&gt;以节点X为根&lt;strong&gt;顺时针&lt;/strong&gt;旋转二叉搜索树，使得父节点原来的位置被自己的左子节点替代，右子节点的位置被父节点替代；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604262297.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;详解：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，右旋转之后：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点X取代了节点a原来的位置；&lt;/li&gt;
&lt;li&gt;节点Y取代了节点X原来的位置；&lt;/li&gt;
&lt;li&gt;节点X的&lt;strong&gt;右子树&lt;/strong&gt; a 仍然是节点X的&lt;strong&gt;右子树&lt;/strong&gt;（这里X的右子树虽然只有一个节点，但是多个节点时同样适用，以下同理）；&lt;/li&gt;
&lt;li&gt;节点Y的&lt;strong&gt;左子树&lt;/strong&gt; b 仍然是节点Y的&lt;strong&gt;左子树&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;节点Y的&lt;strong&gt;右子树 c 向右平移&lt;/strong&gt;成为了节点X的&lt;strong&gt;左子树&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外，二叉搜索树右旋转之后仍为二叉搜索树：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604315554.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3红黑树的插入操作&#34;&gt;3.红黑树的插入操作&lt;/h1&gt;
&lt;p&gt;首先需要明确，在保证满足红黑树5条规则的情况下，新插入的节点必然是&lt;strong&gt;红色节点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为了方便说明，规定以下四个节点：新插入节点为&lt;strong&gt;N&lt;/strong&gt;（Node），N的父节点为&lt;strong&gt;P&lt;/strong&gt;（Parent），P的兄弟节点为&lt;strong&gt;U&lt;/strong&gt;（Uncle），U的父节点为&lt;strong&gt;G&lt;/strong&gt;（Grandpa），如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604357068.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;31情况1&#34;&gt;3.1.情况1&lt;/h2&gt;
&lt;p&gt;当插入的新节点N位于树的根上时，没有父节点。&lt;/p&gt;
&lt;p&gt;这种情况下，只需要将红色节点变为黑色节点即可满足规则2 。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604378412.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;32情况2&#34;&gt;3.2.情况2&lt;/h2&gt;
&lt;p&gt;新界点N的父节点P为黑色节点，此时不需要任何变化。&lt;/p&gt;
&lt;p&gt;此时既满足规则4也满足规则5。尽管新节点是红色的，但是新节点N有两个黑色节点NIL，所以通向它的路径上黑色节点的个数依然相等，因此满足规则5 。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604403948.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;33情况3&#34;&gt;3.3.情况3&lt;/h2&gt;
&lt;p&gt;节点P为红色，节点U也为红色，此时节点G必为黑色，即&lt;strong&gt;父红叔红祖黑&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在这种情况下需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先将父节点P变为黑色；&lt;/li&gt;
&lt;li&gt;再将叔叔节点U变为黑色；&lt;/li&gt;
&lt;li&gt;最后将祖父节点G变为红色；&lt;/li&gt;
&lt;li&gt;即变为父黑叔黑祖红，如下图所示：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即变为&lt;strong&gt;父黑叔黑祖红&lt;/strong&gt;，如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604452528.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;可能出现的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;N的祖父节点G的父节点也可能是红色，这就违反了规则4，此时可以通过递归调整节点颜色；&lt;/li&gt;
&lt;li&gt;当递归调整到根节点时就需要旋转了，如下图节点A和节点B所示，具体情况后面会介绍；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604474905.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;34情况4&#34;&gt;3.4.情况4&lt;/h2&gt;
&lt;p&gt;节点P是红色节点，节点U是黑色节点，并且节点N为节点P的&lt;strong&gt;左子节点&lt;/strong&gt;，此时节点G一定是黑色节点，即&lt;strong&gt;父红叔黑祖黑&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在这种情况下需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先变色：将父节点P变为黑色，将祖父节点G变为红色；&lt;/li&gt;
&lt;li&gt;后旋转：以祖父节点G为根进行右旋转；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604502174.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;35情况5&#34;&gt;3.5.情况5&lt;/h2&gt;
&lt;p&gt;节点P是红色节点，节点U是黑色节点，并且节点N为节点P的&lt;strong&gt;右子节点&lt;/strong&gt;，此时节点G一定是黑色节点，即&lt;strong&gt;父红叔黑祖黑&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在这种情况下需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先以节点P为根进行左旋转，旋转后如图b所示；&lt;/li&gt;
&lt;li&gt;随后将&lt;strong&gt;红色&lt;/strong&gt;节点&lt;strong&gt;P&lt;/strong&gt;和&lt;strong&gt;黑色&lt;/strong&gt;节点&lt;strong&gt;B&lt;/strong&gt;看成一个整体的&lt;strong&gt;红色&lt;/strong&gt;节点&lt;strong&gt;N1&lt;/strong&gt;，将新插入的&lt;strong&gt;红色&lt;/strong&gt;节点&lt;strong&gt;N&lt;/strong&gt;看成&lt;strong&gt;红色&lt;/strong&gt;节点&lt;strong&gt;P1&lt;/strong&gt; 如图c所示。此时整体就转换为了情况4。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604584661.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接着可以按照情况4进行处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先变色：将N1节点的父节点P1变为黑色，将祖父节点G变为红色；&lt;/li&gt;
&lt;li&gt;后旋转：以祖父节点G为根进行右旋转，旋转后如图 e 所示；&lt;/li&gt;
&lt;li&gt;最后将节点N1和P1变换回来，完成节点N的插入，如图 f 所示；&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604622077.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;36案例&#34;&gt;3.6.案例&lt;/h2&gt;
&lt;p&gt;在二叉树中依次插入节点：10，9，8，7，6，5，4，3，2，1 。&lt;/p&gt;
&lt;p&gt;如果直接采用普通的二叉搜索树，节点全部插入后是这样的：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604643226.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;是一个严重的&lt;strong&gt;不平衡树&lt;/strong&gt;，相当于一个链表，不能体现出二叉搜索树的高效率。而按照红黑树的五条规则插入节点就能最大程度保证搜索二叉树是一棵&lt;strong&gt;平衡树&lt;/strong&gt;。以下为过程详解：&lt;strong&gt;为了方便解释省略了部分红黑树的叶子节点（NIL）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;插入10&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;符合&lt;strong&gt;情况1：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入节点10；&lt;/li&gt;
&lt;li&gt;将节点10的颜色变为黑色；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604704418.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;插入9&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;符合&lt;strong&gt;情况2&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不需要任何变化；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604750380.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;插入8&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;快速判断属于情况3还是情况4的方法：&lt;br&gt;
从新插入的节点N出发，按图示箭头经过的四个节点，若为&lt;strong&gt;红红黑红&lt;/strong&gt;3个红色节点则为情况3，若为&lt;strong&gt;红红黑黑&lt;/strong&gt;两个红色节点则为情况4；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604802506.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;符合&lt;strong&gt;情况4：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点9变成黑，祖父节点10变为红；&lt;/li&gt;
&lt;li&gt;以祖父节点为根进行右旋转；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604830569.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;插入7&lt;/code&gt;&lt;br&gt;
符合&lt;strong&gt;情况3&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点8和叔节点10变为黑，祖父节点9变为红；&lt;/li&gt;
&lt;li&gt;此时会出现问题：不符合规则2，即根节点不为黑，此时可以把以9为根节点的二叉搜索树当作一个整体作为一个新插入的节点N，而此时又符合情况1，只需要把9变回黑色即可。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604863568.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;插入6&lt;/code&gt;&lt;br&gt;
符合&lt;strong&gt;情况4：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点7变为黑，祖父节点8变为红；&lt;/li&gt;
&lt;li&gt;以祖父节点8为根进行右旋转；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604890220.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;插入5&lt;/code&gt;&lt;br&gt;
符合&lt;strong&gt;情况3&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点6和叔节点8变为黑，祖父节点7变为红；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604951192.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;插入4&lt;/code&gt;&lt;br&gt;
符合&lt;strong&gt;情况4&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点5变为黑，祖父节点6变为红；&lt;/li&gt;
&lt;li&gt;以祖父节点6为根进行右旋转；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604975864.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;插入3&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;第一次变换&lt;/strong&gt;：符合&lt;strong&gt;情况3&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点4和叔节点6变为黑，祖父节点5变为红；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;变换之后发现5和7为相连的两个红色节点，于是把以5为根的整个子树看成一个新插入的节点N1，再进行第二次变换。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614605014069.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二次变换&lt;/strong&gt;：符合&lt;strong&gt;情况4&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点7变为黑，祖父节点9变为红；&lt;/li&gt;
&lt;li&gt;以祖父节点9为根进行右旋转；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614605037802.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后复原N1得到变换后的红黑树：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614605062771.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;插入2&lt;/code&gt;&lt;br&gt;
符合&lt;strong&gt;情况4&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点3变为黑，祖父节点4变为红；&lt;/li&gt;
&lt;li&gt;以祖父节点4为根进行右旋转；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614605088621.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;插入1&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;第一次变换&lt;/strong&gt;：符合&lt;strong&gt;情况3&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点2和叔节点4变为黑，祖父节点3变为红；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;变换之后发现3和5为相连的两个红色节点，于是把以3为根的整个子树看成一个新插入的节点N1，再进行第二次变换。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614605114950.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二次变换&lt;/strong&gt;：符合&lt;strong&gt;情况3&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点5和叔节点9变为黑，祖父节点7变为红；即由图 b -&amp;gt; 图 c 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;变换之后发现根节点7为红色不符合规则2，所以把以7为根节点的红黑树看成一个新插入的节点N2，再进行第三次变换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三次变换&lt;/strong&gt;：符合&lt;strong&gt;情况1&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接将根节点7变为黑色即可。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614605156139.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由此，完成了1~10节点的插入，虽然没有遇到情况5，不过情况5经过左旋转的操作便可转换为情况4，原理一样。如下图所示，将这棵红黑树的叶子节点NIL补全之后，经检验满足红黑树的五条规则，并且基本属于&lt;strong&gt;平衡树&lt;/strong&gt;，效率较高。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614605184855.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;4红黑树的删除操作&#34;&gt;4.红黑树的删除操作&lt;/h1&gt;
&lt;p&gt;红黑树的删除操作结合了复杂的&lt;strong&gt;二叉树的删除操作&lt;/strong&gt;和复杂的&lt;strong&gt;红黑树的插入规则&lt;/strong&gt;，整体来说难度非常大，篇幅较长，这里暂不进行探讨。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av86801505?from=search&amp;amp;seid=4967761411915016256&#34;&gt;参考资料：JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现红黑树</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/javascript-shi-xian-shu-jie-gou-xia/"" data-c="
          &lt;h1 id=&#34;1二叉搜索树的封装&#34;&gt;1.二叉搜索树的封装&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;二叉树搜索树的基本属性&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;如图所示：二叉搜索树有四个最基本的属性：指向节点的&lt;strong&gt;根&lt;/strong&gt;（root），节点中的&lt;strong&gt;键&lt;/strong&gt;（key）、&lt;strong&gt;左指针&lt;/strong&gt;（right）、&lt;strong&gt;右指针&lt;/strong&gt;（right）。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431790313.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
所以，二叉搜索树中除了定义root属性外，还应定义一个节点内部类，里面包含每个节点中的left、right和key三个属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //封装二叉搜索树
    function BinarySearchTree(){

      //节点内部类
      function Node(key){
        this.key = key
        this.left = null
        this.right = null
      }

      //属性
      this.root = null
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;二叉搜索树的常见操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insert（key）：向树中插入一个新的键；&lt;/li&gt;
&lt;li&gt;search（key）：在树中查找一个键，如果节点存在，则返回true；如果不存在，则返回false；&lt;/li&gt;
&lt;li&gt;inOrderTraverse：通过中序遍历方式遍历所有节点；&lt;/li&gt;
&lt;li&gt;preOrderTraverse：通过先序遍历方式遍历所有节点；&lt;/li&gt;
&lt;li&gt;postOrderTraverse：通过后序遍历方式遍历所有节点；&lt;/li&gt;
&lt;li&gt;min：返回树中最小的值/键；&lt;/li&gt;
&lt;li&gt;max：返回树中最大的值/键；&lt;/li&gt;
&lt;li&gt;remove（key）：从树中移除某个键；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;11插入数据&#34;&gt;1.1.插入数据&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先根据传入的key创建节点对象；&lt;/li&gt;
&lt;li&gt;然后判断根节点是否存在，不存在时通过：this.root = newNode，直接把新节点作为二叉搜索树的根节点。&lt;/li&gt;
&lt;li&gt;若存在根节点则重新定义一个内部方法insertNode（）用于查找插入点。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    //insert方法:对外向用户暴露的方法
      BinarySearchTree.prototype.insert = function(key){
        //1.根据key创建节点
        let newNode = new Node(key)
          
        //2.判断根节点是否存在
        if (this.root == null) {
          this.root = newNode
          //根节点存在时
        }else {
          this.insertNode(this.root, newNode)
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;内部方法insertNode（）的实现思路:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据比较传入的两个节点，一直查找新节点适合插入的位置，直到成功插入新节点为止。&lt;/p&gt;
&lt;p&gt;当newNode.key &amp;lt; node.key向左查找:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：当node无左子节点时，直接插入：&lt;/li&gt;
&lt;li&gt;情况2：当node有左子节点时，递归调用insertNode(),直到遇到无左子节点成功插入newNode后，不再符合该情况，也就不再调用insertNode()，递归停止。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431894630.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当newNode.key &amp;gt;= node.key向右查找，与向左查找类似：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：当node无右子节点时，直接插入：&lt;/li&gt;
&lt;li&gt;情况2：当node有右子节点时，依然递归调用insertNode(),直到遇到传入insertNode方法的node无右子节点成功插入newNode为止：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431913325.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;insertNode()代码实现：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    //内部使用的insertNode方法:用于比较节点从左边插入还是右边插入
      BinarySearchTree.prototype.insertNode = function(node, newNode){
        //当newNode.key &amp;lt; node.key向左查找
/*----------------------分支1:向左查找--------------------------*/      
        if(newNode.key &amp;lt; node.key){
          //情况1：node无左子节点，直接插入
/*----------------------分支1.1--------------------------*/
          if (node.left == null) {
            node.left = newNode
          //情况2：node有左子节点，递归调用insertNode(),直到遇到无左子节点成功插入newNode后，不再符合该情况，也就不再调用insertNode()，递归停止。
/*----------------------分支1.2--------------------------*/
          }else{
            this.insertNode(node.left, newNode)
          }
        //当newNode.key &amp;gt;= node.key向右查找
/*-----------------------分支2:向右查找--------------------------*/        
        }else{
          //情况1：node无右子节点，直接插入
/*-----------------------分支2.1--------------------------*/ 
          if(node.right == null){
            node.right == newNode
          //情况2：node有右子节点，依然递归调用insertNode(),直到遇到无右子节点成功插入newNode为止
/*-----------------------分支2.2--------------------------*/ 
          }else{
            this.insertNode(node.right, newNode)
          }
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
为了更好理解以下列二叉搜索树为例：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431949845.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
想要上述的二叉搜索树（蓝色）中插入数据10：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先把key = 10 传入insert方法，由于存在根节点 9，所以直接调用insetNode方法，传入的参数：node = 9，newNode = 10；&lt;/li&gt;
&lt;li&gt;由于10 &amp;gt; 9，进入分支2，向右查找适合插入的位置；&lt;/li&gt;
&lt;li&gt;由于根节点 9 的右子节点存在且为 13 ，所以进入分支2.2，递归调用insertNode方法，传入的参数：node = 13，newNode = 10；&lt;/li&gt;
&lt;li&gt;由于 10 &amp;lt; 13 ，进入分支1，向左查找适合插入的位置；&lt;/li&gt;
&lt;li&gt;由于父节点 13 的左子节点存在且为11，所以进入分支1.2，递归调用insertNode方法，传入的参数：node = 11，newNode = 10；&lt;/li&gt;
&lt;li&gt;由于 10 &amp;lt; 11，进入分支1，向左查找适合插入的位置；&lt;/li&gt;
&lt;li&gt;由于父节点 11 的左子节点不存在，所以进入分支1.1，成功插入节点 10 。由于不符合分支1.2的条件所以不会继续调用insertNode方法，递归停止。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试代码
    //1.创建BinarySearchTree
    let bst = new BinarySearchTree()

    //2.插入数据
    bst.insert(11);
    bst.insert(7);
    bst.insert(15);
    bst.insert(5);
    bst.insert(9);
	console.log(bst);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应得到下图所示的二叉搜索树：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432007528.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试结果&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432014572.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;12遍历数据&#34;&gt;1.2.遍历数据&lt;/h2&gt;
&lt;p&gt;这里所说的树的遍历不仅仅针对二叉搜索树，而是适用于所有的二叉树。由于树结构不是线性结构，所以遍历方式有多种选择，常见的三种二叉树遍历方式为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先序遍历；&lt;/li&gt;
&lt;li&gt;中序遍历；&lt;/li&gt;
&lt;li&gt;后序遍历；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有层序遍历，使用较少。&lt;/p&gt;
&lt;h3 id=&#34;121先序遍历&#34;&gt;1.2.1.先序遍历&lt;/h3&gt;
&lt;p&gt;先序遍历的过程为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，遍历根节点；&lt;/li&gt;
&lt;li&gt;然后，遍历其左子树；&lt;/li&gt;
&lt;li&gt;最后，遍历其右子树；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432186175.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如上图所示，二叉树的节点遍历顺序为：A -&amp;gt; B -&amp;gt; D -&amp;gt; H -&amp;gt; I -&amp;gt; E -&amp;gt; C -&amp;gt; F -&amp;gt; G。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	  //先序遍历
      //掺入一个handler函数方便之后对得到的key进行处理
      BinarySearchTree.prototype.preOrderTraversal = function(handler){
        this.preOrderTraversalNode(this.root, handler)
      }

      //封装内部方法，对某个节点进行遍历
      BinarySearchTree.prototype.preOrderTraversalNode = function(node,handler){
        if (node != null) {
          //1.处理经过的节点
          handler(node.key)
/*----------------------递归1----------------------------*/
          //2.遍历左子树中的节点
          this.preOrderTraversalNode(node.left, handler)
/*----------------------递归2----------------------------*/
          //3.遍历右子树中的节点
          this.preOrderTraversalNode(node.right, handler)
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
以遍历以下二叉搜索树为例：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432234410.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先调用preOrderTraversal方法，在方法里再调用preOrderTraversalNode方法用于遍历二叉搜索树。在preOrderTraversalNode方法中，递归1负责遍历左子节点，递归2负责遍历右子节点。先执行递归1，执行过程如下图所示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;记：preOrderTraversalNode() 为 A()&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432256706.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看到一共递归调用了4次方法A，分别传入11、7、5、3，最后遇到null不满足 node != null 条件结束递归1；注意此时只是执行完最开始的递归1，并没有执行递归2，并且递归1执行到null停止后要一层层地往上返回，按顺序将调用的函数压出函数调用栈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于函数调用栈：之前的四次递归共把4个函数压入了函数调用栈，现在递归执行完了一层层地把函数压出栈。&lt;/p&gt;
&lt;p&gt;值得注意的是：每一层函数都只是执行完了递归1，当返回到该层函数时，比如A（3）要继续执行递归2遍历二叉搜索树中的右子节点；&lt;/p&gt;
&lt;p&gt;在执行递归2的过程中会不断调用方法A，并依次执行递归1和递归2，以此类推直到遇到null不满足 node != null 条件为止，才停止递归并一层层返回，如此循环。同理A（5）层、A（7）层、A（11）层都要经历上述循环，直到将二叉搜索树中的节点全部遍历完为止。&lt;/p&gt;
&lt;p&gt;具体过程如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432285791.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试代码
    //1.创建BinarySearchTree
    let bst = new BinarySearchTree()

    //2.插入数据
    bst.insert(11);
    bst.insert(7);
    bst.insert(15);
    bst.insert(5);
    bst.insert(3);
    bst.insert(9);
    bst.insert(8);
    bst.insert(10);
    bst.insert(13);
    bst.insert(12);
    bst.insert(14);
    bst.insert(20);
    bst.insert(18);
    bst.insert(25);
    bst.insert(6);
    
    //3.测试遍历
    let resultString = &amp;quot;&amp;quot;
    //掺入处理节点值的处理函数
    bst.preOrderTraversal(function(key){
      resultString += key + &amp;quot;-&amp;gt;&amp;quot;
    })
    alert(resultString)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应输出这样的顺序：11 -&amp;gt; 7 -&amp;gt; 5 -&amp;gt; 3 -&amp;gt; 6 -&amp;gt; 9 -&amp;gt; 8 -&amp;gt; 10 -&amp;gt; 15 -&amp;gt; 13 -&amp;gt;12 -&amp;gt; 14 -&amp;gt; 20 -&amp;gt; 18 -&amp;gt; 25 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432317782.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;122中序遍历&#34;&gt;1.2.2.中序遍历&lt;/h3&gt;
&lt;p&gt;实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，遍历其左子树；&lt;/li&gt;
&lt;li&gt;然后，遍历根（父）节点；&lt;/li&gt;
&lt;li&gt;最后，遍历其右子树；&lt;br&gt;
&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    //中序遍历
      BinarySearchTree.prototype.midOrderTraversal = function(handler){
        this.midOrderTraversalNode(this.root, handler)
      }

      BinarySearchTree.prototype.midOrderTraversalNode = function(node, handler){
        if (node != null) {
          //1.遍历左子树中的节点
          this.midOrderTraversalNode(node.left, handler)
          
          //2.处理节点
          handler(node.key)

          //3.遍历右子树中的节点
          this.midOrderTraversalNode(node.right, handler)
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
遍历的顺序应如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432386478.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先调用midOrderTraversal方法，在方法里再调用midOrderTraversalNode方法用于遍历二叉搜索树。先使用递归1遍历左子树中的节点；然后，处理父节点；最后，遍历右子树中的节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     //测试代码
    //1.创建BinarySearchTree
    let bst = new BinarySearchTree()

    //2.插入数据
    bst.insert(11);
    bst.insert(7);
    bst.insert(15);
    bst.insert(5);
    bst.insert(3);
    bst.insert(9);
    bst.insert(8);
    bst.insert(10);
    bst.insert(13);
    bst.insert(12);
    bst.insert(14);
    bst.insert(20);
    bst.insert(18);
    bst.insert(25);
    bst.insert(6);	
    
    //3.测试中序遍历
    let resultString2 =&amp;quot;&amp;quot;
    bst.midOrderTraversal(function(key){
      resultString2 += key + &amp;quot;-&amp;gt;&amp;quot;
    })
    alert(resultString2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出节点的顺序应为：3 -&amp;gt; 5 -&amp;gt; 6 -&amp;gt; 7 -&amp;gt; 8 -&amp;gt; 9 -&amp;gt; 10 -&amp;gt; 11 -&amp;gt; 12 -&amp;gt; 13 -&amp;gt; 14 -&amp;gt; 15 -&amp;gt; 18 -&amp;gt; 25-&amp;gt; 20 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432578638.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;123后续遍历&#34;&gt;1.2.3.后续遍历&lt;/h3&gt;
&lt;p&gt;实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，遍历其左子树；&lt;/li&gt;
&lt;li&gt;然后，遍历其右子树；&lt;/li&gt;
&lt;li&gt;最后，遍历根（父）节点；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //后序遍历
      BinarySearchTree.prototype.postOrderTraversal = function(handler){
        this.postOrderTraversalNode(this.root, handler)
      }

      BinarySearchTree.prototype.postOrderTraversalNode = function(node, handler){
        if (node != null) {
          //1.遍历左子树中的节点
          this.postOrderTraversalNode(node.left, handler)
          
          //2.遍历右子树中的节点
          this.postOrderTraversalNode(node.right, handler)

          //3.处理节点
          handler(node.key)
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
遍历的顺序应如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432643528.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先调用postOrderTraversal方法，在方法里再调用postOrderTraversalNode方法用于遍历二叉搜索树。先使用递归1遍历左子树中的节点；然后，遍历右子树中的节点；最后，处理父节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试代码
    //1.创建BinarySearchTree
    let bst = new BinarySearchTree()

    //2.插入数据
    bst.insert(11);
    bst.insert(7);
    bst.insert(15);
    bst.insert(5);
    bst.insert(3);
    bst.insert(9);
    bst.insert(8);
    bst.insert(10);
    bst.insert(13);
    bst.insert(12);
    bst.insert(14);
    bst.insert(20);
    bst.insert(18);
    bst.insert(25);
    bst.insert(6);
    
    //3.测试后序遍历
    let resultString3 =&amp;quot;&amp;quot;
    bst.postOrderTraversal(function(key){
      resultString3 += key + &amp;quot;-&amp;gt;&amp;quot;
    })
    alert(resultString3)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出节点的顺序应为：3 -&amp;gt; 6 -&amp;gt; 5 -&amp;gt; 8 -&amp;gt; 10 -&amp;gt; 9 -&amp;gt; 7 -&amp;gt; 12 -&amp;gt; 14 -&amp;gt; 13 -&amp;gt; 18 -&amp;gt; 25 -&amp;gt; 20 -&amp;gt; 15 -&amp;gt; 11 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432682849.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：以遍历根（父）节点的顺序来区分三种遍历方式。比如：先序遍历先遍历根节点、中序遍历第二遍历根节点、后续遍历最后遍历根节点。&lt;/p&gt;
&lt;h2 id=&#34;13查找数据&#34;&gt;1.3.查找数据&lt;/h2&gt;
&lt;h3 id=&#34;131查找最大值最小值&#34;&gt;1.3.1.查找最大值&amp;amp;最小值&lt;/h3&gt;
&lt;p&gt;在二叉搜索树中查找最值非常简单，最小值在二叉搜索树的最左边，最大值在二叉搜索树的最右边。只需要一直向左/右查找就能得到最值，如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432719664.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //寻找最大值
      BinarySearchTree.prototype.max = function () {
        //1.获取根节点
        let node = this.root
        //2.定义key保存节点值
        let key = null
        //3.依次向右不断查找，直到节点为null
        while (node != null) {
          key = node.key
          node = node.right
        }
        return key
      }

      //寻找最小值
      BinarySearchTree.prototype.min = function(){
         //1.获取根节点
         let node = this.root
        //2.定义key保存节点值
        let key = null
        //3.依次向左不断查找，直到节点为null
        while (node != null) {
          key = node.key
          node = node.left
        }
        return key
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试代码
    //1.创建BinarySearchTree
    let bst = new BinarySearchTree()

    //2.插入数据
    bst.insert(11);
    bst.insert(7);
    bst.insert(15);
    bst.insert(5);
    bst.insert(3);
    bst.insert(9);
    bst.insert(8);
    bst.insert(10);
    bst.insert(13);
    bst.insert(12);
    bst.insert(14);
    bst.insert(20);
    bst.insert(18);
    bst.insert(25);
    bst.insert(6);
    
    //4.测试最值
    console.log(bst.max());
    console.log(bst.min());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432766498.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;132查找特定值&#34;&gt;1.3.2.查找特定值&lt;/h3&gt;
&lt;p&gt;查找二叉搜索树当中的特定值效率也非常高。只需要从根节点开始将需要查找节点的key值与之比较，若&lt;strong&gt;node.key &amp;lt; root&lt;/strong&gt;则向左查找，若&lt;strong&gt;node.key &amp;gt; root&lt;/strong&gt;就向右查找，直到找到或查找到null为止。这里可以使用递归实现，也可以采用循环来实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //查找特定的key
      BinarySearchTree.prototype.search = function(key){
        //1.获取根节点
        let node = this.root

        //2.循环搜索key
        while(node != null){
          if (key &amp;lt; node.key) {
            //小于根(父)节点就往左边找
            node = node.left
            //大于根(父)节点就往右边找
          }else if(key &amp;gt; node.key){
            node = node.right
          }else{
            return true
          }
        } 
        return false
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试代码
    //1.创建BinarySearchTree
    let bst = new BinarySearchTree()

    //2.插入数据
    bst.insert(11);
    bst.insert(7);
    bst.insert(15);
    bst.insert(5);
    bst.insert(3);
    bst.insert(9);
    bst.insert(8);
    bst.insert(10);
    bst.insert(13);
    bst.insert(12);
    bst.insert(14);
    bst.insert(20);
    bst.insert(18);
    bst.insert(25);
    bst.insert(6);
    
    //3.测试搜索方法
    console.log(bst.search(24));//false
    console.log(bst.search(13));//true
    console.log(bst.search(2));//false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432854806.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;14删除数据&#34;&gt;1.4.删除数据&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;第一步&lt;/strong&gt;：先找到需要删除的节点，若没找到，则不需要删除；&lt;/p&gt;
&lt;p&gt;首先定义变量current用于保存需要删除的节点、变量parent用于保存它的父节点、变量isLeftChild保存current是否为parent的左节点，这样方便之后删除节点时改变相关节点的指向。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现代码&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	    //1.1.定义变量
        let current = this.root
        let parent = null
        let isLeftChild = true

        //1.2.开始寻找删除的节点
        while (current.key != key) {
          parent = current
          // 小于则往左查找
          if (key &amp;lt; current.key) {
            isLeftChild = true
            current = current.left
          } else{
            isLeftChild = false
            current = current.rigth
          }
          //找到最后依然没有找到相等的节点
          if (current == null) {
            return false
          }
        }
        //结束while循环后：current.key = key
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第二步&lt;/strong&gt;：删除找到的指定节点，后分3种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除叶子节点；&lt;/li&gt;
&lt;li&gt;删除只有一个子节点的节点；&lt;/li&gt;
&lt;li&gt;删除有两个子节点的节点；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;141情况1没有子节点&#34;&gt;1.4.1.情况1：没有子节点&lt;/h3&gt;
&lt;p&gt;没有子节点时也有两种情况：&lt;/p&gt;
&lt;p&gt;当该叶子节点为根节点时，如下图所示，此时&lt;strong&gt;current == this.root&lt;/strong&gt;，直接通过：&lt;strong&gt;this.root = null&lt;/strong&gt;，删除根节点。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432946911.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当该叶子节点不为根节点时也有两种情况，如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432958464.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
若current = 8，可以通过：parent.left = null，删除节点8；&lt;/p&gt;
&lt;p&gt;若current = 10，可以通过：parent.right = null，删除节点10；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     //情况1：删除的是叶子节点(没有子节点)
        if (current.left == null &amp;amp;&amp;amp; current.right ==null) {
          if (current == this.root) {
            this.root = null
          }else if(isLeftChild){
            parent.left = null
          }else {
            parent.right =null
          }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;142情况2有一个子节点&#34;&gt;1.4.2.情况2：有一个子节点&lt;/h3&gt;
&lt;p&gt;有六种情况分别是：&lt;/p&gt;
&lt;p&gt;当current存在左子节点时（current.right == null）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：current为根节点（current == this.root），如节点11，此时通过：this.root = current.left，删除根节点11；&lt;/li&gt;
&lt;li&gt;情况2：current为父节点parent的左子节点（isLeftChild == true），如节点5，此时通过：parent.left = current.left，删除节点5；&lt;/li&gt;
&lt;li&gt;情况3：current为父节点parent的右子节点（isLeftChild == false），如节点9，此时通过：parent.right = current.left，删除节点9；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614433008524.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当current存在右子节点时（current.left = null）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况4：current为根节点（current == this.root），如节点11，此时通过：this.root = current.right，删除根节点11。&lt;/li&gt;
&lt;li&gt;情况5：current为父节点parent的左子节点（isLeftChild == true），如节点5，此时通过：parent.left = current.right，删除节点5；&lt;/li&gt;
&lt;li&gt;情况6：current为父节点parent的右子节点（isLeftChild == false），如节点9，此时通过：parent.right = current.right，删除节点9；&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614433035143.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;实现代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        //情况2：删除的节点有一个子节点
        //当current存在左子节点时
        else if(current.right == null){
            if (current == this.root) {
              this.root = current.left
            } else if(isLeftChild) {
                parent.left = current.left
            } else{
                parent.right = current.left
            }
        //当current存在右子节点时
      } else if(current.left == null){
            if (current == this.root) {
              this.root = current.rigth
            } else if(isLeftChild) {
                parent.left = current.right
            } else{
                parent.right = current.right
            } 
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;143情况3有两个子节点&#34;&gt;1.4.3.情况3：有两个子节点&lt;/h3&gt;
&lt;p&gt;这种情况&lt;strong&gt;十分复杂&lt;/strong&gt;，首先依据以下二叉搜索树，讨论这样的问题：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614433090866.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;删除节点9&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在保证删除节点9后原二叉树仍为二叉搜索树的前提下，有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方式1：从节点9的左子树中选择一合适的节点替代节点9，可知节点8符合要求；&lt;/li&gt;
&lt;li&gt;方式2：从节点9的右子树中选择一合适的节点替代节点9，可知节点10符合要求；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614433110249.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;删除节点7&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在保证删除节点7后原二叉树仍为二叉搜索树的前提下，也有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方式1：从节点7的左子树中选择一合适的节点替代节点7，可知节点5符合要求；&lt;/li&gt;
&lt;li&gt;方式2：从节点7的右子树中选择一合适的节点替代节点7，可知节点8符合要求；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614433138554.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;删除节点15&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在保证删除节点15后原树二叉树仍为二叉搜索树的前提下，同样有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方式1：从节点15的左子树中选择一合适的节点替代节点15，可知节点14符合要求；&lt;/li&gt;
&lt;li&gt;方式2：从节点15的右子树中选择一合适的节点替代节点15，可知节点18符合要求；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614433162474.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相信你已经发现其中的规律了！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规律总结&lt;/strong&gt;：如果要删除的节点有两个子节点，甚至子节点还有子节点，这种情况下需要从要删除节点&lt;strong&gt;下面的子节点中找到一个合适的节点&lt;/strong&gt;，来替换当前的节点。&lt;/p&gt;
&lt;p&gt;若用current表示需要删除的节点，则合适的节点指的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;current左子树中比current&lt;strong&gt;小一点点的节点&lt;/strong&gt;，即current&lt;strong&gt;左子树&lt;/strong&gt;中的&lt;strong&gt;最大值&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;current右子树中比current&lt;strong&gt;大一点点的节点&lt;/strong&gt;，即current&lt;strong&gt;右子树&lt;/strong&gt;中的&lt;strong&gt;最小值&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;前驱&amp;amp;后继&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在二叉搜索树中，这两个特殊的节点有特殊的名字：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比current小一点点的节点，称为current节点的&lt;strong&gt;前驱&lt;/strong&gt;。比如下图中的节点5就是节点7的前驱；&lt;/li&gt;
&lt;li&gt;比current大一点点的节点，称为current节点的&lt;strong&gt;后继&lt;/strong&gt;。比如下图中的节点8就是节点7的后继；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614433240999.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查找需要被删除的节点current的后继时，需要在current的&lt;strong&gt;右子树&lt;/strong&gt;中查找&lt;strong&gt;最小值&lt;/strong&gt;，即在current的&lt;strong&gt;右子树&lt;/strong&gt;中一直&lt;strong&gt;向左遍历&lt;/strong&gt;查找；&lt;/li&gt;
&lt;li&gt;查找前驱时，则需要在current的&lt;strong&gt;左子树&lt;/strong&gt;中查找&lt;strong&gt;最大值&lt;/strong&gt;，即在current的&lt;strong&gt;左子树&lt;/strong&gt;中一直&lt;strong&gt;向右遍历&lt;/strong&gt;查找。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面只讨论查找current后继的情况，查找前驱的原理相同，这里暂不讨论。&lt;/p&gt;
&lt;h3 id=&#34;144完整实现&#34;&gt;1.4.4.完整实现&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;    //删除节点
      BinarySearchTree.prototype.remove = function(key){
/*------------------------------1.寻找要删除的节点---------------------------------*/
        //1.1.定义变量current保存删除的节点，parent保存它的父节点。isLeftChild保存current是否为parent的左节点
        let current = this.root
        let parent = null
        let isLeftChild = true

        //1.2.开始寻找删除的节点
        while (current.key != key) {
          parent = current
          // 小于则往左查找
          if (key &amp;lt; current.key) {
            isLeftChild = true
            current = current.left
          } else{
            isLeftChild = false
            current = current.right
          }
          //找到最后依然没有找到相等的节点
          if (current == null) {
            return false
          }
        }
        //结束while循环后：current.key = key

/*------------------------------2.根据对应情况删除节点------------------------------*/
        //情况1：删除的是叶子节点(没有子节点)
        if (current.left == null &amp;amp;&amp;amp; current.right ==null) {
          if (current == this.root) {
            this.root = null
          }else if(isLeftChild){
            parent.left = null
          }else {
            parent.right =null
          }
        }
        //情况2：删除的节点有一个子节点
        //当current存在左子节点时
        else if(current.right == null){
            if (current == this.root) {
              this.root = current.left
            } else if(isLeftChild) {
                parent.left = current.left
            } else{
                parent.right = current.left
            }
        //当current存在右子节点时
      } else if(current.left == null){
            if (current == this.root) {
              this.root = current.right
            } else if(isLeftChild) {
                parent.left = current.right
            } else{
                parent.right = current.right
            } 
      }
        //情况3：删除的节点有两个子节点
        else{
          //1.获取后继节点
          let successor = this.getSuccessor(current)

          //2.判断是否根节点
          if (current == this.root) {
            this.root = successor
          }else if (isLeftChild){
            parent.left = successor
          }else{
            parent.right = successor
          }

          //3.将后继的左子节点改为被删除节点的左子节点
          successor.left = current.left
        }
      }

      //封装查找后继的方法
      BinarySearchTree.prototype.getSuccessor = function(delNode){
        //1.定义变量,保存找到的后继
        let successor = delNode
        let current = delNode.right
        let successorParent = delNode

        //2.循环查找current的右子树节点
        while(current != null){
          successorParent = successor
          successor = current
          current = current.left
        }

        //3.判断寻找到的后继节点是否直接就是删除节点的right节点
        if(successor != delNode.right){
          successorParent.left = successor.right
          successor.right = delNode.right 
        }
        return successor
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试代码
    //1.创建BinarySearchTree
    let bst = new BinarySearchTree()

    //2.插入数据
    bst.insert(11);
    bst.insert(7);
    bst.insert(15);
    bst.insert(5);
    bst.insert(3);
    bst.insert(9);
    bst.insert(8);
    bst.insert(10);
    bst.insert(13);
    bst.insert(12);
    bst.insert(14);
    bst.insert(20);
    bst.insert(18);
    bst.insert(25);
    bst.insert(6);
    bst.insert(19);
    
   //3.测试删除代码
    //删除没有子节点的节点
    bst.remove(3)
    bst.remove(8)
    bst.remove(10)

    //删除有一个子节点的节点
    bst.remove(5)
    bst.remove(19)

    //删除有两个子节点的节点
    bst.remove(9)
    bst.remove(7)
    bst.remove(15)

    //遍历二叉搜索树并输出
    let resultString = &amp;quot;&amp;quot;
    bst.midOrderTraversal(function(key){
      resultString += key + &amp;quot;-&amp;gt;&amp;quot;
    })
    alert(resultString)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614433417414.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可见三种情况的节点都被成功删除了。&lt;/p&gt;
&lt;h2 id=&#34;15二叉搜索树完整封装&#34;&gt;1.5.二叉搜索树完整封装&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;    //封装二叉搜索树
    function BinarySearchTree(){

      //节点内部类
      function Node(key){
        this.key = key
        this.left = null
        this.right = null
      }

      //属性
      this.root = null

      //方法
      //一.插入数据：insert方法:对外向用户暴露的方法
      BinarySearchTree.prototype.insert = function(key){
        //1.根据key创建节点
        let newNode = new Node(key)
          
        //2.判断根节点是否存在
        if (this.root == null) {
          this.root = newNode
          //根节点存在时
        }else {
          this.insertNode(this.root, newNode)
        }
      }

      //内部使用的insertNode方法:用于比较节点从左边插入还是右边插入
      BinarySearchTree.prototype.insertNode = function(node, newNode){
        //当newNode.key &amp;lt; node.key向左查找
        if(newNode.key &amp;lt; node.key){
          //情况1：node无左子节点，直接插入
          if (node.left == null) {
            node.left = newNode
          //情况2：node有左子节点，递归调用insertNode(),直到遇到无左子节点成功插入newNode后，不再符合该情况，也就不再调用insertNode()，递归停止。
          }else{
            this.insertNode(node.left, newNode)
          }
        //当newNode.key &amp;gt;= node.key向右查找
        }else{
          //情况1：node无右子节点，直接插入
          if(node.right == null){
            node.right = newNode
          //情况2：node有右子节点，依然递归调用insertNode(),直到遇到无右子节点成功插入newNode为止
          }else{
            this.insertNode(node.right, newNode)
          }
        }
      }

      //二.树的遍历
      //1.先序遍历
      //掺入一个handler函数对得到的key进行处理
      BinarySearchTree.prototype.preOrderTraversal = function(handler){
        this.preOrderTraversalNode(this.root, handler)
      }

      //封装内部方法，对某个节点进行遍历
      BinarySearchTree.prototype.preOrderTraversalNode = function(node,handler){
        if (node != null) {
          //1.处理经过的节点
          handler(node.key)

          //2.遍历经过节点的左子节点
          this.preOrderTraversalNode(node.left, handler)

          //3.遍历经过节点的右子节点
          this.preOrderTraversalNode(node.right, handler)
        }
      }

      //2.中序遍历
      BinarySearchTree.prototype.midOrderTraversal = function(handler){
        this.midOrderTraversalNode(this.root, handler)
      }

      BinarySearchTree.prototype.midOrderTraversalNode = function(node, handler){
        if (node != null) {
          //1.遍历左子树中的节点
          this.midOrderTraversalNode(node.left, handler)
          
          //2.处理节点
          handler(node.key)

          //3.遍历右子树中的节点
          this.midOrderTraversalNode(node.right, handler)
        }
      }

      //3.后序遍历
      BinarySearchTree.prototype.postOrderTraversal = function(handler){
        this.postOrderTraversalNode(this.root, handler)
      }

      BinarySearchTree.prototype.postOrderTraversalNode = function(node, handler){
        if (node != null) {
          //1.遍历左子树中的节点
          this.postOrderTraversalNode(node.left, handler)
          
          //2.遍历右子树中的节点
          this.postOrderTraversalNode(node.right, handler)

          //3.处理节点
          handler(node.key)
        }
      }

      //三.寻找最值
      //寻找最大值
      BinarySearchTree.prototype.max = function () {
        //1.获取根节点
        let node = this.root
        //2.定义key保存节点值
        let key = null
        //3.依次向右不断查找，直到节点为null
        while (node != null) {
          key = node.key
          node = node.right
        }
        return key
      }

      //寻找最小值
      BinarySearchTree.prototype.min = function(){
         //1.获取根节点
         let node = this.root
        //2.定义key保存节点值
        let key = null
        //3.依次向左不断查找，直到节点为null
        while (node != null) {
          key = node.key
          node = node.left
        }
        return key
      }

      //查找特定的key
      BinarySearchTree.prototype.search = function(key){
        //1.获取根节点
        let node = this.root

        //2.循环搜索key
        while(node != null){
          if (key &amp;lt; node.key) {
            //小于根(父)节点就往左边找
            node = node.left
            //大于根(父)节点就往右边找
          }else if(key &amp;gt; node.key){
            node = node.right
          }else{
            return true
          }
        } 
        return false
      }

      //四.删除节点
      BinarySearchTree.prototype.remove = function(key){
/*------------------------------1.寻找要删除的节点---------------------------------*/
        //1.1.定义变量current保存删除的节点，parent保存它的父节点。isLeftChild保存current是否为parent的左节点
        let current = this.root
        let parent = null
        let isLeftChild = true

        //1.2.开始寻找删除的节点
        while (current.key != key) {
          parent = current
          // 小于则往左查找
          if (key &amp;lt; current.key) {
            isLeftChild = true
            current = current.left
          } else{
            isLeftChild = false
            current = current.right
          }
          //找到最后依然没有找到相等的节点
          if (current == null) {
            return false
          }
        }
        //结束while循环后：current.key = key

/*------------------------------2.根据对应情况删除节点------------------------------*/
        //情况1：删除的是叶子节点(没有子节点)
        if (current.left == null &amp;amp;&amp;amp; current.right ==null) {
          if (current == this.root) {
            this.root = null
          }else if(isLeftChild){
            parent.left = null
          }else {
            parent.right =null
          }
        }
        //情况2：删除的节点有一个子节点
        //当current存在左子节点时
        else if(current.right == null){
            if (current == this.root) {
              this.root = current.left
            } else if(isLeftChild) {
                parent.left = current.left
            } else{
                parent.right = current.left
            }
        //当current存在右子节点时
      } else if(current.left == null){
            if (current == this.root) {
              this.root = current.right
            } else if(isLeftChild) {
                parent.left = current.right
            } else{
                parent.right = current.right
            } 
      }
        //情况3：删除的节点有两个子节点
        else{
          //1.获取后继节点
          let successor = this.getSuccessor(current)

          //2.判断是否根节点
          if (current == this.root) {
            this.root = successor
          }else if (isLeftChild){
            parent.left = successor
          }else{
            parent.right = successor
          }

          //3.将后继的左子节点改为被删除节点的左子节点
          successor.left = current.left
        }
      }

      //封装查找后继的方法
      BinarySearchTree.prototype.getSuccessor = function(delNode){
        //1.定义变量,保存找到的后继
        let successor = delNode
        let current = delNode.right
        let successorParent = delNode

        //2.循环查找current的右子树节点
        while(current != null){
          successorParent = successor
          successor = current
          current = current.left
        }

        //3.判断寻找到的后继节点是否直接就是删除节点的right节点
        if(successor != delNode.right){
          successorParent.left = successor.right
          successor.right = delNode.right 
        }
        return successor
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2平衡树&#34;&gt;2.平衡树&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;二叉搜索树的缺陷：&lt;/strong&gt;&lt;br&gt;
当插入的数据是有序的数据，就会造成二叉搜索树的深度过大。比如原二叉搜索树右 11 7 15 组成，如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614433630544.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当插入一组有序数据：6 5 4 3 2就会变成深度过大的搜索二叉树，会严重影响二叉搜索树的性能。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614433639468.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非平衡树&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比较好的二叉搜索树，它的数据应该是&lt;strong&gt;左右均匀分布&lt;/strong&gt;的；&lt;/li&gt;
&lt;li&gt;但是插入&lt;strong&gt;连续数据&lt;/strong&gt;后，二叉搜索树中的数据分布就变得&lt;strong&gt;不均匀了&lt;/strong&gt;，我们称这种树为&lt;strong&gt;非平衡树&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;对于一棵&lt;strong&gt;平衡二叉树&lt;/strong&gt;来说，插入/查找等操作的效率是&lt;strong&gt;O（logN）&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;而对于一棵&lt;strong&gt;非平衡二叉树&lt;/strong&gt;来说，相当于编写了一个链表，查找效率变成了&lt;strong&gt;O（N）&lt;/strong&gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;树的平衡性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了能以&lt;strong&gt;较快的时间O（logN）&lt;strong&gt;来操作一棵树，我们需要&lt;/strong&gt;保证树总是平衡&lt;/strong&gt;的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;起码大部分是平衡的，此时的时间复杂度也是接近O（logN）的；&lt;/li&gt;
&lt;li&gt;这就要求树中&lt;strong&gt;每个节点左边的子孙节点&lt;/strong&gt;的个数，应该尽可能地等于&lt;strong&gt;右边的子孙节点&lt;/strong&gt;的个数；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;常见的平衡树&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;AVL树&lt;/strong&gt;：是最早的一种平衡树，它通过在每个节点多存储一个额外的数据来保持树的平衡。由于AVL树是平衡树，所以它的时间复杂度也是O（logN）。但是它的整体效率不如红黑树，开发中比较少用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;红黑树&lt;/strong&gt;：同样通过一些&lt;strong&gt;特性&lt;/strong&gt;来保持树的平衡，时间复杂度也是O（logN）。进行插入/删除等操作时，性能优于AVL树，所以平衡树的应用基本都是红黑树。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av86801505?from=search&amp;amp;seid=4967761411915016256&#34;&gt;参考资料：JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现树结构（下）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/javascript-shi-xian-shu-jie-gou/"" data-c="
          &lt;h1 id=&#34;1树结构简介&#34;&gt;1.树结构简介&lt;/h1&gt;
&lt;h2 id=&#34;11简单了解树结构&#34;&gt;1.1.简单了解树结构&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;什么是树？&lt;/strong&gt;&lt;br&gt;
真实的树：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614430459970.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;树的特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树一般都有一个&lt;strong&gt;根&lt;/strong&gt;，连接着根的是&lt;strong&gt;树干&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;树干会发生分叉，形成许多&lt;strong&gt;树枝&lt;/strong&gt;，树枝会继续分化成更小的&lt;strong&gt;树枝&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;树枝的最后是&lt;strong&gt;叶子&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现实生活中很多结构都是树的抽象，模拟的树结构相当于旋转180°的树。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614430500028.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;树结构对比于数组/链表/哈希表有哪些优势呢：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数组：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：可以通过&lt;strong&gt;下标值访问&lt;/strong&gt;，效率高；&lt;/li&gt;
&lt;li&gt;缺点：查找数据时需要先对数据进行&lt;strong&gt;排序&lt;/strong&gt;，生成&lt;strong&gt;有序数组&lt;/strong&gt;，才能提高查找效率；并且在插入和删除元素时，需要大量的&lt;strong&gt;位移操作&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;链表：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：数据的插入和删除操作效率都很高；&lt;/li&gt;
&lt;li&gt;缺点：&lt;strong&gt;查找&lt;/strong&gt;效率低，需要从头开始依次查找，直到找到目标数据为止；当需要在链表中间位置插入或删除数据时，插入或删除的效率都不高。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;哈希表：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：哈希表的插入/查询/删除效率都非常高；&lt;/li&gt;
&lt;li&gt;缺点：&lt;strong&gt;空间利用率不高&lt;/strong&gt;，底层使用的数组中很多单元没有被利用；并且哈希表中的元素是&lt;strong&gt;无序&lt;/strong&gt;的，不能按照固定顺序遍历哈希表中的元素；而且不能快速找出哈希表中&lt;strong&gt;最大值或最小值&lt;/strong&gt;这些特殊值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;树结构：&lt;/strong&gt;&lt;br&gt;
优点：树结构综合了上述三种结构的优点，同时也弥补了它们存在的缺点（虽然效率不一定都比它们高），比如树结构中数据都是有序的，查找效率高；空间利用率高；并且可以快速获取最大值和最小值等。&lt;/p&gt;
&lt;p&gt;总的来说：&lt;strong&gt;每种数据结构都有自己特定的应用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;树结构：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;树（Tree）&lt;/strong&gt;:由 n（n ≥ 0）个节点构成的&lt;strong&gt;有限集合&lt;/strong&gt;。当 n = 0 时，称为&lt;strong&gt;空树&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于任一棵非空树（n &amp;gt; 0），它具备以下性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数中有一个称为**根（Root）**的特殊节点，用 **r **表示；&lt;/li&gt;
&lt;li&gt;其余节点可分为 m（m &amp;gt; 0）个互不相交的有限集合 T1，T2，...，Tm，其中每个集合本身又是一棵树，称为原来树的&lt;strong&gt;子树（SubTree）&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;树的常用术语：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614430719871.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;节点的度（Degree）&lt;/strong&gt;：节点的&lt;strong&gt;子树个数&lt;/strong&gt;，比如节点B的度为2；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;树的度&lt;/strong&gt;：树的所有节点中&lt;strong&gt;最大的度数&lt;/strong&gt;，如上图树的度为2；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;叶节点（Leaf）&lt;/strong&gt;：&lt;strong&gt;度为0的节点&lt;/strong&gt;（也称为叶子节点），如上图的H，I等；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;父节点（Parent）&lt;/strong&gt;：度不为0的节点称为父节点，如上图节点B是节点D和E的父节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;子节点（Child）&lt;/strong&gt;：若B是D的父节点，那么D就是B的子节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;兄弟节点（Sibling）&lt;/strong&gt;：具有同一父节点的各节点彼此是兄弟节点，比如上图的B和C，D和E互为兄弟节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路径和路径长度&lt;/strong&gt;：路径指的是一个节点到另一节点的通道，路径所包含边的个数称为路径长度，比如A-&amp;gt;H的路径长度为3；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;节点的层次（Level）&lt;/strong&gt;：规定&lt;strong&gt;根节点在1层&lt;/strong&gt;，其他任一节点的层数是其父节点的&lt;strong&gt;层数加1&lt;/strong&gt;。如B和C节点的层次为2；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;树的深度（Depth）&lt;/strong&gt;：树种所有节点中的&lt;strong&gt;最大层次&lt;/strong&gt;是这棵树的深度，如上图树的深度为4；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12树结构的表示方式&#34;&gt;1.2.树结构的表示方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;最普通的表示方法：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614430807590.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如图，树结构的组成方式类似于链表，都是由一个个节点连接构成。不过，根据每个父节点子节点数量的不同，每一个父节点需要的引用数量也不同。比如节点A需要3个引用，分别指向子节点B，C，D；B节点需要2个引用，分别指向子节点E和F；K节点由于没有子节点，所以不需要引用。&lt;/p&gt;
&lt;p&gt;这种方法缺点在于我们无法确定某一结点的引用数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;儿子-兄弟表示法：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614430840465.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这种表示方法可以完整地记录每个节点的数据，比如：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;//节点A
Node{
  //存储数据
  this.data = data
  //统一只记录左边的子节点
  this.leftChild = B
  //统一只记录右边的第一个兄弟节点
  this.rightSibling = null
}

//节点B
Node{
  this.data = data
  this.leftChild = E
  this.rightSibling = C
}

//节点F
Node{
  this.data = data
  this.leftChild = null
  this.rightSibling = null
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种表示法的优点在于每一个节点中引用的数量都是确定的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;儿子-兄弟表示法旋转&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下为儿子-兄弟表示法组成的树结构：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614430881094.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
将其顺时针旋转45°之后：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614430888569.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这样就成为了一棵&lt;strong&gt;二叉树&lt;/strong&gt;，由此我们可以得出结论：&lt;strong&gt;任何树都可以通过二叉树进行模拟&lt;/strong&gt;。但是这样父节点不是变了吗？其实，父节点的设置只是为了方便指向子节点，在代码实现中谁是父节点并没有关系，只要能正确找到对应节点即可。&lt;/p&gt;
&lt;h1 id=&#34;2二叉树&#34;&gt;2.二叉树&lt;/h1&gt;
&lt;h2 id=&#34;21二叉树简介&#34;&gt;2.1.二叉树简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;二叉树的概念&lt;/strong&gt;：如果树中的每一个节点最多只能由&lt;strong&gt;两个子节点&lt;/strong&gt;，这样的树就称为&lt;strong&gt;二叉树&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;二叉树十分重要，不仅仅是因为简单，更是因为几乎所有的树都可以表示成二叉树形式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二叉树的组成&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二叉树可以为空，也就是没有节点；&lt;/li&gt;
&lt;li&gt;若二叉树不为空，则它由根节点和称为其左子树TL和右子树TR的两个不相交的二叉树组成；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;二叉树的五种形态：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614430959785.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
上图分别表示：空的二叉树、只有一个节点的二叉树、只有左子树TL的二叉树、只有右子树TR的二叉树和有左右两个子树的二叉树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二叉树的特性：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个二叉树的第 i 层的最大节点树为：2(i-1)，i &amp;gt;= 1；&lt;/li&gt;
&lt;li&gt;深度为k的二叉树的最大节点总数为：2k - 1 ，k &amp;gt;= 1；&lt;/li&gt;
&lt;li&gt;对任何非空二叉树，若 n0 表示叶子节点的个数，n2表示度为2的非叶子节点个数，那么两者满足关系：n0 = n2 + 1；如下图所示：H，E，I，J，G为叶子节点，总数为5；A，B，C，F为度为2的非叶子节点，总数为4；满足n0 = n2 + 1的规律。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614430990764.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;22特殊的二叉树&#34;&gt;2.2.特殊的二叉树&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;完美二叉树&lt;/strong&gt;&lt;br&gt;
完美二叉树（Perfect Binary Tree）也成为满二叉树（Full Binary Tree），在二叉树中，除了最下一层的叶子节点外，每层节点都有2个子节点，这就构成了完美二叉树。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431028944.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完全二叉树&lt;/strong&gt;&lt;br&gt;
完全二叉树（Complete Binary Tree）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;除了二叉树最后一层外，其他各层的节点数都达到了最大值；&lt;/li&gt;
&lt;li&gt;并且，最后一层的叶子节点从左向右是连续存在，只缺失右侧若干叶子节点；&lt;/li&gt;
&lt;li&gt;完美二叉树是特殊的完全二叉树；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431051756.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在上图中，由于H缺失了右子节点，所以它不是完全二叉树。&lt;/p&gt;
&lt;h2 id=&#34;23二叉树的数据存储&#34;&gt;2.3.二叉树的数据存储&lt;/h2&gt;
&lt;p&gt;常见的二叉树存储方式为&lt;strong&gt;数组&lt;/strong&gt;和&lt;strong&gt;链表&lt;/strong&gt;：&lt;br&gt;
&lt;strong&gt;使用数组：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完全二叉树：按从上到下，从左到右的方式存储数据。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431087611.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;节点&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;A&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;B&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;C&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;E&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;F&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;G&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;H&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;序号&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;使用数组存储时，取数据的时候也十分方便：左子节点的序号等于父节点序号 * 2，右子节点的序号等于父节点序号 * 2 + 1 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非完全二叉树：非完全二叉树需要转换成完全二叉树才能按照上面的方案存储，这样会浪费很大的存储空间。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431341849.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431447014.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;使用链表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;二叉树最常见的存储方式为&lt;strong&gt;链表&lt;/strong&gt;：每一个节点封装成一个Node，Node中包含存储的数据、左节点的引用和右节点的引用。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431472922.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3二叉搜索树&#34;&gt;3.二叉搜索树&lt;/h1&gt;
&lt;h2 id=&#34;31认识二叉搜索树&#34;&gt;3.1.认识二叉搜索树&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;二叉搜索树&lt;/strong&gt;（&lt;strong&gt;BST&lt;/strong&gt;，Binary Search Tree），也称为&lt;strong&gt;二叉排序树&lt;/strong&gt;和&lt;strong&gt;二叉查找树&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;二叉搜索树是一棵二叉树，可以为空；&lt;/p&gt;
&lt;p&gt;如果不为空，则满足以下&lt;strong&gt;性质&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;条件1：非空左子树的&lt;strong&gt;所有&lt;/strong&gt;键值&lt;strong&gt;小于&lt;/strong&gt;其根节点的键值。比如三中节点6的所有非空左子树的键值都小于6；&lt;/li&gt;
&lt;li&gt;条件2：非空右子树的&lt;strong&gt;所有&lt;/strong&gt;键值&lt;strong&gt;大于&lt;/strong&gt;其根节点的键值；比如三中节点6的所有非空右子树的键值都大于6；&lt;/li&gt;
&lt;li&gt;条件3：左、右子树本身也都是二叉搜索树；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431547872.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如上图所示，树二和树三符合3个条件属于二叉树，树一不满足条件3所以不是二叉树。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：二叉搜索树的特点主要是&lt;strong&gt;较小的值&lt;/strong&gt;总是保存在&lt;strong&gt;左节点&lt;/strong&gt;上，相对&lt;strong&gt;较大的值&lt;/strong&gt;总是保存在&lt;strong&gt;右节点&lt;/strong&gt;上。这种特点使得二叉搜索树的查询效率非常高，这也就是二叉搜索树中&amp;quot;搜索&amp;quot;的来源。&lt;/p&gt;
&lt;h2 id=&#34;32二叉搜索树应用举例&#34;&gt;3.2.二叉搜索树应用举例&lt;/h2&gt;
&lt;p&gt;下面是一个二叉搜索树：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431584847.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
若想在其中查找数据10，只需要查找4次，查找效率非常高。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第1次：将10与根节点9进行比较，由于10 &amp;gt; 9，所以10下一步与根节点9的右子节点13比较；&lt;/li&gt;
&lt;li&gt;第2次：由于10 &amp;lt; 13，所以10下一步与父节点13的左子节点11比较；&lt;/li&gt;
&lt;li&gt;第3次：由于10 &amp;lt; 11，所以10下一步与父节点11的左子节点10比较；&lt;/li&gt;
&lt;li&gt;第4次：由于10 = 10，最终查找到数据10 。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431605019.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
同样是15个数据，在排序好的数组中查询数据10，需要查询10次：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431617619.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实：如果是排序好的数组，可以通过二分查找：第一次找9，第二次找13，第三次找15...。我们发现如果把每次二分的数据拿出来以树的形式表示的话就是&lt;strong&gt;二叉搜索树&lt;/strong&gt;。这就是数组二分法查找效率之所以高的原因。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av86801505?from=search&amp;amp;seid=4967761411915016256&#34;&gt;参考资料：JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现树结构（上）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/javascript-shi-xian-ha-xi-biao/"" data-c="
          &lt;h1 id=&#34;1哈希表简介&#34;&gt;1.哈希表简介&lt;/h1&gt;
&lt;h2 id=&#34;11认识哈希表&#34;&gt;1.1.认识哈希表&lt;/h2&gt;
&lt;p&gt;哈希表通常是基于&lt;strong&gt;数组&lt;/strong&gt;实现的，但是相对于数组，它存在更多优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哈希表可以提供非常快速的&lt;strong&gt;插入-删除-查找操作&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;无论多少数据，插入和删除值都只需要非常短的时间，即O(1)的时间级。实际上，只需要&lt;strong&gt;几个机器指令&lt;/strong&gt;即可完成；&lt;/li&gt;
&lt;li&gt;哈希表的速度比&lt;strong&gt;树还要快&lt;/strong&gt;，基本可以瞬间查找到想要的元素。但是相对于树来说编码要简单得多。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;哈希表同样存在不足之处：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哈希表中的数据是&lt;strong&gt;没有顺序&lt;/strong&gt;的，所以不能以一种固定的方式（比如从小到大 ）来遍历其中的元素。&lt;/li&gt;
&lt;li&gt;通常情况下，哈希表中的key是&lt;strong&gt;不允许重复&lt;/strong&gt;的，不能放置相同的key，用于保存不同的元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;哈希表是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哈希表并不好理解，不像数组、链表和树等可通过图形的形式表示其结构和原理。&lt;/li&gt;
&lt;li&gt;哈希表的结构就是&lt;strong&gt;数组&lt;/strong&gt;，但它神奇之处在于对&lt;strong&gt;下标值的一种变换&lt;/strong&gt;，这种变换我们可以称之为&lt;strong&gt;哈希函数&lt;/strong&gt;，通过哈希函数可以获取&lt;strong&gt;HashCode&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;通过以下案例了解哈希表：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;案例一：公司想要存储1000个人的信息，每一个工号对应一个员工的信息。若使用数组，增删数据时比较麻烦；使用链表，获取数据时比较麻烦。有没有一种数据结构，能把某一员工的姓名转换为它对应的工号，再根据工号查找该员工的完整信息呢？没错此时就可以使用哈希表的哈希函数来实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;案例二：存储联系人和对应的电话号码：当要查找张三（比如）的号码时，若使用数组：由于不知道存储张三数据对象的下标值，所以查找起来十分麻烦，使用链表时也同样麻烦。而使用哈希表就能通过哈希函数把张三这个名称转换为它对应的下标值，再通过下标值查找效率就非常高了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是说：哈希表最后还是基于数据来实现的，只不过哈希表能够通过哈希函数把字符串转化为对应的&lt;strong&gt;下标值&lt;/strong&gt;，建立字符串和下标值的对应关系。&lt;/p&gt;
&lt;h2 id=&#34;12哈希化的方式&#34;&gt;1.2.哈希化的方式&lt;/h2&gt;
&lt;p&gt;为了把字符串转化为对应的下标值，需要有一套编码系统，为了方便理解我们创建这样一套编码系统：比如&lt;strong&gt;a为1，b为2，c为3，以此类推z为26，空格为27（不考虑大写情况）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;有了编码系统后，将字母转化为数字也有很多种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方式一：数字相加。例如&lt;strong&gt;cats转化为数字&lt;/strong&gt;：3+1+20+19=43，那么就把43作为cats单词的下标值储存在数组中；&lt;br&gt;
但是这种方式会存在这样的问题：很多的单词按照该方式转化为数字后都是43，比如was。而在数组中&lt;strong&gt;一个下标值&lt;/strong&gt;只能&lt;strong&gt;储存一个数据&lt;/strong&gt;，所以该方式不合理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方式二：幂的连乘。我们平时使用的&lt;strong&gt;大于10的数字&lt;/strong&gt;，就是用&lt;strong&gt;幂的连乘&lt;/strong&gt;来表示它的唯一性的。比如： 6543=6 * 103 + 5 * 102 + 4 * 10 + 3；这样单词也可以用该种方式来表示：cats = 3 * 273 + 1 * 272 + 20 * 27 + 17 =60337;&lt;br&gt;
虽然该方式可以保证字符的唯一性，但是如果是较长的字符（如aaaaaaaaaa）所表示的数字就非常大，此时要求很大容量的数组，然而其中却有许多下标值指向的是无效的数据（比如不存在zxcvvv这样的单词），造成了数组空间的浪费。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;两种方案总结：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一种方案（让数字相加求和）产生的&lt;strong&gt;数组下标太少；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;第二种方案（与27的幂相乘求和）产生的&lt;strong&gt;数组下标又太多；&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在需要一种&lt;strong&gt;压缩方法&lt;/strong&gt;，把幂的连乘方案系统中得到的&lt;strong&gt;巨大整数范围&lt;/strong&gt;压缩到&lt;strong&gt;可接受的数组范围&lt;/strong&gt;中。可以通过取余操作来实现。虽然取余操作得到的结构也有可能重复，但是可以通过其他方式解决。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;哈希表的一些概念：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;哈希化&lt;/strong&gt;：将&lt;strong&gt;大数字&lt;/strong&gt;转化成&lt;strong&gt;数组范围内下标&lt;/strong&gt;的过程，称之为&lt;strong&gt;哈希化&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;哈希函数&lt;/strong&gt;：我们通常会将&lt;strong&gt;单词&lt;/strong&gt;转化成&lt;strong&gt;大数字&lt;/strong&gt;，把&lt;strong&gt;大数字&lt;/strong&gt;进行&lt;strong&gt;哈希化&lt;/strong&gt;的代码实现放在一个函数中，该函数就称为&lt;strong&gt;哈希函数&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;哈希表&lt;/strong&gt;：对最终数据插入的&lt;strong&gt;数组&lt;/strong&gt;进行整个&lt;strong&gt;结构的封装&lt;/strong&gt;，得到的就是&lt;strong&gt;哈希表&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;仍然需要解决的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哈希化过后的下标依然可能&lt;strong&gt;重复&lt;/strong&gt;，如何解决这个问题呢？这种情况称为&lt;strong&gt;冲突&lt;/strong&gt;，冲突是&lt;strong&gt;不可避免&lt;/strong&gt;的，我们只能&lt;strong&gt;解决冲突&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;13解决冲突的方法&#34;&gt;1.3.解决冲突的方法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;解决冲突常见的两种方案：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方案一：&lt;strong&gt;链地址法（拉链法）&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下图所示，我们将每一个数字都对&lt;strong&gt;10&lt;/strong&gt;进行取余操作，则余数的范围&lt;strong&gt;0~9&lt;/strong&gt;作为数组的下标值。并且，数组每一个下标值对应的位置存储的不再是一个数字了，而是存储由经过取余操作后得到相同余数的数字组成的&lt;strong&gt;数组&lt;/strong&gt;或&lt;strong&gt;链表&lt;/strong&gt;。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614344975950.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这样可以根据下标值获取到整个数组或链表，之后继续在数组或链表中查找就可以了。而且，产生冲突的元素一般不会太多。&lt;br&gt;
&lt;strong&gt;总结&lt;/strong&gt;：链地址法解决冲突的办法是&lt;strong&gt;每个数组单元&lt;/strong&gt;中存储的不再是&lt;strong&gt;单个数据&lt;/strong&gt;，而是一条&lt;strong&gt;链条&lt;/strong&gt;，这条链条常使用的数据结构为&lt;strong&gt;数组&lt;/strong&gt;或&lt;strong&gt;链表&lt;/strong&gt;，两种数据结构查找的效率相当（因为链条的元素一般不会太多）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方案二：&lt;strong&gt;开放地址法&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开放地址法的主要工作方式是&lt;strong&gt;寻找空白的单元格&lt;/strong&gt;来放置&lt;strong&gt;冲突&lt;/strong&gt;的数据项。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614345198909.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
根据探测空白单元格位置方式的不同，可分为三种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线性探测&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;二次探测&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;再哈希法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;14寻找空白单元格的方式&#34;&gt;1.4.寻找空白单元格的方式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;线性探测&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;当插入13时&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;经过哈希化（对10取余）之后得到的下标值index=3，但是该位置已经放置了数据33。而线性探测就是从&lt;strong&gt;index位置+1&lt;/strong&gt;开始向后一个一个来查找&lt;strong&gt;合适的位置&lt;/strong&gt;来放置13，所谓合适的位置指的是&lt;strong&gt;空的位置&lt;/strong&gt;，如上图中index=4的位置就是合适的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;当查询13时：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先13经过哈希化得到index=3，如果index=3的位置存放的数据与需要查询的数据13相同，就直接返回；&lt;/li&gt;
&lt;li&gt;不相同时，则线性查找，从&lt;strong&gt;index+1&lt;/strong&gt;位置开始一个一个位置地查找数据13；&lt;/li&gt;
&lt;li&gt;查询过程中不会遍历整个哈希表，只要查询到&lt;strong&gt;空位置，就停止&lt;/strong&gt;，因为插入13时不会跳过空位置去插入其他位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;当删除13时&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除操作和上述两种情况类似，但需要注意的是，删除一个数据项时，&lt;strong&gt;不能&lt;/strong&gt;将该位置下标的&lt;strong&gt;内容设置为null&lt;/strong&gt;，否则会&lt;strong&gt;影响到之后其他的查询操作&lt;/strong&gt;，因为一遇到为null的位置就会停止查找。&lt;/li&gt;
&lt;li&gt;通常&lt;strong&gt;删除一个位置的数据项&lt;/strong&gt;时，我们可以&lt;strong&gt;将它进行特殊处理&lt;/strong&gt;（比如设置为-1），这样在查找时遇到-1就知道要&lt;strong&gt;继续查找&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;线性探测存在的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性探测存在一个比较严重的问题，就是&lt;strong&gt;聚集&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;如哈希表中还没插入任何元素时，插入23、24、25、26、27，这就意味着下标值为3、4、5、6、7的位置都放置了数据，这种&lt;strong&gt;一连串填充单元&lt;/strong&gt;就称为&lt;strong&gt;聚集&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;聚集会影响哈希表的&lt;strong&gt;性能&lt;/strong&gt;，无论是插入/查询/删除都会影响；&lt;/li&gt;
&lt;li&gt;比如插入13时就会发现，连续的单元3~7都不允许插入数据，并且在插入的过程中需要经历多次这种情况。二次探测法可以解决该问题。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614345460679.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;二次探测&lt;/code&gt;&lt;br&gt;
上文所说的&lt;strong&gt;线性探测存在的问题&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果之前的数据是&lt;strong&gt;连续插入&lt;/strong&gt;的，那么新插入的一个数据可能需要&lt;strong&gt;探测很长的距离&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;二次探测是在线性探测的基础上进行了&lt;strong&gt;优化&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;线性探测&lt;/strong&gt;：我们可以看成是&lt;strong&gt;步长为1&lt;/strong&gt;的探测，比如从下表值x开始，那么线性探测就是按照下标值：x+1、x+2、x+3等依次探测；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;二次探测&lt;/strong&gt;：对步长进行了优化，比如从下标值x开始探测：x+12、x+22、x+33 。这样&lt;strong&gt;一次性探测比较长的距离&lt;/strong&gt;，避免了数据聚集带来的影响。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;二次探测存在的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当插入数据分布性较大的一组数据时，比如：13-163-63-3-213，这种情况会造成&lt;strong&gt;步长不一的一种聚集&lt;/strong&gt;（虽然这种情况出现的概率较线性探测的聚集要小），同样会影响性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;再哈希化&lt;/code&gt;&lt;br&gt;
在开放地址法中寻找空白单元格的最好的解决方式为&lt;strong&gt;再哈希化&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二次探测的步长是固定的：1，4，9，16依次类推；&lt;/li&gt;
&lt;li&gt;现在需要一种方法：产生一种&lt;strong&gt;依赖关键字(数据)的探测序列&lt;/strong&gt;，而不是每个关键字探测步长都一样；&lt;/li&gt;
&lt;li&gt;这样，&lt;strong&gt;不同的关键字&lt;/strong&gt;即使映射到&lt;strong&gt;相同的数组下标&lt;/strong&gt;，也可以使用&lt;strong&gt;不同的探测序列&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;再哈希法的做法为：把关键字用&lt;strong&gt;另一个&lt;/strong&gt;哈希函数，&lt;strong&gt;再做一次哈希化&lt;/strong&gt;，用这次哈希化的&lt;strong&gt;结果作为该关键字的步长&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;第二次哈希化需要满足以下两点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和&lt;strong&gt;第一个哈希函数不同&lt;/strong&gt;，不然哈希化后的结果仍是原来位置；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不能输出为0&lt;/strong&gt;，否则每次探测都是原地踏步的死循环；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;优秀的哈希函数：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;stepSize = constant - （key % constant）&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;其中constant是&lt;strong&gt;质数&lt;/strong&gt;，且小于数组的容量；&lt;/li&gt;
&lt;li&gt;例如：stepSize = 5 - （key % 5），满足需求，并且结果不可能为0；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;哈希化的效率&lt;/strong&gt;&lt;br&gt;
哈希表中执行插入和搜索操作效率是非常高的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果没有&lt;strong&gt;发生冲突&lt;/strong&gt;，那么效率就会更高；&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;发生冲突&lt;/strong&gt;，存取时间就依赖后来的探测长度；&lt;/li&gt;
&lt;li&gt;平均探测长度以及平均存取时间，取决于装填因子，随着&lt;strong&gt;装填因子&lt;/strong&gt;变大，探测长度会越来越长。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;理解概念&lt;strong&gt;装填因子&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;装填因子表示当前哈希表中已经&lt;strong&gt;包含的数据项&lt;/strong&gt;和&lt;strong&gt;整个哈希表长度&lt;/strong&gt;的&lt;strong&gt;比值&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;装填因子 = 总数据项 / 哈希表长度&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开放地址法的装填因子&lt;/strong&gt;最大为1，因为只有空白的单元才能放入元素；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链地址法的装填因子&lt;/strong&gt;可以&lt;strong&gt;大于1&lt;/strong&gt;，因为只要愿意，拉链法可以无限延伸下去；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;15不同探测方式性能的比较&#34;&gt;1.5.不同探测方式性能的比较&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线性探测&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，随着装填因子的增大，平均探测长度呈指数形式增长，性能较差。实际情况中，最好的装填因子取决于存储效率和速度之间的平衡，随着装填因子变小，存储效率下降，而速度上升。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614347865771.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;二次探测和再哈希化的性能&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二次探测和再哈希法性能相当，它们的性能比线性探测略好。由下图可知，随着装填因子的变大，平均探测长度呈指数形式增长，需要探测的次数也呈指数形式增长，性能不高。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614347917941.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;链地址法的性能&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到随着装填因子的增加，平均探测长度呈线性增长，较为平缓。在开发中使用链地址法较多，比如Java中的HashMap中使用的就是&lt;strong&gt;链地址法&lt;/strong&gt;。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614347946852.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;16优秀的哈希函数&#34;&gt;1.6.优秀的哈希函数&lt;/h2&gt;
&lt;p&gt;哈希表的优势在于它的速度，所以哈希函数不能采用消耗性能较高的复杂算法。提高速度的一个方法是在哈希函数中&lt;strong&gt;尽量减少乘法和除法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;性能高的哈希函数应具备以下两个优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;快速的计算&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;均匀的分布&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;快速计算&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;霍纳法则&lt;/strong&gt;：在中国霍纳法则也叫做&lt;strong&gt;秦久韶算法&lt;/strong&gt;，具体算法为：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614352364784.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
求多项式的值时，首先计算最内层括号内一次多项式的值，然后由内向外逐层计算一次多项式的值。这种算法把求n次多项式f(x)的值就转化为求n个一次多项式的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;变换之前：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;乘法次数：n（n+1）/2次；&lt;/li&gt;
&lt;li&gt;加法次数：n次；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;变换之前：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;乘法次数：n次；&lt;/li&gt;
&lt;li&gt;加法次数：n次；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果使用大O表示时间复杂度的话，直接从变换前的&lt;strong&gt;O(N2)&lt;strong&gt;降到了&lt;/strong&gt;O(N)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;均匀分布&lt;/code&gt;&lt;br&gt;
为了保证数据在哈希表中&lt;strong&gt;均匀分布&lt;/strong&gt;，当我们需要&lt;strong&gt;使用常量的地方&lt;/strong&gt;，尽量使用&lt;strong&gt;质数&lt;/strong&gt;；比如：哈希表的长度、N次幂的底数等。&lt;/p&gt;
&lt;p&gt;Java中的HashMap采用的是链地址法，哈希化采用的是公式为：&lt;strong&gt;index = HashCode（key）&amp;amp;（Length-1）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即将数据化为二进制进行&lt;strong&gt;与&lt;/strong&gt;运算，而不是取余运算。这样计算机直接运算二进制数据，效率更高。但是JavaScript在进行叫大数据的&lt;strong&gt;与&lt;/strong&gt;运算时会出现问题，所以以下使用JavaScript实现哈希化时还是采用取余运算。&lt;/p&gt;
&lt;h1 id=&#34;2初步封装哈希表&#34;&gt;2.初步封装哈希表&lt;/h1&gt;
&lt;p&gt;** 哈希表的常见操作为**：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;put（key，value）：插入或修改操作；&lt;/li&gt;
&lt;li&gt;get（key）：获取哈希表中特定位置的元素；&lt;/li&gt;
&lt;li&gt;remove（key）：删除哈希表中特定位置的元素；&lt;/li&gt;
&lt;li&gt;isEmpty（）：如果哈希表中不包含任何元素，返回trun，如果哈希表长度大于0则返回false；&lt;/li&gt;
&lt;li&gt;size（）：返回哈希表包含的元素个数；&lt;/li&gt;
&lt;li&gt;resize（value）：对哈希表进行扩容操作；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;21哈希函数的简单实现&#34;&gt;2.1.哈希函数的简单实现&lt;/h2&gt;
&lt;p&gt;首先使用霍纳法则计算hashCode的值，通过取余操作实现哈希化，此处先简单地指定数组的大小。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //设计哈希函数
    //1.将字符串转成比较大的数字：hashCede
    //2.将大的数字hasCode压缩到数组范围(大小)之内
    function hashFunc(str, size){
      //1.定义hashCode变量
      let hashCode = 0

      //2.霍纳法则，计算hashCode的值
      //cats -&amp;gt; Unicode编码
      for(let i = 0 ;i &amp;lt; str.length; i++){
        // str.charCodeAt(i)//获取某个字符对应的unicode编码
        hashCode = 37 * hashCode + str.charCodeAt(i)
      }

      //3.取余操作
      let index = hashCode % size
      return index
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     //测试哈希函数
    console.log(hashFunc(&#39;123&#39;, 7));
    console.log(hashFunc(&#39;NBA&#39;, 7));
    console.log(hashFunc(&#39;CBA&#39;, 7));
    console.log(hashFunc(&#39;CMF&#39;, 7));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614352556116.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;22创建哈希表&#34;&gt;2.2.创建哈希表&lt;/h2&gt;
&lt;p&gt;封装哈希表的数组结构模型：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614352568255.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先创建哈希表类HashTable，并添加必要的属性和上面实现的哈希函数，再进行其他方法的实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //封装哈希表类
    function HashTable() {
      //属性
      this.storage = []
      this.count = 0//计算已经存储的元素个数
      //装填因子：loadFactor &amp;gt; 0.75时需要扩容；loadFactor &amp;lt; 0.25时需要减少容量
      this.limit = 7//初始长度

      //方法
      //哈希函数
      HashTable.prototype.hashFunc = function(str, size){
      //1.定义hashCode变量
      let hashCode = 0

      //2.霍纳法则，计算hashCode的值
      //cats -&amp;gt; Unicode编码
      for(let i = 0 ;i &amp;lt; str.length; i++){
        // str.charCodeAt(i)//获取某个字符对应的unicode编码
        hashCode = 37 * hashCode + str.charCodeAt(i)
      }

      //3.取余操作
      let index = hashCode % size
      return index
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;23putkeyvalue&#34;&gt;2.3.put(key,value)&lt;/h2&gt;
&lt;p&gt;哈希表的插入和修改操作是同一个函数：因为，当使用者传入一个&amp;lt;key，value&amp;gt;时，如果原来不存在该key，那么就是插入操作，如果原来已经存在该key，那么就是修改操作。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614352604336.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，根据key获取索引值index，目的为将数据插入到storage的对应位置；&lt;/li&gt;
&lt;li&gt;然后，根据索引值取出bucket，如果bucket不存在，先创建bucket，随后放置在该索引值的位置；&lt;/li&gt;
&lt;li&gt;接着，判断新增还是修改原来的值。如果已经有值了，就修改该值；如果没有，就执行后续操作。&lt;/li&gt;
&lt;li&gt;最后，进行新增数据操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //插入&amp;amp;修改操作
    HashTable.prototype.put = function (key, value){
      //1.根据key获取对应的index
      let index = this.hashFunc(key, this.limit)

      //2.根据index取出对应的bucket
      let bucket = this.storage[index]

      //3.判断该bucket是否为null
      if (bucket == null) {
        bucket = []
        this.storage[index] = bucket
      }

      //4.判断是否是修改数据
      for (let i = 0; i &amp;lt; bucket.length; i++) {
        let tuple = bucket[i];
        if (tuple[0] == key) {
          tuple[1] = value
          return//不用返回值
        }
      }

      //5.进行添加操作
      bucket.push([key, value])
      this.count += 1
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   //测试哈希表
    //1.创建哈希表
    let ht = new HashTable()

    //2.插入数据
    ht.put(&#39;class1&#39;,&#39;Tom&#39;)
    ht.put(&#39;class2&#39;,&#39;Mary&#39;)
    ht.put(&#39;class3&#39;,&#39;Gogo&#39;)
    ht.put(&#39;class4&#39;,&#39;Tony&#39;)
    ht.put(&#39;class4&#39;, &#39;Vibi&#39;)
    console.log(ht);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614352672421.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;24getkey&#34;&gt;2.4.get(key)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，根据key通过哈希函数获取它在storage中对应的索引值index；&lt;/li&gt;
&lt;li&gt;然后，根据索引值获取对应的bucket；&lt;/li&gt;
&lt;li&gt;接着，判断获取到的bucket是否为null，如果为null，直接返回null；&lt;/li&gt;
&lt;li&gt;随后，线性遍历bucket中每一个key是否等于传入的key。如果等于，直接返回对应的value；&lt;/li&gt;
&lt;li&gt;最后，遍历完bucket后，仍然没有找到对应的key，直接return null即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    //获取操作
    HashTable.prototype.get = function(key){
      //1.根据key获取对应的index
      let index = this.hashFunc(key, this.limit)

      //2.根据index获取对应的bucket
      let bucket = this.storage[index]

      //3.判断bucket是否等于null
      if (bucket == null) {
        return null
      }

      //4.有bucket，那么就进行线性查找
      for (let i = 0; i &amp;lt; bucket.length; i++) {
        let tuple = bucket[i];
        if (tuple[0] == key) {//tuple[0]存储key，tuple[1]存储value
          return tuple[1]
        }
      }

      //5.依然没有找到，那么返回null
      return null
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试哈希表
    //1.创建哈希表
    let ht = new HashTable()
    
	//2.插入数据
    ht.put(&#39;class1&#39;,&#39;Tom&#39;)
    ht.put(&#39;class2&#39;,&#39;Mary&#39;)
    ht.put(&#39;class3&#39;,&#39;Gogo&#39;)
    ht.put(&#39;class4&#39;,&#39;Tony&#39;)
    
    //3.获取数据
    console.log(ht.get(&#39;class3&#39;));
    console.log(ht.get(&#39;class2&#39;));
    console.log(ht.get(&#39;class1&#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614352753473.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;25removekey&#34;&gt;2.5.remove(key)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，根据key通过哈希函数获取它在storage中对应的索引值index；&lt;/li&gt;
&lt;li&gt;然后，根据索引值获取对应的bucket；&lt;/li&gt;
&lt;li&gt;接着，判断获取到的bucket是否为null，如果为null，直接返回null；&lt;/li&gt;
&lt;li&gt;随后，线性查找bucket，寻找对应的数据，并且删除；&lt;/li&gt;
&lt;li&gt;最后，依然没有找到，返回null；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //删除操作
    HashTable.prototype.remove = function(key){
      //1.根据key获取对应的index
      let index = this.hashFunc(key, this.limit)

      //2.根据index获取对应的bucket
      let bucket = this.storage[index]

      //3.判断bucket是否为null
      if (bucket == null) {
        return null
      }

      //4.有bucket,那么就进行线性查找并删除
      for (let i = 0; i &amp;lt; bucket.length; i++) {
        let tuple = bucket[i]
        if (tuple[0] == key) {
          bucket.splice(i,1)
          this.count -= 1 
          return tuple[1]
        }
    }

      //5.依然没有找到，返回null
      return null
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   //测试哈希表
   //1.创建哈希表
   let ht = new HashTable()
   
   //2.插入数据
   ht.put(&#39;class1&#39;,&#39;Tom&#39;)
   ht.put(&#39;class2&#39;,&#39;Mary&#39;)
   ht.put(&#39;class3&#39;,&#39;Gogo&#39;)
   ht.put(&#39;class4&#39;,&#39;Tony&#39;)
   
   //3.删除数据
   console.log( ht.remove(&#39;class2&#39;));
   console.log(ht.get(&#39;class2&#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614352863082.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;26其他方法的实现&#34;&gt;2.6.其他方法的实现&lt;/h2&gt;
&lt;p&gt;其他方法包括：&lt;strong&gt;isEmpty()、size()&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  //判断哈希表是否为null
  HashTable.prototype.isEmpty = function(){
    return this.count == 0
  }

  //获取哈希表中元素的个数
  HashTable.prototype.size = function(){
    return this.count
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  //测试哈希表
  //1.创建哈希表
  let ht = new HashTable()

  //2.插入数据
  ht.put(&#39;class1&#39;,&#39;Tom&#39;)
  ht.put(&#39;class2&#39;,&#39;Mary&#39;)
  ht.put(&#39;class3&#39;,&#39;Gogo&#39;)
  ht.put(&#39;class4&#39;,&#39;Tony&#39;)
  
  //3.测试isEmpty()
  console.log(ht.isEmpty());
  //4.测试isEmpty()
  console.log(ht.size());
  console.log(ht);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614352923431.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3哈希表的扩容&#34;&gt;3.哈希表的扩容&lt;/h1&gt;
&lt;h2 id=&#34;31扩容与压缩&#34;&gt;3.1.扩容与压缩&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;为什么需要扩容？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前面我们在哈希表中使用的是&lt;strong&gt;长度为7的数组&lt;/strong&gt;，由于使用的是&lt;strong&gt;链地址法&lt;/strong&gt;，**装填因子(loadFactor)**可以大于1，所以这个哈希表可以无限制地插入新数据。&lt;/li&gt;
&lt;li&gt;但是，随着&lt;strong&gt;数据量的增多&lt;/strong&gt;，storage中每一个index对应的bucket数组（链表）就会越来越长，这就会造成哈希表&lt;strong&gt;效率的降低&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;什么情况下需要扩容？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常见的情况是&lt;strong&gt;loadFactor &amp;gt; 0.75&lt;/strong&gt;的时候进行扩容；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;如何进行扩容？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单的扩容可以直接扩大&lt;strong&gt;两倍&lt;/strong&gt;（关于质数，之后讨论）；&lt;/li&gt;
&lt;li&gt;扩容之后&lt;strong&gt;所有的&lt;/strong&gt;数据项都要进行&lt;strong&gt;同步修改&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现思路:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，定义一个变量，比如oldStorage指向原来的storage；&lt;/li&gt;
&lt;li&gt;然后，创建一个新的容量更大的数组，让this.storage指向它；&lt;/li&gt;
&lt;li&gt;最后，将oldStorage中的每一个bucket中的每一个数据取出来依次添加到this.storage指向的新数组中；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614353051852.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //哈希表扩容
  HashTable.prototype.resize = function(newLimit){
    //1.保存旧的storage数组内容
    let oldStorage = this.storage

    //2.重置所有的属性
    this.storage = []
    this.count = 0
    this.limit = newLimit

    //3.遍历oldStorage中所有的bucket
    for (let i = 0; i &amp;lt; oldStorage.length; i++) {
      //3.1.取出对应的bucket
      const bucket = oldStorage[i];

      //3.2.判断bucket是否为null
      if (bucket == null) {
        continue
      }      

      //3.3.bucket中有数据，就取出数据重新插入
      for (let j = 0; j &amp;lt; bucket.length; j++) {
        const tuple = bucket[j];
        this.put(tuple[0], tuple[1])//插入数据的key和value
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述定义的哈希表的resize方法，既可以实现哈希表的&lt;strong&gt;扩容&lt;/strong&gt;，也可以实现哈希表容量的&lt;strong&gt;压缩&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;装填因子 = 哈希表中数据 / 哈希表长度，即 loadFactor = count / HashTable.length。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;通常情况下当&lt;strong&gt;装填因子laodFactor &amp;gt; 0.75&lt;/strong&gt;时，对哈希表进行扩容。在哈希表中的添加方法（push方法）中添加如下代码，判断是否需要调用扩容函数进行扩容：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;     //判断是否需要扩容操作
      if(this.count &amp;gt; this.limit * 0.75){
        this.resize(this.limit * 2)
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;当装填因子&lt;strong&gt;laodFactor &amp;lt; 0.25&lt;/strong&gt;时，对哈希表容量进行压缩。在哈希表中的删除方法（remove方法）中添加如下代码，判断是否需要调用扩容函数进行压缩：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    //缩小容量
    if (this.limit &amp;gt; 7 &amp;amp;&amp;amp; this.count &amp;lt; this.limit * 0.25) {
      this.resize(Math.floor(this.limit / 2))
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;32选择质数作为容量&#34;&gt;3.2.选择质数作为容量&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;质数的判断&lt;/strong&gt;&lt;br&gt;
首先我们来复习一下，判断质数的方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意1不是质数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;方法一：针对质数的特点：只能被1和num整除，不能被2 ~ (num-1)整除。遍历2 ~ (num-1) 。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;function isPrime(num){
      if(num &amp;lt;= 1 ){
        return false
      } 
      for(let i = 2; i &amp;lt;= num - 1; i++){
        if(num % i ==0){
          return false
        }
      }
        return true
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方法虽然能实现质数的判断，但是效率不高。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法二：只需要遍历2 ~ num的平方根即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    function isPrime(num){
      if (num &amp;lt;= 1) {
        return false
      }
      //1.获取num的平方根:Math.sqrt(num)
      //2.循环判断
      for(var i = 2; i&amp;lt;= Math.sqrt(num); i++ ){
        if(num % i == 0){
          return false;
        }
      }
        return true;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;实现扩容后的哈希表容量为质数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;br&gt;
2倍扩容之后，通过循环调用isPrime判断得到的容量是否为质数，不是则+1，直到是为止。比如原长度：7，2倍扩容后长度为14，14不是质数，14 + 1 = 15不是质数，15 + 1 = 16不是质数，16 + 1 = 17是质数，停止循环，由此得到质数17。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步：首先需要为HashTable类添加判断质数的isPrime方法和获取质数的getPrime方法：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;  //判断传入的num是否质数
  HashTable.prototype.isPrime = function(num){
      if (num &amp;lt;= 1) {
        return false
      }
      //1.获取num的平方根:Math.sqrt(num)
      //2.循环判断
      for(var i = 2; i&amp;lt;= Math.sqrt(num); i++ ){
        if(num % i == 0){
          return false;
        }
      }
        return true;
    }

    //获取质数的方法
    HashTable.prototype.getPrime = function(num){
       //7*2=14,+1=15,+1=16,+1=17(质数)
      while (!this.isPrime(num)) {
        num++
      }
      return num
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;第二步：修改添加元素的put方法和删除元素的remove方法中关于数组扩容的相关操作：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在put方法中添加如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //判断是否需要扩容操作
      if(this.count &amp;gt; this.limit * 0.75){
        let newSize = this.limit * 2
        let newPrime = this.getPrime(newSize)
        this.resize(newPrime)
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在remove方法中添加如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     //缩小容量
          if (this.limit &amp;gt; 7 &amp;amp;&amp;amp; this.count &amp;lt; this.limit * 0.25) {
            let newSize = Math.floor(this.limit / 2)
            let newPrime = this.getPrime(newSize)
            this.resize(newPrime)
          }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  let ht = new HashTable()

    ht.put(&#39;class1&#39;,&#39;Tom&#39;)
    ht.put(&#39;class2&#39;,&#39;Mary&#39;)
    ht.put(&#39;class3&#39;,&#39;Gogo&#39;)
    ht.put(&#39;class4&#39;,&#39;Tony&#39;)
    ht.put(&#39;class5&#39;,&#39;5&#39;)
    ht.put(&#39;class6&#39;,&#39;6&#39;)
    ht.put(&#39;class7&#39;,&#39;7&#39;)
    ht.put(&#39;class8&#39;,&#39;8&#39;)
    ht.put(&#39;class9&#39;,&#39;9&#39;)
    ht.put(&#39;class10&#39;,&#39;10&#39;)
    console.log(ht.size());//10
    console.log(ht.limit);//17
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614353404211.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;4哈希表的完整实现&#34;&gt;4.哈希表的完整实现&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;    //封装哈希表类
    function HashTable() {
      //属性
      this.storage = []
      this.count = 0//计算已经存储的元素个数
      //装填因子：loadFactor &amp;gt; 0.75时需要扩容；loadFactor &amp;lt; 0.25时需要减少容量
      this.limit = 7//初始长度

      //方法
      //哈希函数
      HashTable.prototype.hashFunc = function(str, size){
      //1.定义hashCode变量
      let hashCode = 0

      //2.霍纳法则，计算hashCode的值
      //cats -&amp;gt; Unicode编码
      for(let i = 0 ;i &amp;lt; str.length; i++){
        // str.charCodeAt(i)//获取某个字符对应的unicode编码
        hashCode = 37 * hashCode + str.charCodeAt(i)
      }

      //3.取余操作
      let index = hashCode % size
      return index
    }

    //一.插入&amp;amp;修改操作
    HashTable.prototype.put = function (key, value){
      //1.根据key获取对应的index
      let index = this.hashFunc(key, this.limit)

      //2.根据index取出对应的bucket
      let bucket = this.storage[index]

      //3.判断该bucket是否为null
      if (bucket == null) {
        bucket = []
        this.storage[index] = bucket
      }

      //4.判断是否是修改数据
      for (let i = 0; i &amp;lt; bucket.length; i++) {
        let tuple = bucket[i];
        if (tuple[0] == key) {
          tuple[1] = value
          return//不用返回值
        }
      }

      //5.进行添加操作
      bucket.push([key, value])
      this.count += 1

      //6.判断是否需要扩容操作
      if(this.count &amp;gt; this.limit * 0.75){
        let newSize = this.limit * 2
        let newPrime = this.getPrime(newSize)
        this.resize(newPrime)
      }
    }

    //二.获取操作
    HashTable.prototype.get = function(key){
      //1.根据key获取对应的index
      let index = this.hashFunc(key, this.limit)

      //2.根据index获取对应的bucket
      let bucket = this.storage[index]

      //3.判断bucket是否等于null
      if (bucket == null) {
        return null
      }

      //4.有bucket，那么就进行线性查找
      for (let i = 0; i &amp;lt; bucket.length; i++) {
        let tuple = bucket[i];
        if (tuple[0] == key) {//tuple[0]存储key，tuple[1]存储value
          return tuple[1]
        }
      }

      //5.依然没有找到，那么返回null
      return null
    }

    //三.删除操作
    HashTable.prototype.remove = function(key){
      //1.根据key获取对应的index
      let index = this.hashFunc(key, this.limit)

      //2.根据index获取对应的bucket
      let bucket = this.storage[index]

      //3.判断bucket是否为null
      if (bucket == null) {
        return null
      }

      //4.有bucket,那么就进行线性查找并删除
      for (let i = 0; i &amp;lt; bucket.length; i++) {
        let tuple = bucket[i]
        if (tuple[0] == key) {
          bucket.splice(i,1)
          this.count -= 1 
          return tuple[1]

          //6.缩小容量
          if (this.limit &amp;gt; 7 &amp;amp;&amp;amp; this.count &amp;lt; this.limit * 0.25) {
            let newSize = Math.floor(this.limit / 2)
            let newPrime = this.getPrime(newSize)
            this.resize(newPrime)
          }
        }
    }

      //5.依然没有找到，返回null
      return null
    }

  /*------------------其他方法--------------------*/
  //判断哈希表是否为null
  HashTable.prototype.isEmpty = function(){
    return this.count == 0
  }

  //获取哈希表中元素的个数
  HashTable.prototype.size = function(){
    return this.count
  }


  //哈希表扩容
  HashTable.prototype.resize = function(newLimit){
    //1.保存旧的storage数组内容
    let oldStorage = this.storage

    //2.重置所有的属性
    this.storage = []
    this.count = 0
    this.limit = newLimit

    //3.遍历oldStorage中所有的bucket
    for (let i = 0; i &amp;lt; oldStorage.length; i++) {
      //3.1.取出对应的bucket
      const bucket = oldStorage[i];

      //3.2.判断bucket是否为null
      if (bucket == null) {
        continue
      }      

      //3.3.bucket中有数据，就取出数据重新插入
      for (let j = 0; j &amp;lt; bucket.length; j++) {
        const tuple = bucket[j];
        this.put(tuple[0], tuple[1])//插入数据的key和value
      }
    }
  }

  //判断传入的num是否质数
  HashTable.prototype.isPrime = function(num){
      if (num &amp;lt;= 1) {
        return false
      }
      //1.获取num的平方根:Math.sqrt(num)
      //2.循环判断
      for(var i = 2; i&amp;lt;= Math.sqrt(num); i++ ){
        if(num % i == 0){
          return false;
        }
      }
        return true;
    }

    //获取质数的方法
    HashTable.prototype.getPrime = function(num){
       //7*2=14,+1=15,+1=16,+1=17(质数)
      while (!this.isPrime(num)) {
        num++
      }
      return num
    }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1x7411L7Q7?from=search&amp;amp;seid=3912456004602554239&#34;&gt;参考资料:JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现哈希表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/fan-wai-cong-a-li-yun-ban-jia-dao-teng-xun-yun-de-tian-keng-zhi-lu/"" data-c="
          &lt;p&gt;原因：穷，续费超过花呗上限🙁&lt;br&gt;
目的：域名(备案)从阿里云转移到腾讯云&lt;br&gt;
题记：作为一个“敬业”的博主(其实是怕以后忘了)，随手记录并分享出来。&lt;/p&gt;
&lt;h1 id=&#34;一-域名转移&#34;&gt;一、域名转移&lt;/h1&gt;
&lt;h2 id=&#34;11-阿里云索取域名转移密码&#34;&gt;1.1 阿里云索取域名转移密码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.aliyun.com/minisite/goods?userCode=2rbhf9dd&#34;&gt;点我登陆&lt;/a&gt;阿里云控制台，进入域名控制台，在域名基本信息中点击【索取域名转移码】，这时阿里云会向域名管理邮箱发送一封带有转移密码的邮件，名头是“万网域名转出密码通知”。复制邮件中的转移密码。&lt;br&gt;
提示:如果提示“已开启[禁止更新锁],该功能暂不可用”，这是阿里云的安全机制作用了，需要你去手动关闭，在【安全设置】中关闭系统自带的“两把锁”，按照提示操作，提供相应的手机验证码即可。然后就能正常索取密码了。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613741482839.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;12-腾讯云域名转入操作&#34;&gt;1.2 腾讯云域名转入操作&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://cloud.tencent.com/?fromSource=gwzcw.1293314.1293314.1293314&amp;amp;cps_key=5c28f3346f24fe86eb5b34852bad6c77&#34;&gt;点我打开&lt;/a&gt;腾讯云官网，进入控制台中的域名管理，先创建一份【域名信息模板】，按照页面要求填写完毕提交，等待审核完毕。正常审核时间为一个工作日，实际上1小时左右就能完成。&lt;br&gt;
然后在下图的【域名转入】页面中，输入域名和转移码，要求中间有空格，不懂的看系统提示。&lt;br&gt;
绑定域名信息模板后，提交。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613741580974.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;13-等待域名转移和后悔期&#34;&gt;1.3 等待域名转移和后悔期&lt;/h2&gt;
&lt;p&gt;这时候阿里云再次发邮件给你，名头是“阿里云域名转出通知”，里面有转移到期的日期，意思是说如果你想转移域名，就可以忽略这封邮件。等待几天就会自动转移成功了。&lt;br&gt;
提示:在这期间有5~7天的后悔期，就是说转移不是马上就完成了，在这些天中如果你不想转移了，可以点击阿里云域名控制台或者邮件中的【取消】，来停止这场转移，这样域名仍旧留在阿里云了。&lt;/p&gt;
&lt;h2 id=&#34;14-域名转移到腾讯云&#34;&gt;1.4 域名转移到腾讯云&lt;/h2&gt;
&lt;p&gt;超过了到期时间后域名就会自动转移到腾讯云了，域名邮箱也会同时收到转移成功的邮件。这时候域名会借助域名信息模板自动实名，接下来就是网站备案，域名解析，安装环境及部署网站等一系列操作了。&lt;/p&gt;
&lt;h1 id=&#34;二-部署个人博客&#34;&gt;二、部署个人博客&lt;/h1&gt;
&lt;h2 id=&#34;21-所需工具&#34;&gt;2.1 所需工具&lt;/h2&gt;
&lt;p&gt;使用github托管个人博客静态网页，使用gridea作为静态网页生成器(操作简单)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;github账号&lt;a href=&#34;https://github.com/&#34;&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;gridea下载安装&lt;a href=&#34;https://gridea.dev/&#34;&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;22-创建仓库存储静态网页&#34;&gt;2.2 创建仓库存储静态网页&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742044871.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742050262.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;23-生成个人访问令牌&#34;&gt;2.3 生成个人访问令牌&lt;/h2&gt;
&lt;p&gt;依次点击，右上角头像-&amp;gt;Developer settings-&amp;gt;Personal access tokens-&amp;gt;Generate new token&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742116246.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742119740.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;24-在gridea填写域名仓库名称等信息同步&#34;&gt;2.4 在gridea填写域名，仓库名称等信息，同步&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742207612.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742210710.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
刷新一下github仓库网页，会看到多了很多文件&lt;/p&gt;
&lt;h1 id=&#34;三-github绑定自己的域名&#34;&gt;三、github绑定自己的域名&lt;/h1&gt;
&lt;h2 id=&#34;31-在仓库里添加cname文件并在文件中填写绑定的域名&#34;&gt;3.1 在仓库里添加CNAME文件并在文件中填写绑定的域名&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742323733.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
文件里填写的内容：要绑定的域名（不要包含Http://和www）&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742361386.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
进入设置&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742397702.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
找到 Custom domain添加域名后保存即可。&lt;br&gt;
（添加CNAME文件并在文件中填写绑定的域名后应该会自动保存，看看有没有自动保存）&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742412812.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-添加域名解析&#34;&gt;3.2 添加域名解析&lt;/h2&gt;
&lt;p&gt;ping你的http://github.io域名，得到一个IP&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742460079.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
修改你的域名解析记录；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742567477.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加两个记录分别为A和CNAME，A绑定刚才得到的ip地址，CNAME绑定自己的域名&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742731980.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;33-绑定成功&#34;&gt;3.3 绑定成功&lt;/h2&gt;
&lt;h1 id=&#34;四-本地dns更新&#34;&gt;四、本地DNS更新&lt;/h1&gt;
&lt;p&gt;域名指向新的服务器IP后不能访问的解决办法：&lt;br&gt;
不能访问是因为本地DNS缓存，缓存清除方法：dos命令窗口输入ipconfig/flushdns ，回车即可。&lt;/p&gt;
">【番外】从阿里云搬家到腾讯云的填坑之路</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/javascript-shi-xian-ji-he-yu-zi-dian/"" data-c="
          &lt;h1 id=&#34;1集合结构&#34;&gt;1.集合结构&lt;/h1&gt;
&lt;h2 id=&#34;11简介&#34;&gt;1.1.简介&lt;/h2&gt;
&lt;p&gt;集合比较常见的实现方式是&lt;strong&gt;哈希表&lt;/strong&gt;，这里使用JavaScript的Object类进行封装。&lt;br&gt;
集合通常是由一组&lt;strong&gt;无序的、不能重复&lt;/strong&gt;的元素构成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数学中常指的集合中的元素是可以重复的，但是计算机中集合的元素不能重复。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;集合是特殊的数组：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特殊之处在于里面的元素&lt;strong&gt;没有顺序，也不能重复&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;没有顺序意味着&lt;strong&gt;不能通过下标值进行访问&lt;/strong&gt;，不能重复意味着&lt;strong&gt;相同的对象&lt;/strong&gt;在集合中只会&lt;strong&gt;存在一份&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现集合类：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在ES6中的&lt;strong&gt;Set&lt;/strong&gt;类就是一个集合类，这里我们重新封装一个Set类，了解集合的底层实现。&lt;/li&gt;
&lt;li&gt;JavaScript中的&lt;strong&gt;Object&lt;/strong&gt;类中的&lt;strong&gt;key&lt;/strong&gt;就是一个集合，可以使用它来封装集合类Set。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;集合常见的操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;add（value）：向集合添加一个新的项；&lt;/li&gt;
&lt;li&gt;remove（value）：从集合中移除一个值；&lt;/li&gt;
&lt;li&gt;has（value）：如果值在集合中，返回true，否则返回false；&lt;/li&gt;
&lt;li&gt;clear（）：移除集合中的所有项；&lt;/li&gt;
&lt;li&gt;size（）：返回集合所包含元素的数量，与数组的length属性相似；&lt;/li&gt;
&lt;li&gt;values（）：返回一个包含集合中所有值的数组；&lt;br&gt;
还有其他的方法，用的不多这里不做封装；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12代码实现&#34;&gt;1.2.代码实现&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;     //封装集合类
    function Set() {
      //属性
      this.items = {}

      //方法
      //一.has方法
      Set.prototype.has = value =&amp;gt; {
        return this.items.hasOwnProperty(value)
      }

      //二.add方法
      Set.prototype.add = value =&amp;gt; {
        //判断集合中是否已经包含该元素
        if (this.has(value)) {
          return false
        }
        //将元素添加到集合中
        this.items[value] = value//表示该属性键和值都为value
        return true//表示添加成功
      }

      //三.remove方法
      Set.prototype.remove = (value) =&amp;gt; {
        //1.判断集合中是否包含该元素
        if (!this.has(value)) {
          return false
        }

        //2.将元素从属性中删除
        delete this.items[value]
        return true
      }

      //四.clear方法
      Set.prototype.clear = () =&amp;gt; {
        //原来的对象没有引用指向，会被自动回收
        this.items = {}
      }

      //五.size方法
      Set.prototype.size = () =&amp;gt; {
        return Object.keys(this.items).length
      }

      //获取集合中所有的值
      //六.values方法
      Set.prototype.values = function() {
        return Object.keys(this.items)
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试集合类
    //1.创建Set类对象
    let set = new Set()

    //添加元素
    //2.测试add方法
    console.log(set.add(&#39;a&#39;));									
    console.log(set.add(&#39;a&#39;));										
    console.log(set.add(&#39;b&#39;));									
    console.log(set.add(&#39;c&#39;));										
    console.log(set.add(&#39;d&#39;));										

    //3.测试values方法
    console.log(set.values());									

    //删除元素
    //4.测试remove方法
    console.log(set.remove(&#39;a&#39;));								
    console.log(set.remove(&#39;a&#39;));								
    console.log(set.values());										

    //5.测试has方法
    console.log(set.has(&#39;b&#39;));										

    //6.测试size方法和clear方法
    console.log(set.size());										
    set.clear()
    // 由于clear方法的实现原理为指向另外一个空对象，所以不影响原来的对象
    console.log(set.size());										
    console.log(set.values());				
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613738370515.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;13集合间的操作&#34;&gt;1.3.集合间的操作&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;集合间操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合；&lt;/li&gt;
&lt;li&gt;交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合；&lt;/li&gt;
&lt;li&gt;差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合；&lt;/li&gt;
&lt;li&gt;子集：验证一个给定集合是否是另一个集合的子集；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613738411477.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;并集的实现：&lt;/strong&gt;&lt;br&gt;
实现思路：创建集合C代表集合A和集合B的并集，先将集合A中的所有元素添加到集合C中，再遍历集合B，如果是集合C所没有的元素就把它添加到集合C中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Set.prototype.union = otherSet =&amp;gt; {
      // this:集合对象A
      // otherSet:集合对象B
      //1.创建一个新的集合
      let unionSet = new Set()

      //2.将A集合中的所有元素添加到新集合中
      let values = this.values()
      // for(let i of values){
      //   unionSet.add(i)
      // }
      for(let i = 0;i &amp;lt; values.length;i++){
        unionSet.add(values[i])
      }

      //3.取出B集合中的元素,判断是否需要加到新集合中
      values = otherSet.values()
      // for(let i of values){
      //   //由于集合的add方法已经对重复的元素进行了判断,所以这里可以直接添加
      //   unionSet.add(i)
      // }
      for(let i = 0;i &amp;lt; values.length;i++){
        unionSet.add(values[i])
      }
      return unionSet
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;交集的实现：&lt;/strong&gt;&lt;br&gt;
实现思路：遍历集合A，当取得的元素也存在于集合B时，就把该元素添加到另一个集合C中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; Set.prototype.intersection = otherSet =&amp;gt; {
      // this:集合A
      // otherSet:集合B
      //1.创建新的集合
      let intersectionSet = new Set()
      
      //2.从A中取出一个元素，判断是否同时存在于集合B中，是则放入新集合中
      let values = this.values()
      for(let i =0 ; i &amp;lt; values.length; i++){
        let item = values[i]
        if (otherSet.has(item)) {
          intersectionSet.add(item)
        }
      }
      return intersectionSet
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;差集的实现：&lt;/strong&gt;&lt;br&gt;
实现思路：遍历集合A，当取得的元素不存在于集合B时，就把该元素添加到另一个集合C中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Set.prototype.diffrence = otherSet =&amp;gt; {
        //this:集合A
        //otherSet:集合B
        //1.创建新的集合
        var diffrenceSet = new Set()

        //2.取出A集合中的每一个元素，判断是否同时存在于B中，不存在则添加到新集合中
        var values = this.values()
        for(var i = 0;i &amp;lt; values.length; i++){
          var item = values[i]
          if (!otherSet.has(item)) {
            diffrenceSet.add(item)
          }
        }
        return diffrenceSet
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;子集的实现：&lt;/strong&gt;&lt;br&gt;
实现思路：遍历集合A，当取得的元素中有一个不存在于集合B时，就说明集合A不是集合B的子集，返回false。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; Set.prototype.subset = otherSet =&amp;gt; {
        //this:集合A
        //otherSet：集合B
        //遍历集合A中的所有元素，如果发现，集合A中的元素，在集合B中不存在，那么放回false，如果遍历完整个集合A没有返回false，就返回true
        let values = this.values()
        for(let i = 0; i &amp;lt; values.length; i++){
          let item = values[i]
          if(!otherSet.has(item)){
            return false
          }
        }
        return true
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2字典结构&#34;&gt;2.字典结构&lt;/h1&gt;
&lt;h2 id=&#34;21简介&#34;&gt;2.1.简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;字典的特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字典存储的是键值对，主要特点是一一对应；&lt;/li&gt;
&lt;li&gt;比如保存一个人的信息：数组形式：[19，‘Tom’，1.65]，可通过下标值取出信息；字典形式：{&amp;quot;age&amp;quot;：19，&amp;quot;name&amp;quot;：&amp;quot;Tom&amp;quot;，&amp;quot;height&amp;quot;：165}，可以通过key取出value。&lt;/li&gt;
&lt;li&gt;此外，在字典中&lt;strong&gt;key&lt;/strong&gt;是&lt;strong&gt;不能重复&lt;/strong&gt;且&lt;strong&gt;无序&lt;/strong&gt;的，而&lt;strong&gt;Value&lt;/strong&gt;可以&lt;strong&gt;重复&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;字典和映射的关系：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有些编程语言中称这种映射关系为字典，如Swift中的Dictonary，Python中的dict；&lt;/li&gt;
&lt;li&gt;有些编程语言中称这种映射关系为Map，比如Java中的HashMap&amp;amp;TreeMap等；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;字典类常见的操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;set(key,value)：向字典中添加新元素。&lt;/li&gt;
&lt;li&gt;remove(key)：通过使用键值来从字典中移除键值对应的数据值。&lt;/li&gt;
&lt;li&gt;has(key)：如果某个键值存在于这个字典中，则返回true，反之则返回false。&lt;/li&gt;
&lt;li&gt;get(key)：通过键值查找特定的数值并返回。&lt;/li&gt;
&lt;li&gt;clear()：将这个字典中的所有元素全部删除。&lt;/li&gt;
&lt;li&gt;size()：返回字典所包含元素的数量。与数组的length属性类似。&lt;/li&gt;
&lt;li&gt;keys()：将字典所包含的所有键名以数组形式返回。&lt;/li&gt;
&lt;li&gt;values()：将字典所包含的所有数值以数组形式返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;22封装字典&#34;&gt;2.2.封装字典&lt;/h2&gt;
&lt;p&gt;字典类可以基于JavaScript中的对象结构来实现，比较简单，这里直接实现字典类中的常用方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//封装字典类
function Dictionary(){
  //字典属性
  this.items = {}

  //字典操作方法
  //一.在字典中添加键值对
  Dictionary.prototype.set = function(key, value){
    this.items[key] = value
  }

  //二.判断字典中是否有某个key
  Dictionary.prototype.has = function(key){
    return this.items.hasOwnProperty(key)
  }

  //三.从字典中移除元素
  Dictionary.prototype.remove = function(key){
    //1.判断字典中是否有这个key
    if(!this.has(key)) return false

    //2.从字典中删除key
    delete this.items[key]
    return true
  }

  //四.根据key获取value
  Dictionary.prototype.get = function(key){
    return this.has(key) ? this.items[key] : undefined
  }

  //五.获取所有keys
  Dictionary.prototype.keys = function(){
    return Object.keys(this.items)
  }

  //六.size方法
  Dictionary.prototype.keys = function(){
    return this.keys().length
  }

  //七.clear方法
  Dictionary.prototype.clear = function(){
    this.items = {}
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1x7411L7Q7?from=search&amp;amp;seid=3912456004602554239&#34;&gt;参考资料:JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现集合与字典</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/javascript-shi-xian-shuang-xiang-lian-biao/"" data-c="
          &lt;h1 id=&#34;1双向链表简介&#34;&gt;1.双向链表简介&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;双向链表&lt;/strong&gt;：既可以&lt;strong&gt;从头遍历到尾&lt;/strong&gt;，又可以&lt;strong&gt;从尾遍历到头&lt;/strong&gt;。也就是说链表连接的过程是&lt;strong&gt;双向&lt;/strong&gt;的，它的实现原理是：一个节点既有&lt;strong&gt;向前连接的引用&lt;/strong&gt;，也有一个&lt;strong&gt;向后连接的引用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;双向链表的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次在插入或删除某个节点时，都需要处理四个引用，而不是两个，实现起来会困难些；&lt;/li&gt;
&lt;li&gt;相对于单向链表，所占内存空间更大一些；&lt;/li&gt;
&lt;li&gt;但是，相对于双向链表的便利性而言，这些缺点微不足道。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;双向链表的结构：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612851991692.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双向链表不仅有&lt;strong&gt;head&lt;/strong&gt;指针指向第一个节点，而且有&lt;strong&gt;tail&lt;/strong&gt;指针指向最后一个节点；&lt;/li&gt;
&lt;li&gt;每一个节点由三部分组成：&lt;strong&gt;item&lt;/strong&gt;储存数据、&lt;strong&gt;prev&lt;/strong&gt;指向前一个节点、&lt;strong&gt;next&lt;/strong&gt;指向后一个节点；&lt;/li&gt;
&lt;li&gt;双向链表的第一个节点的&lt;strong&gt;prev&lt;/strong&gt;指向&lt;strong&gt;null&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;双向链表的最后一个节点的&lt;strong&gt;next&lt;/strong&gt;指向&lt;strong&gt;null&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;双向链表常见的操作（方法）：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;append（element）：向链表尾部添加一个新的项；&lt;br&gt;
*inset（position，element）：向链表的特定位置插入一个新的项；&lt;/li&gt;
&lt;li&gt;get（element）：获取对应位置的元素；&lt;/li&gt;
&lt;li&gt;indexOf（element）：返回元素在链表中的索引，如果链表中没有元素就返回-1；&lt;/li&gt;
&lt;li&gt;update（position，element）：修改某个位置的元素；&lt;/li&gt;
&lt;li&gt;removeAt（position）：从链表的特定位置移除一项；&lt;/li&gt;
&lt;li&gt;isEmpty（）：如果链表中不包含任何元素，返回trun，如果链表长度大于0则返回false；&lt;/li&gt;
&lt;li&gt;size（）：返回链表包含的元素个数，与数组的length属性类似；&lt;/li&gt;
&lt;li&gt;toString（）：由于链表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值；&lt;/li&gt;
&lt;li&gt;forwardString（）：返回正向遍历节点字符串形式；&lt;/li&gt;
&lt;li&gt;backwordString（）：返回反向遍历的节点的字符串形式；&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2封装双向链表类&#34;&gt;2.封装双向链表类&lt;/h1&gt;
&lt;h2 id=&#34;21创建双向链表类&#34;&gt;2.1.创建双向链表类&lt;/h2&gt;
&lt;p&gt;先创建双向链表类DoubleLinklist，并添加基本属性，再实现双向链表的常用方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //封装双向链表类
    function DoubleLinklist(){
      //封装内部类：节点类
      function Node(data){
        this.data = data
        this.prev = null
        this.next = null
      }

      //属性
      this.head = null
      this.tail ==null
      this.length = 0
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;22appendelement&#34;&gt;2.2.append(element)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //append方法
      DoubleLinklist.prototype.append = data =&amp;gt; {
        //1.根据data创建新节点
        let newNode = new Node(data)

        //2.添加节点
        //情况1：添加的是第一个节点
        if (this.length == 0) {
          this.tail = newNode
          this.head = newNode 
        //情况2：添加的不是第一个节点
        }else {
          newNode.prev = this.tail
          this.tail.next = newNode
          this.tail = newNode
        }

        //3.length+1
        this.length += 1
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
添加节点时分为多种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：添加的是第一个节点：只需要让head和tail都指向新节点即可；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852175479.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;情况2：添加的不是第一个节点，如下图所示：只需要改变相关引用的指向即可。&lt;br&gt;
通过：newNode.prev = this.tail：建立指向1；&lt;br&gt;
通过：this.tail.next = newNode：建立指向2；&lt;br&gt;
通过：this.tail = newNode：建立指向3&lt;br&gt;
要注意改变变量指向的顺序，最后修改tail指向，这样未修改前tail始终指向原链表的最后一个节点。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852234410.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852237080.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
   //1.创建双向链表
   let list = new DoubleLinklist()

    //2.测试append方法
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;next方向：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852391457.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;prev方向：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852402201.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;23tostring汇总&#34;&gt;2.3.toString()汇总&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //将链表转变为字符串形式
      //一.toString方法
      DoubleLinklist.prototype.toString = () =&amp;gt; {
        return this.backwardString()
      }

      //二.forwardString方法
      DoubleLinklist.prototype.forwardString = () =&amp;gt; {
        //1.定义变量
        let current =this.tail
        let resultString = &amp;quot;&amp;quot;
        //2.依次向前遍历，获取每一个节点
        while (current) {
          resultString += current.data + &amp;quot;--&amp;quot;
          current = current.prev 
        }
        return resultString
      }

      //三.backwardString方法
      DoubleLinklist.prototype.backwardString = () =&amp;gt; {
        //1.定义变量
        let current = this.head
        let resultString = &amp;quot;&amp;quot;

        //2.依次向后遍历，获取每一个节点
        while (current) {
          resultString += current.data + &amp;quot;--&amp;quot;
          current = current.next
        }
        return resultString
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
三种获取字符串的方法：toString（）、forwardString（）、backwardString（）实现原理相似，仅以backWardString方法为例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义current变量记录当前指向的节点。首先让current指向第一个节点，然后通过 current = current.next 依次向后遍历。在while循环中以(current)作为条件遍历链表，只要current ！= null就一直遍历，由此可获取链表所有节点的数据。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852477706.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建双向链表
    let list = new DoubleLinklist()
    
    //2.测试字符串方法   
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)
    console.log(list.toString());
    console.log(list.forwardString());
    console.log(list.backwardString());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852509395.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;24insertpositionelement&#34;&gt;2.4.insert(position,element)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      //insert方法
      DoubleLinklist.prototype.insert = (position, data) =&amp;gt; {
        //1.越界判断
        if (position &amp;lt; 0 || position &amp;gt; this.length) return false

        //2.根据data创建新的节点
        let newNode = new Node(data)

        //3.插入新节点
        //原链表为空
          //情况1：插入的newNode是第一个节点
        if (this.length == 0) {
          this.head = newNode
          this.tail = newNode
        //原链表不为空
        }else {
          //情况2：position == 0
          if (position == 0) {
            this.head.prev = newNode
            newNode.next = this.head
            this.head = newNode
          //情况3：position == this.length 
          } else if(position == this.length){
            this.tail.next = newNode
            newNode.prev = this.tail
            this.tail = newNode
            //情况4：0 &amp;lt; position &amp;lt; this.length
          }else{
            let current = this.head
            let index = 0
            while(index++ &amp;lt; position){
              current = current.next
            }
            //修改pos位置前后节点变量的指向
            newNode.next = current
            newNode.prev = current.prev
            current.prev.next = newNode
            current.prev = newNode
          }
        }
        //4.length+1
        this.length += 1
        return true//返回true表示插入成功
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
插入节点可分为多种情况：&lt;br&gt;
&lt;strong&gt;当原链表为空时：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：插入的新节点是链表的第一个节点；只需要让head和tail都指向newNode即可。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852572211.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;当原链表不为空时：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;情况2：当position == 0，即在链表的首部添加节点：如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852606766.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先，通过：this.head.prev = newNode，改变指向1；&lt;br&gt;
然后，通过：newNode.next = this.head，改变指向2；&lt;br&gt;
最后，通过：this.head = newNode，改变指向3；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852623273.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;情况3：position == this.length，即在链表的尾部添加节点，如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852636699.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;首先&lt;/strong&gt;，通过：this.tail.next = newNode，改变指向1；（注意这里使用this.tail指向原链表最后一个节点，而不是this.head。因为当length&amp;gt;1时，this.head != this.tail。）&lt;br&gt;
&lt;strong&gt;然后&lt;/strong&gt;，通过：newNode.prev = this.tail，改变指向2；&lt;br&gt;
&lt;strong&gt;最后&lt;/strong&gt;，通过：this.tail = newNode，改变指向3；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852702385.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;情况4：0 &amp;lt; position &amp;lt; this.length，即在链表的中间插入新节点，假设在position = 1的位置插入，如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852718023.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先，需要定义变量current按照之前的思路，通过while循环找到position位置的后一个节点，循环结束后index = position&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852732864.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如下图所示：当position = 1时，current就指向了Node2。这样操作current就等同于间接地操作Node2，还可以通过current.prev间接获取Node1。得到了newNode的前一个节点和后一个节点就可以通过改变它们的prev和next变量的指向来插入newNode了。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852753700.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;通过&lt;/strong&gt;：newNode.next = current，改变指向1；&lt;br&gt;
&lt;strong&gt;通过&lt;/strong&gt;：newNode.prev = current.prev，改变指向2；&lt;br&gt;
&lt;strong&gt;通过&lt;/strong&gt;：current.prev.next = newNode，改变指向3；&lt;br&gt;
&lt;code&gt;注意必须最后才修改current.prev的指向，不然就无法通过current.prev获取需要操作的Node1了。&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;通过&lt;/strong&gt;：current.prev = current，改变指向4；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852934567.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建双向链表
    let list = new DoubleLinklist()

	//2.测试insert方法
    list.insert(0, &#39;插入链表的第一个元素&#39;)
    list.insert(0, &#39;在链表首部插入元素&#39;)
    list.insert(1, &#39;在链表中间插入元素&#39;)
    list.insert(3, &#39;在链表尾部插入元素&#39;)
    console.log(list);
    alert(list)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852974146.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852977704.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;25getposition&#34;&gt;2.5.get(position)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      //get方法
      DoubleLinklist.prototype.get = position =&amp;gt; {
        //1.越界判断
        if (position &amp;lt; 0 || position &amp;gt;= this.length) {//获取元素时position不能等于length
          return null
        }

        //2.获取元素
        let current = null
        let index = 0
        //this.length / 2 &amp;gt; position:从头开始遍历
        if ((this.length / 2) &amp;gt; position) {
          current = this.head
          while(index++ &amp;lt; position){
          current = current.next
        }
        //this.length / 2 =&amp;lt; position:从尾开始遍历
        }else{
          current = this.tail
          index = this.length - 1
          while(index-- &amp;gt; position){
          current = current.prev
        }
        }
        return current.data
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
定义两个变量current和index，按照之前的思路通过while循环遍历分别获取当前节点和对应的索引值index，直到找到需要获取的position位置后的一个节点，此时index = pos =x，然后return current.data即可。&lt;/p&gt;
&lt;p&gt;如果链表的节点数量很多时，这种查找方式效率不高，改进方法为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一定要通过this.length来获取链表的节点数否则就会报错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;当this.length / 2 &amp;gt; position：从头（head）开始遍历；&lt;/li&gt;
&lt;li&gt;当this.length / 2 &amp;lt; position：从尾（tail）开始遍历；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853079217.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建双向链表
    let list = new DoubleLinklist()
    
  	//2.测试get方法
    list.append(&#39;a&#39;)
    list.append(&#39;b&#39;)
    list.append(&#39;b1&#39;)
    list.append(&#39;b2&#39;)
    list.append(&#39;b3&#39;)
    list.append(&#39;b4&#39;)
    list.append(&#39;b5&#39;)
    list.append(&#39;b6&#39;)
    list.append(&#39;b7&#39;)
    console.log(list.get(0));
    console.log(list.get(7));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853118806.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;26indexofelement&#34;&gt;2.6.indexOf(element)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      //indexOf方法
      DoubleLinklist.prototype.indexOf = data =&amp;gt; {
        //1.定义变量
        let current = this.head
        let index = 0

        //2.遍历链表，查找与data相同的节点
        while(current){
          if (current.data == data) {
            return index
          }
          current = current.next
          index += 1
        }
        return -1
      } 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
以（current）作为条件，通过while循环遍历链表中的所有节点（停止条件为current = null）。在遍历每个节点时将current指向的当前节点的data和传入的data进行比较即可。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853385534.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建双向链表
    let list = new DoubleLinklist()
    
    //2.测试indexOf方法
    list.append(&#39;a&#39;)
    list.append(&#39;b&#39;)
    list.append(&#39;c&#39;)
    console.log(list.indexOf(&#39;a&#39;));
    console.log(list.indexOf(&#39;c&#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853417022.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;28updatepositionelement&#34;&gt;2.8.update(position,element)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;        //update方法
      DoubleLinklist.prototype.update = (position, newData) =&amp;gt; {
        //1.越界判断
        if (position &amp;lt; 0 || position &amp;gt;= this.length) {
          return false
        }

        //2.寻找正确的节点
        let current = this.head
        let index = 0
        //this.length / 2 &amp;gt; position:从头开始遍历
        if (this.length / 2 &amp;gt; position) {
          while(index++ &amp;lt; position){
          current = current.next
        }
        //this.length / 2 =&amp;lt; position:从尾开始遍历
        }else{
          current = this.tail
          index = this.length - 1
          while (index -- &amp;gt; position) {
            current = current.prev
          }
        }

        //3.修改找到节点的data
        current.data = newData
        return true//表示成功修改
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
以（index++ &amp;lt; position）为条件，通过while循环遍历链表中的节点（停止条件为index = position）。循环结束后，current指向需要修改的节点。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853464522.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建双向链表
    let list = new DoubleLinklist()
    
    //2.测试update方法
    list.append(&#39;a&#39;)
    list.append(&#39;b&#39;)
    console.log(list.update(1, &#39;c&#39;));
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853512616.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;29removeatposition&#34;&gt;2.9.removeAt(position)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      //removeAt方法
      DoubleLinklist.prototype.removeAt = position =&amp;gt; {
        //1.越界判断
        if (position &amp;lt; 0 || position &amp;gt;= this.length) {
          return null
        }
        
        //2.删除节点
        //当链表中length == 1
        //情况1：链表只有一个节点
        let current = this.head//定义在最上面方便以下各种情况返回current.data
        if (this.length == 1) {
          this.head = null
          this.tail = null
        //当链表中length &amp;gt; 1
        } else{
          //情况2：删除第一个节点
          if (position == 0) {
            this.head.next.prev = null
            this.head = this.head.next
          //情况3：删除最后一个节点
          }else if(position == this.length - 1){
            current = this.tail//该情况下返回被删除的最后一个节点
            this.tail.prev.next = null
            this.tail = this.tail.prev
          }else{
          //情况4：删除链表中间的节点
            let index = 0
            while(index++ &amp;lt; position){
              current = current.next
            }
            current.next.prev = current.prev
            current.prev.next = current.next
          }
        }

        //3.length -= 1
        this.length -= 1
        return current.data//返回被删除节点的数据
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
删除节点时有多种情况：&lt;br&gt;
&lt;strong&gt;当链表的length = 1时：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：删除链表中的所有节点：只需要让链表的head和tail指向null即可。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853571732.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;当链表的length &amp;gt; 1时：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;情况2：删除链表中的第一个节点：&lt;br&gt;
通过：this.head.next.prev = null，改变指向1；&lt;br&gt;
通过：this.head = this.head.next，改变指向2；&lt;br&gt;
虽然Node1有引用指向其它节点，但是没有引用指向Node1，那么Node1会被自动回收。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853599140.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;情况3：删除链表中的最后一个节点：&lt;br&gt;
通过：this.tail.prev.next = null，修改指向1；&lt;br&gt;
通过：this.tail = this.tail.prev，修改指向2；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853618439.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;情况4：删除链表中间的节点：&lt;br&gt;
通过while循环找到需要删除的节点，比如position = x，那么需要删除的节点就是Node(x+1)，如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853635573.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
通过：current.next.prev = current.prev，修改指向1；&lt;br&gt;
通过：current.prev.next = current.next，修改指向2；&lt;br&gt;
这样就没有引用指向Node(x+1)了（current虽指向Node(x+1)，但current时临时变量，该方法执行完就会被销毁），随后Node(x+1)就会被自动删除。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853650608.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建双向链表
    let list = new DoubleLinklist()	
	
	//2.测试removeAt方法
    list.append(&#39;a&#39;)
    list.append(&#39;b&#39;)
    list.append(&#39;c&#39;)
    console.log(list.removeAt(1));
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853684660.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;210其他方法&#34;&gt;2.10.其他方法&lt;/h2&gt;
&lt;p&gt;其他方法包括：&lt;strong&gt;remove(element)、isEmpty()、size()、getHead()、getTail()&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  //八.remove方法
  DoubleLinklist.prototype.remove = data =&amp;gt; {
    //1.根据data获取下标值
    let index = this.indexOf(data)
    
    //2.根据index删除对应位置的节点
    return this.removeAt(index)
  }

  //九.isEmpty方法
  DoubleLinklist.prototype.isEmpty = () =&amp;gt; {
    return this.length == 0
  }

  //十.size方法
  DoubleLinklist.prototype.size = () =&amp;gt; {
    return this.length
  }

  //十一.getHead方法：获取链表的第一个元素
  DoubleLinklist.prototype.getHead = () =&amp;gt; {
    return this.head.data
  }

  //十二.getTail方法：获取链表的最后一个元素
  DoubleLinklist.prototype.getTail = () =&amp;gt; {
    return this.tail.data
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//测试代码
    //1.创建双向链表
    let list = new DoubleLinklist()	

/*------------其他方法的测试--------------*/
    list.append(&#39;a&#39;)
    list.append(&#39;b&#39;)
    list.append(&#39;c&#39;)
    list.append(&#39;d&#39;)
    //remove方法
    console.log(list.remove(&#39;a&#39;));
    console.log(list);
    //isEmpty方法
    console.log(list.isEmpty());
    //size方法
    console.log(list.size());
    //getHead方法
    console.log(list.getHead());
    //getTead方法
    console.log(list.getTail());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853763963.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;211完整实现&#34;&gt;2.11.完整实现&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//封装双向链表
function DoubleLinklist(){
  //封装内部类：节点类
  function Node(data){
    this.data = data
    this.prev = null
    this.next = null
  }

  //属性
  this.head = null
  this.tail ==null
  this.length = 0

  //常见的操作：方法
  //一.append方法
  DoubleLinklist.prototype.append = data =&amp;gt; {
    //1.根据data创建新节点
    let newNode = new Node(data)

    //2.添加节点
    //情况1：添加的是第一个节点
    if (this.length == 0) {
      this.tail = newNode
      this.head = newNode 
    //情况2：添加的不是第一个节点
    }else {
      newNode.prev = this.tail
      this.tail.next = newNode
      this.tail = newNode
    }

    //3.length+1
    this.length += 1
  }

  //二.将链表转变为字符串形式
  //2.1.toString方法
  DoubleLinklist.prototype.toString = () =&amp;gt; {
    return this.backwardString()
  }

  //2.2.forwardString方法
  DoubleLinklist.prototype.forwardString = () =&amp;gt; {
    //1.定义变量
    let current =this.tail
    let resultString = &amp;quot;&amp;quot;

    //2.依次向前遍历，获取每一个节点
    while (current) {
      resultString += current.data + &amp;quot;--&amp;quot;
      current = current.prev 
    }
    return resultString
  }

  //2.3.backwardString方法
  DoubleLinklist.prototype.backwardString = () =&amp;gt; {
    //1.定义变量
    let current = this.head
    let resultString = &amp;quot;&amp;quot;

    //2.依次向后遍历，获取每一个节点
    while (current) {
      resultString += current.data + &amp;quot;--&amp;quot;
      current = current.next
    }
    return resultString
  }

  //三.insert方法
  DoubleLinklist.prototype.insert = (position, data) =&amp;gt; {
    //1.越界判断
    if (position &amp;lt; 0 || position &amp;gt; this.length) return false

    //2.根据data创建新的节点
    let newNode = new Node(data)

    //3.插入新节点
    //原链表为空
      //情况1：插入的newNode是第一个节点
    if (this.length == 0) {
      this.head = newNode
      this.tail = newNode
    //原链表不为空
    }else {
      //情况2：position == 0
      if (position == 0) {
        this.head.prev = newNode
        newNode.next = this.head
        this.head = newNode
      //情况3：position == this.length 
      } else if(position == this.length){
        this.tail.next = newNode
        newNode.prev = this.tail
        this.tail = newNode
        //情况4：0 &amp;lt; position &amp;lt; this.length
      }else{
        let current = this.head
        let index = 0
        while(index++ &amp;lt; position){
          current = current.next
        }
        //修改pos位置前后节点变量的指向
        newNode.next = current
        newNode.prev = current.prev
        current.prev.next = newNode
        current.prev = newNode
      }
    }
    //4.length+1
    this.length += 1
    return true//返回true表示插入成功
  }

  //四.get方法
  DoubleLinklist.prototype.get = position =&amp;gt; {
    //1.越界判断
    if (position &amp;lt; 0 || position &amp;gt;= this.length) {//获取元素时position不能等于length
      return null
    }

    //2.获取元素
    let current = null
    let index = 0
    //this.length / 2 &amp;gt; position:从头开始遍历
    if ((this.length / 2) &amp;gt; position) {
      current = this.head
      while(index++ &amp;lt; position){
      current = current.next
    }
    //this.length / 2 =&amp;lt; position:从尾开始遍历
    }else{
      current = this.tail
      index = this.length - 1
      while(index-- &amp;gt; position){
      current = current.prev
    }
    }
    return current.data
  }

  //五.indexOf方法
  DoubleLinklist.prototype.indexOf = data =&amp;gt; {
    //1.定义变量
    let current = this.head
    let index = 0

    //2.遍历链表，查找与data相同的节点
    while(current){
      if (current.data == data) {
        return index
      }
      current = current.next
      index += 1
    }
    return -1
  } 

  //六.update方法
  DoubleLinklist.prototype.update = (position, newData) =&amp;gt; {
    //1.越界判断
    if (position &amp;lt; 0 || position &amp;gt;= this.length) {
      return false
    }

    //2.寻找正确的节点
    let current = this.head
    let index = 0
    //this.length / 2 &amp;gt; position:从头开始遍历
    if (this.length / 2 &amp;gt; position) {
      while(index++ &amp;lt; position){
      current = current.next
    }
    //this.length / 2 =&amp;lt; position:从尾开始遍历
    }else{
      current = this.tail
      index = this.length - 1
      while (index -- &amp;gt; position) {
        current = current.prev
      }
    }

    //3.修改找到节点的data
    current.data = newData
    return true//表示成功修改
  }

  //七.removeAt方法
  DoubleLinklist.prototype.removeAt = position =&amp;gt; {
    //1.越界判断
    if (position &amp;lt; 0 || position &amp;gt;= this.length) {
      return null
    }
    
    //2.删除节点
    //当链表中length == 1
    //情况1：链表只有一个节点
    let current = this.head//定义在最上面方便以下各种情况返回current.data
    if (this.length == 1) {
      this.head = null
      this.tail = null
    //当链表中length &amp;gt; 1
    } else{
      //情况2：删除第一个节点
      if (position == 0) {
        this.head.next.prev = null
        this.head = this.head.next
      //情况3：删除最后一个节点
      }else if(position == this.length - 1){
        current = this.tail//该情况下返回被删除的最后一个节点
        this.tail.prev.next = null
        this.tail = this.tail.prev
      }else{
      //情况4：删除链表中间的节点
        let index = 0
        while(index++ &amp;lt; position){
          current = current.next
        }
        current.next.prev = current.prev
        current.prev.next = current.next
      }
    }

    //3.length -= 1
    this.length -= 1
    return current.data//返回被删除节点的数据
  }
  /*--------------------其他方法-------------------*/
  //八.remove方法
  DoubleLinklist.prototype.remove = data =&amp;gt; {
    //1.根据data获取下标值
    let index = this.indexOf(data)
    
    //2.根据index删除对应位置的节点
    return this.removeAt(index)
  }

  //九.isEmpty方法
  DoubleLinklist.prototype.isEmpty = () =&amp;gt; {
    return this.length == 0
  }

  //十.size方法
  DoubleLinklist.prototype.size = () =&amp;gt; {
    return this.length
  }

  //十一.getHead方法：获取链表的第一个元素
  DoubleLinklist.prototype.getHead = () =&amp;gt; {
    return this.head.data
  }

  //十二.getTail方法：获取链表的最后一个元素
  DoubleLinklist.prototype.getTail = () =&amp;gt; {
    return this.tail.data
  }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3链表结构总结&#34;&gt;3.链表结构总结&lt;/h1&gt;
&lt;p&gt;单向链表有head和next两个属性，双向链表有head、tail、next、prev四个属性。处理好它们的指向，相当于将它们正确地连接在一起，这样就组成了一条链，这就是简单链表的实现。&lt;/p&gt;
&lt;p&gt;在实际开发中链表使用得非常多，比如Java中的&lt;strong&gt;LinkList&lt;/strong&gt;就是双向链表。&lt;/p&gt;
&lt;h2 id=&#34;31注意点&#34;&gt;3.1.注意点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在链表中current = current.next 可以从左往右看，看成是current --&amp;gt; current.next，即current指向current的下一个节点。&lt;/li&gt;
&lt;li&gt;删除节点的原理：只要没有引用指向该对象，无论该对象是否有引用指向其他对象，该对象都会被回收（删除）。&lt;/li&gt;
&lt;li&gt;参数中凡是有position的都要进行越界判断。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;32链表的增删改查&#34;&gt;3.2.链表的增删改查&lt;/h2&gt;
&lt;p&gt;以双向链表为例：&lt;strong&gt;链表的增删改查无非就是获取链表中相应的节点改变其中的prev和next两个变量的指向。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况一：只需要&lt;strong&gt;head&lt;/strong&gt;和&lt;strong&gt;tail&lt;/strong&gt;两个变量就可以获取需要操作的变量（这里指的是能够轻松获取，当然你想通过head.next.next...或tail.prev.prev...来获取想要的节点也可以），在这种情况下链表的长度length：&lt;strong&gt;0 &amp;lt;= length &amp;lt;=2&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;情况二：不能靠tail和head来获取到需要操作的变量时，可采用while循环遍历的方式，找到需要操作的节点：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853909360.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在这种情况下，如果我们想要在链表的position = x的位置插入新节点，那么可以通过current获取position的后一个节点Node(x+1)，通过current.prev获取position位置的前一个节点Node(x)；之后修改Node(x+1)和Node(x)中的prev和next两个变量的指向即可在pos=x 的位置插入新节点。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853922088.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;33修改链表引用指向&#34;&gt;3.3.修改链表引用指向&lt;/h2&gt;
&lt;p&gt;应先修改newNode引用的指向，再修改其他引用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：通过head和tail引用就能获取需要操作的节点时，最后更改head或tail变量的指向（因为它们分别指向链表的第一个和最后一个节点，获取其他节点时可能需要用到它们）。&lt;/li&gt;
&lt;li&gt;情况2：使用current获取到需要操作的节点时，最后更改curren.next或current.prev的指向。因为current.next和current.prev表示的是Node(x+2)和Node(x)这两个节点，如下图所示，一旦变更它们的指向就无法获取Node(x)或Node(x+2)了，&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853947258.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;34遍历链表&#34;&gt;3.4.遍历链表&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;积累两种遍历思路&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取指定的position = x 位置的后一个节点和索引值：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853980453.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853983952.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
循环结束后index = position = x，变量current就指向了Node(x+1)，变量index的值为Node(x+1)的索引值x。&lt;/li&gt;
&lt;li&gt;遍历链表中的所有节点：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612854002125.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612854005730.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当current.next = null时停止循环，此时current指向链表的最后一个节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av86801505?from=search&amp;amp;seid=4967761411915016256&#34;&gt;参考资料：JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现双向链表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/javascript-shi-xian-dan-xiang-lian-biao/"" data-c="
          &lt;h1 id=&#34;1单向链表简介&#34;&gt;1.单向链表简介&lt;/h1&gt;
&lt;p&gt;链表和数组一样，可以用于&lt;strong&gt;存储一系列的元素&lt;/strong&gt;，但是链表和数组的&lt;strong&gt;实现机制完全不同&lt;/strong&gt;。链表的每个元素由一个存储&lt;strong&gt;元素本身的节点&lt;/strong&gt;和一个&lt;strong&gt;指向下一个元素的引用&lt;/strong&gt;（有的语言称为指针或连接）组成。类似于火车头，一节车厢载着乘客（数据），通过节点连接另一节车厢。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612443894132.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612443897959.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612443901003.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;head属性指向链表的第一个节点；&lt;/li&gt;
&lt;li&gt;链表中的最后一个节点指向null；&lt;/li&gt;
&lt;li&gt;当链表中一个节点也没有的时候，head直接指向null；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;数组存在的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组的创建通常需要申请一段&lt;strong&gt;连续的内存空间&lt;/strong&gt;（一整块内存），并且大小是固定的。所以当原数组&lt;strong&gt;不能满足容量需求&lt;/strong&gt;时，需要&lt;strong&gt;扩容&lt;/strong&gt;（一般情况下是申请一个更大的数组，比如2倍，然后将原数组中的元素复制过去）。&lt;/li&gt;
&lt;li&gt;在数组的开头或中间位置插入数据的成本很高，需要进行大量元素的位移。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;链表的优势：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链表中的元素在内存中&lt;strong&gt;不必是连续的空间&lt;/strong&gt;，可以充分利用计算机的内存，实现灵活的&lt;strong&gt;内存动态管理&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;链表不必在创建时就&lt;strong&gt;确定大小&lt;/strong&gt;，并且大小可以&lt;strong&gt;无限地延伸&lt;/strong&gt;下去。&lt;/li&gt;
&lt;li&gt;链表在&lt;strong&gt;插入和删除&lt;/strong&gt;数据时，&lt;strong&gt;时间复杂度&lt;/strong&gt;可以达到O(1)，相对数组效率高很多。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;链表的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链表访问任何一个位置的元素时，都需要&lt;strong&gt;从头开始访问&lt;/strong&gt;（无法跳过第一个元素访问任何一个元素）。&lt;/li&gt;
&lt;li&gt;无法通过下标值直接访问元素，需要从头开始一个个访问，直到找到对应的元素。&lt;/li&gt;
&lt;li&gt;虽然可以轻松地到达&lt;strong&gt;下一个节点&lt;/strong&gt;，但是回到&lt;strong&gt;前一个节点&lt;/strong&gt;是很难的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;链表中的常见操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;append（element）：向链表尾部添加一个新的项；&lt;/li&gt;
&lt;li&gt;insert（position，element）：向链表的特定位置插入一个新的项；&lt;/li&gt;
&lt;li&gt;get（position）：获取对应位置的元素；&lt;/li&gt;
&lt;li&gt;indexOf（element）：返回元素在链表中的索引。如果链表中没有该元素就返回-1；&lt;/li&gt;
&lt;li&gt;update（position，element）：修改某个位置的元素；&lt;/li&gt;
&lt;li&gt;removeAt（position）：从链表的特定位置移除一项；&lt;/li&gt;
&lt;li&gt;remove（element）：从链表中移除一项；&lt;/li&gt;
&lt;li&gt;isEmpty（）：如果链表中不包含任何元素，返回trun，如果链表长度大于0则返回false；&lt;/li&gt;
&lt;li&gt;size（）：返回链表包含的元素个数，与数组的length属性类似；&lt;/li&gt;
&lt;li&gt;toString（）：由于链表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先需要弄清楚：下文中的position指的是两个节点之间，并且与index的关系如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444098945.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;position的值一般表示position所指位置的下一个节点。当position的值与index的值相等时，比如position = index = 1，那么它们都表示Node2。&lt;/p&gt;
&lt;h1 id=&#34;2封装单向链表类&#34;&gt;2.封装单向链表类&lt;/h1&gt;
&lt;h2 id=&#34;21创建单向链表类&#34;&gt;2.1.创建单向链表类&lt;/h2&gt;
&lt;p&gt;先创建单向链表类Linklist，并添加基本属性，再实现单向链表的常用方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    // 封装单向链表类
    function LinkList(){
      // 封装一个内部类：节点类
      function Node(data){
        this.data = data;
        this.next = null;
      }

      // 属性
      // 属性head指向链表的第一个节点
      this.head = null;
      this.length = 0;
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;22appendelement&#34;&gt;2.2.append(element)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;     // 一.实现append方法
      LinkList.prototype.append = data =&amp;gt; {
        //1.创建新节点
        let newNode = new Node(data)

        //2.添加新节点
        //情况1：只有一个节点时候
        if(this.length == 0){
          this.head = newNode
        //情况2：节点数大于1，在链表的最后添加新节点  
        }else {              
          //让变量current指向第一个节点
          let current = this.head
          //当current.next(下一个节点不为空)不为空时，一直循环，直到current指向最后一个节点
          while (current.next){
            current = current.next
          }
          // 最后节点的next指向新的节点
          current.next = newNode
        }
        //3.添加完新结点之后length+1
        this.length += 1
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先让current指向第一个节点：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444270200.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;通过while循环使current指向最后一个节点，最后通过current.next = newNode，让最后一个节点指向新节点newNode：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444281470.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建LinkList
    let list = new LinkList()
    
    //2.测试append方法
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)
    console.log(list);  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444320368.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;23tostring&#34;&gt;2.3.toString()&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;     // 实现toString方法
      LinkList.prototype.toString = () =&amp;gt; {
        // 1.定义变量
        let current = this.head
        let listString = &amp;quot;&amp;quot;

        // 2.循环获取一个个的节点
        while(current){ 
          listString += current.data + &amp;quot; &amp;quot;
          current = current.next//千万不要忘了拼接完一个节点数据之后，让current指向下一个节点
        }
        return  listString
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建LinkList
    let list = new LinkList()
    
    //2.插入数据
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)
    
    //3.测试toString方法
    console.log(list.toString());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444411617.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;24insertpositionelement&#34;&gt;2.4.insert(position,element)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    // 实现insert方法
      LinkList.prototype.insert = (position, data) =&amp;gt; {
      //理解positon的含义：position=0表示新界点插入后要成为第1个节点，position=2表示新界点插入后要成为第3个节点
        //1.对position进行越界判断:要求传入的position不能是负数且不能超过LinkList的length
        if(position &amp;lt; 0 || position &amp;gt; this.length){
          return false
        }
        //2.根据data创建newNode
        let newNode = new Node(data)

        //3.插入新节点
        //情况1：插入位置position=0
        if(position == 0){
          // 让新节点指向第一个节点
          newNode.next = this.head
          // 让head指向新节点
          this.head = newNode
        //情况2：插入位置position&amp;gt;0(该情况包含position=length)
        } else{
          let index = 0
          let previous = null
          let current = this.head
          //步骤1：通过while循环使变量current指向position位置的后一个节点(注意while循环的写法)
          while(index++ &amp;lt; position){
          //步骤2：在current指向下一个节点之前，让previous指向current当前指向的节点
            previous = current
            current = current.next
          }
          // 步骤3：通过变量current(此时current已经指向position位置的后一个节点)，使newNode指向position位置的后一个节点
          newNode.next = current
          //步骤4：通过变量previous，使position位置的前一个节点指向newNode
          previous.next = newNode
          /*
            启示：
            1.我们无法直接操作链表中的节点，但是可以通过变量指向这些节点，以此间接地操作节点(替身使者)；
            比如current指向节点3，想要节点3指向节点4只需要：current.next = 4即可。
            2.两个节点间是双向的，想要节点2的前一个节点为节点1，可以通过：1.next=2，来实现；
          */
        }
        //4.新节点插入后要length+1
        this.length += 1;

        return true
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
inset方法实现的过程：根据插入节点位置的不同可分为多种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：position = 0：&lt;br&gt;
通过： newNode.next = this.head，建立连接1；&lt;br&gt;
通过： this.head = newNode，建立连接2；（不能先建立连接2，否则this.head不再指向Node1）&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444479910.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;情况2：position &amp;gt; 0：&lt;br&gt;
首先定义两个变量previous和curent分别指向需要插入位置pos = X的前一个节点和后一个节点；&lt;br&gt;
然后，通过：newNode.next = current，改变指向3；&lt;br&gt;
最后，通过：previous.next = newNode，改变指向4；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444504059.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;情况2的特殊情形：position = length：&lt;br&gt;
情况2也包含了pos = length的情况，该情况下current和newNode.next都指向null；建立连接3和连接4的方式与情况2相同。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444521406.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;     //测试代码
    //1.创建LinkList
    let list = new LinkList()
    
    //2.插入数据
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)
    
    //3.测试insert方法
    list.insert(0, &#39;在链表最前面插入节点&#39;);
    list.insert(2, &#39;在链表中第二个节点后插入节点&#39;);
    list.insert(5, &#39;在链表最后插入节点&#39;);
    alert(list);
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444552747.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444561625.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;25getposition&#34;&gt;2.5.get(position)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      //实现get方法
      LinkList.prototype.get = (position) =&amp;gt; {
        //1.越界判断
        // 当position = length时，取到的是null所以0 =&amp;lt; position &amp;lt; length
        if(position &amp;lt; 0 || position &amp;gt;= this.length){
          return null
        }
        //2.获取指定的positon位置的后一个节点的data
        //同样使用一个变量间接操作节点
        let current = this.head
        let index = 0
        while(index++ &amp;lt; position){
          current = current.next
        }
        return current.data
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
get方法的实现过程：以获取position = 2为例，如下图所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先使current指向第一个节点，此时index=0；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444624072.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;通过while循环使current循环指向下一个节点，注意循环终止的条件index++ &amp;lt; position，即当index=position时停止循环，此时循环了1次，current指向第二个节点(Node2)，最后通过current.data返回Node2节点的数据；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444638164.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建LinkList
    let list = new LinkList()
    
    //2.插入数据
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)	

	//3.测试get方法
    console.log(list.get(0));
    console.log(list.get(1));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444676610.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;26indexofelement&#34;&gt;2.6.indexOf(element)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//实现indexOf方法
      LinkList.prototype.indexOf = data =&amp;gt; {
        //1.定义变量
        let current = this.head
        let index = 0

        //2.开始查找:只要current不指向null就一直循环
        while(current){
          if(current.data == data){
            return index
          }
          current = current.next
          index += 1
        } 

        //3.遍历完链表没有找到，返回-1
        return -1
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
indexOf方法的实现过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用变量current记录当前指向的节点，使用变量index记录当前节点的索引值（注意index = node数-1）：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444722712.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建LinkList
    let list = new LinkList()
    
    //2.插入数据
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)	
    
    //3.测试indexOf方法
    console.log(list.indexOf(&#39;aaa&#39;));
    console.log(list.indexOf(&#39;ccc&#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444758126.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;27updatepositionelement&#34;&gt;2.7.update(position,element)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;     //实现update方法
      LinkList.prototype.update = (position, newData) =&amp;gt; {
        //1.越界判断
        //因为被修改的节点不能为null，所以position不能等于length
        if(position &amp;lt; 0 || position &amp;gt;= this.length){
          return false
        }
        //2.查找正确的节点
        let current = this.head
        let index = 0
        while(index++ &amp;lt; position){
          current = current.next
        }
        //3.将position位置的后一个节点的data修改成newData
        current.data = newData
        //返回true表示修改成功
        return true
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建LinkList
    let list = new LinkList()
    
    //2.插入数据
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)	
    
    //3.测试update方法
    list.update(0, &#39;修改第一个节点&#39;)
    list.update(1, &#39;修改第二个节点&#39;)
    console.log(list);
    console.log(list.update(3, &#39;能修改么&#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444815485.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;28removeatposition&#34;&gt;2.8.removeAt(position)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      //实现removeAt方法
      LinkList.prototype.removeAt = position =&amp;gt; {
        //1.越界判断
        if (position &amp;lt; 0 || position &amp;gt;= this.length) {//position不能为length
          return null
        }
        //2.删除元素
        //情况1：position = 0时(删除第一个节点)
        let current = this.head
        if (position ==0 ) {
        //情况2：position &amp;gt; 0时
          this.head = this.head.next
        }else{
          let index = 0
          let previous = null
          while (index++ &amp;lt; position) {
            previous = current
            current = current.next
          }
          //循环结束后，current指向position后一个节点，previous指向current前一个节点
          //再使前一个节点的next指向current的next即可
          previous.next = current.next
        }
        //3，length-1
        this.length -= 1

        //返回被删除节点的data，为此current定义在最上面
        return current.data
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
removeAt方法的实现过程：删除节点时存在多种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：position = 0，即移除第一个节点（Node1）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过：this.head = this.head.next，改变指向1即可；&lt;br&gt;
虽然Node1的next仍指向Node2，但是没有引用指向Node1，则Node1会被垃圾回收器自动回收，所以不用处理Node1指向Node2的引用next。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444914446.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况2：positon &amp;gt; 0，比如pos = 2即移除第三个节点（Node3）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：position = length时position后一个节点为null不能删除，因此position != length；&lt;br&gt;
首先，定义两个变量previous和curent分别指向需要删除位置pos = x的前一个节点和后一个节点；&lt;br&gt;
然后，通过：previous.next = current.next，改变指向1即可；&lt;br&gt;
随后，没有引用指向Node3，Node3就会被自动回收，至此成功删除Node3 。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612445034409.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建LinkList
    let list = new LinkList()
    
    //2.插入数据
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)
  
  //3.测试removeAt方法
    console.log(list.removeAt(0));
    console.log(list.removeAt(0));
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612445073288.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;29其他方法&#34;&gt;2.9.其他方法&lt;/h2&gt;
&lt;p&gt;其他方法包括：&lt;strong&gt;remove(element)、isEmpty()、size()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/*-------------其他方法的实现--------------*/
      //一.实现remove方法
      LinkList.prototype.remove = (data) =&amp;gt; {
        //1.获取data在列表中的位置
        let position = this.indexOf(data)
        //2.根据位置信息，删除结点
        return this.removeAt(position)
      }

      //二.实现isEmpty方法
      LinkList.prototype.isEmpty = () =&amp;gt; {
        return this.length == 0
      }

      //三.实现size方法
      LinkList.prototype.size = () =&amp;gt; {
        return this.length
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  //测试代码
    //1.创建LinkList
    let list = new LinkList()
    
    //2.插入数据
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)

/*---------------其他方法测试----------------*/
  	//remove方法
  	console.log(list.remove(&#39;aaa&#39;));
  	console.log(list);
  	//isEmpty方法
  	console.log(list.isEmpty());
  	//size方法
  	console.log(list.size());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612445152104.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;210完整实现&#34;&gt;2.10.完整实现&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; // 封装链表类
    function LinkList(){
      // 封装一个内部类：节点类
      function Node(data){
        this.data = data;
        this.next = null;
      }

      // 属性
      // 属性head指向链表的第一个节点
      this.head = null;
      this.length = 0;

      // 一.实现append方法
      LinkList.prototype.append = data =&amp;gt; {
        //1.创建新节点
        let newNode = new Node(data)

        //2.添加新节点
        //情况1：只有一个节点时候
        if(this.length == 0){
          this.head = newNode
        //情况2：节点数大于1，在链表的最后添加新节点  
        }else {              
          //让变量current指向第一个节点
          let current = this.head
          //当current.next(下一个节点不为空)不为空时，一直循环，直到current指向最后一个节点
          while (current.next){
            current = current.next
          }
          // 最后节点的next指向新的节点
          current.next = newNode
        }
        //3.添加完新结点之后length+1
        this.length += 1
      }

      // 二.实现toString方法
      LinkList.prototype.toString = () =&amp;gt; {
        // 1.定义变量
        let current = this.head
        let listString = &amp;quot;&amp;quot;

        // 2.循环获取一个个的节点
        while(current){ 
          listString += current.data + &amp;quot; &amp;quot;
          current = current.next//千万不要忘了拼接完一个节点数据之后，让current指向下一个节点
        }
        return  listString
      }

      // 三.实现insert方法
      LinkList.prototype.insert = (position, data) =&amp;gt; {
      //理解positon的含义：position=0表示新界点插入后要成为第1个节点，position=2表示新界点插入后要成为第3个节点
        //1.对position进行越界判断:要求传入的position不能是负数且不能超过LinkList的length
        if(position &amp;lt; 0 || position &amp;gt; this.length){
          return false
        }
        //2.根据data创建newNode
        let newNode = new Node(data)

        //3.插入新节点
        //情况1：插入位置position=0
        if(position == 0){
          // 让新节点指向第一个节点
          newNode.next = this.head
          // 让head指向新节点
          this.head = newNode
        //情况2：插入位置position&amp;gt;0(该情况包含position=length)
        } else{
          let index = 0
          let previous = null
          let current = this.head
          //步骤1：通过while循环使变量current指向position位置的后一个节点(注意while循环的写法)
          while(index++ &amp;lt; position){
          //步骤2：在current指向下一个节点之前，让previous指向current当前指向的节点
            previous = current
            current = current.next
          }
          // 步骤3：通过变量current(此时current已经指向position位置的后一个节点)，使newNode指向position位置的后一个节点
          newNode.next = current
          //步骤4：通过变量previous，使position位置的前一个节点指向newNode
          previous.next = newNode
          
		//我们无法直接操作链表中的节点，但是可以通过变量指向这些节点，以此间接地操作节点；
        }
        //4.新节点插入后要length+1
        this.length += 1;

        return true
      }

      //四.实现get方法
      LinkList.prototype.get = (position) =&amp;gt; {
        //1.越界判断
        // 当position = length时，取到的是null所以0 =&amp;lt; position &amp;lt; length
        if(position &amp;lt; 0 || position &amp;gt;= this.length){
          return null
        }
        //2.获取指定的positon位置的后一个节点的data
        //同样使用一个变量间接操作节点
        let current = this.head
        let index = 0
        while(index++ &amp;lt; position){
          current = current.next
        }
        return current.data
      }

      //五.实现indexOf方法
      LinkList.prototype.indexOf = data =&amp;gt; {
        //1.定义变量
        let current = this.head
        let index = 0

        //2.开始查找:只要current不指向null就一直循环
        while(current){
          if(current.data == data){
            return index
          }
          current = current.next
          index += 1
        } 

        //3.遍历完链表没有找到，返回-1
        return -1
      }

      //六.实现update方法
      LinkList.prototype.update = (position, newData) =&amp;gt; {
        //1.越界判断
        //因为被修改的节点不能为null，所以position不能等于length
        if(position &amp;lt; 0 || position &amp;gt;= this.length){
          return false
        }
        //2.查找正确的节点
        let current = this.head
        let index = 0
        while(index++ &amp;lt; position){
          current = current.next
        }
        //3.将position位置的后一个节点的data修改成newData
        current.data = newData
        //返回true表示修改成功
        return true
      }

      //七.实现removeAt方法
      LinkList.prototype.removeAt = position =&amp;gt; {
        //1.越界判断
        if (position &amp;lt; 0 || position &amp;gt;= this.length) {
          return null
        }
        //2.删除元素
        //情况1：position = 0时(删除第一个节点)
        let current = this.head
        if (position ==0 ) {
        //情况2：position &amp;gt; 0时
          this.head = this.head.next
        }else{
          let index = 0
          let previous = null
          while (index++ &amp;lt; position) {
            previous = current
            current = current.next
          }
          //循环结束后，current指向position后一个节点，previous指向current前一个节点
          //再使前一个节点的next指向current的next即可
          previous.next = current.next
        }
        //3，length-1
        this.length -= 1

        //返回被删除节点的data，为此current定义在最上面
        return current.data
      }

/*-------------其他方法的实现--------------*/
      //八.实现remove方法
      LinkList.prototype.remove = (data) =&amp;gt; {
        //1.获取data在列表中的位置
        let position = this.indexOf(data)
        //2.根据位置信息，删除结点
        return this.removeAt(position)
      }

      //九.实现isEmpty方法
      LinkList.prototype.isEmpty = () =&amp;gt; {
        return this.length == 0
      }

      //十.实现size方法
      LinkList.prototype.size = () =&amp;gt; {
        return this.length
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1x7411L7Q7?from=search&amp;amp;seid=3912456004602554239&#34;&gt;参考资料:JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现单向链表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/javascript-shi-xian-dui-lie-jie-gou-queue/"" data-c="
          &lt;h1 id=&#34;1队列简介&#34;&gt;1.队列简介&lt;/h1&gt;
&lt;p&gt;队列是是一种受限的线性表，特点为&lt;strong&gt;先进先出&lt;/strong&gt;（&lt;strong&gt;FIFO&lt;/strong&gt;：first in first out）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;受限之处在于它只允许在表的&lt;strong&gt;前端&lt;/strong&gt;（front）进行删除操作；&lt;/li&gt;
&lt;li&gt;在表的&lt;strong&gt;后端&lt;/strong&gt;（rear）进行插入操作；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612359092282.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
相当于排队买票，先来的先买票，后来的后买票。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612359106480.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;队列的应用&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打印队列：计算机打印多个文件的时候，需要排队打印；&lt;/li&gt;
&lt;li&gt;线程队列：当开启多线程时，当新开启的线程所需的资源不足时就先放入线程队列，等待CPU处理；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;队列类的实现&lt;/strong&gt;：&lt;br&gt;
队列的实现和栈一样，有两种方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于数组实现；&lt;/li&gt;
&lt;li&gt;基于链表实现；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;队列的常见操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;enqueue（element）：向队列尾部添加一个（或多个）新的项；&lt;/li&gt;
&lt;li&gt;dequeue（）：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素；&lt;/li&gt;
&lt;li&gt;front（）：返回队列中的第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息与Stack类的peek方法非常类似）；&lt;/li&gt;
&lt;li&gt;isEmpty（）：如果队列中不包含任何元素，返回true，否则返回false；&lt;/li&gt;
&lt;li&gt;size（）：返回队列包含的元素个数，与数组的length属性类似；&lt;/li&gt;
&lt;li&gt;toString（）：将队列中的内容，转成字符串形式；&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2封装队列类&#34;&gt;2.封装队列类&lt;/h1&gt;
&lt;h2 id=&#34;21代码实现&#34;&gt;2.1.代码实现&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;    // 基于数组封装队列类
    function Queue() {
    // 属性
      this.items = []
      
    // 方法
    // 1.enqueue():将元素加入到队列中
    Queue.prototype.enqueue = element =&amp;gt; {
      this.items.push(element)
    }

    // 2.dequeue():从队列中删除前端元素
    Queue.prototype.dequeue = () =&amp;gt; {
      return this.items.shift()
    }

    // 3.front():查看前端的元素
    Queue.prototype.front = () =&amp;gt; {
      return this.items[0]
    }

    // 4.isEmpty:查看队列是否为空
    Queue.prototype.isEmpty = () =&amp;gt; {
      return this.items.length == 0;
    }

    // 5.size():查看队列中元素的个数
    Queue.prototype.size = () =&amp;gt; {
      return this.items.length
    }

    // 6.toString():将队列中元素以字符串形式输出
    Queue.prototype.toString = () =&amp;gt; {
      let resultString = &#39;&#39;
        for (let i of this.items){
          resultString += i + &#39; &#39;
        }
        return resultString
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;    // 创建队列
    let queue = new  Queue()

    // 将元素加入到队列中
    queue.enqueue(&#39;a&#39;)
    queue.enqueue(&#39;b&#39;)
    queue.enqueue(&#39;c&#39;)
    queue.enqueue(&#39;d&#39;)
    console.log(queue);												

    // 从队列中删除元素
    queue.dequeue()
    console.log(queue);											
    queue.dequeue()
    console.log(queue);											

    //front
    console.log(queue.front());								 		
    
    // 验证其他方法
    console.log(queue.isEmpty());								 	
    console.log(queue.size());								 	
    console.log(queue.toString());								 	
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612359291030.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;22队列的应用&#34;&gt;2.2.队列的应用&lt;/h2&gt;
&lt;p&gt;使用队列实现小游戏：击鼓传花，传入一组数据和设定的数字num，循环遍历数组内元素，遍历到的元素为指定数字num时将该元素删除，直至数组剩下一个元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;    // 队列应用：面试题：击鼓传花
    let passGame = (nameList, num) =&amp;gt; {
      //1.创建队列结构
      let queue = new Queue()

      //2.将所有人依次加入队列
      // 这是ES6的for循环写法，i相当于nameList[i]
      for(let i of nameList){
        queue.enqueue(i)
      }
      

      // 3.开始数数
     while(queue.size() &amp;gt; 1){//队列中只剩1个人就停止数数
      // 不是num的时候，重新加入队列末尾
      // 是num的时候，将其从队列中删除
      // 3.1.num数字之前的人重新放入队列的末尾(把队列前面删除的加到队列最后)
      for(let i = 0; i&amp;lt; num-1; i++ ){
        queue.enqueue(queue.dequeue())
      }
      // 3.2.num对应这个人，直接从队列中删除
      /*
        思路是这样的，由于队列没有像数组一样的下标值不能直接取到某一元素，所以采用，把num前面的num-1个元素先删除后添加到队列末尾，这样第num个元素就排到了队列的最前面，可以直接使用dequeue方法进行删除
      */
      queue.dequeue()
     }

      //4.获取剩下的那个人
      console.log(queue.size());									
      let endName = queue.front()
      console.log(&#39;最终剩下的人：&#39; + endName);						   	
      
      return nameList.indexOf(endName);
    }

    //5.测试击鼓传花
    let names = [&#39;lily&#39;, &#39;lucy&#39;, &#39;Tom&#39;, &#39;Lilei&#39;, &#39;Tony&#39;]
    console.log(passGame(names, 3));		
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612359343343.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3优先队列&#34;&gt;3.优先队列&lt;/h1&gt;
&lt;p&gt;优先级队列主要考虑的问题为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个元素不再只是一个数据，还包含数据的优先级；&lt;/li&gt;
&lt;li&gt;在添加数据过程中，根据优先级放入到正确位置；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;31优先级队列的实现&#34;&gt;3.1.优先级队列的实现&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;    // 封装优先级队列
    function PriorityQueue() {

      //内部类：在类里面再封装一个类;表示带优先级的数据
      function QueueElement(element, priority) {
        this.element = element;
        this.priority = priority;
      } 

      // 封装属性
      this.items = []

      // 1.实现按照优先级插入方法
      PriorityQueue.prototype.enqueue = (element, priority) =&amp;gt; {
        // 1.1.创建QueueElement对象
        let queueElement = new QueueElement(element, priority)

        // 1.2.判断队列是否为空
        if(this.items.length == 0){
          this.items.push(queueElement)
        }else{
          // 定义一个变量记录是否成功添加了新元素
          let added = false
          for(let i of this.items){
            // 让新插入的元素与原有元素进行优先级比较(priority越小，优先级越大)
            if(queueElement.priority &amp;lt; i.priority){
              this.items.splice(i, 0, queueElement)
              added = true
              // 新元素已经找到插入位置了可以使用break停止循环
              break
            }
          }
          // 新元素没有成功插入，就把它放在队列的最前面
          if(!added){
            this.items.push(queueElement)
          }
        }
      }

      // 2.dequeue():从队列中删除前端元素
      PriorityQueue.prototype.dequeue = () =&amp;gt; {
        return this.items.shift()
      }

      // 3.front():查看前端的元素
      PriorityQueue.prototype.front = () =&amp;gt; {
        return this.items[0]
      }

      // 4.isEmpty():查看队列是否为空
      PriorityQueue.prototype.isEmpty = () =&amp;gt; {
        return this.items.length == 0;
      }

      // 5.size():查看队列中元素的个数
      PriorityQueue.prototype.size = () =&amp;gt; {
        return this.items.length
      }

      // 6.toString():以字符串形式输出队列中的元素
      PriorityQueue.prototype.toString = () =&amp;gt; {
        let resultString = &#39;&#39;
          for (let i of this.items){
            resultString += i.element + &#39;-&#39; + i.priority + &#39; &#39;
          }
          return resultString
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;  // 测试代码
    let pq = new PriorityQueue();
    pq.enqueue(&#39;Tom&#39;,111);
    pq.enqueue(&#39;Hellen&#39;,200);
    pq.enqueue(&#39;Mary&#39;,30);
    pq.enqueue(&#39;Gogo&#39;,27);
    // 打印修改过后的优先队列对象
    console.log(pq);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612359507202.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;32注意点&#34;&gt;3.2.注意点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;关于数组方法splice用法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;splice（1，0，&#39;Tom&#39;）：表示在索引为1的元素前面插入元素’Tom‘（也可以理解为从索引为1的元素开始删除，删除0个元素，再在索引为1的元素前面添加元素&#39;Tom&#39;）；&lt;/li&gt;
&lt;li&gt;splice（1，1，&#39;Tom&#39;）：表示从索引为1的元素开始删除（包括索引为1的元素），共删除1个元素，并添加元素&#39;Tom&#39;。即把索引为1的元素替换为元素&#39;Tom&#39;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;数组的push方法在数组、栈和队列中的形式：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数组&lt;/strong&gt;：在数组[0，1，2]中，pop(3)，结果为[0，1，2，3]；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;栈&lt;/strong&gt;：执行pop(0)，pop(1)，pop(2)，pop(3)，从栈底到栈顶的元素分别为：0，1，2，3；如果看成数组，可写为[0，1，2，3]，但是索引为3的元素3其实是栈顶元素；所以说栈的push方法是向栈顶添加元素（但在数组的视角下为向数组尾部添加元素）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;队列&lt;/strong&gt;：enqueue方法可以由数组的push方法实现，与数组相同，相当于在数组尾部添加元素。&lt;br&gt;
可以这样想：栈结构是头朝下（索引值由下往上增大）的数组结构。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612359579513.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1x7411L7Q7?from=search&amp;amp;seid=3912456004602554239&#34;&gt;参考资料:JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现队列结构（Queue）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/javascript-shu-ju-jie-gou-yu-suan-fa-shi-xian-zhan-jie-gou-stack/"" data-c="
          &lt;h1 id=&#34;1前言&#34;&gt;1.前言&lt;/h1&gt;
&lt;h2 id=&#34;11-什么是数据结构&#34;&gt;1.1 什么是数据结构？&lt;/h2&gt;
&lt;p&gt;数据结构就是在计算机中，存储和组织数据的方式。&lt;br&gt;
例如：图书管理，怎样摆放图书才能既能放很多书，也方便取？&lt;/p&gt;
&lt;p&gt;主要需要考虑两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作一：新书怎么插入？&lt;/li&gt;
&lt;li&gt;操作二：怎么找到某本指定的书？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;常见的数据结构：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组（Aarray）&lt;/li&gt;
&lt;li&gt;栈（Stack）&lt;/li&gt;
&lt;li&gt;链表（Linked List）&lt;/li&gt;
&lt;li&gt;图（Graph）&lt;/li&gt;
&lt;li&gt;散列表（Hash）&lt;/li&gt;
&lt;li&gt;队列（Queue）&lt;/li&gt;
&lt;li&gt;树（Tree）&lt;/li&gt;
&lt;li&gt;堆（Heap）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：数据结构与算法与语言无关，常见的编程语言都有&lt;strong&gt;直接或间接&lt;/strong&gt;的使用上述常见的数据结构。&lt;/p&gt;
&lt;h2 id=&#34;12什么是算法&#34;&gt;1.2.什么是算法？&lt;/h2&gt;
&lt;p&gt;算法（Algorithm）的定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个有限指令集，每条指令的描述不依赖于语言；&lt;/li&gt;
&lt;li&gt;接收一些输入（有些情况下不需要输入）；&lt;/li&gt;
&lt;li&gt;产生输入；&lt;/li&gt;
&lt;li&gt;一定在有限步骤之后终止；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;算法通俗理解：解决问题的办法/步骤逻辑。数据结构的实现，离不开算法。&lt;/p&gt;
&lt;h1 id=&#34;2栈结构stack&#34;&gt;2.栈结构（Stack）&lt;/h1&gt;
&lt;h2 id=&#34;21简介&#34;&gt;2.1简介&lt;/h2&gt;
&lt;p&gt;数组是一个线性结构，并且可以在数组的&lt;strong&gt;任意位置&lt;/strong&gt;插入和删除元素。而&lt;strong&gt;栈和队列&lt;/strong&gt;就是比较常见的&lt;strong&gt;受限的线性结构&lt;/strong&gt;。如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612336192859.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
栈的特点为&lt;strong&gt;先进后出，后进先出&lt;/strong&gt;（LIFO：last in first out）。&lt;/p&gt;
&lt;p&gt;程序中的栈结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;函数调用栈&lt;/strong&gt;：A（B（C（D（））））：即A函数中调用B，B调用C，C调用D；在A执行的过程中会将A压入栈，随后B执行时B也被压入栈，函数C和D执行时也会被压入栈。所以当前栈的顺序为：A-&amp;gt;B-&amp;gt;C-&amp;gt;D（栈顶）；函数D执行完之后，会弹出栈被释放，弹出栈的顺序为D-&amp;gt;C-&amp;gt;B-&amp;gt;A;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;递归&lt;/strong&gt;：为什么没有停止条件的递归会造成栈溢出？比如函数A为递归函数，不断地调用自己（因为函数还没有执行完，不会把函数弹出栈），不停地把相同的函数A压入栈，最后造成&lt;strong&gt;栈溢出&lt;/strong&gt;（Stack Overfloat）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.练习：题目：有6个元素6，5，4，3，2，1按顺序进栈，问下列哪一个不是合法的出栈顺序？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A：5	4	3	6	1	2	（√）&lt;/li&gt;
&lt;li&gt;B：4 5 3 2 1 6 （√）&lt;/li&gt;
&lt;li&gt;C：3 4 6 5 2 1 （×）&lt;/li&gt;
&lt;li&gt;D：2 3 4 1 5 6 （√）&lt;br&gt;
题目所说的按顺序进栈指的不是一次性全部进栈，而是有进有出，进栈顺序为6 -&amp;gt; 5 -&amp;gt; 4 -&amp;gt; 3 -&amp;gt; 2 -&amp;gt; 1。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A答案：65进栈，5出栈，4进栈出栈，3进栈出栈，6出栈，21进栈，1出栈，2出栈（整体入栈顺序符合654321）;&lt;/li&gt;
&lt;li&gt;B答案：654进栈，4出栈，5出栈，3进栈出栈，2进栈出栈，1进栈出栈，6出栈（整体的入栈顺序符合654321）;&lt;/li&gt;
&lt;li&gt;C答案：6543进栈，3出栈，4出栈，之后应该5出栈而不是6，所以错误；&lt;/li&gt;
&lt;li&gt;D答案：65432进栈，2出栈，3出栈，4出栈，1进栈出栈，5出栈，6出栈。符合入栈顺序；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;栈常见的操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;push（element）：添加一个新元素到栈顶位置；&lt;/li&gt;
&lt;li&gt;pop（）：移除栈顶的元素，同时返回被移除的元素；&lt;/li&gt;
&lt;li&gt;peek（）：返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）；&lt;/li&gt;
&lt;li&gt;isEmpty（）：如果栈里没有任何元素就返回true，否则返回false；&lt;/li&gt;
&lt;li&gt;size（）：返回栈里的元素个数。这个方法和数组的length属性类似；&lt;/li&gt;
&lt;li&gt;toString（）：将栈结构的内容以字符串的形式返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;22封装栈类&#34;&gt;2.2封装栈类&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    // 封装栈类
    function Stack(){
      // 栈中的属性
      this.items =[]

      // 栈的相关操作
      // 1.push():将元素压入栈
      //方式一(不推荐)：给对象添加方法，其他对象不能复用
      // this.push = () =&amp;gt; {
      // }
      
      //方式二(推荐)：给Stack类添加方法，能够多对象复用
      Stack.prototype.push = function(element) {
      // 利用数组item的push方法实现Stack类的pop方法
        this.items.push(element)
      }

      // 2.pop():从栈中取出元素
      Stack.prototype.pop = () =&amp;gt; {
      // 利用数组item的pop方法实现Stack类的pop方法
        return this.items.pop()
      }

      // 3.peek():查看一下栈顶元素
      Stack.prototype.peek = () =&amp;gt; {
        return this.items[this.items.length - 1]
      }

      // 4.isEmpty():判断栈是否为空
      Stack.prototype.isEmpty = () =&amp;gt; {
      // 两个小时的教训啊不是this.length(不是Stack对象的length，Stack类没有length属性啊)，而是			Stack类中定义的数组items才有length属性呀
        return this.items.length == 0 
      }

      // 5.size():获取栈中元素的个数
      Stack.prototype.size = () =&amp;gt; {
        return this.items.length
      }

      // 6.toString():以字符串形式输出栈内数据
      Stack.prototype.toString = () =&amp;gt; {
        //希望输出的形式：20 10 12 8 7
        let resultString = &#39;&#39;
        for (let i of this.items){
          resultString += i + &#39; &#39;
        }
        return resultString
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    // 栈的使用
    let  s = new Stack()
    s.push(20)
    s.push(10)
    s.push(100)
    s.push(77)
    console.log(s)													//65

    console.log(s.pop());											//68
    console.log(s.pop());											//69
    
    console.log(s.peek());											//71
	console.log(s.isEmpty());										//72
   
    console.log(s.size());											//74
    console.log(s.toString());			
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612336478157.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;栈结构的简单应用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;利用栈结构的特点封装十进至转换为二进至的函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;     //简单应用：
    //封装函数：将十进制转成二进制(十转二的运算最后倒叙取余的特点符合栈&#39;先进后出&#39;)
    let dec2bin = decNumber =&amp;gt; {
      //1.定义一个栈对象，保存余数
      var  stack = new Stack()

      // 2.循环操作
      while(decNumber &amp;gt; 0){
        // 2.1.获取余数并放入栈中
        stack.push(decNumber % 2)
        // 2.2.获取整除后的结果作为下一次运算的数字(floor:向下取整)
        decNumber = Math.floor(decNumber / 2)
      }

      // 3.从栈中取出0和1
      let  binaryString = &#39;&#39;;
      let a = stack.items.length
     while(stack.items.length != 0){
        binaryString += stack.pop();
      }
      return binaryString;
    }
    
    //测试代码
    console.log(dec2bin(10));										
    console.log(dec2bin(100));										
    console.log(dec2bin(1000));				
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612336555837.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV1x7411L7Q7?from=search&amp;amp;seid=3912456004602554239&#34;&gt;参考资料：JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript数据结构与算法—实现栈结构（Stack）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/ji-suan-ji-wang-luo-bi-ji-part6-ying-yong-ceng-application-layer/"" data-c="
          &lt;h1 id=&#34;1-概述&#34;&gt;1. 概述&lt;/h1&gt;
&lt;p&gt;因为不同的网络应用之间需要有一个确定的通信规则&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273015782.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;11-两种常用的网络应用模型&#34;&gt;1.1 两种常用的网络应用模型&lt;/h2&gt;
&lt;h3 id=&#34;111-客户服务器模型clientserver&#34;&gt;1.1.1 客户/服务器模型（Client/Server）&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273041065.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;112-p2p模型peer-to-peer&#34;&gt;1.1.2 P2P模型（Peer-to-Peer）&lt;/h3&gt;
&lt;p&gt;网络健壮性指的是P2P模型不容易坏掉，即使一个节点坏了也没问题，可以有其他节点代替&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273076632.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;2-域名系统协议dns&#34;&gt;2. 域名系统协议（DNS）&lt;/h1&gt;
&lt;h2 id=&#34;21-概述&#34;&gt;2.1 概述&lt;/h2&gt;
&lt;p&gt;DNS就是将打在地址栏的域名转化为IP地址的东西&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273105853.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;211-域名&#34;&gt;2.1.1 域名&lt;/h3&gt;
&lt;p&gt;域名就是www.xxx.com，当然这是最简单的一种&lt;br&gt;
.com之后还可以有东西，称之为根&lt;br&gt;
域名从左向右，级别逐渐增高&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273137155.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273140326.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;22-域名服务器dns服务器&#34;&gt;2.2 域名服务器（DNS服务器）&lt;/h2&gt;
&lt;p&gt;DNS服务器有很多台，根据层次结构分为三层，根域名服务器，顶级域名服务器，权限域名服务器&lt;br&gt;
本地域名服务器不算层次结构，特点是里主机比较近，当主机和另一台比较近的主机通信时，就不用走哪些更高级的服务器了&lt;br&gt;
根域名服务器并不是一个域名只有一台，而是一个域名对应多台域名服务器，全世界一共有13个这样的域名，分别是a.rootservers.net，b.rootservers.net，c.rootservers.net，~m.rootservers.net&lt;br&gt;
在权限域名服务器中，虽然看似abc.com比y.abc.com少了一位，但是他们的&lt;strong&gt;地位仍是对等的&lt;/strong&gt;，对应的两台权限域名服务器&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273183064.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;23-域名解析过程&#34;&gt;2.3 域名解析过程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273223655.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273226529.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;231-递归查询&#34;&gt;2.3.1 递归查询&lt;/h3&gt;
&lt;p&gt;在上图中&lt;br&gt;
主机先是想本地域名服务器发送请求，如果查不到的话，&lt;br&gt;
&lt;code&gt;本地域名服务器&lt;/code&gt;向根域名服务器发送请求（找别人），如果还是查不到的话，&lt;br&gt;
&lt;code&gt;根域名域名服务器&lt;/code&gt;向顶级域名服务器发送请求（找别人），如果还是查不到的话，&lt;br&gt;
&lt;code&gt;顶级域名服务器&lt;/code&gt;向权限域名服务器发送请求（找别人）&lt;br&gt;
可以看到每一次向下一个查询的服务器都变了，不是主机一个个去问，而是&lt;code&gt;服务器自己一个个问下去&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;232-迭代查询&#34;&gt;2.3.2 迭代查询&lt;/h3&gt;
&lt;p&gt;在上图中&lt;br&gt;
主机先是想本地域名服务器发送请求，如果查不到的话，&lt;br&gt;
本地域名服务器就让&lt;code&gt;主机&lt;/code&gt;去向根域名服务器发送请求（主机去找，本地域名给目标根域名服务器的IP地址），如果还是查不到的话，&lt;br&gt;
根域名域名服务器让&lt;code&gt;主机&lt;/code&gt;去向对应的顶级域名服务器发送请求（主机去找，根域名给目标顶级域名服务器的IP地址），如果还是查不到的话，&lt;br&gt;
顶级域名服务器让&lt;code&gt;主机&lt;/code&gt;去向权限域名服务器发送请求（主机去找，顶级域名给目标权限域名服务器的IP地址）&lt;br&gt;
可以看到这里是&lt;code&gt;主机&lt;/code&gt;一个个挨个问的地址&lt;/p&gt;
&lt;h3 id=&#34;233-高速缓存&#34;&gt;2.3.3 高速缓存&lt;/h3&gt;
&lt;p&gt;为了减少多次查询同一个域名的资源浪费，&lt;code&gt;本地域名服务器&lt;/code&gt;会存储最近使用的ip地址解析，下次再访问同一个域名就不需要这么多查询步骤了。同时这个高速缓存&lt;code&gt;主机本身也有存储&lt;/code&gt;&lt;br&gt;
同时本地域名服务器还可以对顶级域名服务器，权限域名服务器的地址进行缓存，下一次即使是不知道的ip地址，查询也可以更快&lt;br&gt;
高速缓存为了保持正确性，需要定时更新&lt;/p&gt;
&lt;h1 id=&#34;3-文件传输协议ftptftp&#34;&gt;3. 文件传输协议（FTP，TFTP）&lt;/h1&gt;
&lt;h2 id=&#34;31-概述&#34;&gt;3.1 概述&lt;/h2&gt;
&lt;p&gt;TFTP是一个轻量的，比较容易实现的，面对小文件的，UDP的文件传输协议&lt;br&gt;
这里我们重点是FTP协议&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273377105.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-ftp的服务端和客户端&#34;&gt;3.2 FTP的服务端和客户端&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273399779.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;33-ftp的工作原理&#34;&gt;3.3 FTP的工作原理&lt;/h2&gt;
&lt;p&gt;为什么有匿名登陆：对于一些公共服务器来说，增加验证阶段就是增加资源开销，减少验证阶段就可以节省资源来更好地服务&lt;br&gt;
主进程和从属进程的区别：主进程是打开端口，让外部发送的数据可以进来，并且将这些数据逐个分配各从属进程。从属进程则是单独为这些数据服务&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273431637.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273434321.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
先注释一下这里的主进程被忽略掉了，只是没标在上面，不是没有啊&lt;br&gt;
这里客户端和服务器端先建立TCP连接，端口是21，称为控制连接&lt;br&gt;
然后看情况是主动建立连接还是被动建立连接&lt;br&gt;
主动建立连接是指服务器端主动发送请求和客户端进行连接，此时端口号固定是20&lt;br&gt;
被动连接是指客户端发送请求和服务器端建立数据传送连接，此时端口号是不确定，有两者协商得到&lt;br&gt;
数据传输完成之后，数据连接断开，控制连接继续保持，直至两边发送断开请求&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273448354.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;FTP的两种传输模式了解即可&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273464576.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;4-电子邮件&#34;&gt;4. 电子邮件&lt;/h1&gt;
&lt;h2 id=&#34;41-概述&#34;&gt;4.1 概述&lt;/h2&gt;
&lt;h3 id=&#34;411-电子邮件的格式&#34;&gt;4.1.1 电子邮件的格式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273598681.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;412-电子邮件系统的组成结构&#34;&gt;4.1.2 电子邮件系统的组成结构&lt;/h3&gt;
&lt;p&gt;注释：&lt;br&gt;
用户代理的四个功能解释：&lt;br&gt;
撰写就是给用户编辑信件的环境&lt;br&gt;
显示就是可以看到自己写的和自己收的信件内容&lt;br&gt;
处理就是对信件进行操作，包括删除，打印，转发等等&lt;br&gt;
通信就是可以将邮件发送到&lt;strong&gt;邮件服务器当中&lt;/strong&gt;，同时可以从&lt;strong&gt;邮件服务器当中&lt;/strong&gt;读取邮件&lt;/p&gt;
&lt;p&gt;邮件服务器的功能注释&lt;br&gt;
邮件服务器端的发送和接受是指从自己的&lt;strong&gt;用户代理处接收邮件&lt;/strong&gt;，之后&lt;strong&gt;向对面的邮件服务器发送邮件&lt;/strong&gt;&lt;br&gt;
邮件服务器的报告邮件发送结果就是投递是否成功这种情况&lt;br&gt;
邮件服务器既可以作为客户端又可以作为服务器端，使用的是C/S方式&lt;/p&gt;
&lt;p&gt;协议的功能注释&lt;br&gt;
发邮件用的是SMTP&lt;br&gt;
收邮件的是POP3或者IMAP&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273640637.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273652798.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;42-几个邮件协议&#34;&gt;4.2 几个邮件协议&lt;/h2&gt;
&lt;h3 id=&#34;421-简单邮件传送协议smtp&#34;&gt;4.2.1 简单邮件传送协议SMTP&lt;/h3&gt;
&lt;p&gt;注意一下，这里STMP客户和服务器不是固定死的，可以也可以成为服务器，服务器也可以成为用户，由发送方和接收方决定，发送方就是客户，接收方就是服务器&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273682225.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注释&lt;br&gt;
可以看见这里比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;220 service ready
250 OK
421 service not available
550 xxx
354 xxx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;都是应答信息&lt;/p&gt;
&lt;p&gt;这里RCPT能有多条命令的原因是，电子邮件可以有多个收件人，就是群发，所以允许多个RCPT&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;再强调一下，这里服务器和客户端可以互换，视具体情况而定，发送方是客户端，接收方是服务器端&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273748438.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;422-改进smtp缺点的mime协议&#34;&gt;4.2.2 改进SMTP缺点的MIME协议&lt;/h3&gt;
&lt;p&gt;MIME改善SMTP发送数据的缺点，是SMTP的功能性扩展&lt;br&gt;
MIME协议已经逐渐开始应用到浏览器当中，通过对不同文件类型用不同的标识符标识，来让浏览器读取通过MIME的相关文件&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273765867.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;423-邮局协议pop3&#34;&gt;4.2.3 邮局协议POP3&lt;/h3&gt;
&lt;p&gt;这里接收方是客户端，邮件服务器是服务器端&lt;br&gt;
POP3确实很简单，但是有不少缺点，比较难受的就是邮件一旦下载就自动删除了&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273790716.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;424-比较复杂的读取邮件的协议imap协议&#34;&gt;4.2.4 比较复杂的读取邮件的协议——IMAP协议&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273808897.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;43-基于万维网的电子邮件&#34;&gt;4.3 基于万维网的电子邮件&lt;/h2&gt;
&lt;p&gt;与之前的不同的地方就是，基于万维网的电子邮件的&lt;strong&gt;邮件服务器端可以不同&lt;/strong&gt;&lt;br&gt;
同时，发送邮件使用的SMTP/MIME和收邮件时的POP3/IMAP协议都&lt;strong&gt;换成了HTTP协议&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273840716.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;5-万维网和http协议&#34;&gt;5. 万维网和HTTP协议&lt;/h1&gt;
&lt;h2 id=&#34;51-万维网概述&#34;&gt;5.1 万维网概述&lt;/h2&gt;
&lt;p&gt;URL用来标识整个互联网当中的某一个资源（文字，视屏，音频等）的位置&lt;/p&gt;
&lt;p&gt;HTTP用来将这些资源传送给用户&lt;/p&gt;
&lt;p&gt;HTML帮助设计者来设计页面，让不同设计者设计的页面都可以在界面上显示&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273871245.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;52-http协议&#34;&gt;5.2 HTTP协议&lt;/h2&gt;
&lt;h3 id=&#34;521-http协议的过程&#34;&gt;5.2.1 HTTP协议的过程&lt;/h3&gt;
&lt;p&gt;这张图里讲了HTTP的具体过程&lt;/p&gt;
&lt;p&gt;服务器通过TCP 80端口来监听HTTP请求&lt;/p&gt;
&lt;p&gt;注意HTTP可以不一次性下载完页面的所有资源，可以只下载文本部分，其他音频视频等待用户下一步请求之后再传输&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273896774.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;522-http协议的特点&#34;&gt;5.2.2 HTTP协议的特点&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273916610.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;523-http的连接方式持久连接和非持久连接&#34;&gt;5.2.3 HTTP的连接方式——持久连接和非持久连接&lt;/h3&gt;
&lt;p&gt;非持久连接在TCP三次握手的第三次握手时发生，将HTTP请求作为第三次握手的数据部分发给服务器，服务器收到请求之后将HTTP相应报文传输给客户。耗时就是RTT*2+文档传输时间。&lt;br&gt;
缺点就是这样如果再想传输，那么就需要重新建立TCP连接从头开始&lt;/p&gt;
&lt;p&gt;持久连接和非持久连接类似，都是在第三次握手时发生，将HTTP请求作为第三次握手的数据部分发给服务器，服务器收到请求之后将HTTP相应报文传输给客户。但是持久连接再需要请资源的时候就不需要建立新的TCP连接了&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273937976.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;持久连接的两种方式非流水线和流水线&#34;&gt;持久连接的两种方式——非流水线和流水线&lt;/h2&gt;
&lt;p&gt;非流水线就是发一个，确认一个，才能再发下一个&lt;br&gt;
流水线就是一个个连着发，然后多个确认&lt;br&gt;
和之前说过的停止等待协议，后退N帧协议和选择重传协议很像，忘了的话可以去复习一下&lt;br&gt;
开个传送门&lt;a href=&#34;https://ttarea.com/post/ji-suan-ji-wang-luo-bi-ji-part3-shu-ju-lian-lu-ceng-data-link-layer/&#34;&gt;计算机网络笔记Part3 数据链路层（Data Link Layer）&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;524-http的报文结构&#34;&gt;5.2.4 HTTP的报文结构&lt;/h3&gt;
&lt;p&gt;开始行用于区别请求报文和响应报文。可以明显的看到两者第一行的东西都不一样&lt;/p&gt;
&lt;p&gt;请求报文的方法是指命令，就是对所请求的对象进行什么操作，如获取/删除等等&lt;br&gt;
URL就是之间说的资源标识符&lt;br&gt;
版本是指使用的是什么版本的HTTP协议&lt;/p&gt;
&lt;p&gt;CRLF相当于我们程序里面的；，标识一行的结束。同时，在整个首部行结束时，为了区别首部行和实体主体还会有一行单独的CRLF&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612274029654.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里举了请求报文的例子，和一些常用的状态码&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612274047064.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;6-本章思维导图&#34;&gt;6. 本章思维导图&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612274078846.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;本章常用中英文对照&#34;&gt;本章常用中英文对照&lt;/h1&gt;
&lt;p&gt;Server farm 服务器集群&lt;br&gt;
Infrastructure 基础设施，或基础架构&lt;br&gt;
Self-scalability 自扩展性&lt;br&gt;
Timing 实时性&lt;br&gt;
Connection-oriented service 面向连接的服务&lt;br&gt;
Base HTML file 基本HTML文件&lt;br&gt;
Stateless protocol 无状态协议&lt;br&gt;
RTT (round-trip time ) 往返时间&lt;br&gt;
User agents 用户代理&lt;br&gt;
Mail servers 邮件服务器&lt;br&gt;
Top-level domain (TLD) servers 顶级域名服务器&lt;br&gt;
Authoritative DNS servers P161 权威域名服务器&lt;br&gt;
Iterative queries 迭代查询&lt;br&gt;
Resource records (RRs) 资源记录&lt;br&gt;
Nonpersistent HTTP 非持久HTTP，或非坚持HTTP&lt;br&gt;
Persistent HTTP 持久性HTTP，或坚持的HTTP&lt;br&gt;
Peer-to-Peer (P2P) Network 对等网络&lt;br&gt;
Socket programming 套接字编程&lt;/p&gt;
&lt;p&gt;参考资料&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV19E411D78Q?p=1&#34;&gt;2019 王道考研 计算机网络&lt;/a&gt;&lt;/p&gt;
">计算机网络笔记Part6 应用层（Application Layer）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/ji-suan-ji-wang-luo-bi-ji-part5-chuan-shu-ceng-transport-layer/"" data-c="
          &lt;h1 id=&#34;1-概述&#34;&gt;1. 概述&lt;/h1&gt;
&lt;h2 id=&#34;11-传输层的意义&#34;&gt;1.1 传输层的意义&lt;/h2&gt;
&lt;p&gt;网络层可以把数据从一个主机传送到另一个主机，但是没有和进程建立联系。&lt;br&gt;
传输层就是讲进程和收到的数据联系到一起，使数据能够为应用服务&lt;br&gt;
所以说传输层是主机才有的层次&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612264339876.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;12-传输层的两个协议&#34;&gt;1.2 传输层的两个协议&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612264374947.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;13-传输层的寻址和端口&#34;&gt;1.3 传输层的寻址和端口&lt;/h2&gt;
&lt;p&gt;端口号只用于计算机分辨本地进程，总共有2^16=65536种端口号，端口号有很多种，不能随便使用&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612264395717.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;131-常见的应用程序端口号&#34;&gt;1.3.1 常见的应用程序端口号&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612264419074.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;2-udp协议&#34;&gt;2. UDP协议&lt;/h1&gt;
&lt;h2 id=&#34;21-udp概述&#34;&gt;2.1 UDP概述&lt;/h2&gt;
&lt;p&gt;注释：&lt;br&gt;
因为UDP一次发送一个完整报文不会分片，所以需要应用层传输过来的数据不要太大，否则网络层分片任务就很重，但是也不能太小，不然效率较低&lt;br&gt;
UDP适合一些实时应用，因为实时应用延迟要求高，需要立即响应&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612264447032.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;22-udp首部格式&#34;&gt;2.2 UDP首部格式&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612264472057.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;221-udp的校验位构成&#34;&gt;2.2.1 UDP的校验位构成&lt;/h3&gt;
&lt;p&gt;这里的伪首部只是用来计算检验和的，计算完了就丢弃，可以见下UDP的校验方式&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612264492450.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;222-udp校验方式&#34;&gt;2.2.2 UDP校验方式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;总结一下步骤：&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;在发送端的时候：&lt;/strong&gt;&lt;br&gt;
1.就是将每一行（4字节）拆成两部分，左右平均2字节大小，将这两字节数据写成二进制，那么2字节一共就需要2*8=16位。此时检验和没有计算，默认填充0，同时如果数据字段不整齐，则用0补齐，这样就可以写出几十行二进制数，如图中方所示&lt;br&gt;
2.计算着几十行二进制数按&lt;strong&gt;二进制反码运算求和&lt;/strong&gt;，二进制反码运算可以参考&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/jcchan/p/10400504.html&#34;&gt;二进制反码求和运算&lt;/a&gt;&lt;br&gt;
得到的最后简介再反码，之后将&lt;strong&gt;反码之后&lt;/strong&gt;的放入原来的检验和字段&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在接收端的时候&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;与发送端的时候不同的是，此时检验和字段不是0了&lt;/strong&gt;&lt;br&gt;
按照发送端的步骤再将所有数据写成二进制进行二进制反码运算求和&lt;br&gt;
如果最后得到结果全1就是没问题，否则丢弃&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612264590178.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-tcp协议&#34;&gt;3. TCP协议&lt;/h1&gt;
&lt;h2 id=&#34;31-tcp协议的特点&#34;&gt;3.1 TCP协议的特点&lt;/h2&gt;
&lt;p&gt;TCP必须要建立连接之后才可以进行数据交换，所以TCP是面向连接的&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612271954885.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
TCP传输数据是随机切割数据的&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612271959573.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-tcp报文段的首部&#34;&gt;3.2 TCP报文段的首部&lt;/h2&gt;
&lt;p&gt;注释：&lt;br&gt;
见上图，可以看到TCP是将数据随机分割后加上TCP头传输的，所以序号就是为了标记这些随机分割之后的数据，这里把第一个字节的编号当成序号。&lt;br&gt;
确认号就是收到之后做一下标记，代表这之前的都收到了，希望收到的下一个编号的数据就是确认号打头的那个数据。&lt;br&gt;
偏移量就是为了标记一下距离TCP开始多少字节是数据，这里的单位是4B，这个偏移量就是TCP首部长度。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612271997941.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
窗口就是接收方告诉发送方，还有多少地方（缓存）可以放数据&lt;br&gt;
紧急指针就是告诉TCP从哪里到哪里是紧急数据&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272021989.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;321-tcp的六个控制位&#34;&gt;3.2.1 TCP的六个控制位&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;紧急位URG&lt;/code&gt;&lt;br&gt;
URG的特点就是让数据&lt;strong&gt;插队&lt;/strong&gt;，URG=1的就会在缓存中被提前到第一个传输&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272088545.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272102301.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;确认位ACK&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272129028.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;推送位PSH&lt;/code&gt;&lt;br&gt;
就是接收端的URG，将PSH=1的数据尽快接收&lt;br&gt;
注意一下，如果没有PSH，一般都是接收方缓存满了之后再将数据发送到主机&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272160110.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;复位RST&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272172344.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;同步位SYN&lt;/code&gt;&lt;br&gt;
A和B主机要建立连接，就A先发一个报文，其中SYN=1&lt;br&gt;
B收到之后也回复一个SYN=1的报文，代表接受连接&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272207838.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;终止位FIN&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272235086.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️&lt;/p&gt;
&lt;h2 id=&#34;33-tcp连接管理&#34;&gt;3.3 TCP连接管理&lt;/h2&gt;
&lt;h2 id=&#34;331-tcp三次握手建立连接&#34;&gt;3.3.1 TCP三次握手（建立连接）&lt;/h2&gt;
&lt;p&gt;注释：&lt;br&gt;
第一段的意思是&lt;br&gt;
SYN=1：(A)要建立连接了！&lt;br&gt;
seq=x（随机）：因为还没有数据，所以写什么都无所谓&lt;/p&gt;
&lt;p&gt;第二段的意思是&lt;br&gt;
SYN=1：我(B)同意你(A)建立连接！&lt;br&gt;
ACK=1：连接建立了，之后的ACK必须都置为1&lt;br&gt;
seq=y（随机）：因为还没有数据，所以写什么都无所谓&lt;br&gt;
ack=x+1：之前发送方(A)说发送的是第x位数据（虽然发送方是瞎说的），所以我(B)要的是x+1位数据&lt;/p&gt;
&lt;p&gt;第三段的意思是&lt;br&gt;
SYN=0：SYN只有在建立连接时才为1，其他时候均设为0&lt;br&gt;
ACK=1：连接建立了，之后的ACK必须都置为1&lt;br&gt;
seq=x+1：我(A)发送的报文段的第一个字节就是x+1&lt;br&gt;
ack=y+1：之前接收方(B)说发送的是第y位数据（虽然接收方是瞎说的），所以我(A)要的是y+1位数据&lt;/p&gt;
&lt;p&gt;注意一下，TCP是双向的，所以不存在绝对不变的发送方接收方，这里的两台主机都同时是发送方和接收方&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272302854.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TCP三次握手特定导致的SYN洪泛攻击&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272318640.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️&lt;/p&gt;
&lt;h3 id=&#34;332-tcp四次挥手连接释放&#34;&gt;3.3.2 TCP四次挥手（连接释放）&lt;/h3&gt;
&lt;p&gt;注释：&lt;br&gt;
第一段的意思是&lt;br&gt;
FIN=1：(A)要释放连接了！&lt;br&gt;
seq=u：发了好多数据，这里只是用u指代一下，这里u是有确定值的&lt;/p&gt;
&lt;p&gt;第二段的意思是&lt;br&gt;
ACK=1：连接建立了，之后的ACK必须都置为1&lt;br&gt;
seq=v：发了好多数据，这里只是用v指代一下，这里v是有确定值的&lt;br&gt;
ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（尽管此时A已经决定释放连接了）&lt;/p&gt;
&lt;p&gt;第三段的意思是&lt;br&gt;
FIN=1：(B)要释放连接了！&lt;br&gt;
ACK=1：连接建立了，之后的ACK必须都置为1&lt;br&gt;
seq=w：发了好多数据，这里只是用w指代一下，这里w是有确定值的&lt;br&gt;
ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（因为A直接不发数据了，所以第二段第三段的ack都是u+1）&lt;/p&gt;
&lt;p&gt;第四段的意思是&lt;br&gt;
ACK=1：连接建立了，之后的ACK必须都置为1&lt;br&gt;
seq=u+1：之前发的数据时第u位数据，B也要第u+1位数据，所以我发第u+1位数据&lt;br&gt;
ack=w+1：之前发送方(B)说发送的是第w位数据，所以我(A)要的是w+1位数据&lt;/p&gt;
&lt;p&gt;为什么需要等待计时2MSL？&lt;br&gt;
因为这样可以保证B可以收到A的终止报文段进而进入关闭状态&lt;br&gt;
比如说如果A的第四段报文丢失，那么等待一个MSL之后B就会重传第三段报文，花费小于1MSL之后A就会再收到第三段报文，之后就可以再次向B发送第四段报文提示B关闭连接&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272433783.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;34-tcp可靠传输&#34;&gt;3.4 TCP可靠传输&lt;/h2&gt;
&lt;p&gt;TCP是提供可靠传输，UDP这种本身还是不可靠传输的就再靠应用层解决了&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272456274.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;341-序号&#34;&gt;3.4.1 序号&lt;/h3&gt;
&lt;p&gt;就是TCP根据下方数据链路层的MTU（最大传输单元）来随即将数据切割成好几端并且进行编号&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272493105.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;342-确认&#34;&gt;3.4.2 确认&lt;/h3&gt;
&lt;p&gt;发送方每一次发送数据之后都需要接收方进行确认。&lt;br&gt;
TCP使用的是累计确认机制，就是从第一个丢失的字节开始请求丢失的报文段。如图中456丢失，78到达，但仍然请求发送的数据序号是4&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272519527.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;343-重传&#34;&gt;3.4.3 重传&lt;/h3&gt;
&lt;p&gt;为什么要使用自适应算法？网络环境太复杂，路径又长又短，RTT设置短了照顾不了距离远的，RTT设置长了又导致网络利用率降低，所以使用RTTs&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272538461.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;35-tcp流量控制&#34;&gt;3.5 TCP流量控制&lt;/h2&gt;
&lt;p&gt;简单来说就是接收方可以动态的发送信息告诉发送方发送窗口的大小。&lt;br&gt;
接收方接受不过来了就让发送方发送窗口小点，这样发送方发送的速率就慢下来了，接收方就有时间处理它的数据了&lt;br&gt;
接受方处理完了也可以发送请求让发送方发送窗口大点，这样发送方发送的速率就快起来了，接收方就可以处理更多数据而不是空闲等着收数据了&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272568911.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;351-计时器&#34;&gt;3.5.1 计时器&lt;/h3&gt;
&lt;p&gt;在本例子中，使用的累计确认机制（一次回复收到ack=201）和三次流量控制机制。&lt;br&gt;
但是有一个情况就是，如果最后B不允许A再发送数据了，B在处理完数据之后想要恢复窗口大小时发送的有rwnd大小的数据报丢了怎么办？此时A有B的指令在前，发送窗口为0无法发送数据，B也在等待A回复，造成了类似死锁的现象&lt;br&gt;
解决方法：使用计时器&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272591905.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;36-tcp拥塞控制&#34;&gt;3.6 TCP拥塞控制&lt;/h2&gt;
&lt;p&gt;流量控制是对单独一个来说的，拥塞控制是一群&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272745809.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;361-拥塞控制四种算法&#34;&gt;3.6.1 拥塞控制四种算法&lt;/h3&gt;
&lt;p&gt;这里虽然是四种算法，但是通常是两两结合进行使用&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272768432.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;362-慢开始和拥塞避免&#34;&gt;3.6.2 慢开始和拥塞避免&lt;/h3&gt;
&lt;p&gt;这里开始时以&lt;strong&gt;指数形式增长&lt;/strong&gt;，ssthresh的意思是慢开始门限，代表从这个地方注入的报文段就比较多了，需要开始慢速增加了。&lt;br&gt;
之后一段都是&lt;strong&gt;线性增长&lt;/strong&gt;，每次增加1，直至达到网络拥塞状态&lt;br&gt;
瞬间将cwnd设置为1，同时调整原来的ssthresh的值到之前达到网络拥塞状态的1/2,（这里是24降到12）&lt;br&gt;
重复以上步骤，但是注意此时ssthresh变了之后线性增长的转折点也变了&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272809278.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;363-快重传和快恢复&#34;&gt;3.6.3 快重传和快恢复&lt;/h3&gt;
&lt;p&gt;这里和上面的慢开始和拥塞避免的一开始步骤差不多，都是先指数增长再转变为线性增长。&lt;br&gt;
不同的点是快重传和快恢复算法是在收到连续的ack确认之后执行，这里的ack就是冗余ack，冗余ack的特点是如果多次对某一段请求的数据没有被收到，达到一定数目之后就会立即执行重传。但是此时只是降到现在cwnd的一半，再重新线性增长。而不是像慢开始和拥塞避免的从头开始&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272834927.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;4-本章思维导图&#34;&gt;4. 本章思维导图&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272877495.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;本文常用名词中英文对照&#34;&gt;本文常用名词中英文对照&lt;/h1&gt;
&lt;p&gt;Multiplexing and demultiplexing 复用与分用&lt;br&gt;
Positive acknowledgments 肯定确认&lt;br&gt;
Negative acknowledgments 否定确认&lt;br&gt;
Countdown timer （倒数）计时器&lt;br&gt;
Cumulative acknowledgment 累积确认&lt;br&gt;
Receive buffer 接收缓冲区，或接收缓存&lt;br&gt;
Resource-management cells 资源管理单元&lt;br&gt;
Source (port number) 源端口号&lt;br&gt;
Destination (port number) 目的端口号&lt;br&gt;
Checksum 校验和&lt;br&gt;
Pipelined protocols 流水线（型）协议&lt;br&gt;
Go-back-N 回退N&lt;br&gt;
Selective Repeat 选择重传&lt;br&gt;
Timeout （定时器）超时&lt;br&gt;
Fast Retransmit 快速重传&lt;br&gt;
Flow Control 流量控制&lt;br&gt;
Three way handshake 三次握手&lt;br&gt;
sequence number 序列号（简写为seq）&lt;br&gt;
acknowledgement number 确认号（简写为ack；注意与大小的ACK不同）&lt;br&gt;
Congestion Control 拥塞控制&lt;br&gt;
additive increase, multiplicative decrease 加性增乘性减&lt;br&gt;
Slow Start 慢启动&lt;br&gt;
congestion-avoidance 拥塞避免&lt;br&gt;
fast recovery 快速恢复&lt;br&gt;
duplicate (ACK) 冗余（ACK）&lt;br&gt;
Random Early Detection 随机早期检测&lt;/p&gt;
&lt;p&gt;参考资料&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV19E411D78Q?p=1&#34;&gt;2019 王道考研 计算机网络&lt;/a&gt;&lt;/p&gt;
">计算机网络笔记Part5 传输层（Transport Layer）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/22/"" data-c="
          &lt;h1 id=&#34;1tcp报文格式&#34;&gt;1.TCP报文格式&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1611559421318.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;1、端口号&lt;/strong&gt;：用来标识同一台计算机的不同的应用进程。&lt;br&gt;
&lt;strong&gt;1）源端口&lt;/strong&gt;：源端口和IP地址的作用是标识报文的返回地址。&lt;br&gt;
&lt;strong&gt;2）目的端口&lt;/strong&gt;：端口指明接收方计算机上的应用程序接口。&lt;br&gt;
&lt;code&gt;TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、序号和确认号&lt;/strong&gt;：是TCP可靠传输的关键部分。&lt;strong&gt;序号&lt;/strong&gt;是本报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节一个序号。e.g.一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性。&lt;strong&gt;确认号&lt;/strong&gt;，即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、数据偏移／首部长度&lt;/strong&gt;：4bits。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32/8 = 60，&lt;code&gt;故报头最大长度为60字节&lt;/code&gt;。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、保留&lt;/strong&gt;：为将来定义新的用途保留，现在一般置0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、控制位&lt;/strong&gt;：URG  ACK  PSH  RST  SYN  FIN，共6个，每一个标志位表示一个控制功能。&lt;br&gt;
&lt;strong&gt;1）URG&lt;/strong&gt;：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。&lt;br&gt;
&lt;strong&gt;2）ACK&lt;/strong&gt;：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。&lt;br&gt;
&lt;strong&gt;3）PSH&lt;/strong&gt;：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。&lt;br&gt;
&lt;strong&gt;4）RST&lt;/strong&gt;：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。&lt;br&gt;
&lt;strong&gt;5）SYN&lt;/strong&gt;：同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。&lt;br&gt;
&lt;strong&gt;6）FIN&lt;/strong&gt;：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、窗口&lt;/strong&gt;：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、校验和&lt;/strong&gt;：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8、紧急指针&lt;/strong&gt;：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9、选项和填充&lt;/strong&gt;：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10、数据部分&lt;/strong&gt;： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。&lt;/p&gt;
&lt;h1 id=&#34;2三次握手&#34;&gt;2.三次握手&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612076354558.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
TCP/IP 协议是传输层的一个面向连接的安全可靠的一个传输协议，三次握手的机制是为了保证能建立一个安全可靠的连接，那么第一次握手是由客户端发起，客户端会向服务端发送一个报文，在报文里面：SYN标志位置为1，表示发起新的连接。当服务端收到这个报文之后就知道客户端要和我建立一个新的连接，于是服务端就向客户端发送一个确认消息包，在这个消息包里面：ack标志位置为1，表示确认客户端发起的第一次连接请求。以上两次握手之后，对于客户端而言：已经明确了我既能给服务端成功发消息，也能成功收到服务端的响应。但是对于服务端而言：两次握手是不够的，因为到目前为止，服务端只知道一件事，客户端发给我的消息我能收到，但是我响应给客户端的消息，客户端能不能收到我是不知道的。所以，还需要进行第三次握手，第三次握手就是当客户端收到服务端发送的确认响应报文之后，还要继续去给服务端进行回应，也是一个ack标志位置1的确认消息。通过以上三次连接，不管是客户端还是服务端，都知道我既能给对方发送消息，也能收到对方的响应。那么，这个连接就被安全的建了。&lt;/p&gt;
&lt;h1 id=&#34;3四次挥手&#34;&gt;3.四次挥手&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612076620053.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
四次握手机制也是由客户端去发起，客户端会发送一个报文，在报文里面FIN位标志位置一，当服务端收到这个报文之后，我就知道了客户端想要和我断开连接，但是此时服务端不一定能做好准备，因为当客户端发起断开连接的这个消息的时候，对于服务端而言，他和还有可能有未发送完的消息，他还要继续发送，所以呢，此时对于服务端而言，我只能进行一个消息确认，就是我先告诉服务端，我知道你要给我断开连接了，但是我这里边还可能没有做好准备，你需要等我一下，等会儿我会告诉你，于是呢，发完这个消息确认包之后，可能稍过片刻它就会继续发送一个断开连接的一个报文啊，也是一个FIN位置1的报文也是由服务端发给客户端的啊，这个报文表示服务端已经做好了断开连接的准备，那么当这个报文发给客户端的时候，客户端同样要给服务端继续发送一个消息确认的报文一共有四次，那么，通过这四次的相互沟通和连接，我就知道了，不管是服务端还是客户端都已经做好了断开连接的准备，于是连接就可以被断开啊，这是我对三次握手和四次挥手的一个理解。&lt;/p&gt;
">TCP报文——三次握手&四次挥手</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/ji-suan-ji-wang-luo-bi-ji-part4-wang-luo-ceng-network-layer/"" data-c="
          &lt;h1 id=&#34;1-概述&#34;&gt;1. 概述&lt;/h1&gt;
&lt;p&gt;注释：&lt;br&gt;
数据报和分组的关系：分组是一段比较长的数据，将它进行切割成一段段之后就得到数据报&lt;br&gt;
功能一就是让数据在路由器之间走最佳的路径&lt;br&gt;
功能二就是让不同的设备（手机，电脑，平板等）都能正常连接&lt;br&gt;
功能三见图中解释&lt;br&gt;
开环控制就是在拥塞之前就提前设计解决&lt;br&gt;
闭环控制就是在拥塞时自动调整解决问题&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612095965455.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;OSI参考模型&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;各层次的传输单元&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;应用层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;报文&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;传输层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;报文段&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;网络层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IP数据报，分组（如果IP数据报太大就切割成分组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据链路层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;帧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;物理层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;比特流&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;2-数据交换方式&#34;&gt;2. 数据交换方式&lt;/h1&gt;
&lt;p&gt;为什么要进行数据交换？因为每个节点之间都拉网线太麻烦了也不实际，所以通过大量交换设备互联进行数据交换&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096463674.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;21-电路交换&#34;&gt;2.1 电路交换&lt;/h2&gt;
&lt;p&gt;常见的例子：打电话&lt;br&gt;
注释：&lt;br&gt;
链路支持多路复用（可参考数据链路层的TDM等）&lt;br&gt;
特点是独占资源，因为两者建立了连接&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096503276.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;22-报文交换&#34;&gt;2.2 报文交换&lt;/h2&gt;
&lt;p&gt;注释：报文发送的过程&lt;br&gt;
1.源先根据报文加上ip地址，物理地址等，通过物理层发送&lt;br&gt;
2.交换机收到报文之后，先进行存储，等待链路空闲之后进行转发，但是转发的路径不是固定的，是比较随机的&lt;br&gt;
3.最后通过许多交换机最终到达目的地&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096535503.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;23-分组交换&#34;&gt;2.3 分组交换&lt;/h2&gt;
&lt;p&gt;分组交换和报文交换基本相同，就是将报文切割之后再进行发送&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096614492.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;24-分组交换和报文交换的具体计算对比&#34;&gt;2.4 分组交换和报文交换的具体计算对比&lt;/h2&gt;
&lt;p&gt;注释：是怎么计算的？&lt;br&gt;
报文交换：一共三段，每段都需要10000bit/1000bps=10s，三段就是3x10=30s&lt;br&gt;
分组交换：可以分为两段，一个是第一个数据开始发到最后一个数据从源发出，一段是最后一个数据到达目的地。第一段总时间是10000bit/1000bps=10s，第二段总时间是（10/1000）*2=0.02s，所以总时间是10.02s。&lt;br&gt;
理解一下，这里就是报文交换的时候，由于报文没有分割，所以即使先到的数据也不能先发走，只能等到最后一段报文全部到了之后才能一起走，相对于分组交换明显拖慢了前面数据的速度，所以导致报文交换明显慢于分组交换。&lt;br&gt;
可以看到分组交换明显快于报文交换，所以我们通常使用分组交换&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096647245.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;241-分组传输的两种传输方式-数据报与虚电路&#34;&gt;2.4.1 分组传输的两种传输方式-数据报与虚电路&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;综述&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096711651.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096715380.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据报&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096731409.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虚电路&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096762230.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-路由算法和路由协议概述&#34;&gt;3. 路由算法和路由协议概述&lt;/h1&gt;
&lt;p&gt;路由算法就是让路由知道收到报文之后下一步怎么走&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096787286.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
AS就是多个路由器之间构成的单独的小圈子，圈子内使用自己的协议，圈子和圈子之间用的是BGP协议&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096806087.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;31-rip协议和距离向量算法&#34;&gt;3.1 RIP协议和距离向量算法&lt;/h2&gt;
&lt;h3 id=&#34;311-rip协议概述&#34;&gt;3.1.1 RIP协议概述&lt;/h3&gt;
&lt;p&gt;通过交换信息构建路由表&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096856709.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;312-如何建立路由表&#34;&gt;3.1.2 如何建立路由表&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096869111.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;313-rip协议报文格式&#34;&gt;3.1.3 RIP协议报文格式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096886347.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;314-rip协议特点&#34;&gt;3.1.4 RIP协议特点&lt;/h3&gt;
&lt;p&gt;就是来回更新路由表，错误信息被覆盖，导致直至达到距离上限强制错误时才可以得知出错&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096940327.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096944098.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096947518.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096950613.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;315-距离向量算法&#34;&gt;3.1.5 距离向量算法&lt;/h3&gt;
&lt;p&gt;注释：&lt;br&gt;
为什么改地址？因为图中是从x得到的信息&lt;br&gt;
为什么距离固定+1？因为路由器只从相邻路由器之间获取RIP报文，举例只会是1&lt;br&gt;
为什么下一跳是x就要替换？因为网络环境不断变化，可能这次某个节点挂掉，所以保持最新的&lt;br&gt;
为什么下一跳不是x时有更新和不处理两种手段？因为这样可以提高效率，比原来快就换，比原来慢就保留原来的，也可以理解&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097004430.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097008383.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097012997.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-ospf协议和链路状态算法&#34;&gt;3.2 OSPF协议和链路状态算法&lt;/h2&gt;
&lt;h3 id=&#34;321-ospf协议概述&#34;&gt;3.2.1 OSPF协议概述&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097042017.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;322-ospf的其他特点&#34;&gt;3.2.2 OSPF的其他特点&lt;/h3&gt;
&lt;p&gt;为什么OSPF收敛速度快？因为它只是刷新一下链路状态，得知其是否连通，不需要和RIP一样进行对照，而是直接通过Dijilstra算法来自己算出路径&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097062831.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;323-链路状态路由算法&#34;&gt;3.2.3 链路状态路由算法&lt;/h3&gt;
&lt;p&gt;了解即可&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097087324.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;324-ospf区域&#34;&gt;3.2.4 OSPF区域&lt;/h3&gt;
&lt;p&gt;了解即可&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097205918.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;325-ospf分组&#34;&gt;3.2.5 OSPF分组&lt;/h3&gt;
&lt;p&gt;了解即可&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097230145.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;33-bgp协议&#34;&gt;3.3 BGP协议&lt;/h2&gt;
&lt;h3 id=&#34;331-bgp协议简介&#34;&gt;3.3.1 BGP协议简介&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097260741.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;332-bgp协议交换信息的过程&#34;&gt;3.3.2 BGP协议交换信息的过程&lt;/h3&gt;
&lt;p&gt;了解即可，只需要知道BGP交换协议里面交换的是一组路径向量&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097302736.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097305652.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097309001.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;333-bgp协议报文格式&#34;&gt;3.3.3 BGP协议报文格式&lt;/h3&gt;
&lt;p&gt;BGP是应用层协议&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097339499.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;334-bgp协议特点&#34;&gt;3.3.4 BGP协议特点&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097372931.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;335-bgp的四种报文&#34;&gt;3.3.5 BGP的四种报文&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097376737.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;34-三种路由协议的比较&#34;&gt;3.4 三种路由协议的比较&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097403721.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097407772.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;4-ip数据报&#34;&gt;4. IP数据报&lt;/h1&gt;
&lt;h2 id=&#34;41-ip数据报格式&#34;&gt;4.1 IP数据报格式&lt;/h2&gt;
&lt;p&gt;注释：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;注释&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;大小&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;版本 Version&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ipv4或者ipv6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;首部长度 IHL&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;此处数值再乘以4才是真正大小，同时因为IP数据报固定长度为20字节，所以此处最小值为5，即二进制的0101&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;区分服务 DSCP + ECN&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;希望获得哪种服务，用的比较少&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;总长度 Total Length&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;首部+数据的长度，最大为2^16-1=65535&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;标识 Identification&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用来表示是哪一个数据报的分片，不同的分片标识各不相同&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;标志 Flags&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用来表示是否分片和分片是否结束&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3位，但实际有用的只有后两位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;片偏移 Fragment Offset&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用来标记分片之后，该分片在原来的数据报的位置，以8字节为单位&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;13位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;生存时间 Time To Live&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;即TTL，没经过一个路由器TTL-1,0时自动放弃，根据系统不同默认的TTL不同&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;协议 Protocol&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用来标记协议名的字段值，如TCP,UDP,ICMP等等&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;首部检验和 Header Checksum&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;检验首部的字段是否出错，出错就丢弃此数据报&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;源地址 Source IP Address&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;发送方ip地址&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;目的地址 Destination IP Address&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;接收方ip地址&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选字段 Options&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用来排错等安全检测&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;未知，可在0-40位之间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;填充&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将数据报对齐成4字节的整数倍，数值全部为0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;未知，根据可选字段来定&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098474398.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098477627.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
计算偏移量时记住是以0开始的就行，以每一篇最开始的除以8得到的数值就是偏移量&lt;br&gt;
MF和DF的定义见上图&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098493784.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;5-ip&#34;&gt;5. IP&lt;/h1&gt;
&lt;h2 id=&#34;51-ipv4地址&#34;&gt;5.1 ipv4地址&lt;/h2&gt;
&lt;p&gt;全球唯一的表示某一个主机或者路由器接口的编码&lt;/p&gt;
&lt;h3 id=&#34;511-ip地址分类&#34;&gt;5.1.1 ip地址分类&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098535241.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;512-特殊ip地址&#34;&gt;5.1.2 特殊ip地址&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098614057.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;513-私有ip地址&#34;&gt;5.1.3 私有ip地址&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098637063.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;解释一下&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;为什么A类最大是126.xxx.xxx.xxx？&lt;/code&gt;&lt;br&gt;
因为网络号最开始第一位是0，一共八位，所以二进制表示位0xxxxxxx，最大就是2^7-1=127，但是因为127.xxx.xxx.xxx是特殊ip地址，所以将其去掉&lt;br&gt;
&lt;code&gt;为什么B类最大是191.255.xxx.xxx？&lt;/code&gt;&lt;br&gt;
因为网络号最开始第一位是10，一共八位，所以二进制表示位10xxxxxx，最大就是10111111=191，最小就是10000000=128，无特殊ip地址&lt;br&gt;
&lt;code&gt;为什么C类最大是223.255.xxx.xxx？&lt;/code&gt;&lt;br&gt;
因为网络号最开始第一位是110，一共八位，所以二进制表示位110xxxxx，最大就是11011111=223，最小就是10000000=192，无特殊ip地址&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098684254.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;52-网络地址转换nat&#34;&gt;5.2 网络地址转换NAT&lt;/h2&gt;
&lt;p&gt;注释：连接内网和外网，就是找个代理的用它的ip地址与外面收发数据&lt;br&gt;
NAT需要构建NAT转换表，既要存广域网（WAN，外网）也要存局域网（LAN，内网）的ip地址和端口号&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098723762.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;53-子网划分和子网掩码&#34;&gt;5.3 子网划分和子网掩码&lt;/h2&gt;
&lt;h3 id=&#34;531-为什么需要子网划分&#34;&gt;5.3.1 为什么需要子网划分&lt;/h3&gt;
&lt;p&gt;总结一下，就是ip不够用，所以需要额外整个子网扩展ip&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098876586.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注释：&lt;br&gt;
为什么子网好能全0或者全1：因为CIDR编址（可见下一段）&lt;br&gt;
为什么主机号不能全0或者全1：因为全0代表本网络，全1代表广播分组&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098885794.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;532-子网掩码&#34;&gt;5.3.2 子网掩码&lt;/h3&gt;
&lt;p&gt;子网掩码就是用来和ip地址一起计算子网的地址的&lt;br&gt;
方法就是讲子网掩码逐位写成二进制然后而原来ip地址进行与运算，就可以得到子网ip地址&lt;br&gt;
因为255是11111111，所以如果写着255的话，ip地址和子网ip地址对应的地方的数值就相同&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098919450.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这道题可以看出来，即使子网掩码不同，相同ip地址对应的子网ip地址也可能相同&lt;br&gt;
但是子网掩码不同，划分的&lt;strong&gt;子网数目不同&lt;/strong&gt;&lt;br&gt;
为什么划分的子网数目不同？或者说怎么算划分的子网位数目？&lt;br&gt;
以255.255.192.0为例，255是11111111即八个1,192是11000000即2个1，一共是82+2=18个1，一共有32位地址，所以剩余有32-18=14位&lt;br&gt;
以255.255.224.0为例，255是11111111即八个1,224是11100000即3个1，一共是82+3=19个1，一共有32位地址，所以剩余有32-19=13位&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098940092.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这道题先将255.255.252.0计算出一共有8+8+6=22位网络号位&lt;br&gt;
所以就有32-22=10位主机号位&lt;br&gt;
将180.80.77.55解析，可以知道在77部分某部分开始会用来表示主机号位&lt;br&gt;
77的二进制是0100 1101，因为一共有22位网络号位，所以010011 （此处分开） 01，从这个01开始是主机号位。&lt;br&gt;
所以用来表示子网ip地址的应该是180.80.76（010011 00）.xxx PS注意76括号内后两位二进制00&lt;br&gt;
但是本体是发布广播地址，所以主机号全部都要是1&lt;br&gt;
所以应该是180.80.79（010011 11）.255（11111111）注意79括号内后两位二进制11&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098960245.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注释：&lt;br&gt;
1.这里特定主机路由就是指找特定的处理这里这个ip地址的路由&lt;br&gt;
2.默认路由会将这个数据报发给另一个路由，直至找到对应的路由，或者TTL耗尽被丢弃&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098976631.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;54-无分类编制cidr&#34;&gt;5.4 无分类编制CIDR&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098994138.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
使用CIDR可以聚合网络&lt;br&gt;
如图，通过缩短前缀，R1和R2就可以合并在206.1.0.0/16的子网下&lt;br&gt;
但是这样转发表之中就会有多个匹配结果，所以我们使用&lt;strong&gt;最长前缀匹配&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099099244.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
最长前缀匹配就是在计算后符合同一子网的时候，选前缀越长的&lt;br&gt;
这道题选B&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099115616.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
因为本网络是192.168.5.0/24，就是192.168.5.（0000 0000）/24，将248写成二进制是11111 000，有五个1，所以前五位都可以作为子网的编号，剩下的三位就是用来分配子网内剩余的地址了，因为不能全0或者全1，所以还要减2&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099128555.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;55-arp协议&#34;&gt;5.5 ARP协议&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099442070.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099446128.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;56-dhcp协议&#34;&gt;5.6 DHCP协议&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099461816.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;57-icmp协议&#34;&gt;5.7 ICMP协议&lt;/h2&gt;
&lt;h3 id=&#34;571-icmp协议概述&#34;&gt;5.7.1 ICMP协议概述&lt;/h3&gt;
&lt;p&gt;ICMP，IGMP处于网络层和传输层之间，就是为了更好地转发ip数据报和提高交互成功的几率&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099557198.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;572-icmp差错报告报文&#34;&gt;5.7.2 ICMP差错报告报文&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ICMP差错报告报文如何与IP数据报结合&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099586573.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五种ICMP差错报文&lt;/strong&gt;&lt;br&gt;
其中源点抑制已废弃不用&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099758130.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四种不发送ICMP差错报文的情况&lt;/strong&gt;&lt;br&gt;
注释：组播是指由一点到多点，但不是无脑发到所有点，无脑发到所有点的是广播，组播有筛选条件&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099792458.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;573-icmp询问报文&#34;&gt;5.7.3 ICMP询问报文&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;四种ICMP询问报文&lt;/strong&gt;&lt;br&gt;
后两种是掩码地址请求和回答报文，路由器询问和通告报文，这两个已经废弃不再使用&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099832338.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;574-icmp的应用&#34;&gt;5.7.4 ICMP的应用&lt;/h3&gt;
&lt;p&gt;1.ping命令：测试两个主机之间连通性，使用了ICMP回送请求和回答报文&lt;br&gt;
2.traceroute命令：跟踪一个分组从原点到终点的路径，使用了ICMP时间超过差错报告报文&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/llq_200/article/details/81034345&#34;&gt;traceroute命令讲解&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;6-ipv6&#34;&gt;6. IPV6&lt;/h1&gt;
&lt;h2 id=&#34;61-为什么会有ipv6&#34;&gt;6.1 为什么会有IPV6&lt;/h2&gt;
&lt;p&gt;就是IPV4地址用完了，从根本上增加ip地址数目，之前讲的NAT和CIDR也只是在IPV4的基础上扩展了IPV4地址数目，治标不治本&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099968178.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;62-ipv6地址表示形式&#34;&gt;6.2 IPV6地址表示形式&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099983088.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;63-ipv6数据报格式&#34;&gt;6.3 IPV6数据报格式&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;作用&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;位数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;版本 Version&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;知名协议版本，此处因为是ipv6所以总是6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;优先级 Traffic Class&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;又来区分数据报的类型和优先级&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;流标签 Flow Label&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;和ipv4标识某个数据报分片不同，这是对于一整个数据报流的标记&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;19位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有效载荷长度 Payload Length&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;指的是扩展首部+数据部分的大小，和ipv4的总长度和首部长度都不同，ipv6的首部长度是固定的40字节&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;下一个首部 Next Header&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;基本首部的下一个首部指的是有效载荷里标记的的扩展首部，有效载荷里的扩展首部再指向有效载荷里标记的的扩展首部，直至最后指向数据&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;跳数限制 Hop Limit&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;基本相当于ipv4当中的TTL，每到一个路由器-1.减到0时丢弃&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;源地址 Source Address&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;发送方ipv6地址&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;128位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;目标地址 Destination Address&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;接收方ipv6地址&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;128位&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100298399.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;64-ipv4和ipv6的区别&#34;&gt;6.4 IPV4和IPV6的区别&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100321103.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;65-ipv6基本地址类型&#34;&gt;6.5 IPV6基本地址类型&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;作用&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;要求&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一对一通信&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可做源地址，目的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;多播&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一对多通信，以前的广播地址当做覆盖所有主机的多播&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可做目的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;任播&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一对多当中的一个通信，看似一对多，实则一对一&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可做目的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;66-ipv4和ipv6之间的过渡&#34;&gt;6.6 IPV4和IPV6之间的过渡&lt;/h2&gt;
&lt;p&gt;如果是ipv6的数据报到了ipv4，就用ipv4重新封装，把ipv6数据报前面加上ipv4伪装成ipv4数据报继续传输，直至到了ipv6路由再解开ipv4伪装&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100421431.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;7-ip组播多播&#34;&gt;7. IP组播（多播）&lt;/h1&gt;
&lt;h2 id=&#34;71-什么是组播&#34;&gt;7.1 什么是组播&lt;/h2&gt;
&lt;p&gt;单播只能一对一，广播必须一对全部，组播就可以是一对全部中的一部分&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100449986.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
辅助理解：单播所占资源多&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100580765.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
组播明显减轻了压力&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100600765.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;72-ip组播地址&#34;&gt;7.2 IP组播地址&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100630663.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;73-硬件组播&#34;&gt;7.3 硬件组播&lt;/h2&gt;
&lt;p&gt;就像全F的mac地址代表广播一样，00-10-5E打头的MAC地址就代表组播&lt;br&gt;
7为什么最大是00-10-5E-7F-FF-FF？因为只有最后23位决定&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100653018.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;74-igmp协议与组播路由选择协议&#34;&gt;7.4 IGMP协议与组播路由选择协议&lt;/h2&gt;
&lt;h3 id=&#34;741-igmp协议&#34;&gt;7.4.1 IGMP协议&lt;/h3&gt;
&lt;p&gt;注释：IGMP只能知道有没有组播组成员，对有几个组播组成员，成员在哪个地方都不知道&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100779176.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100792527.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;742-组播路由选择协议&#34;&gt;7.4.2 组播路由选择协议&lt;/h3&gt;
&lt;p&gt;有了这个，成员可以自行找到转发组，自行决定参加哪个组播（就像电视机选台一样）&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100819411.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100823553.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;8-移动ip&#34;&gt;8. 移动IP&lt;/h1&gt;
&lt;p&gt;移动IP&lt;strong&gt;不等于&lt;/strong&gt;动态IP（DHCP获得的）&lt;br&gt;
移动IP的可以让用户因为地理原因等等，即使不在内网也可以访问内网的东西&lt;/p&gt;
&lt;h2 id=&#34;81-移动ip的相关术语&#34;&gt;8.1 移动IP的相关术语&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100855884.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;82-移动ip通信过程&#34;&gt;8.2 移动IP通信过程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100886983.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100892321.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;9-网络层设备&#34;&gt;9. 网络层设备&lt;/h1&gt;
&lt;h2 id=&#34;91-路由器&#34;&gt;9.1 路由器&lt;/h2&gt;
&lt;h3 id=&#34;911-路由器的构造&#34;&gt;9.1.1 路由器的构造&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100922364.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;912-路由器的输入输出端口构造&#34;&gt;9.1.2 路由器的输入输出端口构造&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100934897.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100957008.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;913-集线器网桥路由表几层设备比较&#34;&gt;9.1.3 集线器，网桥，路由表几层设备比较&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100985820.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;914-路由器的路由表和转发表&#34;&gt;9.1.4 路由器的路由表和转发表&lt;/h3&gt;
&lt;p&gt;这里实际上就是对前面知识的复习了&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612101019453.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;10-本章思维导图&#34;&gt;10. 本章思维导图&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612101037645.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;本章常用名词中英文对照&#34;&gt;本章常用名词中英文对照&lt;/h1&gt;
&lt;p&gt;Forwarding table 转发表&lt;br&gt;
Virtual-circuit networks 虚电路网络&lt;br&gt;
Datagram networks 数据报网络&lt;br&gt;
Signaling message 信令报文&lt;br&gt;
Active queue management 主动队列管理&lt;br&gt;
Head-of-the-line 队头&lt;br&gt;
Classless interdomain routing (CIDR) 无类域间路由&lt;br&gt;
Plug-and-play 即插即用&lt;br&gt;
Anycast 任播&lt;br&gt;
Interior gateway protocols 内部网关协议&lt;br&gt;
Routing information Protocol 路由信息协议（RIP）&lt;br&gt;
Open shortest Path First OSPF 开放最短路径优先&lt;br&gt;
Area border routers 区域边界路由器&lt;br&gt;
Circuit Switching 电路转换&lt;br&gt;
Packet Switching 分组交换&lt;/p&gt;
&lt;p&gt;参考资料&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV19E411D78Q?p=1&#34;&gt;2019 王道考研 计算机网络&lt;/a&gt;&lt;/p&gt;
">计算机网络笔记Part4 网络层（Network Layer）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/ji-suan-ji-wang-luo-bi-ji-part3-shu-ju-lian-lu-ceng-data-link-layer/"" data-c="
          &lt;h1 id=&#34;1-基本概念&#34;&gt;1. 基本概念&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609390124988.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;2-封装成帧与透明传输&#34;&gt;2. 封装成帧与透明传输&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;封装成帧&lt;/strong&gt;就是加将数据加头加尾，相当于将数据打包&lt;br&gt;
&lt;strong&gt;透明传输&lt;/strong&gt;就是为了防止&lt;strong&gt;特殊的数据无法正常传输&lt;/strong&gt;的情况的发生，比如说在封装成帧的过程中出现数据中的某些标记符与开始/结束标记符恰巧重复等等情况&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609390179336.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609390192674.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;21-透明传输的应用&#34;&gt;2.1 透明传输的应用&lt;/h2&gt;
&lt;h3 id=&#34;211-字符计数法&#34;&gt;2.1.1 字符计数法&lt;/h3&gt;
&lt;p&gt;就是在帧的首部做&lt;strong&gt;计数&lt;/strong&gt;，看看数据是否错误&lt;br&gt;
缺点：如果在某一个帧内，标记位后面的某个字节的数据丢失，那么会影响后面的帧&lt;br&gt;
比如3 1 1 和 4 2 2 2，如果前面的帧丢失变成 3 1，那么后面的4就会被补到前面变成 3 1 4导致错误&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568481663.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;212-字符填充法&#34;&gt;2.1.2 字符填充法&lt;/h3&gt;
&lt;p&gt;就是加头加尾分别标记开始结束，和零比特填充法（见下）对比，&lt;strong&gt;开始和结束的对应的字符不一样&lt;/strong&gt;&lt;br&gt;
但有可能出现数据内某段比特流数据正好&lt;strong&gt;与标记字段重复&lt;/strong&gt;，从而导致误判断的情况&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568577190.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;解决方法：添加转义字符&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568606048.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;213-零比特填充法&#34;&gt;2.1.3 零比特填充法&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568630555.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;214-违规编码法&#34;&gt;2.1.4 违规编码法&lt;/h3&gt;
&lt;p&gt;因为曼彻斯特编码不使用高-高，低-低来表示，所以如果使用高-高，低-低来表示帧起始和终止就&lt;strong&gt;不会与数据冲突&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568672962.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-差错控制&#34;&gt;3. 差错控制&lt;/h1&gt;
&lt;h2 id=&#34;31-差错是什么从哪来的&#34;&gt;3.1 差错是什么，从哪来的&lt;/h2&gt;
&lt;p&gt;数据链路层的差错检测的是&lt;strong&gt;比特&lt;/strong&gt;的错误&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568711580.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-为什么要在数据链路层进行差错控制&#34;&gt;3.2 为什么要在数据链路层进行差错控制？&lt;/h2&gt;
&lt;p&gt;因为错误可以尽早发现，不会让一个错误的数据包发送了很长时间到达最终目的地之后才被发现，从而导致网络资源的浪费&lt;/p&gt;
&lt;h2 id=&#34;33-检错编码奇偶校验码循环冗余码crc&#34;&gt;3.3 检错编码（奇偶校验码，循环冗余码CRC）&lt;/h2&gt;
&lt;h3 id=&#34;331-奇偶校验码&#34;&gt;3.3.1 奇偶校验码&lt;/h3&gt;
&lt;p&gt;缺点：只能检测出1，3，5，7…等等奇位数错误，检测成功率位50%&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568769474.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;332-循环冗余码crc&#34;&gt;3.3.2 循环冗余码CRC&lt;/h3&gt;
&lt;p&gt;就是用传输数据除以生成多项式得到冗余码&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568796342.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
实际例子&lt;br&gt;
注释：&lt;br&gt;
1.阶数就是最高位是哪位，然后位数-1，如10011就是5-1=4,1011就是4-1=3&lt;br&gt;
2.异或运算就是相同得0，不同得1，比如100和101做异或，结果就是001&lt;br&gt;
3.出书和最后的余数添加到要发送的数据后面，称为&lt;strong&gt;帧检验序列FCS&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568834916.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
接收方收到数据后进行检测&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568859283.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
需要注意的地方&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568878943.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;34-纠错编码海明码&#34;&gt;3.4 纠错编码（海明码）&lt;/h2&gt;
&lt;p&gt;分为四步&lt;/p&gt;
&lt;h2 id=&#34;第一步-确认校验码位数r&#34;&gt;第一步 确认校验码位数r&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568956027.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;第二步-确定校验码和数据的位置&#34;&gt;第二步 确定校验码和数据的位置&lt;/h2&gt;
&lt;p&gt;注释：&lt;br&gt;
1.为什么是10为数据位？因为4位校验码+6位信息位=10位&lt;br&gt;
2.校验码放到2的几次方的位置，其他的地方按顺序放已知的信息位&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568978597.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;第三步-求出校验码的值&#34;&gt;第三步 求出校验码的值&lt;/h2&gt;
&lt;p&gt;注释&lt;br&gt;
1.先是通过二进制位确定有几位。本题中因为最大位10的二进制是1010，所以是4为，将其标注&lt;br&gt;
2.然后从p1开始看，看p1的二进制位的数值和所有信息位的对应位置的数值是否相同，然后找出来这些位&lt;br&gt;
这里有点难理解，这里以p1为例辅助理解，这里找出来的就是P1,D1,D2,D4,D5&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569004823.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
然后计算异或值，比如说这里D1=1,D2=0,D4=1,D5=0,就是p1要同时和0,1，0,1进行异或之后得到0，为了标识我加粗原始计算数据&lt;br&gt;
举例：0和1异或得1,1和0异或得1,1和1异或得0，那么p1和0异或得0，p1就是0了&lt;br&gt;
3.其他同理，按顺序计算出P2,P3,P4,然后填入表格&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569018649.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;第四步-检测并纠错&#34;&gt;第四步 检测并纠错&lt;/h2&gt;
&lt;p&gt;就是和上面一样，将所有校验位进行运算，得出的结果的值就是错误的位&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569067668.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;4-数据链路层的流量控制和可靠传输&#34;&gt;4. 数据链路层的流量控制和可靠传输&lt;/h1&gt;
&lt;h2 id=&#34;41-流量控制与可靠传输&#34;&gt;4.1 流量控制与可靠传输&lt;/h2&gt;
&lt;p&gt;流量控制是为了让传输过程中的发送速度和接受速度匹配，减少传输出错与资源浪费&lt;br&gt;
可靠传输是发送端发送什么，接收端就要受到什么&lt;/p&gt;
&lt;h3 id=&#34;411-停止等待协议stop-and-wait&#34;&gt;4.1.1 停止等待协议（Stop-and-Wait）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569129958.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
停止等待协议的&lt;strong&gt;无差错&lt;/strong&gt;情况&lt;br&gt;
注释：因为一次就一个，所以用0和1标记ack就行&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569160486.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
停止等待协议的&lt;strong&gt;有差错&lt;/strong&gt;情况&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569192898.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569221465.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569225134.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
停止等待协议的特点&lt;br&gt;
1.简单&lt;br&gt;
2.信道利用率低。大部分时间数据都在路上，发送方很长时间闲置，资源浪费&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569585809.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569581900.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;412-后退n帧协议gbn&#34;&gt;4.1.2 后退N帧协议（GBN）&lt;/h3&gt;
&lt;p&gt;因为停止等待协议太浪费时间了，所以尝试采用GBN，发送连续多个数据帧，以增大信道利用率&lt;br&gt;
注释：&lt;br&gt;
累计确认：就是收到一个确认帧，那么&lt;strong&gt;它和它之前的所有帧&lt;/strong&gt;都默认已收到，反之，如果某个确认帧没收到，那么&lt;strong&gt;它和它之后的所有帧&lt;/strong&gt;都默认丢失（即使收到了也丢掉），进行重传&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569637867.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
下图是一个实例&lt;br&gt;
注释：此图发送2帧时丢失，所以接收方几首收到后面的帧也是直接丢弃并且发送最晚收到的有效帧1的ACK，直至2帧的超时重传机制被触发进行重传并得到ACK之后，接收方才会接受2帧以及后面的帧&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569648684.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发送窗口不能无限大，与使用的编号的比特数有关&lt;br&gt;
很简单，就是1比特编号0和1,同理2比特编号0-3，如果用1比特编号，却要4个窗口长度，那么窗口内数据编号都编不过来，直接乱套了&lt;br&gt;
GBN的优缺点也显而易见，优点是提高了信道利用率，缺点是因为重传机制的原因导致已经收到数据却需要强行丢弃而造成浪费&lt;/p&gt;
&lt;h3 id=&#34;413-选择重传协议sr&#34;&gt;4.1.3 选择重传协议（SR）&lt;/h3&gt;
&lt;p&gt;为了解决GBN的缺点，我们打算尝试只重传错误的帧，这样的话就不用浪费资源吧已经收到的帧再重传一次了。&lt;br&gt;
和GBN相比，两者都有窗口了，和GBN的区别其实就是做了一个数据缓存，已经收到的帧不用扔了，等待之前因意外丢失的帧收到的时候确认即可，但是只能缓存窗口尺寸内的包含的帧（PS，缓存咋可能无限大）&lt;br&gt;
&lt;code&gt;SR运行过程&lt;/code&gt;&lt;br&gt;
注释：2帧丢失之后仍然在发送，但是2帧丢失之后只是缓存，并没有移动窗口，直至最后2帧收到后一次性确认2-5帧&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569746034.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
同样的，因为编号的问题，发送窗口不能无限大&lt;br&gt;
发送窗口最后和接受窗口&lt;strong&gt;大小相同&lt;/strong&gt;，这样利用率比较高&lt;/p&gt;
&lt;h1 id=&#34;5-介质访问控制技术&#34;&gt;5. 介质访问控制技术&lt;/h1&gt;
&lt;p&gt;就是让节点之间的通信不会进行相互干扰&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569788475.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;51-信道划分介质访问控制&#34;&gt;5.1 信道划分介质访问控制&lt;/h2&gt;
&lt;p&gt;虽然使用一条共享信道，但是通过多路复用技术组合进行传输，提高了信道的利用率&lt;/p&gt;
&lt;h3 id=&#34;511-频分多路复用fdm&#34;&gt;5.1.1 频分多路复用FDM&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569822950.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;512-时分多路复用tdm&#34;&gt;5.1.2 时分多路复用TDM&lt;/h3&gt;
&lt;p&gt;TDM的缺点就是利用率低，所以又衍生出了STDM&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569854305.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;513-统计时分复用stdm&#34;&gt;5.1.3 统计时分复用STDM&lt;/h3&gt;
&lt;p&gt;STDM的原则是先到先走，满了就发，相对于TDM提高了利用率&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569881696.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;514-码分多路复用cdm&#34;&gt;5.1.4 码分多路复用CDM&lt;/h3&gt;
&lt;p&gt;CDM只是做一下记录，暂时还用不到，有需要请自行查找资料&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569908502.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;52-随机访问介质访问控制&#34;&gt;5.2 随机访问介质访问控制&lt;/h2&gt;
&lt;p&gt;所有用户都可以随机发送信息，发送时可以占用全部带宽，理论上个人使用时比静态分配信道的速度更快&lt;/p&gt;
&lt;h3 id=&#34;521-aloha协议&#34;&gt;5.2.1 ALOHA协议&lt;/h3&gt;
&lt;p&gt;纯ALOHA协议缺点：太随性，导致效率低&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569957093.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
时隙ALOHA协议&lt;br&gt;
相对于纯ALOHA协议就是固定了发送的时间（只能在一个时间片的开始），提高了效率&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569986799.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;522-csma协议&#34;&gt;5.2.2 CSMA协议&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609570006807.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;优点&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;缺点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1-坚持CSMA&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;发送信息时监听信道，一空闲下来就立即传输，信道忙也一直监听，如果发送时冲突就等待随机时长之后再监听&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;立即发送，利用率高&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;如果多台设备同时监听，那么会发生冲突&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;非坚持CSMA&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;发送信息时监听信道，如果空闲就立即传输，信道忙就随机等待一段时间后再监听&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;冲突发生的几率减少&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;因为需要等待，所以利用率不高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;p-坚持CSMA&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;发送信息时监听信道，空闲时以概率p进行传输，概率1-p不传输。信道忙就随机等待一段时间后再监听&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;冲突减少的同时效率也比较高&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;即使发生冲突也要坚持发送数据，资源被浪费&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;523-csmacd协议&#34;&gt;5.2.3 CSMA/CD协议&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;br&gt;
就是因为链路实际有长短，发送数据需要时间，这个时间内可能就被其他节点当成空闲状态导致发生碰撞&lt;br&gt;
知道自己发生碰撞的最长时间是2τ（两倍的&lt;strong&gt;传播时延&lt;/strong&gt;），就是一去一回&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609570559893.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
图示传播时延对载波监听的影响&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609570573007.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609570597526.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609570601177.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
由此我们可以想到最小帧长的问题，因为如果帧太短，帧都发送完了才检测到碰撞导致停止，导致无法停止碰撞&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609570623056.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;524-csmaca协议&#34;&gt;5.2.4 CSMA/CA协议&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609570763204.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609570766975.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;525-csmacd-与-csmaca的区别&#34;&gt;5.2.5 CSMA/CD 与 CSMA/CA的区别&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609570843437.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;53-轮询访问介质访问控制&#34;&gt;5.3 轮询访问介质访问控制&lt;/h2&gt;
&lt;p&gt;主要包括两大类，一个是&lt;strong&gt;轮询协议&lt;/strong&gt;，另一个是&lt;strong&gt;令牌传递协议&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;531-轮询协议&#34;&gt;5.3.1 轮询协议&lt;/h3&gt;
&lt;p&gt;就是选出一个代表，让他控制所有的传输&lt;br&gt;
注释：&lt;br&gt;
轮询开销在随着服务的节点越多，需要用于查询是否发送数据发送的数据帧也就越多，会造成一定开销&lt;br&gt;
等待延迟就是因为这是轮流“邀请”，所以难免某个节点需要发送数据，但是主节点还在较远的需要里有需求的节点那边，导致需求得不到立即响应&lt;br&gt;
单点故障很好理解，就是代表挂了&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609570905055.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;532-令牌传递协议&#34;&gt;5.3.2 令牌传递协议&lt;/h3&gt;
&lt;p&gt;注释：在节点之间没有收发数据的需求时，令牌在节点之间循环。&lt;br&gt;
发送数据的流程&lt;br&gt;
》当一个节点需要时就可以获得这个令牌。然后修改这个令牌的状态（空闲-&amp;gt;占用）&lt;br&gt;
》再将令牌与数据帧结合，让其在节点构成的环之间流动&lt;br&gt;
》不是目的地的节点收到令牌也不接受，直接略过，目标节点收到信息并复制一份到本地（传输完成），因为是个闭环，所以发送节点最后得到令牌&lt;br&gt;
》最后，发送令牌的节点对令牌的内容进行检查，如果发现数据出错还要重新发一遍&lt;br&gt;
问题基本和轮询协议相同&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609570949965.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;6局域网&#34;&gt;6.局域网&lt;/h1&gt;
&lt;h2 id=&#34;61-局域网的概念&#34;&gt;6.1 局域网的概念&lt;/h2&gt;
&lt;p&gt;概括：范围大小，速度快，延迟低，节点平等&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609570990208.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;611-局域网的网络拓扑结构&#34;&gt;6.1.1 局域网的网络拓扑结构&lt;/h3&gt;
&lt;p&gt;常用的是&lt;strong&gt;总线型拓扑&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571010148.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;612-局域网的传播介质&#34;&gt;6.1.2 局域网的传播介质&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;局域网&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;常用介质&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有线局域网&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;双绞线，同轴电缆，光纤&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无线局域网&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;电磁波&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;613-局域网介质访问方法&#34;&gt;6.1.3 局域网介质访问方法&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571141124.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;62-局域网的分类&#34;&gt;6.2 局域网的分类&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571180089.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;63-ieee802标准&#34;&gt;6.3 IEEE802标准&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571191251.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;631-ieee802描述的局域网参考模型&#34;&gt;6.3.1 IEEE802描述的局域网参考模型&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571213929.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;64以太网&#34;&gt;6.4以太网&lt;/h2&gt;
&lt;h3 id=&#34;641-以太网概念&#34;&gt;6.4.1 以太网概念&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571245741.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571249735.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;642-以太网的发展&#34;&gt;6.4.2 以太网的发展&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571279431.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;643-适配器和mac地址&#34;&gt;6.4.3 适配器和MAC地址&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571294253.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;644-以太网mac帧&#34;&gt;6.4.4 以太网MAC帧&lt;/h3&gt;
&lt;p&gt;注释：&lt;br&gt;
1.这里的mac层指的是数据链路层&lt;br&gt;
2.之前说过数据链路层将上一层ip数据包加头加尾&lt;br&gt;
头就是目标地址（6字节），源地址（6字节），类型（2字节）&lt;br&gt;
尾就是FCS（帧检验序列），（4字节）&lt;br&gt;
3.前导码&lt;strong&gt;不是MAC帧的一部分&lt;/strong&gt;，目的是使时钟同步&lt;br&gt;
4.为什么数据长度时46~1500？&lt;br&gt;
因为有最小传输字节64字节，mac占用6+6+2+4=18，所以数据最小为64-18=46，1500则是规定的默认最大字节，没有理由&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571340452.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;645-10base-t以太网&#34;&gt;6.4.5 10BASE-T以太网&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571372027.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;646-高速以太网&#34;&gt;6.4.6 高速以太网&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571385266.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;65-无线局域网&#34;&gt;6.5 无线局域网&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571418731.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571423009.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;651-两种无线局域网&#34;&gt;6.5.1 两种无线局域网&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571452731.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571457676.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;7广域网&#34;&gt;7.广域网&lt;/h1&gt;
&lt;h2 id=&#34;71-广域网的概述&#34;&gt;7.1 广域网的概述&lt;/h2&gt;
&lt;p&gt;概括一下，一个字大&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572131515.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;72-ppp协议point-to-point-protocol&#34;&gt;7.2 PPP协议（Point-to-Point Protocol）&lt;/h2&gt;
&lt;p&gt;PPP协议是目前&lt;strong&gt;使用最广泛&lt;/strong&gt;的数据链路层协议，拨号基本都是PPP协议&lt;br&gt;
PPP协议&lt;strong&gt;仅支持全双工&lt;/strong&gt;链路&lt;/p&gt;
&lt;h3 id=&#34;721-ppp协议需要满足的要求&#34;&gt;7.2.1 PPP协议需要满足的要求&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572186032.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;722-ppp协议不需要满足的要求&#34;&gt;7.2.2 PPP协议不需要满足的要求&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572227622.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;723-ppp协议组成成分以及功能&#34;&gt;7.2.3 PPP协议组成成分以及功能&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572247195.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;724-ppp协议的帧格式&#34;&gt;7.2.4 PPP协议的帧格式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572272595.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;73-hdlc协议high-level-data-link-control&#34;&gt;7.3 HDLC协议（High-Level Data Link Control）&lt;/h2&gt;
&lt;h3 id=&#34;731-hdlc协议概述&#34;&gt;7.3.1 HDLC协议概述&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572303168.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;732-hdlc的三种站&#34;&gt;7.3.2 HDLC的三种站&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572325373.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;733-hdlc的帧格式&#34;&gt;7.3.3 HDLC的帧格式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572351245.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;74-ppp协议和hdlc协议对比&#34;&gt;7.4 PPP协议和HDLC协议对比&lt;/h2&gt;
&lt;p&gt;为什么HDLC协议更可靠，但是我们使用PPP协议？&lt;br&gt;
因为现在网络要求高，数据链路层本来就是不可靠的尽力传输，差错控制这些复杂的交给了TCP等&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572379651.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;8-链路层设备&#34;&gt;8. 链路层设备&lt;/h1&gt;
&lt;h2 id=&#34;81-集线器hub&#34;&gt;8.1 集线器（Hub）&lt;/h2&gt;
&lt;p&gt;可以扩展以太网，但是集线器会无脑将一个设备的所有消息转发到集线器所连的所有设备，故会将所连接的&lt;strong&gt;所有设备&lt;/strong&gt;变成一个大的冲突域，同时只能有两台设备进行通信，且设备越多，冲突越多。由此诞生了网桥&lt;/p&gt;
&lt;h2 id=&#34;82-网桥bridge&#34;&gt;8.2 网桥（Bridge）&lt;/h2&gt;
&lt;p&gt;使用网桥时，由于网桥会根据mac地址进行过滤，所以&lt;strong&gt;不会形成冲突域&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572446383.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;821-两种网桥&#34;&gt;8.2.1 两种网桥&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;透明网桥&lt;/strong&gt;&lt;br&gt;
通过自学习来构建转发表。每一个通过网桥的数据包都会被记录下网桥收到数据时&lt;strong&gt;数据对应的地址&lt;/strong&gt;和&lt;strong&gt;网桥自己的接口&lt;/strong&gt;，通过许许多多的数据包的构造的缓存，网桥就可以知道哪个数据包在哪个接口，以后如果要穿数据包就知道要往哪个接口发送数据包了&lt;br&gt;
&lt;strong&gt;原路由网桥&lt;/strong&gt;&lt;br&gt;
在发送时，直接将最佳路径放到帧首部。那么网桥如何获得最佳路径？通过广播方式想目标地址发送广播，此时可能会经过不同路由产生不同的路径，目标地址收到后再将每一条路径都发一个响应帧给网桥，网桥经过对比就知道哪个接口最快了&lt;/p&gt;
&lt;h2 id=&#34;83-交换机&#34;&gt;8.3 交换机&lt;/h2&gt;
&lt;p&gt;网桥接口越来越多，网桥就变成了交换机&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572535311.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;84-冲突域和广播域&#34;&gt;8.4 冲突域和广播域&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572566320.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;9-本章总结思维导图&#34;&gt;9. 本章总结思维导图&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572590789.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;本章常用中英文对照&#34;&gt;本章常用中英文对照&lt;/h1&gt;
&lt;p&gt;End system 端系统&lt;br&gt;
Modem 调制解调器（俗称：猫）&lt;br&gt;
Base station 基站&lt;br&gt;
Communication link 通信链路&lt;br&gt;
Physical media 物理介质&lt;br&gt;
Coaxial cable 同轴电缆&lt;br&gt;
Fiber optics 光纤&lt;br&gt;
Radio spectrum 射频频谱&lt;br&gt;
Transmission rate 传输速率&lt;br&gt;
Packets （数据）包，或分组&lt;br&gt;
Routers 路由器&lt;br&gt;
Path 路径&lt;br&gt;
ISP (Internet Service Provider) 网络服务提供商&lt;br&gt;
FDM (frequency-division multiplexing) 频分多路复用&lt;br&gt;
TDM (time-division multiplexing) 时分多路复用&lt;br&gt;
Statistical Multiplexing 统计复用&lt;br&gt;
Store-and-forward 存储转发&lt;br&gt;
Queuing delays 排队延迟&lt;br&gt;
Transmission delay 传输延迟，或发送延迟&lt;br&gt;
Propagation delay 传播延迟&lt;br&gt;
Throughput 吞吐量&lt;br&gt;
Internet backbone 骨干网&lt;br&gt;
Delay 延迟，或时延&lt;br&gt;
Loss 丢包&lt;br&gt;
Message 消息，或报文&lt;br&gt;
Segment （报文）段&lt;br&gt;
Datagram 数据报&lt;br&gt;
Frames 帧&lt;/p&gt;
&lt;p&gt;参考资料&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV19E411D78Q&#34;&gt;2019 王道考研 计算机网络&lt;/a&gt;&lt;/p&gt;
">计算机网络笔记Part3 数据链路层（Data Link Layer）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/ji-suan-ji-wang-luo-bi-ji-part2-wu-li-ceng-physical-layer/"" data-c="
          &lt;h1 id=&#34;1-基本概念&#34;&gt;1. 基本概念&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609332989754.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;2-数据通信基本知识&#34;&gt;2. 数据通信基本知识&lt;/h1&gt;
&lt;h2 id=&#34;21-一个数据通信例子&#34;&gt;2.1 一个数据通信例子&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609333260138.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;22-相关术语&#34;&gt;2.2 相关术语&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609333847379.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;23-三种通讯方式&#34;&gt;2.3 三种通讯方式&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;英文&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;定义&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;需要信道条数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;单工通信&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Simplex&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只能一个发一个收&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一条&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;半双工通信&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;half-duplex&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;都可以发或者收，但是同一时间只能进行一个&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;两条&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;全双工通信&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;duplex&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;都可以同时收发数据&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;两条&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;24-两种数据传输方式&#34;&gt;2.4 两种数据传输方式&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;传输方式&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;特点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;串行传输&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;速度慢，省钱，适合远距离&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;并行传输&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;速度快，耗钱，适合近距离&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379006539.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;25-码元symbol&#34;&gt;2.5 码元（Symbol）&lt;/h2&gt;
&lt;p&gt;定义：码元是指用一个固定时长的信号波形（数字脉冲），代表离散数值的基本波形。当有多个离散状态时，成为M进制码元。一个码元可以携带多个比特的信息&lt;br&gt;
个人理解：码元就是在网线上传输的一个个信号段。码元的不同进制就是用来表示不同的数值的&lt;/p&gt;
&lt;h2 id=&#34;26-波特baud&#34;&gt;2.6 波特（Baud）&lt;/h2&gt;
&lt;p&gt;用来指一秒可以传输多少个码元&lt;/p&gt;
&lt;h2 id=&#34;27-速率&#34;&gt;2.7 速率&lt;/h2&gt;
&lt;p&gt;分为&lt;strong&gt;码元传输速率&lt;/strong&gt;和&lt;strong&gt;信息传输速率&lt;/strong&gt;&lt;br&gt;
信息传输速率就是b/s，就是我们平常说的&lt;strong&gt;网速&lt;/strong&gt;&lt;br&gt;
码元可以理解为几个比特的&lt;strong&gt;集合&lt;/strong&gt;，所以信息传输速率（网速）=码元传输速率x码元所带信息量（多少比特）&lt;br&gt;
码元所带信息量（比特数）=log2（码元进制数）&lt;/p&gt;
&lt;h2 id=&#34;28-带宽band-width&#34;&gt;2.8 带宽（Band Width）&lt;/h2&gt;
&lt;p&gt;用来表示最高数据速率&lt;/p&gt;
&lt;h2 id=&#34;29-奈式准则nyquist&#34;&gt;2.9 奈式准则（Nyquist）&lt;/h2&gt;
&lt;p&gt;是在&lt;strong&gt;理想状态下&lt;/strong&gt;得出的结论&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379171027.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;210-香农公式shannon&#34;&gt;2.10 香农公式（Shannon）&lt;/h2&gt;
&lt;p&gt;是在&lt;strong&gt;有噪声的信道中&lt;/strong&gt;得出的结论&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379224887.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379228696.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;211-基带信号和宽带带通信号base-bandpass-band&#34;&gt;2.11 基带信号和宽带/带通信号（Base band，pass band）&lt;/h2&gt;
&lt;p&gt;计算机网络中用的基带信号是&lt;strong&gt;数字信号&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379264723.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;212-编码&#34;&gt;2.12 编码&lt;/h2&gt;
&lt;p&gt;将数据转化为&lt;strong&gt;数字信号&lt;/strong&gt;&lt;br&gt;
数字数据(digtal data)通过 数字发送器(digit emitter) 转化为 数字信号(digtal signal)&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379325314.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
模拟数据(analog data)通过 PCM编码器(PCM coder) 转化为 数字信号 (digtal signal)&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379338474.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;单极性不归零编码：只使用一个电压值，高电平表示1，低电平表示0。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;双极性不归零编码：用幅值相等的正负电平表示二进制数1和0。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;单极性归零编码：发送码1时高电平在整个码元期间只持续一段时间，其余时间返回零电平。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;双极性归零编码：正负零三个电平，信号本身携带同步信息。
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379405647.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;曼彻斯特编码：&lt;/code&gt;单极性编码的缺点是没有办法区分此时是没有信号，还是有信号，但是信号是0.&lt;br&gt;
这种编码方式是bit中间有信号，低-高跳转表示0，高-低跳转表示1，一个时钟周期只可以表示一个bit，并且必须通过两次采样才能得到一个bit。它能携带时钟信号，而且能区分此时是没有信号还是信号为0.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;差分曼彻斯特编码：&lt;/code&gt;抗干扰能力比曼彻斯特编码更强。bit与bit之间有信号跳变，表示下一个bit为0，bit与bit之间没有信号跳变，表示下一个bit为1。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379572032.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;213-调制数据转化为模拟信号了解&#34;&gt;2.13 调制：数据转化为模拟信号（了解）&lt;/h2&gt;
&lt;p&gt;常用的调制方法：调频(AM)，调频(FM)，调相(PM)&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379690610.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
模拟数据(analog data)通过 调制器(modulaotr) 转化为 模拟信号 (analog signal)&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379708749.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
数字数据(digtal data)通过 调制器(modulaotr) 转化为 模拟信号 (analog signal)&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379737643.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-物理层传输介质&#34;&gt;3. 物理层传输介质&lt;/h1&gt;
&lt;p&gt;传输介质分为&lt;strong&gt;导向性&lt;/strong&gt;传输介质和&lt;strong&gt;非导向性&lt;/strong&gt;传输介质&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;导向性传输介质&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;电磁波沿着固体媒介（铜线or光纤）被导向传播&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;非导向性传输介质&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;自由空间，如空气，水等等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;31-常见的导向性传输介质&#34;&gt;3.1 常见的导向性传输介质&lt;/h2&gt;
&lt;h3 id=&#34;311-双绞线&#34;&gt;3.1.1 双绞线&lt;/h3&gt;
&lt;p&gt;根据有无屏蔽层分为&lt;strong&gt;屏蔽双绞线（STP）和无屏蔽双绞线（UTP）&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379878165.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;312-同轴电缆coaxial-cable&#34;&gt;3.1.2 同轴电缆（Coaxial Cable）&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379892737.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;313-光纤optical-fiber&#34;&gt;3.1.3 光纤（Optical fiber）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379932961.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
根据&lt;strong&gt;入射角&lt;/strong&gt;不同，又分为单模光纤和多模光纤&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379946815.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-常见的非导向性传输介质&#34;&gt;3.2 常见的非导向性传输介质&lt;/h2&gt;
&lt;p&gt;包括&lt;strong&gt;无线电波&lt;/strong&gt;，&lt;strong&gt;微波&lt;/strong&gt;，&lt;strong&gt;红外线&lt;/strong&gt;和&lt;strong&gt;激光&lt;/strong&gt;等&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379994768.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;4-物理层设备&#34;&gt;4. 物理层设备&lt;/h1&gt;
&lt;h2 id=&#34;41-中继器rp-repeater&#34;&gt;4.1 中继器（RP repeater）&lt;/h2&gt;
&lt;p&gt;注释：5-4-3规则是为了限制中继器使用次数的，理由可见图&lt;br&gt;
5是指不能超过5个网段&lt;br&gt;
4是指在这些网段中的物理层网络设备（中继器，集线器）最多不超过4个&lt;br&gt;
3是指这些网段中最多只有三个网段挂有计算机&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609380050132.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;42-集线器hub&#34;&gt;4.2 集线器（Hub）&lt;/h2&gt;
&lt;p&gt;集线器是个大的冲突域，同时&lt;strong&gt;只能有两个设备进行通讯&lt;/strong&gt;，只会传输信号，没有智能。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609380082969.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;5-本章思维导图&#34;&gt;5. 本章思维导图&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609380107652.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;br&gt;
&lt;br&gt;&lt;br&gt;
参考资料&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV19E411D78Q&#34;&gt;2019 王道考研 计算机网络&lt;/a&gt;&lt;/p&gt;
">计算机网络笔记Part2 物理层（Physical Layer）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/ji-suan-ji-wang-luo-bi-ji-part11/"" data-c="
          &lt;h1 id=&#34;1-速率相关性能指标&#34;&gt;1. 速率相关性能指标&lt;/h1&gt;
&lt;h2 id=&#34;11-速率&#34;&gt;1.1 速率&lt;/h2&gt;
&lt;p&gt;定义：连接在计算机网络上的主机在数字信道上传送数据位数的速率&lt;br&gt;
单位:b/s,Kb/s,Mb/s,Tb/s，&lt;br&gt;
如果用字节表示，则是B/s,KB/s,MB/s,TB/s&lt;br&gt;
1Byte=8Bit&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609227285065.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;12-带宽&#34;&gt;1.2 带宽&lt;/h2&gt;
&lt;p&gt;在计算机网络中，指的是网络设备所支持的最高速度，单位同速率，是&lt;strong&gt;理想条件下最高速率&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;13-吞吐量&#34;&gt;1.3 吞吐量&lt;/h2&gt;
&lt;p&gt;指的是单位时间内通过某个网络的数据&lt;strong&gt;总&lt;/strong&gt;量&lt;/p&gt;
&lt;h3 id=&#34;个人理解&#34;&gt;个人理解&lt;/h3&gt;
&lt;p&gt;速率就是实际网速，带宽是理论网速（长城宽带警告），吞吐量是一个或多个设备的综合速率，比如说1000m宽带的路由器连着三部手机，每部手机都是10mb/s看片，那么速率就是10mb/s，带宽是宽带的1000m，路由器吞吐量是30mb/s，即三者之和&lt;/p&gt;
&lt;h1 id=&#34;2时延相关指标&#34;&gt;2.时延相关指标&lt;/h1&gt;
&lt;h2 id=&#34;21-时延&#34;&gt;2.1 时延&lt;/h2&gt;
&lt;p&gt;时延包括四大类&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;计算公式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;发送时延&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据从主机到信道上所用的时间&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据从主机到信道上所用的时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;传播时延&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据在信道上传播所花费的时间&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;信道长度/电磁波在信道上传播的速率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;排队时延&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据在路由器前等待前面数据处理的时间&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无计算方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;处理时延&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据在路由器中处理需求的时间&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无计算方式&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;使用高速链路(提高网速)，只能减小发送时延，无法减少其他三个时延&lt;/p&gt;
&lt;h2 id=&#34;22-时延带宽积&#34;&gt;2.2 时延带宽积&lt;/h2&gt;
&lt;p&gt;公式：时延带宽积=传播时延x带宽&lt;br&gt;
意思是链路上有多少比特的数据&lt;/p&gt;
&lt;h2 id=&#34;23往返时延rtt&#34;&gt;2.3往返时延RTT&lt;/h2&gt;
&lt;p&gt;从发送方发送数据开始，到接收方确认收到为止所花费的时间&lt;br&gt;
RTT=传播时延x2+处理时间(有时可能直接忽略)&lt;/p&gt;
&lt;h2 id=&#34;24-利用率&#34;&gt;2.4 利用率&lt;/h2&gt;
&lt;h3 id=&#34;241-信道利用率&#34;&gt;2.4.1 信道利用率&lt;/h3&gt;
&lt;p&gt;信道利用率=有数据通过&lt;strong&gt;时间&lt;/strong&gt;/有+无数据通过&lt;strong&gt;时间&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;242-网络利用率&#34;&gt;2.4.2 网络利用率&lt;/h3&gt;
&lt;p&gt;网络利用率=所有信道利用率加权求平均值&lt;/p&gt;
&lt;h3 id=&#34;243-时延和利用率的关系图&#34;&gt;2.4.3 时延和利用率的关系图&lt;/h3&gt;
&lt;p&gt;利用率越高，延迟越大&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609228615004.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-分层结构&#34;&gt;3. 分层结构&lt;/h1&gt;
&lt;h2 id=&#34;31-为什么要分层分层要做什么&#34;&gt;3.1 为什么要分层，分层要做什么&lt;/h2&gt;
&lt;p&gt;（1）发起通信的计算机必须将数据通信的通路进行激活。&lt;br&gt;
（2）要告诉网络如何识别目的主机。&lt;br&gt;
（3）发起通信的计算机要查明目的主机是否开机，并且与网络连接正常。&lt;br&gt;
（4）发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作。&lt;br&gt;
（5）确保差错和意外可以解决。&lt;/p&gt;
&lt;h2 id=&#34;32-正式认识分层结构&#34;&gt;3.2 正式认识分层结构&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609229035668.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;4-参考模型&#34;&gt;4. 参考模型&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;英文&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;应用层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Application Layer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;直接为用户的应用进程（例如电子邮件、文件传输和终端仿真）提供服务。如HTTP、SMTP、FTP、DNS等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;表示层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Presentation Layer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;把数据转换为能与接收者的系统格式兼容并适合传输的格式，即让两个系统可以交换信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;会话层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Session Layer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;传输层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Transport Layer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;负责端到端通讯，可靠传输，不可靠传输 ，流量控制，复用分用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网络层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Network Layer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;负责选择路由最佳路径，规划IP地址(ipv4和ipv6变化只会影响网络层)，拥塞控制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据链路层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Data Link Layer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;帧的开始和结束，还有透明传输，差错校验(纠错由传输层解决)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;物理层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Physical Layer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;定义网络设备接口标准，电气标准(电压)，如何在物理链路上传输的更快&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;41-osi流程简介&#34;&gt;4.1 OSI流程简介&lt;/h2&gt;
&lt;p&gt;网络层及以上，每一层都要对上一层发送的数据进行处理（加个头部）&lt;br&gt;
数据链路层不仅需要加头部，还需要加尾部&lt;br&gt;
物理层什么都不加，只管发送数据（比特流）&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609229644091.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;42-tcpip参考模型&#34;&gt;4.2 TCP/IP参考模型&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609229668243.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;43-五层参考模型及其传输过程简介&#34;&gt;4.3 五层参考模型及其传输过程简介&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609229701190.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609229703634.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;参考资料&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV19E411D78Q&#34;&gt;2019 王道考研 计算机网络&lt;/a&gt;&lt;/p&gt;
">计算机网络笔记Part1 概述</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/ji-suan-ji-wang-luo-bi-ji-part0/"" data-c="
          &lt;h1 id=&#34;计算机网络的概念&#34;&gt;计算机网络的概念&lt;/h1&gt;
&lt;p&gt;计算机网络是&lt;code&gt;互连&lt;/code&gt;的、&lt;code&gt;自治&lt;/code&gt;的计算机集合。(互连：互联互通，自治：无助从关系)&lt;/p&gt;
&lt;h1 id=&#34;计算机网络的功能&#34;&gt;计算机网络的功能&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609226192060.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;计算机网络的组成&#34;&gt;计算机网络的组成&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609226327918.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;计算机网络的分类&#34;&gt;计算机网络的分类&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609226484564.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;总结一&#34;&gt;总结一&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609226548838.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;标准化工作&#34;&gt;标准化工作&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609226653873.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;标准化工作流程&#34;&gt;标准化工作流程&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609226712307.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;标准化相关组织&#34;&gt;标准化相关组织&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609226782253.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;总结二&#34;&gt;总结二&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609226812168.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">计算机网络笔记Part0</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/vueandmock-mo-ni-shu-ju/"" data-c="
          &lt;h1 id=&#34;mock在vue里怎么用&#34;&gt;mock在vue里怎么用？&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/nuysoft/Mock/wiki/Getting-Started&#34;&gt;https://github.com/nuysoft/Mock/wiki/Getting-Started&lt;/a&gt;&lt;br&gt;
以上是官方文档，不知道mock是什么的自行查看&lt;/p&gt;
&lt;h1 id=&#34;一-下载nodejs-的npm-自行下载&#34;&gt;一、下载node.js 的npm 自行下载&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;+ npm install -g cnpm --registry=https://registry.npm.taobao.org
     //npm的镜像
	+ npm install -g @vue/cli    //安装全局脚手架  
	    自己新建一个文件夹，并在文件夹中打开  powershell 
	+ vue create mypro(文件名可随意换)   //创建并下载一个文件夹
	+ npm install vue-router --save //启路由的插件
		--save 代表局部
	+ cd mypro
	+ npm run serve //运行 
	+ 用local 地址打开
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;11-创建项目&#34;&gt;1.1 创建项目&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;vue create mock-demo 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608807847530.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;12-安装依赖-不懂请看上面&#34;&gt;1.2 安装依赖 （不懂请看上面）&lt;/h2&gt;
&lt;p&gt;vue环境搭建好后，开始安装 mock依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     //使用axios发送  ajax
	  	cnpm install axios --save
	//使用mockjs产生随机数据
	  	cnpm install mockjs --save-dev
	//使用json5解决json文件,无法添加注释问题
	  	cnpm install json5 --save-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;二-学习mockjs&#34;&gt;二、学习MOCKJS&lt;/h1&gt;
&lt;p&gt;新建mock文件夹,新建testMockjs.js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const Mock = require(&#39;mockjs&#39;);//mockjs 导入依赖模块
var id = Mock.mock(&#39;@id&#39;)//得到随机的id,字符串
console.log(Mock.mock(&#39;@id&#39;), typeof id)

var obj = Mock.mock({
    id: &amp;quot;@id()&amp;quot;,//得到随机的id,对象
    username: &amp;quot;@cname()&amp;quot;,//随机生成中文名字
    date: &amp;quot;@date()&amp;quot;,//随机生成日期
    avatar: &amp;quot;@image(&#39;200x200&#39;,&#39;red&#39;,&#39;#fff&#39;,&#39;avatar&#39;)&amp;quot;,//生成图片,参数:size, background, foreground, text
    description: &amp;quot;@paragraph()&amp;quot;,//描述
    ip: &amp;quot;@ip()&amp;quot;,//IP地址
    email: &amp;quot;@email()&amp;quot;//email
})
console.log(obj)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;三-学习json5&#34;&gt;三、学习JSON5&lt;/h1&gt;
&lt;p&gt;json文件,中如果说存在注释文件和编辑器都会报错,我们采用json5格式来让json格式可以存在注释&lt;/p&gt;
&lt;h2 id=&#34;31编辑器安装json5扩展&#34;&gt;3.1编辑器安装JSON5扩展&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608807967957.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;32引入json5库来解析json5格式&#34;&gt;3.2引入JSON5库来解析JSON5格式&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);
const JSON5 = require(&#39;json5&#39;);
//读取json文件
function getJsonFile(filePath) {
    //读取指定json文件
    var json = fs.readFileSync(path.resolve(__dirname,filePath), &#39;utf-8&#39;);
    //解析并返回
    return JSON5.parse(json);
}
var json = getJsonFile(&#39;./userInfo.json5&#39;);
console.log(&#39;json&#39;, json) 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;四-mock和vue-cli结合&#34;&gt;四、MOCK和VUE-CLI结合&lt;/h1&gt;
&lt;h2 id=&#34;41新建indexjs&#34;&gt;4.1新建INDEX.JS&lt;/h2&gt;
&lt;p&gt;在mock文件夹下,新建index.js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);
const Mock = require(&#39;mockjs&#39;);//mockjs 导入依赖模块
const JSON5 = require(&#39;json5&#39;);
//读取json文件
function getJsonFile(filePath) {
    //读取指定json文件
    var json = fs.readFileSync(path.resolve(__dirname,filePath), &#39;utf-8&#39;);
    //解析并返回
    return JSON5.parse(json);
}

//返回一个函数
module.exports = function(app){
    //监听http请求
    app.get(&#39;/user/userinfo&#39;, function (rep, res) {
        //每次响应请求时读取mock data的json文件
        //getJsonFile方法定义了如何读取json文件并解析成数据对象
        var json = getJsonFile(&#39;./userInfo.json5&#39;);
        //将json传入 Mock.mock 方法中，生成的数据返回给浏览器
        res.json(Mock.mock(json));
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;42-新建vueconfigjs&#34;&gt;4.2 新建VUE.CONFIG.JS&lt;/h2&gt;
&lt;p&gt;在项目根目录下,新建vue.config.js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module.exports = {
    devServer: {
        before: require(&#39;./mock/index.js&#39;)//引入mock/index.js
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;43-发送ajax请求&#34;&gt;4.3 发送AJAX请求&lt;/h2&gt;
&lt;p&gt;在src\components\HelloWorld.vue中发送ajax请求&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import axios from &#39;axios&#39;
	export default {
	  name: &#39;HelloWorld&#39;,
	  props: {
	    msg: String
	  },
	  mounted() {
	    axios.get(&#39;/user/userinfo&#39;)
	    .then(res =&amp;gt; {
	      console.log(res)
	    })
	    .catch(err =&amp;gt; {
	      console.error(err); 
	    })
	  }
	} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;五-移除mock-连接实际api&#34;&gt;五、移除MOCK （连接实际api）&lt;/h1&gt;
&lt;p&gt;在项目根路径新建.env.development&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MOCK=true 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完善mock\index.js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module.exports = function(app){
    if(process.env.MOCK == &#39;true&#39;){
        //监听http请求
        app.get(&#39;/user/userinfo&#39;, function (rep, res) {
            //每次响应请求时读取mock data的json文件
            //getJsonFile方法定义了如何读取json文件并解析成数据对象
            var json = getJsonFile(&#39;./userInfo.json5&#39;);
            //将json传入 Mock.mock 方法中，生成的数据返回给浏览器
            res.json(Mock.mock(json));
        });
    }
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;六-总结mock-json5-devserver-axios职责&#34;&gt;六、总结,MOCK-JSON5-DEVSERVER-AXIOS职责&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608808179446.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;七-mockjs-中常用的函数&#34;&gt;七、mockjs 中常用的函数&lt;/h1&gt;
&lt;p&gt;&#39;Boolean&#39;: &#39;@boolean&#39;, // 随机生成布尔类型&lt;br&gt;
&#39;Natural&#39;: &#39;@natural(1, 100)&#39;, // 随机生成1到100之间自然数&lt;br&gt;
&#39;Integer&#39;: &#39;@integer(1, 100)&#39;, // 生成1到100之间的整数&lt;br&gt;
&#39;Float&#39;: &#39;@float(0, 100, 0, 5)&#39;, // 生成0到100之间的浮点数,小数点后尾数为0到5位&lt;br&gt;
&#39;Character&#39;: &#39;@character(&amp;quot;aeiou&amp;quot;)&#39;, // 在aeiou中，生成随机字符，不传参表示生成随机字符&lt;br&gt;
&#39;String&#39;: &#39;@string( 2, 10)&#39;, // 生成2到10个字符之间的字符串&lt;br&gt;
&#39;Range&#39;: &#39;@range(0, 10, 2)&#39;, // 生成一个数组，数组元素从0开始到10结束，间隔为2&lt;br&gt;
&#39;Date&#39;: &#39;@date(&amp;quot;yyyy yy y MM M dd d&amp;quot;)&#39;, // 生成一个随机日期,可加参数定义日期格式，默认yyyy-mm-dd&lt;br&gt;
&#39;Color1&#39;: &#39;@color&#39;, // 生成一个颜色16进制随机值&lt;br&gt;
&#39;Color2&#39;: &#39;@rgb&#39;, //生成一个颜色rgb随机值&lt;br&gt;
&#39;Paragraph&#39;:&#39;@paragraph(2, 5)&#39;, //生成2至5个句子的文本&lt;br&gt;
&#39;Sentence&#39;:&#39;@sentence(3, 5)&#39;, //生成3至5个单词组成的一个句子&lt;br&gt;
&#39;World&#39;:&#39;@word(3, 5)&#39;, //生成3-5个字母组成的单词&lt;br&gt;
&#39;title&#39;:&#39;@title(3,5)&#39;, //生成3-5个单词组成的标题&lt;br&gt;
&#39;cParagraph&#39;:&#39;@cparagraph(2, 5)&#39;, //生成2至5个句子的中文文本&lt;br&gt;
&#39;cSentence&#39;:&#39;@csentence(3, 5)&#39;, //生成3至5个词语组成的一个中文句子&lt;br&gt;
&#39;cWorld&#39;:&#39;@cword(3, 5)&#39;, //生成3-5个字组成的中文词语&lt;br&gt;
&#39;ctitle&#39;:&#39;@ctitle(3,5)&#39;, //生成3-5个词语组成的中文标题&lt;br&gt;
&#39;Name&#39;: &#39;@name&#39;, // 生成姓名&lt;br&gt;
&#39;cName&#39;: &#39;@cname&#39;, // 生成中文姓名&lt;br&gt;
&#39;Url&#39;: &#39;@url&#39;, // 生成url地址&lt;br&gt;
&#39;Email&#39;:&#39;@email&#39;,//生成邮箱&lt;br&gt;
&#39;Address&#39;: &#39;@county(true)&#39;， // 生成省 市 县组成的地址&lt;br&gt;
&#39;Guid&#39;:&#39;@guid()&#39;, //生成Guid值&lt;/p&gt;
">Vue&mock模拟数据</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/vueandmarkdown-bian-ji-qi-mavoneditor/"" data-c="
          &lt;h1 id=&#34;一-介绍&#34;&gt;一、介绍&lt;/h1&gt;
&lt;p&gt;Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。mavonEditor是国人开源的一款比较好用的markdown编辑器，GitHub地址：&lt;a href=&#34;https://github.com/hinesboy/mavonEditor&#34;&gt;https://github.com/hinesboy/mavonEditor&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;二-安装&#34;&gt;二、安装&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;npm install mavon-editor --save
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;三-使用&#34;&gt;三、使用&lt;/h1&gt;
&lt;h2 id=&#34;方法一&#34;&gt;方法一：&lt;/h2&gt;
&lt;p&gt;main.js:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; // 全局注册
    // import with ES6
    import Vue from &#39;vue&#39;
    import mavonEditor from &#39;mavon-editor&#39;
    import &#39;mavon-editor/dist/css/index.css&#39;
    // use
    Vue.use(mavonEditor)
    new Vue({
        &#39;el&#39;: &#39;#main&#39;,
        data() {
            return { value: &#39;&#39; }
        }
    })
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;index.html&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;main&amp;quot;&amp;gt;
    &amp;lt;mavon-editor v-model=&amp;quot;value&amp;quot;/&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;方法二&#34;&gt;方法二：&lt;/h2&gt;
&lt;p&gt;editor.vue:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;template&amp;gt;
        &amp;lt;div id=&amp;quot;editor&amp;quot;&amp;gt;
            &amp;lt;mavon-editor style=&amp;quot;height: 100%&amp;quot;&amp;gt;&amp;lt;/mavon-editor&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/template&amp;gt;
    &amp;lt;script&amp;gt;
    // Local Registration
    import { mavonEditor } from &#39;mavon-editor&#39;
    import &#39;mavon-editor/dist/css/index.css&#39;
    export default {
        name: &#39;editor&#39;,
        components: {
            mavonEditor
            // or &#39;mavon-editor&#39;: mavonEditor
        }
    }
    &amp;lt;/script&amp;gt;
    &amp;lt;style&amp;gt;
    #editor {
        margin: auto;
        width: 80%;
        height: 580px;
    }
    &amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;index.js:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 下同
    import Vue from &#39;vue&#39;;
    var editor = require(&#39;./editor.vue&#39;);
    new Vue({
        el: &#39;#main&#39;,
        render: h =&amp;gt; h(editor)
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;index.html:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 下同
&amp;lt;div id=&amp;quot;main&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;四-图片上传&#34;&gt;四、图片上传&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
    &amp;lt;mavon-editor ref=md @imgAdd=&amp;quot;$imgAdd&amp;quot; @imgDel=&amp;quot;$imgDel&amp;quot;&amp;gt;&amp;lt;/mavon-editor&amp;gt;
&amp;lt;/template&amp;gt;
exports default {
    methods: {
        // 绑定@imgAdd event
        $imgAdd(pos, $file){
            // 第一步.将图片上传到服务器.
           var formdata = new FormData();
           formdata.append(&#39;image&#39;, $file);
           axios({
               url: &#39;server url&#39;,
               method: &#39;post&#39;,
               data: formdata,
               headers: { &#39;Content-Type&#39;: &#39;multipart/form-data&#39; },
           }).then((url) =&amp;gt; {
               // 第二步.将返回的url替换到文本原位置![...](0) -&amp;gt; ![...](url)
               /**
               * $vm 指为mavonEditor实例，可以通过如下两种方式获取
               * 1. 通过引入对象获取: `import {mavonEditor} from ...` 等方式引入后，`$vm`为`mavonEditor`
               * 2. 通过$refs获取: html声明ref : `&amp;lt;mavon-editor ref=md &amp;gt;&amp;lt;/mavon-editor&amp;gt;，`$vm`为 `this.$refs.md`
               */
               $vm.$img2Url(pos, url);
           })
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注:&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;默认大小样式为 min-height: 300px , min-width: 300px 可自行覆盖&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;基础z-index: 1500&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;仅用作展示可以设置props: toolbarsFlag: false , subfield: false, defaultOpen: &amp;quot;preview&amp;quot;&lt;/strong&gt;&lt;/p&gt;
">Vue&markdown编辑器--mavonEditor</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/nodejs-cong-ling-dan-pai-9/"" data-c="
          &lt;h1 id=&#34;一-在-nodejs-中使用-mongodb&#34;&gt;一、在 Nodejs 中使用 Mongodb&lt;/h1&gt;
&lt;p&gt;在前面的课程我们给大家讲了如何使用命令操作 Mongodb，这一讲开始我们给大家讲解一 下如何使用 Nodejs 来操作 Mongodb 数据库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Nodejs 操作 mongodb 数据库官方文档：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://mongodb.github.io/node-mongodb-native/&#34;&gt;http://mongodb.github.io/node-mongodb-native/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install mongodb --save 
或者
cnpm install mongodb --save 
或者
yarn add mongodb
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;二-nodejs-连接-mongodb-数据库&#34;&gt;二、Nodejs 连接 MongoDb 数据库&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const MongoClient = require(&#39;mongodb&#39;).MongoClient;
const url = &#39;mongodb://localhost:27017&#39;; 
// const url = &#39;mongodb://admin:123456@localhost:27017/&#39;; 有密码连接方式 
const dbName = &#39;itying&#39;; 
const client = new MongoClient(url,{ useUnifiedTopology: true }); client.connect(function(err) { 
    if(err){
        console.log(err); 
        return;
     }
     console.log(&amp;quot;连接成功&amp;quot;); 
     //获取 db 对象 
     const db = client.db(dbName); 
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span style=&#34;color:red&#34;&gt;注意：如果数据库开启了权限验证的话需要使用下面方式连接数据库&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const url = &#39;mongodb://admin:123456@localhost:27017/&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span style=&#34;color:red&#34;&gt;其中：&lt;/span&gt;admin 表示用户名，123456 表示密码&lt;/p&gt;
&lt;h1 id=&#34;三-nodejs-查找-mongodb-数据库的数据&#34;&gt;三、Nodejs 查找 MongoDb 数据库的数据&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const MongoClient = require(&#39;mongodb&#39;).MongoClient; 
const url = &#39;mongodb://localhost:27017&#39;; 
const dbName = &#39;itying&#39;; 
const client = new MongoClient(url,{ useUnifiedTopology: true }); client.connect(function(err) { 
    if(err){
        console.log(err); 
        return; 
    }
    const db = client.db(dbName); //获取 db 对象 
    db.collection(&amp;quot;user&amp;quot;).find({}).toArray(function(err,data){ //查找 
        if(err){
            console.log(err); 
            return; 
        }
        console.log(data); 
        client.close(); 
        })
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;四-nodejs-给-mongodb-增加数据&#34;&gt;四、Nodejs 给 MongoDb 增加数据&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const MongoClient = require(&#39;mongodb&#39;).MongoClient; 
const url = &#39;mongodb://localhost:27017&#39;; 
const dbName = &#39;itying&#39;; 
const client = new MongoClient(url,{ useUnifiedTopology: true }); client.connect(function(err) { 
    if(err){
        console.log(err); 
        return; 
    }
    //获取 db 对象 
    const db = client.db(dbName); 
    //新增数据 
    db.collection(&amp;quot;user&amp;quot;).insertOne({&amp;quot;username&amp;quot;:&amp;quot;nodejs&amp;quot;,&amp;quot;age&amp;quot;:10},(err,result)=&amp;gt;{ 
        if(err){
            console.log(err); 
            return; 
        }
        console.log(result); 
        client.close(); 
     }) 
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;五-nodejs-修改-mongodb-数据&#34;&gt;五、Nodejs 修改 MongoDb 数据&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const MongoClient = require(&#39;mongodb&#39;).MongoClient; 
const url = &#39;mongodb://localhost:27017&#39;; 
// const url = &#39;mongodb://admin:123456@localhost:27017/&#39;; 有密码连接方式 
const dbName = &#39;itying&#39;; 
const client = new MongoClient(url,{ useUnifiedTopology: true }); client.connect(function(err) {
     if(err){
         console.log(err); 
         return; 
    }
    const db = client.db(dbName); 
    //获取 db 对象 
    db.collection(&amp;quot;user&amp;quot;).updateOne({&amp;quot;name&amp;quot;:&amp;quot;zhangsan&amp;quot;},{$set:{&amp;quot;age&amp;quot;:50}},(err,result)=&amp;gt;{ 
        if(err){
         console.log(err); 
         return; 
        }
        console.log(result); 
        client.close(); 
    })
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;六-nodejs-删除-mongodb-数据&#34;&gt;六、Nodejs 删除 MongoDb 数据&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const {MongoClient,ObjectID} = require(&#39;mongodb&#39;); 
const url = &#39;mongodb://localhost:27017&#39;; 
const dbName = &#39;itying&#39;; 
const client = new MongoClient(url,{ useUnifiedTopology: true }); client.connect(function(err) { 
    if(err){
        console.log(err); 
        return; 
        }
        //获取 db 对象 
        const db = client.db(dbName); 
        //删除数据 
        db.collection(&amp;quot;user&amp;quot;).deleteOne({ &amp;quot;username&amp;quot; : &amp;quot;nodejs&amp;quot; }, function(err, result) { 
            if(err){ 
                console.log(err); 
                return; 
            }
            console.log(result); 
            client.close(); 
        }); 
});
&lt;/code&gt;&lt;/pre&gt;
">NodeJs从零单排(9)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/nodejs-cong-ling-dan-pai-8/"" data-c="
          &lt;h1 id=&#34;1-模块化的方式封装&#34;&gt;1、模块化的方式封装&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;var app={ 
    static:function (req, res, staticPath) { 
        //处理静态资源 
    },
    login:function(req,res){ 
        console.log(&#39;login&#39;); 
        res.end(&#39;login&#39;); 
    },
    dologin:function(req,res){ 
        res.end(&#39;doLogin&#39;); 
    }, 
    register:function(req,res){ 
        res.end(&#39;register&#39;); 
    },error:function(req,res){ 
        res.end(&#39;error&#39;); 
    } 
}
module.exports=app;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;http.createServer(function (req, res) { 
    //创建静态 web 服务 
    routes.static(req,res,&#39;static&#39;); 
    //路由 
    let pathname=url.parse(req.url).pathname.replace(&#39;/&#39;,&#39;&#39;); 
    try { 
        routes[pathname](req, res); 
    } catch (err) { 
        routes[&#39;error&#39;](req, res); 
        }
}).listen(3000);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2-封装仿照-express-的路由&#34;&gt;2、封装仿照 express 的路由&lt;/h1&gt;
&lt;p&gt;Express 官网：&lt;a href=&#34;https://www.expressjs.com.cn/&#34;&gt;https://www.expressjs.com.cn/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var express = require(&#39;express&#39;) 
var app = express() 
app.get(&amp;quot;/&amp;quot;, function (req, res) { 
    res.send(&#39;hello world&#39;) 
})
app.get(&amp;quot;/login&amp;quot;, function (req, res) {
    res.send(&#39;hello world&#39;) 
})
app.post(&amp;quot;/doLogin&amp;quot;, function (req, res) { 
    res.send(&#39;POST request to the homepage&#39;) 
})
&lt;/code&gt;&lt;/pre&gt;
">NodeJs从零单排(8)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/nodejs-cong-ling-dan-pai-7/"" data-c="
          &lt;h1 id=&#34;1-nodejs-封装静态-web-服务&#34;&gt;1、 Nodejs 封装静态 web 服务&lt;/h1&gt;
&lt;p&gt;上一讲的静态 web 服务器封装&lt;/p&gt;
&lt;h1 id=&#34;2-路由&#34;&gt;2、 路由&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;官方解释：&lt;/strong&gt;&lt;br&gt;
路由（Routing）是由一个 URI（或者叫路径）和一个特定的 HTTP 方法（GET、POST 等）组成的，涉及到应用如何响应客户端对某个网站节点的访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通俗的说：&lt;/strong&gt;&lt;br&gt;
路由指的就是针对不同请求的 URL，处理不同的业务逻辑。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608781577104.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-初识-ejs-模块引擎&#34;&gt;3、 初识 EJS 模块引擎&lt;/h1&gt;
&lt;p&gt;我们学的 EJS 是后台模板，可以把我们数据库和文件读取的数据显示到 Html 页面上面。它是一个第三方模块，需要通过 npm 安装&lt;br&gt;
&lt;a href=&#34;https://www.npmjs.com/package/ejs&#34;&gt;https://www.npmjs.com/package/ejs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install ejs –save / cnpm install ejs --save
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nodejs 中使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ejs.renderFile(filename, data, options, function(err, str){ 
    // str =&amp;gt;  Rendered HTML string 
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;EJS 常用标签&lt;br&gt;
 &amp;lt;% %&amp;gt;流程控制标签&lt;br&gt;
 &amp;lt;%= %&amp;gt;输出标签（原文输出 HTML 标签）&lt;br&gt;
 &amp;lt;%- %&amp;gt;输出标签（HTML 会被浏览器解析）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;&amp;lt;%= url %&amp;gt;&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;&amp;lt;%= imageURL %&amp;gt;&amp;quot; alt=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt; 
    &amp;lt;% for(var i = 0 ; i &amp;lt; news.length ; i++){ %&amp;gt; 
         &amp;lt;li&amp;gt;&amp;lt;%= news[i] %&amp;gt;&amp;lt;/li&amp;gt; 
    &amp;lt;% } %&amp;gt; 
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;4-get-post&#34;&gt;4、 Get、Post&lt;/h1&gt;
&lt;p&gt;超文本传输协议（HTTP）的设计目的是保证客户端机器与服务器之间的通信。&lt;br&gt;
在客户端和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。&lt;/p&gt;
&lt;p&gt;GET - 从指定的资源请求数据。（一般用于获取数据）&lt;br&gt;
POST - 向指定的资源提交要被处理的数据。（一般用于提交数据）&lt;/p&gt;
&lt;p&gt;获取 GET 传值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var urlinfo=url.parse(req.url,true); 
urlinfo.query;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取 POST 传值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var postData = &#39;&#39;; 
// 数据块接收中 
req.on(&#39;data&#39;, function (postDataChunk) { 
    postData += postDataChunk; 
}); 
// 数据接收完毕，执行回调函数 
req.on(&#39;end&#39;, function () { 
    try {postData = JSON.parse(postData); 
    } catch (e) { } 
    req.query = postData; 
    console.log(querystring.parse(postData)); 
});
&lt;/code&gt;&lt;/pre&gt;
">NodeJs从零单排(7)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/nodejs-cong-ling-dan-pai-6/"" data-c="
          &lt;h1 id=&#34;1-nodejs-创建的第一个应用&#34;&gt;1、Node.js 创建的第一个应用&lt;/h1&gt;
&lt;p&gt;1、引入 http 模块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var http = require(&amp;quot;http&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、创建服务器&lt;br&gt;
接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 3000 端口。 函数通过 request, response 参数来接收和响应数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const http =require(&#39;http&#39;); 
http.createServer((req,res)=&amp;gt;{ 
    //状态码是 200，文件类型是 html，字符集是 utf-8 
    res.writeHead(200,{&amp;quot;Content-type&amp;quot;:&amp;quot;text/html;charset=&#39;utf-8&#39;&amp;quot;}); 
    res.write(&amp;quot;&amp;lt;head&amp;gt; &amp;lt;meta charset=&#39;UTF-8&#39;&amp;gt;&amp;lt;/head&amp;gt;&amp;quot;); 
    res.write(&#39;你好 nodejs&#39;); 
    res.write(&#39;&amp;lt;h2&amp;gt;你好 nodejs&amp;lt;/h2&amp;gt;&#39;); 
    res.end(); //结束响应
}).listen(3000);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2-web-服务器介绍&#34;&gt;2、WEB 服务器介绍&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Web 服务器一般指网站服务器&lt;/strong&gt;，是指驻留于因特网上某种类型计算机的程序，可以向 浏览器等 Web 客户端提供文档，也可以放置网站文件让全世界浏览，还可以放置数据文件， 让全世界下载。目前最主流的 Web 服务器有 Apache 、Nginx 、IIS 等。&lt;/p&gt;
&lt;h1 id=&#34;3-nodejs-创建一个-web-服务器&#34;&gt;3、Nodejs 创建一个 WEB 服务器。&lt;/h1&gt;
&lt;p&gt;1、可以让我们访问 web 服务器上面的网站&lt;br&gt;
2、可以让我们下载 web 服务器上面的文件&lt;/p&gt;
">NodeJs从零单排(6)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/nodejs-cong-ling-dan-pai-5/"" data-c="
          &lt;h1 id=&#34;一-es6-常见语法的使用&#34;&gt;一、 Es6 常见语法的使用&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;let const&lt;/li&gt;
&lt;li&gt;箭头函数&lt;/li&gt;
&lt;li&gt;对象、属性的简写&lt;/li&gt;
&lt;li&gt;模板字符串&lt;/li&gt;
&lt;li&gt;Promise&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;二-async-await-和-promise-的使用&#34;&gt;二、 Async、Await 和 Promise 的使用&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;async&lt;/strong&gt; 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个异步的 function ，而 await 用于等待一个异步方法执行完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单理解：&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;async&lt;/strong&gt; 是让方法变成异步。&lt;br&gt;
&lt;strong&gt;await&lt;/strong&gt; 是等待异步方法执行完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;详细说明：&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;async 是让方法变成异步&lt;/strong&gt;，在终端里用 node 执行这段代码，你会发现输出了 Promise {‘Hello async’ }，这时候会发现它返回的是 Promise。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;async function testAsync(){ 
    return &#39;Hello async&#39;; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;const result = testAsync(); 
console.log(result);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;PS E:\code\BXShop&amp;gt; node async.js 
Promise { &#39;Hello async&#39; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;await 在等待 async 方法执行完毕&lt;/strong&gt;，其实 await 等待的只是一个表达式，这个表达式在官方 文档里说的是 Promise 对象，但是它也可以接受普通值。 &lt;span style=&#34;color:red&#34;&gt;注意：&lt;/span&gt;await 必须在 async 方法中 才可以使用因为 await 访问本身就会造成程序停止堵塞，所以必须在异步方法中才可以使用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function getData(){ 
    return &#39;zhangsan&#39;; 
}
async function testAsync(){ 
    return &#39;Hello async&#39;; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;async function test(){ 
    const v1=await getData(); 
    const v2=await testAsync(); 
    console.log(v1,v2);
}
test();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;async/await 同时使用&lt;/strong&gt;&lt;br&gt;
async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function findData() { 
    return new Promise(resolve =&amp;gt; { 
        setTimeout(() =&amp;gt; resolve(&amp;quot;long_time_value&amp;quot;), 1000); 
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;async function test() { 
    const v = await findData(); 
    console.log(v);
}
test();
&lt;/code&gt;&lt;/pre&gt;
">NodeJs从零单排(5)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/nodejs-cong-ling-dan-pai-4/"" data-c="
          &lt;h1 id=&#34;1-fsstat-检测是文件还是目录&#34;&gt;1. fs.stat 检测是文件还是目录&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;) 
fs.stat(&#39;hello.js&#39;, (error, stats) =&amp;gt;{ 
    if(error){
         console.log(error) 
         } else {
        console.log(stats) 
        console.log(`文件：${stats.isFile()}`) 
        console.log(`目录：${stats.isDirectory()}`) 
        } 
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2-fsmkdir-创建目录&#34;&gt;2. fs.mkdir 创建目录&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;)
fs.mkdir(&#39;logs&#39;, (error) =&amp;gt; { 
    if(error){ 
       console.log(error) 
   } else { 
    console.log(&#39;成功创建目录：logs&#39;) 
     } 
 })
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3-fswritefile-创建写入文件&#34;&gt;3. fs.writeFile 创建写入文件&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;fs.writeFile(&#39;logs/hello.log&#39;, &#39;您好 ~ \n&#39;, (error) =&amp;gt; { 
    if(error) { 
        console.log(error) 
   } else { 
        console.log(&#39;成功写入文件&#39;) 
    } 
 })
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;4-fsappendfile-追加文件&#34;&gt;4. fs.appendFile 追加文件&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;) 
fs.appendFile(&#39;logs/hello.log&#39;, &#39;hello ~ \n&#39;, (error) =&amp;gt; { 
    if(error) { 
    console.log(error) 
    } else { 
        console.log(&#39;成功写入文件&#39;) 
    } 
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5fsreadfile-读取文件&#34;&gt;5.fs.readFile 读取文件&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;) 
fs.readFile(&#39;logs/hello.log&#39;, &#39;utf8&#39;, (error, data) =&amp;gt;{ 
    if (error) { 
     console.log(error) 
} else { 
    console.log(data) 
    } 
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;6fsreaddir-读取目录&#34;&gt;6.fs.readdir 读取目录&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;) 
fs.readdir(&#39;logs&#39;, (error, files) =&amp;gt; { 
   if (error) { 
     console.log(error) 
  } else { 
    console.log(files) 
    }
 })
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;7fsrename-重命名&#34;&gt;7.fs.rename 重命名&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;) 
fs.rename(&#39;js/hello.log&#39;, &#39;js/greeting.log&#39;, (error) =&amp;gt;{ 
 if (error) { 
     console.log(error) 
  } else { 
console.log(&#39;重命名成功&#39;) 
    }
 })
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;8-fsrmdir-删除目录&#34;&gt;8. fs.rmdir 删除目录&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;) 
fs.rmdir(&#39;logs&#39;, (error) =&amp;gt;{ 
 if (error) { 
    console.log(error) 
    } else { 
    console.log(&#39;成功的删除了目录：logs&#39;) 
     } 
 })
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;9-fsunlink-删除文件&#34;&gt;9. fs.unlink 删除文件&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;) 
fs.unlink(`logs/${file}`, (error) =&amp;gt; { 
  if (error) { 
    console.log(error) 
    } else { 
    console.log(`成功的删除了文件: ${file}`) 
    } 
 })
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;10-fscreatereadstream-从文件流中读取数据&#34;&gt;10. fs.createReadStream 从文件流中读取数据&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;) 
var fileReadStream = fs.createReadStream(&#39;data.json&#39;) 
let count=0; 
var str=&#39;&#39;; 
fileReadStream.on(&#39;data&#39;, (chunk) =&amp;gt; { 
    console.log(`${ ++count } 接收到：${chunk.length}`);
     str+=chunk
     })
fileReadStream.on(&#39;end&#39;, () =&amp;gt; { 
    console.log(&#39;--- 结束 ---&#39;); 
    console.log(count); 
    console.log(str); 
})
fileReadStream.on(&#39;error&#39;, (error) =&amp;gt; { 
    console.log(error)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;11-fscreatewritestream-写入文件&#34;&gt;11. fs.createWriteStream 写入文件&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;var fs = require(&amp;quot;fs&amp;quot;); 
var data = &#39;我是从数据库获取的数据，我要保存起来&#39;; 
// 创建一个可以写入的流，写入到文件 output.txt 中
var writerStream = fs.createWriteStream(&#39;output.txt&#39;); 
// 使用 utf8 编码写入数据 
writerStream.write(data,&#39;UTF8&#39;); 
// 标记文件末尾 
writerStream.end();
// 处理流事件 --&amp;gt; finish 事件
writerStream.on(&#39;finish&#39;, function() { 
    /*finish - 所有数据已被写入到底层系统时触发。*/
console.log(&amp;quot;写入完成。&amp;quot;); 
}); 
writerStream.on(&#39;error&#39;, function(err){ 
    console.log(err.stack); 
}); 
console.log(&amp;quot;程序执行完毕&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;12-管道流&#34;&gt;12. 管道流&lt;/h1&gt;
&lt;p&gt;管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传 递到另外一个流中。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608779085554.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如上面的图片所示，我们把文件比作装水的桶，而水就是文件里的内容，我们用一根管子(pipe)连接两个桶使得水从一个桶流入另一个桶，这样就慢慢的实现了大文件的复制过程。 以下实例我们通过读取一个文件内容并将内容写入到另外一个文件中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var fs = require(&amp;quot;fs&amp;quot;); 
// 创建一个可读流 
var readerStream = fs.createReadStream(&#39;input.txt&#39;); 
// 创建一个可写流 
var writerStream = fs.createWriteStream(&#39;output.txt&#39;); 
// 管道读写操作 
// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中 
readerStream.pipe(writerStream);
console.log(&amp;quot;程序执行完毕&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
">NodeJs从零单排(4)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/nodejs-cong-ling-dan-pai-3/"" data-c="
          &lt;h1 id=&#34;一-包与-npm&#34;&gt;一、包与 NPM&lt;/h1&gt;
&lt;h3 id=&#34;1-包&#34;&gt;1. 包&lt;/h3&gt;
&lt;p&gt;Nodejs 中除了它自己提供的&lt;span style=&#34;color:red&#34;&gt;核心模块&lt;/span&gt;外，我们可以&lt;span style=&#34;color:red&#34;&gt;自定义模块&lt;/span&gt;，也可以使用&lt;span style=&#34;color:red&#34;&gt;第三方的模块&lt;/span&gt;。Nodejs 中第三方模块由包组成，可以通过包来对一组具有相互依赖关系的模块进行统一管理。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608777425715.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;完全符合CommonJs规范的&lt;span style=&#34;color:red&#34;&gt;包目录&lt;/span&gt;一般包含如下这些文件。&lt;br&gt;
• package.json :包描述文件。&lt;br&gt;
• bin :用于存放可执行二进制文件的目录。&lt;br&gt;
• lib :用于存放 JavaScript 代码的目录。&lt;br&gt;
• doc :用于存放文档的目录。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;在 NodeJs 中通过 NPM 命令来下载第三方的模块（包）。&lt;/code&gt;&lt;br&gt;
&lt;a href=&#34;https://www.npmjs.com/package/silly-datetime&#34;&gt;https://www.npmjs.com/package/silly-datetime&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm i silly-datetime –save 
var sd = require(&#39;silly-datetime&#39;); 
sd.format(new Date(), &#39;YYYY-MM-DD HH:mm&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;2-npm-介绍&#34;&gt;2. NPM 介绍&lt;/h3&gt;
&lt;p&gt;npm 是&lt;code&gt;世界上最大的开放源代码&lt;/code&gt;的生态系统。我们可以通过 npm 下载各种各样的包， 这些源代码（包）我们可以在&lt;a href=&#34;https://www.npmjs.com&#34;&gt;https://www.npmjs.com&lt;/a&gt;找到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;npm 是随同 NodeJS 一起安装的包管理工具，能解决 NodeJS 代码部署上的很多问题， 常见的使用场景有以下几种：&lt;/strong&gt;&lt;br&gt;
 允许用户从 NPM 服务器下载别人编写的第三方包到本地使用。(silly-datetime)&lt;br&gt;
 允许用户从 NPM 服务器下载并安装别人编写的命令行程序(工具)到本地使用。 （supervisor）&lt;br&gt;
 允许用户将自己编写的包或命令行程序上传到 NPM 服务器供别人使用。&lt;/p&gt;
&lt;h1 id=&#34;二-npm-命令详解&#34;&gt;二、NPM 命令详解。&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;npm -v 查看 npm 版本&lt;/li&gt;
&lt;li&gt;使用 npm 命令安装模块&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;npm install Module Name 
如安装 jq 模块：
npm install jquery
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;npm uninstall moudleName &lt;strong&gt;卸载模块&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;npm uninstall ModuleName
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;npm list 查看当前目录下已安装的 node 包&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;npm list
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;npm info jquery 查看 jquery 的版本&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;npm info 模块 //查看模块的版本
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;code&gt;指定版本安装 npm install jquery@1.8.0&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;三-packagejson&#34;&gt;三、package.json&lt;/h1&gt;
&lt;p&gt;package.json定义了这个项目所需要的各种模块,以及项目的配置信息(比如名称、版本、 许可证等元数据)&lt;br&gt;
1、&lt;code&gt;创建 package.json&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm init 或者 npm init –yes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、&lt;code&gt;package.json 文件&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
     &amp;quot;name&amp;quot;: &amp;quot;test&amp;quot;, 
     &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;, 
     &amp;quot;description&amp;quot;: &amp;quot;test&amp;quot;, 
     &amp;quot;main&amp;quot;: &amp;quot;main.js&amp;quot;, 
     &amp;quot;keywords&amp;quot;: [ &amp;quot;test&amp;quot; ],
     &amp;quot;author&amp;quot;: &amp;quot;wade&amp;quot;,
     &amp;quot;license&amp;quot;: &amp;quot;MIT&amp;quot;, 
     &amp;quot;dependencies&amp;quot;: { 
        &amp;quot;express&amp;quot;: &amp;quot;^4.10.1&amp;quot;
        },
        &amp;quot;devDependencies&amp;quot;: {
        &amp;quot;jslint&amp;quot;: &amp;quot;^0.6.5&amp;quot; 
     }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、安装模块并把模块写入 package.json(依赖)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install babel-cli --save-dev 
npm install 模块 --save 
npm install 模块 --save-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、&lt;code&gt;dependencies 与 devDependencies 之间的区别?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用 npm install node_module –save 自动更新 dependencies 字段值;&lt;br&gt;
使用 npm install node_module –save-dev 自动更新 devDependencies 字段值;&lt;/p&gt;
&lt;p&gt;dependencie 配置当前程序所依赖的其他包。&lt;br&gt;
devDependencie 配置当前程序所依赖的其他包，比如一些工具之类的配置在这里&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;dependencies&amp;quot;: { 
    &amp;quot;ejs&amp;quot;: &amp;quot;^2.3.4&amp;quot;, 
    &amp;quot;express&amp;quot;: &amp;quot;^4.13.3&amp;quot;,
     &amp;quot;formidable&amp;quot;: &amp;quot;^1.0.17&amp;quot;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;div style=&#34;color:red&#34;&gt;
^表示第一位版本号不变，后面两位取最新的&lt;br&gt;
~表示前两位不变，最后一个取最新&lt;br&gt;
*表示全部取最新
&lt;/div&gt;
&lt;h1 id=&#34;四-安装淘宝镜像&#34;&gt;四、安装淘宝镜像&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;http://www.npmjs.org&#34;&gt;http://www.npmjs.org&lt;/a&gt;  npm 包官网&lt;br&gt;
&lt;a href=&#34;https://npm.taobao.org/&#34;&gt;https://npm.taobao.org/&lt;/a&gt; 淘宝 npm 镜像官网&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;淘宝 NPM 镜像&lt;/strong&gt;是一个完整 &lt;strong&gt;npmjs.org&lt;/strong&gt; 镜像，你可以用此代替官方版本(只读)，同步频 率目前为 10 分钟 一次以保证尽量与官方服务同步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们可以使用我们定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g cnpm --registry=https://registry.npm.taobao.org
&lt;/code&gt;&lt;/pre&gt;
">NodeJs从零单排(3)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/nodejs-cong-ling-dan-pai-2/"" data-c="
          &lt;h1 id=&#34;一-什么是-commonjs&#34;&gt;一、什么是 CommonJs？&lt;/h1&gt;
&lt;p&gt;JavaScript 是一个强大面向对象语言，它有很多快速高效的解释器。然而， JavaScript 标准定义的 API 是为了构建基于浏览器的应用程序。并没有制定一个用于更广泛的应用程序 的标准库。&lt;code&gt;CommonJS 规范的提出,主要是为了弥补当前 JavaScript 没有标准库的缺陷。它的 终极目标就是：提供一个类似 Python，Ruby 和 Java 语言的标准库&lt;/code&gt;，而不只是让 JavaScript 停 留在小脚本程序的阶段。用 CommonJS API 编写出的应用，不仅可以利用 JavaScript 开发客户端应用，&lt;strong&gt;而且还可以编写以下应用。&lt;/strong&gt;&lt;br&gt;
     •服务器端 JavaScript 应用程序。（nodejs）&lt;br&gt;
     •命令行工具。&lt;br&gt;
     •桌面图形界面应用程序。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CommonJS 就是模块化的标准，nodejs 就是 CommonJS（模块化）的实现。&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;二-nodejs-中的模块化&#34;&gt;二、Nodejs 中的模块化&lt;/h1&gt;
&lt;p&gt;Node 应用由模块组成，采用 CommonJS 模块规范。&lt;/p&gt;
&lt;h2 id=&#34;21-在-node-中模块分为两类&#34;&gt;2.1 在 Node 中，模块分为两类:&lt;/h2&gt;
&lt;p&gt;一类是 Node 提供的模块,称为&lt;strong&gt;核心模块&lt;/strong&gt;；另一类是用户编写的模块，称为&lt;strong&gt;文件模块&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;    • 核心模块部分在 Node 源代码的编译过程中，编译进了二进制执行文件。在 Node 进 程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和 编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。 &lt;strong&gt;如：HTTP 模块 、URL 模块、Fs 模块都是 nodejs 内置的核心模块，可以直接引入使用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    • 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程、 速度相比核心模块稍微慢一些，但是用的非常多。&lt;strong&gt;这些模块需要我们自己定义。接下来我 们看一下 nodejs 中的自定义模块。&lt;/strong&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;22-commonjsnodejs中自定义模块的规定&#34;&gt;2.2 CommonJS（Nodejs）中自定义模块的规定：&lt;/h2&gt;
&lt;p&gt;1.我们可以把公共的功能&lt;strong&gt;抽离成为一个单独的 js 文件作为&lt;/strong&gt;一个模块，默认情况下面这 个模块里面的方法或者属性，外面是没法访问的。如果要让外部可以访问模块里面的方法或 者属性，就必须在模块里面通过 exports 或者 module.exports 暴露属性或者方法。&lt;/p&gt;
&lt;p&gt;2.在需要使用这些模块的文件中，通过 require 的方式引入这个模块。这个时候就可 以使用模块里面暴露的属性和方法。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608774648876.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;23-定义使用模块&#34;&gt;2.3 定义使用模块：&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 定义一个 tools.js 的模块 
//模块定义
var tools = {
     sayHello: function() {
        return &#39;hello NodeJS&#39;;
        },
        add: function(x, y) {
            return x + y; 
            } 
 };// 模块接口的暴露 
// module.exports = tools; 
    exports.sayHello = tools.sayHello; 
    exports.add = tools.add;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var http = require(&#39;http&#39;); 
// 引入自定义的 tools.js 模块
var tools= require(&#39;./tools&#39;); 
tools.sayHello(); //使用模块
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;三-npm-init-生成-packagejson&#34;&gt;三、npm init 生成 package.json&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;npm init --yes
&lt;/code&gt;&lt;/pre&gt;
">NodeJs从零单排(2)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/nodejs-cong-ling-dan-pai/"" data-c="
          &lt;h1 id=&#34;一-nodejs-环境搭建&#34;&gt;一、NodeJs 环境搭建&lt;/h1&gt;
&lt;p&gt;官网：&lt;a href=&#34;https://nodejs.org/en/&#34;&gt;https://nodejs.org/en/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&#34;https://nodejs.org/en/download/&#34;&gt;https://nodejs.org/en/download/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载稳定版本、双击下一步下一步安装。&lt;/p&gt;
&lt;p&gt;安装完成重新打开 CMD。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608729555271.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;二-nodejs-创建第一个应用&#34;&gt;二、Node.js 创建第一个应用&lt;/h1&gt;
&lt;p&gt;1、引入 http 模块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var http = require(&amp;quot;http&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、创建服务器&lt;br&gt;
接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var http = require(&#39;http&#39;);
 http.createServer(function (request, response) {
    // 发送 HTTP 头部
    // HTTP 状态值: 200 : OK
    //设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf8 
    response.writeHead(200,{&amp;quot;Content-Type&amp;quot;:&amp;quot;text/html;charset=UTF-8&amp;quot;}); 
    // 发送响应数据 &amp;quot;Hello World&amp;quot; 
    res.end(&amp;quot;哈哈哈哈，我买了一个 iPhone&amp;quot; + (1+2+3) + &amp;quot;s&amp;quot;); 
    }).listen(8888); 
    // 终端打印如下信息 
    console.log(&#39;Server running at http://127.0.0.1:8888/&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.运行程序&lt;br&gt;
用命令行切换到程序对应目录。通过 node 命令运行程序。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608771582393.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
浏览器运行&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608771633470.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
你会发现，我们本地写一个 js，打死都不能直接拖入浏览器运行，但是有了 node，我们任何一个 js 文件，都可以通过 node 来运行。&lt;span style=&#34;color:red&#34;&gt;也就是说，node 就是一个 js 的执行环境。&lt;/span&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&#34;三-nodejs-创建第一个应用&#34;&gt;三、Node.js 创建第一个应用&lt;/h1&gt;
&lt;p&gt;Node.js 中，将很多的功能，划分为了一个个 module（模块）。 Node.js 中的很多功能都 是通过模块实现。&lt;/p&gt;
&lt;h2 id=&#34;31-http-模块的使用&#34;&gt;3.1、HTTP 模块的使用&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;//引用模块 
var http = require(&amp;quot;http&amp;quot;); 

//创建一个服务器，回调函数表示接收到请求之后做的事情 
var server = http.createServer(function(req,res){ 
    //req 参数表示请求，res 表示响应 
    console.log(&amp;quot;服务器接收到了请求&amp;quot; + req.url); 
    res.end(); // End 方法使 Web 服务器停止处理脚本并返回当前结果
 }); 
 //监听端口
server.listen(3000,&amp;quot;127.0.0.1&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置一个响应头：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;res.writeHead(200,{&amp;quot;Content-Type&amp;quot;:&amp;quot;text/html;charset=UTF8&amp;quot;});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608772545739.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
我们现在来看一下 req 里面能够使用的东西。&lt;br&gt;
&lt;code&gt;最关键的就是 req.url 属性&lt;/code&gt;，表示用户的请求 URL 地址。所有的路由设计，都是通过 req.url 来实现的。&lt;br&gt;
我们比较关心的不是拿到 URL，而是识别这个 URL。&lt;br&gt;
&lt;span style=&#34;color:green&#34;&gt;识别 URL，用到了下面的&lt;code&gt;url 模块&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-url-模块的使用&#34;&gt;3.2、URL 模块的使用&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;url.parse() 解析 URL
url.format(urlObject) //是上面 url.parse() 操作的逆向操作 
url.resolve(from, to) 添加或者替换地址
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1、url.parse()&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608772888877.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608772910458.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608772947330.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608772951314.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;2、url.format()&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608772985827.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;3、url.resolve()&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608773020569.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&#34;四-nodejs-自启动工具-supervisor&#34;&gt;四、Nodejs 自启动工具 supervisor&lt;/h1&gt;
&lt;p&gt;supervisor 会不停的 watch 你应用下面的所有文件，发现有文件被修改，就重新载入程序文件这样就实现了部署，修 改了程序文件后马上就能看到变更后的结果。麻麻再也不用担心我的重启 nodejs 了！&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先安装 supervisor&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g supervisor
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 supervisor 代替 node 命令启动应用&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608773581099.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
">NodeJs从零单排(1)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/ecmascript-6-11/"" data-c="
          &lt;h1 id=&#34;第-1-章-ecmasript-相关介绍&#34;&gt;第 1 章 ECMASript 相关介绍&lt;/h1&gt;
&lt;h2 id=&#34;11什么是-ecma&#34;&gt;1.1.什么是 ECMA&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1607764166027.png&#34; alt=&#34;ECMA&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;ECMA（European Computer Manufacturers Association）中文名称为欧洲计算机制造商协会，这个组织的目标是评估、开发和认可电信和计算机标准。1994 年后该组织改名为 Ecma 国际。&lt;/p&gt;
&lt;h2 id=&#34;12什么是-ecmascript&#34;&gt;1.2.什么是 ECMAScript&lt;/h2&gt;
&lt;p&gt;ECMAScript 是由 Ecma 国际通过 ECMA-262 标准化的脚本程序设计语言。&lt;/p&gt;
&lt;h2 id=&#34;13什么是-ecma-262&#34;&gt;1.3.什么是 ECMA-262&lt;/h2&gt;
&lt;p&gt;Ecma 国际制定了许多标准，而 ECMA-262 只是其中的一个，所有标准列表查看&lt;br&gt;
&lt;a href=&#34;http://www.ecma-international.org/publications/standards/Standard.htm&#34;&gt;http://www.ecma-international.org/publications/standards/Standard.htm&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;14ecma-262-历史&#34;&gt;1.4.ECMA-262 历史&lt;/h2&gt;
&lt;p&gt;ECMA-262（ECMAScript）历史版本查看网址&lt;br&gt;
&lt;a href=&#34;http://www.ecma-international.org/publications/standards/Ecma-262-arch.htm&#34;&gt;http://www.ecma-international.org/publications/standards/Ecma-262-arch.htm&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1607764588998.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;div style=&#34;color:red&#34;&gt; 注：从 ES6 开始，每年发布一个版本，版本号比年份最后一位大 1&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;15谁在维护-ecma-262&#34;&gt;1.5.谁在维护 ECMA-262&lt;/h2&gt;
&lt;p&gt;TC39（Technical Committee 39）是推进 ECMAScript 发展的委员会。其会员都是公司（其中主要是浏览器厂商，有苹果、谷歌、微软、因特尔等）。TC39 定期召开会议，会议由会员公司的代表与特邀专家出席。&lt;/p&gt;
&lt;h2 id=&#34;16为什么要学习-es6&#34;&gt;1.6.为什么要学习 ES6&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ES6 的版本变动内容最多，具有里程碑意义&lt;/li&gt;
&lt;li&gt;ES6 加入许多新的语法特性，编程实现更简单、高效&lt;/li&gt;
&lt;li&gt;ES6 是前端发展趋势，就业必备技能&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;17es6-兼容性&#34;&gt;1.7.ES6 兼容性&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://kangax.github.io/compat-table/es6/&#34;&gt;可查看兼容性&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;第-2-章-ecmasript-6-新特性&#34;&gt;第 2 章 ECMASript 6 新特性&lt;/h1&gt;
&lt;h2 id=&#34;21let-关键字&#34;&gt;2.1.let 关键字&lt;/h2&gt;
&lt;p&gt;let 关键字用来声明变量，使用 let 声明的变量有几个特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不允许重复声明&lt;/li&gt;
&lt;li&gt;块儿级作用域&lt;/li&gt;
&lt;li&gt;不存在变量提升&lt;/li&gt;
&lt;li&gt;不影响作用域链&lt;/li&gt;
&lt;/ol&gt;
&lt;div style=&#34;color:red&#34;&gt; 应用场景：以后声明变量使用 let 就对了&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;22-const-关键字&#34;&gt;2.2. const 关键字&lt;/h2&gt;
&lt;p&gt;const 关键字用来声明常量，const 声明有以下特点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;声明必须赋初始值&lt;/li&gt;
&lt;li&gt;标识符一般为大写&lt;/li&gt;
&lt;li&gt;不允许重复声明&lt;/li&gt;
&lt;li&gt;值不允许修改&lt;/li&gt;
&lt;li&gt;块儿级作用域&lt;/li&gt;
&lt;/ol&gt;
&lt;div style=&#34;color:red&#34;&gt; 注意: 对象属性修改和数组元素变化不会出发 const 错误&lt;/div&gt;
&lt;div style=&#34;color:red&#34;&gt; 应用场景：声明对象类型使用 const，非对象类型声明选择 let&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;23变量的解构赋值&#34;&gt;2.3.变量的解构赋值&lt;/h2&gt;
&lt;p&gt;ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//数组的解构赋值
const arr = [&#39;张学友&#39;, &#39;刘德华&#39;, &#39;黎明&#39;, &#39;郭富城&#39;];
let [zhang, liu, li, guo] = arr;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;//对象的解构赋值
const lin = {
 name: &#39;林志颖&#39;,
 tags: [&#39;车手&#39;, &#39;歌手&#39;, &#39;小旋风&#39;, &#39;演员&#39;]
};
let {name, tags} = lin;
//复杂解构
let wangfei = {
 name: &#39;王菲&#39;,
 age: 18,
 songs: [&#39;红豆&#39;, &#39;流年&#39;, &#39;暧昧&#39;, &#39;传奇&#39;],
 history: [
 {name: &#39;窦唯&#39;},
 {name: &#39;李亚鹏&#39;},
 {name: &#39;谢霆锋&#39;}
 ]
};
let {songs: [one, two, three], history: [first, second, third]} = 
wangfei;
&lt;/code&gt;&lt;/pre&gt;
&lt;div style=&#34;color:red&#34;&gt;注意：频繁使用对象方法、数组元素，就可以使用解构赋值形式&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;24模板字符串&#34;&gt;2.4.模板字符串&lt;/h2&gt;
&lt;p&gt;模板字符串（template string）是增强版的字符串，用反引号（`）标识，特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;字符串中可以出现换行符&lt;/li&gt;
&lt;li&gt;可以使用 ${xxx} 形式输出变量&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;// 定义字符串
let str = `&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;沈腾&amp;lt;/li&amp;gt;
 &amp;lt;li&amp;gt;玛丽&amp;lt;/li&amp;gt;
 &amp;lt;li&amp;gt;魏翔&amp;lt;/li&amp;gt;
 &amp;lt;li&amp;gt;艾伦&amp;lt;/li&amp;gt;
 &amp;lt;/ul&amp;gt;`;
// 变量拼接
let star = &#39;王宁&#39;;
let result = `${star}在前几年离开了开心麻花`;
&lt;/code&gt;&lt;/pre&gt;
&lt;div style=&#34;color:red&#34;&gt;注意：当遇到字符串与变量拼接的情况使用模板字符串&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;25简化对象写法&#34;&gt;2.5.简化对象写法&lt;/h2&gt;
&lt;p&gt;ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let name = &#39;尚硅谷&#39;;
let slogon = &#39;永远追求行业更高标准&#39;;
let improve = function () {
 console.log(&#39;可以提高你的技能&#39;);
}
//属性和方法简写
let atguigu = {
 name,
 slogon,
 improve,
 change() {
 console.log(&#39;可以改变你&#39;)
 }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;div style=&#34;color:red&#34;&gt;注意：对象简写形式简化了代码，所以以后用简写就对了&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;26箭头函数&#34;&gt;2.6.箭头函数&lt;/h2&gt;
&lt;p&gt;ES6 允许使用「箭头」（=&amp;gt;）定义函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
* 1. 通用写法
*/
let fn = (arg1, arg2, arg3) =&amp;gt; {
 return arg1 + arg2 + arg3;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;箭头函数的注意点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果形参只有一个，则小括号可以省略&lt;/li&gt;
&lt;li&gt;函数体如果只有一条语句，则花括号可以省略，函数的返回值为该条语句的&lt;br&gt;
执行结果&lt;/li&gt;
&lt;li&gt;箭头函数 this 指向声明时所在作用域下 this 的值&lt;/li&gt;
&lt;li&gt;箭头函数不能作为构造函数实例化&lt;/li&gt;
&lt;li&gt;不能使用 arguments&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;/**
* 2. 省略小括号的情况
*/
let fn2 = num =&amp;gt; {
 return num * 10;
};
/**
* 3. 省略花括号的情况
*/
let fn3 = score =&amp;gt; score * 20;
/**
* 4. this 指向声明时所在作用域中 this 的值
*/
let fn4 = () =&amp;gt; {
 console.log(this);
}
let school = {
 name: &#39;尚硅谷&#39;,
 getName(){
 let fn5 = () =&amp;gt; {
 console.log(this);
 }
 fn5();
 }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;div style=&#34;color:red&#34;&gt;注意：箭头函数不会更改 this 指向，用来指定回调函数会非常合适&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;27-rest-参数&#34;&gt;2.7. rest 参数&lt;/h2&gt;
&lt;p&gt;ES6 引入 rest 参数，用于获取函数的实参，用来代替 arguments&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
* 作用与 arguments 类似
*/
function add(...args){
 console.log(args);
}
add(1,2,3,4,5);
/**
* rest 参数必须是最后一个形参
*/
function minus(a,b,...args){
 console.log(a,b,args);
}
minus(100,1,2,3,4,5,19);
&lt;/code&gt;&lt;/pre&gt;
&lt;div style=&#34;color:red&#34;&gt;注意：rest 参数非常适合不定个数参数函数的场景&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;28-spread-扩展运算符&#34;&gt;2.8. spread 扩展运算符&lt;/h2&gt;
&lt;p&gt;扩展运算符（spread）也是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列，对数组进行解包。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
* 展开数组
*/ 
let tfboys = [&#39;德玛西亚之力&#39;,&#39;德玛西亚之翼&#39;,&#39;德玛西亚皇子&#39;];
function fn(){
 console.log(arguments);
}
fn(...tfboys)
/**
* 展开对象
*/
let skillOne = {
 q: &#39;致命打击&#39;,
};
let skillTwo = {
 w: &#39;勇气&#39;
};
let skillThree = {
 e: &#39;审判&#39;
};
let skillFour = {
 r: &#39;德玛西亚正义&#39;
};
let gailun = {...skillOne, ...skillTwo,...skillThree,...skillFour};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;29symbol&#34;&gt;2.9.Symbol&lt;/h2&gt;
&lt;h3 id=&#34;291symbol-基本使用&#34;&gt;2.9.1.Symbol 基本使用&lt;/h3&gt;
&lt;p&gt;ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是JavaScript 语言的第七种数据类型，是一种类似于字符串的数据类型。&lt;/p&gt;
&lt;p&gt;Symbol 特点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Symbol 的值是唯一的，用来解决命名冲突的问题&lt;/li&gt;
&lt;li&gt;Symbol 值不能与其他数据进行运算&lt;/li&gt;
&lt;li&gt;Symbol 定义 的 对象属 性 不能 使 用 for…in 循 环遍 历 ，但 是可 以 使 用&lt;br&gt;
Reflect.ownKeys 来获取对象的所有键名&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;//创建 Symbol
let s1 = Symbol();
console.log(s1, typeof s1);
//添加标识的 Symbol
let s2 = Symbol(&#39;尚硅谷&#39;);
let s2_2 = Symbol(&#39;尚硅谷&#39;);
console.log(s2 === s2_2);
//使用 Symbol for 定义
let s3 = Symbol.for(&#39;尚硅谷&#39;);
let s3_2 = Symbol.for(&#39;尚硅谷&#39;);
console.log(s3 === s3_2);
&lt;/code&gt;&lt;/pre&gt;
&lt;div style=&#34;color:red&#34;&gt;注: 遇到唯一性的场景时要想到 Symbol&lt;/div&gt;
&lt;br&gt;
&lt;h3 id=&#34;292symbol-内置值&#34;&gt;2.9.2.Symbol 内置值&lt;/h3&gt;
&lt;p&gt;除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。可以称这些方法为魔术方法，因为它们会在特定的场景下自动执行。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1607828563219.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;210-迭代器&#34;&gt;2.10. 迭代器&lt;/h2&gt;
&lt;p&gt;遍历器（Iterator）就是一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ES6 创造了一种新的遍历命令 for...of 循环，Iterator 接口主要供 for...of 消费&lt;/li&gt;
&lt;li&gt;原生具备 iterator 接口的数据(可用 for of 遍历)&lt;br&gt;
a) Array&lt;br&gt;
b) Arguments&lt;br&gt;
c) Set&lt;br&gt;
d) Map&lt;br&gt;
e) String&lt;br&gt;
f) TypedArray&lt;br&gt;
g) NodeList&lt;/li&gt;
&lt;li&gt;工作原理&lt;br&gt;
a) 创建一个指针对象，指向当前数据结构的起始位置&lt;br&gt;
b) 第一次调用对象的 next 方法，指针自动指向数据结构的第一个成员&lt;br&gt;
c) 接下来不断调用 next 方法，指针一直往后移动，直到指向最后一个成员&lt;br&gt;
d) 每调用 next 方法返回一个包含 value 和 done 属性的对象&lt;/li&gt;
&lt;/ol&gt;
&lt;div style=&#34;color:red&#34;&gt;注: 需要自定义遍历数据的时候，要想到迭代器。&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;211-生成器&#34;&gt;2.11. 生成器&lt;/h2&gt;
&lt;p&gt;生成器函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function * gen(){
 yield &#39;一只没有耳朵&#39;;
 yield &#39;一只没有尾巴&#39;;
 return &#39;真奇怪&#39;; }
let iterator = gen();
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;* 的位置没有限制&lt;/li&gt;
&lt;li&gt;生成器函数返回的结果是迭代器对象，调用迭代器对象的 next 方法可以得到yield 语句后的值&lt;/li&gt;
&lt;li&gt;yield 相当于函数的暂停标记，也可以认为是函数的分隔符，每调用一次 next方法，执行一段代码&lt;/li&gt;
&lt;li&gt;next 方法可以传递实参，作为 yield 语句的返回值&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;212-promise&#34;&gt;2.12. Promise&lt;/h2&gt;
&lt;p&gt;Promise 是 ES6 引入的异步编程的新解决方案。语法上 Promise 是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Promise 构造函数: Promise (excutor) {}&lt;/li&gt;
&lt;li&gt;Promise.prototype.then 方法&lt;/li&gt;
&lt;li&gt;Promise.prototype.catch 方法&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;213-set&#34;&gt;2.13. Set&lt;/h2&gt;
&lt;p&gt;ES6 提供了新的数据结构 Set（集合）。它类似于数组，但成员的值都是唯一的，集合实现了 iterator 接口，所以可以使用『扩展运算符』和『for…of…』进行遍历，集合的属性和方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;size 返回集合的元素个数&lt;/li&gt;
&lt;li&gt;add 增加一个新元素，返回当前集合&lt;/li&gt;
&lt;li&gt;delete 删除元素，返回 boolean 值&lt;/li&gt;
&lt;li&gt;has 检测集合中是否包含某个元素，返回 boolean 值&lt;/li&gt;
&lt;li&gt;clear 清空集合，返回 undefined&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;//创建一个空集合
let s = new Set();
//创建一个非空集合
let s1 = new Set([1,2,3,1,2,3]);
//集合属性与方法
//返回集合的元素个数
console.log(s1.size);
//添加新元素
console.log(s1.add(4));
//删除元素
console.log(s1.delete(1));
//检测是否存在某个值
console.log(s1.has(2));
//清空集合
console.log(s1.clear());
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;214-map&#34;&gt;2.14. Map&lt;/h2&gt;
&lt;p&gt;ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合。但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map 也实现了iterator 接口，所以可以使用『扩展运算符』和『for…of…』进行遍历。Map 的属性和方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;size 返回 Map 的元素个数&lt;/li&gt;
&lt;li&gt;set 增加一个新元素，返回当前 Map&lt;/li&gt;
&lt;li&gt;get 返回键名对象的键值&lt;/li&gt;
&lt;li&gt;has 检测 Map 中是否包含某个元素，返回 boolean 值&lt;/li&gt;
&lt;li&gt;clear 清空集合，返回 undefined&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;//创建一个空 map
let m = new Map();
//创建一个非空 map
let m2 = new Map([
 [&#39;name&#39;,&#39;尚硅谷&#39;],
 [&#39;slogon&#39;,&#39;不断提高行业标准&#39;]
]);
//属性和方法
//获取映射元素的个数
console.log(m2.size);
//添加映射值
console.log(m2.set(&#39;age&#39;, 6));
//获取映射值
console.log(m2.get(&#39;age&#39;));
//检测是否有该映射
console.log(m2.has(&#39;age&#39;));
//清除
console.log(m2.clear());
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;215-class-类&#34;&gt;2.15. class 类&lt;/h2&gt;
&lt;p&gt;ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过 class 关键字，可以定义类。基本上，ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。&lt;br&gt;
知识点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;class 声明类&lt;/li&gt;
&lt;li&gt;constructor 定义构造函数初始化&lt;/li&gt;
&lt;li&gt;extends 继承父类&lt;/li&gt;
&lt;li&gt;super 调用父级构造方法&lt;/li&gt;
&lt;li&gt;static 定义静态方法和属性&lt;/li&gt;
&lt;li&gt;父类方法可以重写&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;//父类
class Phone {
 //构造方法
 constructor(brand, color, price) {
 this.brand = brand;
 this.color = color;
 this.price = price;
 }
 //对象方法
 call() {
     console.log(&#39;我可以打电话!!!&#39;)
 } }
//子类
class SmartPhone extends Phone {
 constructor(brand, color, price, screen, pixel) {
 super(brand, color, price);
 this.screen = screen;
 this.pixel = pixel;
 }
 //子类方法
 photo(){
 console.log(&#39;我可以拍照!!&#39;);
 }
 playGame(){
 console.log(&#39;我可以玩游戏!!&#39;);
 }
 //方法重写
 call(){
 console.log(&#39;我可以进行视频通话!!&#39;);
 }
 //静态方法
 static run(){
 console.log(&#39;我可以运行程序&#39;)
 }
 static connect(){
 console.log(&#39;我可以建立连接&#39;)
 } }
 //实例化对象
const Nokia = new Phone(&#39;诺基亚&#39;, &#39;灰色&#39;, 230);
const iPhone6s = new SmartPhone(&#39;苹果&#39;, &#39;白色&#39;, 6088, 
&#39;4.7inch&#39;,&#39;500w&#39;);
//调用子类方法
iPhone6s.playGame();
//调用重写方法
iPhone6s.call();
//调用静态方法
SmartPhone.run();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;216-数值扩展&#34;&gt;2.16. 数值扩展&lt;/h2&gt;
&lt;h3 id=&#34;2161-二进制和八进制&#34;&gt;2.16.1. 二进制和八进制&lt;/h3&gt;
&lt;p&gt;ES6 提供了二进制和八进制数值的新的写法，分别用前缀 0b 和 0o 表示。&lt;/p&gt;
&lt;h3 id=&#34;2162-numberisfinite-与-numberisnan&#34;&gt;2.16.2. Number.isFinite() 与 Number.isNaN()&lt;/h3&gt;
&lt;p&gt;Number.isFinite() 用来检查一个数值是否为有限的&lt;br&gt;
Number.isNaN() 用来检查一个值是否为 NaN&lt;/p&gt;
&lt;h3 id=&#34;2163-numberparseint-与-numberparsefloat&#34;&gt;2.16.3. Number.parseInt() 与 Number.parseFloat()&lt;/h3&gt;
&lt;p&gt;ES6 将全局方法 parseInt 和 parseFloat，移植到 Number 对象上面，使用不变。&lt;/p&gt;
&lt;h3 id=&#34;2164-mathtrunc&#34;&gt;2.16.4. Math.trunc&lt;/h3&gt;
&lt;p&gt;用于去除一个数的小数部分，返回整数部分。&lt;/p&gt;
&lt;h3 id=&#34;2165-numberisinteger&#34;&gt;2.16.5. Number.isInteger&lt;/h3&gt;
&lt;p&gt;Number.isInteger() 用来判断一个数值是否为整数&lt;/p&gt;
&lt;h2 id=&#34;217-对象扩展&#34;&gt;2.17. 对象扩展&lt;/h2&gt;
&lt;p&gt;ES6 新增了一些 Object 对象的方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Object.is 比较两个值是否严格相等，与『===』行为基本一致（+0 与 NaN）&lt;/li&gt;
&lt;li&gt;Object.assign 对象的合并，将源对象的所有可枚举属性，复制到目标对象&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;proto&lt;/strong&gt;、setPrototypeOf、 setPrototypeOf 可以直接设置对象的原型&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;218-模块化&#34;&gt;2.18. 模块化&lt;/h2&gt;
&lt;p&gt;模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来。&lt;/p&gt;
&lt;h3 id=&#34;2181-模块化的好处&#34;&gt;2.18.1. 模块化的好处&lt;/h3&gt;
&lt;p&gt;模块化的优势有以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;防止命名冲突&lt;/li&gt;
&lt;li&gt;代码复用&lt;/li&gt;
&lt;li&gt;高维护性&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2182-模块化规范产品&#34;&gt;2.18.2. 模块化规范产品&lt;/h3&gt;
&lt;p&gt;ES6 之前的模块化规范有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CommonJS =&amp;gt; NodeJS、Browserify&lt;/li&gt;
&lt;li&gt;AMD =&amp;gt; requireJS&lt;/li&gt;
&lt;li&gt;CMD =&amp;gt; seaJS&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2183-es6-模块化语法&#34;&gt;2.18.3. ES6 模块化语法&lt;/h3&gt;
&lt;p&gt;模块功能主要由两个命令构成：export 和 import。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;export 命令用于规定模块的对外接口&lt;/li&gt;
&lt;li&gt;import 命令用于输入其他模块提供的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;第-3-章-ecmasript-7-新特性&#34;&gt;第 3 章 ECMASript 7 新特性&lt;/h1&gt;
&lt;h2 id=&#34;31arrayprototypeincludes&#34;&gt;3.1.Array.prototype.includes&lt;/h2&gt;
&lt;p&gt;Includes 方法用来检测数组中是否包含某个元素，返回布尔类型值&lt;/p&gt;
&lt;h2 id=&#34;32指数操作符&#34;&gt;3.2.指数操作符&lt;/h2&gt;
&lt;p&gt;在 ES7 中引入指数运算符「**」，用来实现幂运算，功能与 Math.pow 结果相同&lt;/p&gt;
&lt;h1 id=&#34;第-4-章-ecmasript-8-新特性&#34;&gt;第 4 章 ECMASript 8 新特性&lt;/h1&gt;
&lt;h2 id=&#34;41async-和-await&#34;&gt;4.1.async 和 await&lt;/h2&gt;
&lt;p&gt;async 和 await 两种语法结合可以让异步代码像同步代码一样&lt;/p&gt;
&lt;h3 id=&#34;411async-函数&#34;&gt;4.1.1.async 函数&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;async 函数的返回值为 promise 对象，&lt;/li&gt;
&lt;li&gt;promise 对象的结果由 async 函数执行的返回值决定&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;412await-表达式&#34;&gt;4.1.2.await 表达式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;await 必须写在 async 函数中&lt;/li&gt;
&lt;li&gt;await 右侧的表达式一般为 promise 对象&lt;/li&gt;
&lt;li&gt;await 返回的是 promise 成功的值&lt;/li&gt;
&lt;li&gt;await 的 promise 失败了, 就会抛出异常, 需要通过 try...catch 捕获处理&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;42objectvalues-和-objectentries&#34;&gt;4.2.Object.values 和 Object.entries&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Object.values()方法返回一个给定对象的所有可枚举属性值的数组&lt;/li&gt;
&lt;li&gt;Object.entries()方法返回一个给定对象自身可遍历属性 [key,value] 的数组&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;43objectgetownpropertydescriptors&#34;&gt;4.3.Object.getOwnPropertyDescriptors&lt;/h2&gt;
&lt;p&gt;该方法返回指定对象所有自身属性的描述对象&lt;/p&gt;
&lt;h1 id=&#34;第-5-章-ecmasript-9-新特性&#34;&gt;第 5 章 ECMASript 9 新特性&lt;/h1&gt;
&lt;h2 id=&#34;51restspread-属性&#34;&gt;5.1.Rest/Spread 属性&lt;/h2&gt;
&lt;p&gt;Rest 参数与 spread 扩展运算符在 ES6 中已经引入，不过 ES6 中只针对于数组，在 ES9 中为对象提供了像数组一样的 rest 参数和扩展运算符。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function connect({host, port, ...user}) {
 console.log(host);
 console.log(port);
 console.log(user);
}
connect({
 host: &#39;127.0.0.1&#39;,
 port: 3306,
 username: &#39;root&#39;,
 password: &#39;root&#39;,
 type: &#39;master&#39;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;52正则表达式命名捕获组&#34;&gt;5.2.正则表达式命名捕获组&lt;/h2&gt;
&lt;p&gt;ES9 允许命名捕获组使用符号『?&lt;name&gt;』,这样获取捕获结果可读性更强&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let str = &#39;&amp;lt;a href=&amp;quot;http://www.atguigu.com&amp;quot;&amp;gt;尚硅谷&amp;lt;/a&amp;gt;&#39;;
const reg = /&amp;lt;a href=&amp;quot;(?&amp;lt;url&amp;gt;.*)&amp;quot;&amp;gt;(?&amp;lt;text&amp;gt;.*)&amp;lt;\/a&amp;gt;/;
const result = reg.exec(str);
console.log(result.groups.url);
console.log(result.groups.text);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;53正则表达式反向断言&#34;&gt;5.3.正则表达式反向断言&lt;/h2&gt;
&lt;p&gt;ES9 支持反向断言，通过对匹配结果前面的内容进行判断，对匹配进行筛选。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//声明字符串
let str = &#39;JS5211314 你知道么 555 啦啦啦&#39;;
//正向断言
const reg = /\d+(?=啦)/;
const result = reg.exec(str);
//反向断言
const reg = /(?&amp;lt;=么)\d+/;
const result = reg.exec(str);
console.log(result);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;54正则表达式-dotall-模式&#34;&gt;5.4.正则表达式 dotAll 模式&lt;/h2&gt;
&lt;p&gt;正则表达式中点.匹配除回车外的任何单字符，标记『s』改变这种行为，允许行终止符出现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let str = `
&amp;lt;ul&amp;gt;
 &amp;lt;li&amp;gt;
 &amp;lt;a&amp;gt;肖生克的救赎&amp;lt;/a&amp;gt;
 &amp;lt;p&amp;gt;上映日期: 1994-09-10&amp;lt;/p&amp;gt;
 &amp;lt;/li&amp;gt;
 &amp;lt;li&amp;gt;
 &amp;lt;a&amp;gt;阿甘正传&amp;lt;/a&amp;gt;
 &amp;lt;p&amp;gt;上映日期: 1994-07-06&amp;lt;/p&amp;gt;
 &amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;`;
//声明正则
const reg = /&amp;lt;li&amp;gt;.*?&amp;lt;a&amp;gt;(.*?)&amp;lt;\/a&amp;gt;.*?&amp;lt;p&amp;gt;(.*?)&amp;lt;\/p&amp;gt;/gs;
//执行匹配
const result = reg.exec(str);
let result;
let data = [];
while(result = reg.exec(str)){
 data.push({title: result[1], time: result[2]});
}
//输出结果
console.log(data);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第-6-章-ecmasript-10-新特性&#34;&gt;第 6 章 ECMASript 10 新特性&lt;/h1&gt;
&lt;h2 id=&#34;61objectfromentries&#34;&gt;6.1.Object.fromEntries&lt;/h2&gt;
&lt;h2 id=&#34;62trimstart-和-trimend&#34;&gt;6.2.trimStart 和 trimEnd&lt;/h2&gt;
&lt;h2 id=&#34;63arrayprototypeflat-与-flatmap&#34;&gt;6.3.Array.prototype.flat 与 flatMap&lt;/h2&gt;
&lt;h2 id=&#34;64symbolprototypedescription&#34;&gt;6.4.Symbol.prototype.description&lt;/h2&gt;
&lt;h1 id=&#34;第-7-章-ecmasript-11-新特性&#34;&gt;第 7 章 ECMASript 11 新特性&lt;/h1&gt;
&lt;h2 id=&#34;71stringprototypematchall&#34;&gt;7.1.String.prototype.matchAll&lt;/h2&gt;
&lt;h2 id=&#34;72类的私有属性&#34;&gt;7.2.类的私有属性&lt;/h2&gt;
&lt;h2 id=&#34;73promiseallsettled&#34;&gt;7.3.Promise.allSettled&lt;/h2&gt;
&lt;h2 id=&#34;74可选链操作符&#34;&gt;7.4.可选链操作符&lt;/h2&gt;
&lt;h2 id=&#34;75动态-import-导入&#34;&gt;7.5.动态 import 导入&lt;/h2&gt;
&lt;h2 id=&#34;76globalthis-对象&#34;&gt;7.6.globalThis 对象&lt;/h2&gt;
&lt;p&gt;鸣谢：源自&lt;a href=&#34;https://www.bilibili.com/video/BV1uK411H7on&#34;&gt;视频教程-尚硅谷&lt;/a&gt;&lt;/p&gt;
">ECMAScript 6-11</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/ce-shi/"" data-c="
          &lt;h2 id=&#34;1element-ui-引言&#34;&gt;1.Element UI 引言&lt;/h2&gt;
&lt;p&gt;官网: &lt;a href=&#34;https://element.eleme.cn/#/zh-CN&#34;&gt;Element，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;11-官方定义&#34;&gt;1.1 官方定义&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;网站快速成型工具&lt;/code&gt; 和 &lt;code&gt;桌面端组件库&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;12-定义&#34;&gt;1.2 定义&lt;/h3&gt;
&lt;p&gt;element ui 就是基于vue的一个ui框架,该框架基于vue开发了很多相关组件,方便我们快速开发页面。&lt;/p&gt;
&lt;h3 id=&#34;13-由来&#34;&gt;1.3 由来&lt;/h3&gt;
&lt;p&gt;饿了么前端团队 基于vue进行开发并且进行了开源  element ui 中提供全部都是封装好组件。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2安装element-ui&#34;&gt;2.安装Element UI&lt;/h2&gt;
&lt;h3 id=&#34;21通过vue脚手架创建项目&#34;&gt;2.1通过vue脚手架创建项目&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;vue init webpack element(项目名)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;22在vue脚手架项目中安装elementui&#34;&gt;2.2在vue脚手架项目中安装elementui&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# 1.下载elementui的依赖
	npm i element-ui -S

# 2.指定当前项目中使用elementui
	import ElementUI from &#39;element-ui&#39;;
	import &#39;element-ui/lib/theme-chalk/index.css&#39;;

  //在vue脚手架中使用elementui
	Vue.use(ElementUI);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;3按钮组件示例&#34;&gt;3.按钮组件(示例)&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606975701437.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;31-默认样式按钮&#34;&gt;3.1 默认样式按钮&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-row&amp;gt;
  &amp;lt;el-button&amp;gt;默认按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;primary&amp;quot;&amp;gt;主要按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;success&amp;quot;&amp;gt;成功按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;info&amp;quot;&amp;gt;信息按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;warning&amp;quot;&amp;gt;警告按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;danger&amp;quot;&amp;gt;危险按钮&amp;lt;/el-button&amp;gt;
&amp;lt;/el-row&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;32-简洁按钮&#34;&gt;3.2 简洁按钮&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-row&amp;gt;
  &amp;lt;el-button plain&amp;gt;朴素按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;primary&amp;quot; plain&amp;gt;主要按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;success&amp;quot; plain&amp;gt;成功按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;info&amp;quot; plain&amp;gt;信息按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;warning&amp;quot; plain&amp;gt;警告按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;danger&amp;quot; plain&amp;gt;危险按钮&amp;lt;/el-button&amp;gt;
&amp;lt;/el-row&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;33-圆角按钮&#34;&gt;3.3 圆角按钮&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-row&amp;gt;
  &amp;lt;el-button round&amp;gt;圆角按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;primary&amp;quot; round&amp;gt;主要按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;success&amp;quot; round&amp;gt;成功按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;info&amp;quot; round&amp;gt;信息按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;warning&amp;quot; round&amp;gt;警告按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;danger&amp;quot; round&amp;gt;危险按钮&amp;lt;/el-button&amp;gt;
&amp;lt;/el-row&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;34-图标按钮&#34;&gt;3.4 图标按钮&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-row&amp;gt;
  &amp;lt;el-button icon=&amp;quot;el-icon-search&amp;quot; circle&amp;gt;&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;primary&amp;quot; icon=&amp;quot;el-icon-edit&amp;quot; circle&amp;gt;&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;success&amp;quot; icon=&amp;quot;el-icon-check&amp;quot; circle&amp;gt;&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;info&amp;quot; icon=&amp;quot;el-icon-message&amp;quot; circle&amp;gt;&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;warning&amp;quot; icon=&amp;quot;el-icon-star-off&amp;quot; circle&amp;gt;&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;danger&amp;quot; icon=&amp;quot;el-icon-delete&amp;quot; circle&amp;gt;&amp;lt;/el-button&amp;gt;
&amp;lt;/el-row&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;4按钮组件的详细使用&#34;&gt;4.按钮组件的详细使用&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;总结:日后使用element ui的相关组件时需要注意的是 所有组件都是el-组件名称开头&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;41创建按钮&#34;&gt;4.1创建按钮&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-button&amp;gt;默认按钮&amp;lt;/el-button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;42-按钮属性使用&#34;&gt;4.2 按钮属性使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-button type=&amp;quot;primary&amp;quot; 属性名=属性值&amp;gt;默认按钮&amp;lt;/el-button&amp;gt;
&amp;lt;el-button type=&amp;quot;success&amp;quot; size=&amp;quot;medium&amp;quot; plain=true round circle icon=&amp;quot;el-icon-loading&amp;quot;&amp;gt;&amp;lt;/el-button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;总结:在elementui中所有组件的属性全部写在组件标签上&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;43-按钮组使用&#34;&gt;4.3 按钮组使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-button-group&amp;gt;
  &amp;lt;el-button type=&amp;quot;primary&amp;quot; icon=&amp;quot;el-icon-back&amp;quot;&amp;gt;上一页&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;primary&amp;quot; icon=&amp;quot;el-icon-right&amp;quot;&amp;gt;下一页&amp;lt;/el-button&amp;gt;
&amp;lt;/el-button-group&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在element ui中所有组件都是 &lt;code&gt;el-组件名称&lt;/code&gt; 方式进行命名&lt;/li&gt;
&lt;li&gt;在element ui中组件的属性使用&lt;code&gt;都是直接将属性名=属性值方式写在对应的组件标签上&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;5link-文字链接组件&#34;&gt;5.Link 文字链接组件&lt;/h2&gt;
&lt;h3 id=&#34;51-文字链接组件的创建&#34;&gt;5.1 文字链接组件的创建&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-link&amp;gt;默认链接&amp;lt;/el-link&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;52-文字链接组件的属性的使用&#34;&gt;5.2 文字链接组件的属性的使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-link  target=&amp;quot;_blank&amp;quot; href=&amp;quot;http://www.baidu.com&amp;quot; &amp;gt;默认链接&amp;lt;/el-link&amp;gt;
&amp;lt;el-link type=&amp;quot;primary&amp;quot;:underline=&amp;quot;false&amp;quot;&amp;gt;默认链接&amp;lt;/el-link&amp;gt;
&amp;lt;el-link type=&amp;quot;success&amp;quot; disabled&amp;gt;默认链接&amp;lt;/el-link&amp;gt;
&amp;lt;el-link type=&amp;quot;info&amp;quot; icon=&amp;quot;el-icon-platform-eleme&amp;quot;&amp;gt;默认链接&amp;lt;/el-link&amp;gt;
&amp;lt;el-link type=&amp;quot;warning&amp;quot;&amp;gt;默认链接&amp;lt;/el-link&amp;gt;
&amp;lt;el-link type=&amp;quot;danger&amp;quot;&amp;gt;默认链接&amp;lt;/el-link&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;6layout-栅格布局组件的使用&#34;&gt;6.Layout (栅格)布局组件的使用&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;通过基础的 24 分栏，迅速简便地创建布局&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;在element ui中布局组件将页面划分为多个行row,每行最多分为24栏(列)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;61-使用layout组件&#34;&gt;6.1 使用Layout组件&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-row&amp;gt;
	&amp;lt;el-col :span=&amp;quot;8&amp;quot;&amp;gt;占用8份&amp;lt;/el-col&amp;gt;
  &amp;lt;el-col :span=&amp;quot;8&amp;quot;&amp;gt;占用8份&amp;lt;/el-col&amp;gt;
  &amp;lt;el-col :span=&amp;quot;8&amp;quot;&amp;gt;占用8份&amp;lt;/el-col&amp;gt;
&amp;lt;/el-row&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在一个布局组件中 是由 &lt;code&gt;row&lt;/code&gt; 和 &lt;code&gt;col&lt;/code&gt; 组合而成&lt;/li&gt;
&lt;li&gt;在使用时要区分 &lt;code&gt;row属性&lt;/code&gt; 和 &lt;code&gt;col属性&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;62-属性的使用&#34;&gt;6.2 属性的使用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;行属性使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-row :gutter=&amp;quot;50&amp;quot; tag=&amp;quot;span&amp;quot;&amp;gt;
  &amp;lt;el-col :span=&amp;quot;4&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;border: 1px red solid;&amp;quot;&amp;gt;占用4份&amp;lt;/div&amp;gt;&amp;lt;/el-col&amp;gt;
  &amp;lt;el-col :span=&amp;quot;8&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;border: 1px red solid;&amp;quot;&amp;gt;占用8份&amp;lt;/div&amp;gt;&amp;lt;/el-col&amp;gt;
  &amp;lt;el-col :span=&amp;quot;3&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;border: 1px red solid;&amp;quot;&amp;gt;占用3份&amp;lt;/div&amp;gt;&amp;lt;/el-col&amp;gt;
  &amp;lt;el-col :span=&amp;quot;9&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;border: 1px red solid;&amp;quot;&amp;gt;占用9份&amp;lt;/div&amp;gt;&amp;lt;/el-col&amp;gt;
&amp;lt;/el-row&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列属性的使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-row&amp;gt;
  &amp;lt;el-col :span=&amp;quot;12&amp;quot; :offset=&amp;quot;9&amp;quot; :psuh=&amp;quot;3&amp;quot; xs&amp;gt;&amp;lt;div style=&amp;quot;border: 1px blue solid;&amp;quot;&amp;gt;我是占用12分&amp;lt;/div&amp;gt;&amp;lt;/el-col&amp;gt;
  &amp;lt;el-col :span=&amp;quot;6&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;border: 1px blue solid;&amp;quot;&amp;gt;我是占用6分&amp;lt;/div&amp;gt;&amp;lt;/el-col&amp;gt;
&amp;lt;/el-row&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;7container-布局容器组件&#34;&gt;7.Container 布局容器组件&lt;/h2&gt;
&lt;h3 id=&#34;71-创建布局容器&#34;&gt;7.1 创建布局容器&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-container&amp;gt;
	
&amp;lt;/el-container&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;72-容器中包含的子元素&#34;&gt;7.2 容器中包含的子元素&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-header&amp;gt;：顶栏容器。
&amp;lt;el-aside&amp;gt;：侧边栏容器。
&amp;lt;el-main&amp;gt;：主要区域容器。
&amp;lt;el-footer&amp;gt;：底栏容器。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;73-容器的嵌套使用&#34;&gt;7.3 容器的嵌套使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!--创建容器--&amp;gt;
&amp;lt;el-container&amp;gt;
  &amp;lt;!--header--&amp;gt;
  &amp;lt;el-header&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是标题&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-header&amp;gt;
  &amp;lt;!--容器嵌套使用--&amp;gt;
  &amp;lt;el-container&amp;gt;
    &amp;lt;!--aside--&amp;gt;
    &amp;lt;el-aside&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是菜单&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-aside&amp;gt;
    &amp;lt;!--main--&amp;gt;
    &amp;lt;el-main&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是中心内容&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-main&amp;gt;
  &amp;lt;/el-container&amp;gt;
  &amp;lt;el-footer&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是页脚&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-footer&amp;gt;
&amp;lt;/el-container&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;74-水平容器&#34;&gt;7.4 水平容器&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-container direction=&amp;quot;horizontal&amp;quot;&amp;gt;
  &amp;lt;!--header--&amp;gt;
  &amp;lt;el-header&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是标题&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-header&amp;gt;
  &amp;lt;el-container&amp;gt;
    &amp;lt;!--aside--&amp;gt;
    &amp;lt;el-aside&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是菜单&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-aside&amp;gt;
    &amp;lt;!--main--&amp;gt;
    &amp;lt;el-main&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是中心内容&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-main&amp;gt;
  &amp;lt;/el-container&amp;gt;
  &amp;lt;el-footer&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是页脚&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-footer&amp;gt;
&amp;lt;/el-container&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意:当子元素中没有有 el-header 或 el-footer 时容器排列为水平&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;75-垂直容器&#34;&gt;7.5 垂直容器&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-container direction=&amp;quot;vertical&amp;quot;&amp;gt;
  &amp;lt;!--header--&amp;gt;
  &amp;lt;el-header&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是标题&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-header&amp;gt;
  &amp;lt;el-container&amp;gt;
    &amp;lt;!--aside--&amp;gt;
    &amp;lt;el-aside&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是菜单&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-aside&amp;gt;
    &amp;lt;!--main--&amp;gt;
    &amp;lt;el-main&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是中心内容&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-main&amp;gt;
  &amp;lt;/el-container&amp;gt;
  &amp;lt;!--footer--&amp;gt;
  &amp;lt;el-footer&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是页脚&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-footer&amp;gt;
&amp;lt;/el-container&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;8form相关组件&#34;&gt;8.Form相关组件&lt;/h2&gt;
&lt;h3 id=&#34;81-radio单选按钮&#34;&gt;8.1 Radio单选按钮&lt;/h3&gt;
&lt;h4 id=&#34;1创建radio按钮&#34;&gt;1.创建Radio按钮&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!--组件创建--&amp;gt;
&amp;lt;el-radio v-model=&amp;quot;label&amp;quot; label=&amp;quot;男&amp;quot;&amp;gt;男&amp;lt;/el-radio&amp;gt;
&amp;lt;el-radio v-model=&amp;quot;label&amp;quot; label=&amp;quot;女&amp;quot;&amp;gt;女&amp;lt;/el-radio&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Radio&amp;quot;,
        data(){
            return{
                label:&#39;男&#39;
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意:在使用radio单选按钮是至少加入v-model和label两个属性&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;2radio按钮属性的使用&#34;&gt;2.Radio按钮属性的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-radio v-model=&amp;quot;label&amp;quot; name=&amp;quot;sex&amp;quot; disabled label=&amp;quot;男&amp;quot;&amp;gt;男&amp;lt;/el-radio&amp;gt;
&amp;lt;el-radio v-model=&amp;quot;label&amp;quot; name=&amp;quot;sex&amp;quot; border size=&amp;quot;small&amp;quot; label=&amp;quot;女&amp;quot;&amp;gt;女&amp;lt;/el-radio&amp;gt;
&amp;lt;el-radio v-model=&amp;quot;label&amp;quot; border size=&amp;quot;mini&amp;quot; label=&amp;quot;女&amp;quot;&amp;gt;女&amp;lt;/el-radio&amp;gt;
&amp;lt;el-radio v-model=&amp;quot;label&amp;quot; border size=&amp;quot;medium&amp;quot; label=&amp;quot;女&amp;quot;&amp;gt;女&amp;lt;/el-radio&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;总结:属性使用还是直接卸载对应的组件标签上以 属性名=属性值 方式使用&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;3radio事件的使用&#34;&gt;3.Radio事件的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-radio v-model=&amp;quot;label&amp;quot; @change=&amp;quot;aa&amp;quot; name=&amp;quot;sex&amp;quot; label=&amp;quot;男&amp;quot;&amp;gt;男&amp;lt;/el-radio&amp;gt;
&amp;lt;el-radio v-model=&amp;quot;label&amp;quot; @change=&amp;quot;aa&amp;quot; name=&amp;quot;sex&amp;quot; border size=&amp;quot;small&amp;quot; label=&amp;quot;女&amp;quot;&amp;gt;女&amp;lt;/el-radio&amp;gt;



&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Radio&amp;quot;,
        data(){
            return{
                label:&#39;男&#39;
            }
        },
        methods:{
            aa(){ //定义的事件处理函数
                console.log(this.label);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;总结:&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;​	事件的使用也是和属性使用是一致都是直接写在对应的组件标签上&lt;/li&gt;
&lt;li&gt;事件在使用时必须使用Vue中绑定时间方式进行使用如 @事件名=事件处理函数(绑在在vue组件中对应函数)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;4radio按钮组&#34;&gt;4.radio按钮组&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-radio-group v-model=&amp;quot;radio&amp;quot;&amp;gt;
  &amp;lt;el-radio :label=&amp;quot;3&amp;quot;&amp;gt;备选项3&amp;lt;/el-radio&amp;gt;
  &amp;lt;el-radio :label=&amp;quot;6&amp;quot;&amp;gt;备选项6&amp;lt;/el-radio&amp;gt;
  &amp;lt;el-radio :label=&amp;quot;9&amp;quot;&amp;gt;备选项9&amp;lt;/el-radio&amp;gt;
&amp;lt;/el-radio-group&amp;gt;
&amp;lt;script&amp;gt;
  export default {
    name: &amp;quot;Radio&amp;quot;,
    data() {
      return {
        radio: 6
      }
    }
  }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;82-checkbox组件&#34;&gt;8.2 checkbox组件&lt;/h3&gt;
&lt;h4 id=&#34;1创建checkbox组件&#34;&gt;1.创建checkbox组件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-checkbox v-model=&amp;quot;checked&amp;quot;&amp;gt;北京&amp;lt;/el-checkbox&amp;gt;
&amp;lt;el-checkbox v-model=&amp;quot;checked&amp;quot;&amp;gt;上海&amp;lt;/el-checkbox&amp;gt;
&amp;lt;el-checkbox v-model=&amp;quot;checked&amp;quot;&amp;gt;天津&amp;lt;/el-checkbox&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2属性使用&#34;&gt;2.属性使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-checkbox v-model=&amp;quot;checked&amp;quot;  disabled true-label=&amp;quot;北京&amp;quot;&amp;gt;北京&amp;lt;/el-checkbox&amp;gt;
&amp;lt;el-checkbox checked border true-label=&amp;quot;上海&amp;quot;&amp;gt;上海&amp;lt;/el-checkbox&amp;gt;
&amp;lt;el-checkbox v-model=&amp;quot;checked&amp;quot; true-label=&amp;quot;天津&amp;quot;&amp;gt;天津&amp;lt;/el-checkbox&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3事件使用&#34;&gt;3.事件使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-checkbox @change=&amp;quot;aa&amp;quot;v-model=&amp;quot;checked&amp;quot;  true-label=&amp;quot;上海&amp;quot;&amp;gt;上海&amp;lt;/el-checkbox&amp;gt;
&amp;lt;el-checkbox v-model=&amp;quot;checked&amp;quot; @change=&amp;quot;aa&amp;quot; true-label=&amp;quot;天津&amp;quot;&amp;gt;天津&amp;lt;/el-checkbox&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Checkbox&amp;quot;,
        data(){
            return{
                checked:true
            }
        },
        methods:{
            aa(){
                console.log(this.checked);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4复选框组的使用&#34;&gt;4.复选框组的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-checkbox-group @change=&amp;quot;bb&amp;quot; :min=&amp;quot;1&amp;quot; v-model=&amp;quot;checkList&amp;quot;&amp;gt;
  &amp;lt;el-checkbox label=&amp;quot;复选框 A&amp;quot;&amp;gt;&amp;lt;/el-checkbox&amp;gt;
  &amp;lt;el-checkbox label=&amp;quot;复选框 B&amp;quot;&amp;gt;&amp;lt;/el-checkbox&amp;gt;
  &amp;lt;el-checkbox label=&amp;quot;复选框 C&amp;quot;&amp;gt;&amp;lt;/el-checkbox&amp;gt;
  &amp;lt;el-checkbox label=&amp;quot;禁用&amp;quot; disabled&amp;gt;&amp;lt;/el-checkbox&amp;gt;
  &amp;lt;el-checkbox label=&amp;quot;选中且禁用&amp;quot; disabled&amp;gt;&amp;lt;/el-checkbox&amp;gt;
&amp;lt;/el-checkbox-group&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Checkbox&amp;quot;,
        data(){
            return{
                checked:true,
                checkList:[],
            }
        },
        methods:{
            aa(){
                console.log(this.checked);
            },
            bb(){
                console.log(this.checkList);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;83-input-输入框组件&#34;&gt;8.3 Input 输入框组件&lt;/h3&gt;
&lt;h4 id=&#34;1创建input组件&#34;&gt;1.创建Input组件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-input v-model=&amp;quot;name&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Input&amp;quot;,
        data(){
            return {
                name:&#39;xiaochen&#39;
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2常用属性&#34;&gt;2.常用属性&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-input v-model=&amp;quot;name&amp;quot; disabled type=&amp;quot;textarea&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
&amp;lt;el-input v-model=&amp;quot;price&amp;quot; :maxlength=&amp;quot;10&amp;quot; show-word-limit :minlength=&amp;quot;5&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
&amp;lt;el-input prefix-icon=&amp;quot;el-icon-user-solid&amp;quot; placeholder=&amp;quot;请输入用户名&amp;quot; clearable v-model=&amp;quot;username&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
&amp;lt;el-input suffix-icon=&amp;quot;el-icon-star-off&amp;quot; placeholder=&amp;quot;请输入密码&amp;quot; show-password type=&amp;quot;password&amp;quot; clearable v-model=&amp;quot;password&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Input&amp;quot;,
        data() {
            return {
                restaurants: [],
                state1: &#39;&#39;,
                state2: &#39;&#39;,
                name:&#39;xiaochen&#39;,
                price:0.0,
                username:&amp;quot;&amp;quot;,
                password:&amp;quot;&amp;quot;,
            };
        },
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3事件使用-2&#34;&gt;3.事件使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-input v-model=&amp;quot;username&amp;quot; @blur=&amp;quot;aaa&amp;quot; @focus=&amp;quot;bbb&amp;quot; @clear=&amp;quot;clears&amp;quot; clearable @input=&amp;quot;ccc&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Input&amp;quot;,
        data() {
            return {
                restaurants: [],
                state1: &#39;&#39;,
                state2: &#39;&#39;,
                name:&#39;xiaochen&#39;,
                price:0.0,
                username:&amp;quot;&amp;quot;,
                password:&amp;quot;&amp;quot;,
            };
        },
        methods:{
            aaa(){
                console.log(&#39;失去焦点&#39;);
                ;
            },
            bbb(){
                console.log(&amp;quot;获取焦点&amp;quot;);
            },
            ccc(value){
                console.log(&amp;quot;改变:&amp;quot;+value);
            },
            clears(){
                console.log(&amp;quot;清楚&amp;quot;);
            }


        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4方法的使用&#34;&gt;4.方法的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;h1&amp;gt;方法的使用&amp;lt;/h1&amp;gt;
&amp;lt;el-input v-model=&amp;quot;username&amp;quot; ref=&amp;quot;inputs&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;

&amp;lt;el-button @click=&amp;quot;focusInputs&amp;quot;&amp;gt;focus方法&amp;lt;/el-button&amp;gt;
&amp;lt;el-button @click=&amp;quot;blurInputs&amp;quot;&amp;gt;blur方法&amp;lt;/el-button&amp;gt;

&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Input&amp;quot;,
        data() {
            return{}
        },
        methods:{
            //调用focus方法
            focusInputs(){
                this.$refs.inputs.focus();
            },
           //调用失去焦点方法
            blurInputs(){
                this.$refs.inputs.blur();
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;总结&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;​	在使用组件的方法时需要在对应的组件中加入 &lt;code&gt;ref=&amp;quot;组件别名&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在调用方法时直接使用 &lt;code&gt;this.$refs.组件别名.方法名()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;注意:在elementui中所有组件 都存在 属性 事件 和方法&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;属性:&lt;/code&gt;直接写在对应的组件标签上 使用方式:&lt;code&gt;属性名=属性值&lt;/code&gt;方式&lt;/p&gt;
&lt;p&gt;&lt;code&gt;事件&lt;/code&gt;: 直接使用vue绑定事件方式写在对应的组件标签上 使用方式:&lt;code&gt;@事件名=vue中事件处理函数&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;方法&lt;/code&gt;: 1.在对应组件标签上使用&lt;code&gt;ref=组件别名&lt;/code&gt; 2.&lt;code&gt;通过使用this.$refs.组件别名.方法名()&lt;/code&gt;进行调用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;84-select选择器组件的使用&#34;&gt;8.4 Select选择器组件的使用&lt;/h3&gt;
&lt;h4 id=&#34;1组件创建&#34;&gt;1.组件创建&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# 1.数据写死在页面上
&amp;lt;el-select v-model=&amp;quot;cityName&amp;quot;&amp;gt;
  &amp;lt;el-option value=&amp;quot;北京&amp;quot;&amp;gt;北京&amp;lt;/el-option&amp;gt;
  &amp;lt;el-option value=&amp;quot;天津&amp;quot;&amp;gt;天津&amp;lt;/el-option&amp;gt;
&amp;lt;/el-select&amp;gt;
	注意:1.要求下拉列表中必须存在option的value属性值 2.要求select中必须使用v-model进行数据绑定

# 2.如何动态获取数据
 &amp;lt;el-select&amp;gt;
 		&amp;lt;el-option v-for=&amp;quot;option in options&amp;quot; :label=&amp;quot;option.name&amp;quot; :value=&amp;quot;option.id&amp;quot; :key=&amp;quot;option.id&amp;quot;&amp;gt;
 		&amp;lt;/el-option&amp;gt;
 &amp;lt;/el-select&amp;gt;

  &amp;lt;script&amp;gt;
      export default {
          name: &amp;quot;Select&amp;quot;,
          data(){
              return{
                  options:[
                      {id:&#39;1&#39;,name:&amp;quot;研发部&amp;quot;},
                      {id:&#39;2&#39;,name:&amp;quot;小卖部&amp;quot;},
                      {id:&#39;3&#39;,name:&amp;quot;小米部&amp;quot;},
                  ]
              }
          },
      }
  &amp;lt;/script&amp;gt;
  
# 3.获取下拉列表选中数据
 &amp;lt;el-select v-model=&amp;quot;cityId&amp;quot; multiple clearable&amp;gt;
        &amp;lt;el-option v-for=&amp;quot;option in options&amp;quot; :label=&amp;quot;option.name&amp;quot; :value=&amp;quot;option.id&amp;quot; :key=&amp;quot;option.id&amp;quot;&amp;gt;&amp;lt;/el-option&amp;gt;
&amp;lt;/el-select&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Select&amp;quot;,
        data(){
            return{
                options:[
                    {id:&#39;1&#39;,name:&amp;quot;研发部&amp;quot;},
                    {id:&#39;2&#39;,name:&amp;quot;小卖部&amp;quot;},
                    {id:&#39;3&#39;,name:&amp;quot;小米部&amp;quot;},
                ],
                cityId:&#39;&#39;
            }
        },
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2属性使用-2&#34;&gt;2.属性使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-select v-model=&amp;quot;cityId&amp;quot; multiple clearable&amp;gt;
  ......
&amp;lt;/el-select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3事件的使用&#34;&gt;3.事件的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-select v-model=&amp;quot;cityId&amp;quot; @change=&amp;quot;aaa&amp;quot; multiple clearable&amp;gt;
  &amp;lt;el-option v-for=&amp;quot;option in options&amp;quot; :label=&amp;quot;option.name&amp;quot; :value=&amp;quot;option.id&amp;quot; :key=&amp;quot;option.id&amp;quot;&amp;gt;
  &amp;lt;/el-option&amp;gt;
&amp;lt;/el-select&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Select&amp;quot;,
        data(){
            return{
                options:[
                    {id:&#39;1&#39;,name:&amp;quot;研发部&amp;quot;},
                    {id:&#39;2&#39;,name:&amp;quot;小卖部&amp;quot;},
                    {id:&#39;3&#39;,name:&amp;quot;小米部&amp;quot;},
                ],
                cityId:&#39;&#39;,
                cityName:&#39;&#39;
            }
        },
        methods:{
            aaa(value){
                console.log(value);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4方法的使用-2&#34;&gt;4.方法的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;1.给组件通过ref起别名并绑定到vue实例中
 &amp;lt;el-select ref=&amp;quot;selects&amp;quot; v-model=&amp;quot;cityId&amp;quot; @change=&amp;quot;aaa&amp;quot; multiple clearable&amp;gt;
       ....
 &amp;lt;/el-select&amp;gt;
2.调用方法
 this.$refs.selects.focus();//方法调用
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;85-switch-开关组件&#34;&gt;8.5 Switch 开关组件&lt;/h3&gt;
&lt;h4 id=&#34;1switch组件的创建&#34;&gt;1.Switch组件的创建&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-switch v-model=&amp;quot;value&amp;quot;&amp;gt;&amp;lt;/el-switch&amp;gt;
&amp;lt;script&amp;gt;
  export default {
    name: &amp;quot;Switchs&amp;quot;,
    data(){
      return{
        value:true
      }
    }
  }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2属性使用-3&#34;&gt;2.属性使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-switch v-model=&amp;quot;value&amp;quot; active-text=&amp;quot;打开&amp;quot; active-color=&amp;quot;#13ce66&amp;quot; inactive-color=&amp;quot;#ff4949&amp;quot; :active-
           value=&amp;quot;true&amp;quot; :inactive-value=&amp;quot;false&amp;quot; inactive-text=&amp;quot;关闭&amp;quot; :width=&amp;quot;200&amp;quot;&amp;gt;
&amp;lt;/el-switch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3事件使用-3&#34;&gt;3.事件使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-switch v-model=&amp;quot;value&amp;quot; @change=&amp;quot;aaa&amp;quot;&amp;gt;&amp;lt;/el-switch&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Switchs&amp;quot;,
        data(){
            return{
                value:true
            }
        },
        methods:{
            aaa(value){
                console.log(value);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4方法使用&#34;&gt;4.方法使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-switch ref=&amp;quot;sw&amp;quot; v-model=&amp;quot;value&amp;quot; @change=&amp;quot;aaa&amp;quot; active-text=&amp;quot;打开&amp;quot; active-color=&amp;quot;#13ce66&amp;quot; inactive-color=&amp;quot;#ff4949&amp;quot; :active-value=&amp;quot;true&amp;quot; :inactive-value=&amp;quot;false&amp;quot; inactive-text=&amp;quot;关闭&amp;quot; :width=&amp;quot;200&amp;quot;&amp;gt;&amp;lt;/el-switch&amp;gt;
&amp;lt;el-button @click=&amp;quot;bbb&amp;quot;&amp;gt;调用方法&amp;lt;/el-button&amp;gt;

&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Switchs&amp;quot;,
        data(){
            return{
                value:true
            }
        }
        ,
        methods:{
            aaa(value){
                console.log(value);
            },
            bbb(){
                alert();
                this.$refs.sw.focus();//方法调用
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;86-datepicker组件&#34;&gt;8.6 DatePicker组件&lt;/h3&gt;
&lt;h4 id=&#34;1创建&#34;&gt;1.创建&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-date-picker v-model=&amp;quot;createDate&amp;quot; &amp;gt;&amp;lt;/el-date-picker&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2属性的使用&#34;&gt;2.属性的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-date-picker
        v-model=&amp;quot;createDate&amp;quot;
        :editable=&amp;quot;false&amp;quot;
        :clearable=&amp;quot;false&amp;quot;
        placeholder=&amp;quot;请输入创建时间&amp;quot;
        type=&amp;quot;daterange&amp;quot;
        start-placeholder=&amp;quot;生产时间&amp;quot;
        end-placeholder=&amp;quot;过期时间&amp;quot;
        format=&amp;quot;yyyy/MM/dd&amp;quot;
      &amp;gt;
&amp;lt;/el-date-picker&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3picker-options-和-shortcuts使用&#34;&gt;3.Picker Options 和 Shortcuts使用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Shortcuts:&lt;/strong&gt; 用来增加日期组件的快捷面板&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Picker Options:&lt;/strong&gt; 用来对日期控件做自定义配置&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;31-shortcuts使用&#34;&gt;3.1 Shortcuts使用&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;/el-date-picker&amp;gt;
&amp;lt;h1&amp;gt;日期配置&amp;lt;/h1&amp;gt;
&amp;lt;el-date-picker
                v-model=&amp;quot;createDate&amp;quot;
                type=&amp;quot;date&amp;quot;
                placeholder=&amp;quot;请输入时间&amp;quot;
                :picker-options=&amp;quot;pickerOptions&amp;quot;
                &amp;gt;
&amp;lt;/el-date-picker&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;DatePrickers&amp;quot;,
        data(){
            return{
                createDate:&amp;quot;&amp;quot;,
                pickerOptions: {
                    disabledDate(time) {
                        return time.getTime() &amp;gt; Date.now();
                    },
                    shortcuts: [{  //定义的shortucts
                        text: &#39;今天&#39;,
                        onClick(picker) {
                            picker.$emit(&#39;pick&#39;, new Date());
                        }
                    }, {
                        text: &#39;昨天&#39;,
                        onClick(picker) {
                            const date = new Date();
                            date.setTime(date.getTime() - 3600 * 1000 * 24);
                            picker.$emit(&#39;pick&#39;, date);
                        }
                    }, {
                        text: &#39;一周前&#39;,
                        onClick(picker) {
                            const date = new Date();
                            date.setTime(date.getTime() - 3600 * 1000 * 24 * 7);
                            picker.$emit(&#39;pick&#39;, date);
                        }
                    }]
                },
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606975735552.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;32-picker-options&#34;&gt;3.2 Picker Options&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-date-picker
                v-model=&amp;quot;createDate&amp;quot;
                type=&amp;quot;date&amp;quot;
                placeholder=&amp;quot;请输入时间&amp;quot;
                :picker-options=&amp;quot;pickerOptions&amp;quot;
                &amp;gt;
&amp;lt;/el-date-picker&amp;gt;

&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;DatePrickers&amp;quot;,
        data(){
            return{
                createDate:&amp;quot;&amp;quot;,
                pickerOptions: {
                    disabledDate(time) { //用来对日期进行的控制
                        return time.getTime() &amp;lt; Date.now();
                    }
                },
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606975746134.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;4事件使用&#34;&gt;4.事件使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-date-picker
                .....
                :picker-options=&amp;quot;pickerOptions&amp;quot;
                @change=&amp;quot;aaa&amp;quot;
                &amp;gt;
&amp;lt;/el-date-picker&amp;gt;

&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;DatePrickers&amp;quot;,
        data(){
            return{
                createDate:&amp;quot;&amp;quot;,
            }
        },
        methods:{
            aaa(value){  //发生change事件的函数
                console.log(value);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;87-upload组件&#34;&gt;8.7 Upload组件&lt;/h3&gt;
&lt;h4 id=&#34;1组件创建-2&#34;&gt;1.组件创建&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-upload action=&amp;quot;https://jsonplaceholder.typicode.com/posts/&amp;quot; :file-list=&amp;quot;fileList&amp;quot;&amp;gt;
  &amp;lt;el-button size=&amp;quot;small&amp;quot; type=&amp;quot;primary&amp;quot;&amp;gt;点击上传&amp;lt;/el-button&amp;gt;
  &amp;lt;div slot=&amp;quot;tip&amp;quot; class=&amp;quot;el-upload__tip&amp;quot;&amp;gt;只能上传jpg/png文件，且不超过500kb&amp;lt;/div&amp;gt;
&amp;lt;/el-upload&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意:在使用upload组件时必须设置action属性 action属性为必要参数不能省略&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;2属性和事件的使用&#34;&gt;2.属性和事件的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-upload :limit=&amp;quot;3&amp;quot; :on-exceed=&amp;quot;exceed&amp;quot; :multiple=&amp;quot;false&amp;quot; :before-remove=&amp;quot;beforeRemove&amp;quot; :on-remove=&amp;quot;remove&amp;quot; :on-preview=&amp;quot;show&amp;quot; :drag=&amp;quot;true&amp;quot; accept=&amp;quot;.txt,.png&amp;quot; :show-file-list=&amp;quot;true&amp;quot; name=&amp;quot;aaa&amp;quot; :data=&amp;quot;info&amp;quot; action=&amp;quot;https://jsonplaceholder.typicode.com/posts/&amp;quot;
               :file-list=&amp;quot;fileList&amp;quot;&amp;gt;
  &amp;lt;i class=&amp;quot;el-icon-upload&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;
  &amp;lt;div class=&amp;quot;el-upload__text&amp;quot;&amp;gt;将文件拖到此处，或&amp;lt;em&amp;gt;点击上传&amp;lt;/em&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;el-upload__tip&amp;quot; slot=&amp;quot;tip&amp;quot;&amp;gt;只能上传jpg/png文件，且不超过500kb&amp;lt;/div&amp;gt;
&amp;lt;/el-upload&amp;gt;

&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Uploads&amp;quot;,
        data() {
            return {
                fileList: [{
                    name: &#39;food.jpeg&#39;,
                    url: &#39;https://fuss10.elemecdn.com/3/63/4e7f3a15429bfda99bce42a18cdd1jpeg.jpeg?imageMogr2/thumbnail/360x360/format/webp/quality/100&#39;
                }, {
                    name: &#39;food2.jpeg&#39;,
                    url: &#39;https://fuss10.elemecdn.com/3/63/4e7f3a15429bfda99bce42a18cdd1jpeg.jpeg?imageMogr2/thumbnail/360x360/format/webp/quality/100&#39;
                }],
                info: {id:&amp;quot;21&amp;quot;}
            }
        },
        methods:{
            show(file){
                console.log(file);
            },
            remove(file,fileList){
                console.log(file);
                console.log(fileList);
                //alert(fileList.length)
            },
            beforeRemove(file,fileList){
                if(fileList.length&amp;lt;3){
                    alert(&amp;quot;上传文件不能少于3个&amp;quot;)
                    return false;
                }
            },
            exceed(file,fileList){
                alert(&amp;quot;文件超出上传的个数限制&amp;quot;)
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;注意:在使用upload组件时没有event事件,所有事件都是属性事件&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3方法的使用&#34;&gt;3.方法的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-upload ref=&amp;quot;uploads&amp;quot; ....&amp;gt;........&amp;lt;/el-upload&amp;gt;

方法调用:
	this.$refs.uploads.clearFiles();
	this.$refs.uploads.abort();
	this.$refs.uploads.submit();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;88-form组件&#34;&gt;8.8 Form组件&lt;/h3&gt;
&lt;h4 id=&#34;1组件的创建&#34;&gt;1.组件的创建&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-form ref=&amp;quot;form&amp;quot; :model=&amp;quot;form&amp;quot; label-width=&amp;quot;80px&amp;quot;&amp;gt;
  &amp;lt;el-form-item label=&amp;quot;活动名称&amp;quot;&amp;gt;
    &amp;lt;el-input v-model=&amp;quot;form.name&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
  &amp;lt;/el-form-item&amp;gt;
  ......
  &amp;lt;el-form-item&amp;gt;
    &amp;lt;el-button type=&amp;quot;primary&amp;quot; @click=&amp;quot;onSubmit&amp;quot;&amp;gt;立即创建&amp;lt;/el-button&amp;gt;
    &amp;lt;el-button&amp;gt;取消&amp;lt;/el-button&amp;gt;
  &amp;lt;/el-form-item&amp;gt;
&amp;lt;/el-form&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Form&amp;quot;,
        data() {
            return {
                form: {
                    name: &#39;&#39;,
                    region: &#39;&#39;,
                    date1: &#39;&#39;,
                    date2: &#39;&#39;,
                    delivery: false,
                    type: [],
                    resource: &#39;&#39;,
                    desc: &#39;&#39;
                }
            }
        },
        methods: {
            onSubmit() {
                console.log(&#39;submit!&#39;);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2内联表单&#34;&gt;2.内联表单&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-form :inline=&amp;quot;true&amp;quot; :model=&amp;quot;formInline&amp;quot; class=&amp;quot;demo-form-inline&amp;quot;&amp;gt;
		.......
&amp;lt;/el-form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;通过设置 inline=true方式将表单作为内联表单处理&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;3表单验证&#34;&gt;3.表单验证&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用说明:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Form 组件提供了表单验证的功能，只需要通过 &lt;code&gt;rules&lt;/code&gt; 属性传入约定的验证规则，并将 Form-Item 的 &lt;code&gt;prop&lt;/code&gt; 属性设置为需校验的字段名即可。校验规则参见 &lt;a href=&#34;https://github.com/yiminghe/async-validator&#34;&gt;async-validator&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;31-失去焦点自动验证&#34;&gt;3.1 失去焦点自动验证&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-form :rules=&amp;quot;rules&amp;quot; ...&amp;gt;
  &amp;lt;el-form-item label=&amp;quot;活动名称&amp;quot; prop=&amp;quot;name&amp;quot;&amp;gt;
      &amp;lt;el-input v-model=&amp;quot;form.name&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
  &amp;lt;/el-form-item&amp;gt;
  ....
&amp;lt;/el-form&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Form&amp;quot;,
        data() {
            return {
                form: {
                    name: &#39;&#39;,
                    region: &#39;&#39;,
                    date1: &#39;&#39;,
                    date2: &#39;&#39;,
                    delivery: false,
                    type: [],
                    resource: &#39;&#39;,
                    desc: &#39;&#39;
                },
                rules: {
                    name: [
                        {required: true, message: &#39;请输入活动名称&#39;, trigger: &#39;blur&#39;},
                        {min: 3, max: 5, message: &#39;长度在 3 到 5 个字符&#39;, trigger: &#39;blur&#39;}
                    ],
                }
            }
        },
        methods: {
            onSubmit() {
                console.log(&#39;submit!&#39;);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;32-表单提交调用表单组件的验证方法验证&#34;&gt;3.2 表单提交调用表单组件的验证方法验证&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-form :rules=&amp;quot;rules&amp;quot;.... ref=&amp;quot;form&amp;quot; &amp;gt;
    &amp;lt;el-form-item label=&amp;quot;活动名称&amp;quot; prop=&amp;quot;name&amp;quot;&amp;gt;
      &amp;lt;el-input v-model=&amp;quot;form.name&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
  	&amp;lt;/el-form-item&amp;gt;
  	&amp;lt;el-form-item&amp;gt;
      &amp;lt;el-button type=&amp;quot;primary&amp;quot; @click=&amp;quot;onSubmit(&#39;form&#39;)&amp;quot;&amp;gt;立即创建&amp;lt;/el-button&amp;gt;
      &amp;lt;el-button&amp;gt;取消&amp;lt;/el-button&amp;gt;
  	&amp;lt;/el-form-item&amp;gt;
&amp;lt;/el-form&amp;gt;
...
methods: {
            onSubmit(formName) {
                this.$refs[formName].validate((valid) =&amp;gt; {
                    if (valid) {
                        alert(&#39;submit!&#39;);
                        //发送异步请求 到 springboot项目
                    } else {
                        console.log(&#39;error submit!!&#39;);
                        return false;
                    }
                });
            }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4自定义表单的验证规则&#34;&gt;4.自定义表单的验证规则&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-form :model=&amp;quot;ruleForm&amp;quot; :rules=&amp;quot;rules&amp;quot; ref=&amp;quot;ruleForm&amp;quot; label-width=&amp;quot;100px&amp;quot;&amp;gt;
  &amp;lt;el-form-item label=&amp;quot;手机号&amp;quot; prop=&amp;quot;phone&amp;quot;&amp;gt;
    &amp;lt;el-input type=&amp;quot;password&amp;quot; v-model=&amp;quot;ruleForm.phone&amp;quot; &amp;gt;&amp;lt;/el-input&amp;gt;
  &amp;lt;/el-form-item&amp;gt;
  &amp;lt;el-form-item&amp;gt;
    &amp;lt;el-button type=&amp;quot;primary&amp;quot; @click=&amp;quot;submitForm(&#39;ruleForm&#39;)&amp;quot;&amp;gt;提交&amp;lt;/el-button&amp;gt;
    &amp;lt;el-button @click=&amp;quot;resetForm(&#39;ruleForm&#39;)&amp;quot;&amp;gt;重置&amp;lt;/el-button&amp;gt;
  &amp;lt;/el-form-item&amp;gt;
&amp;lt;/el-form&amp;gt;

&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Form&amp;quot;,
        data() {
            let validatePhone = (rule,value,callback)=&amp;gt;{ //定义自定义的验证规则
                console.log(rule);
                console.log(value);
                console.log(callback);
                if(!value){
                    callback(new Error(&amp;quot;手机号不能为空!&amp;quot;));
                }
                if(!/^1[3456789]\d{9}$/.test(value)){
                    callback(new Error(&amp;quot;手机号码不正确!!&amp;quot;))
                }
            }
            return {
                form: {
                    name: &#39;&#39;,
                    region: &#39;&#39;,
                    date1: &#39;&#39;,
                    date2: &#39;&#39;,
                    delivery: false,
                    type: [],
                    resource: &#39;&#39;,
                    desc: &#39;&#39;
                },
                rules: { //验证规则
                    name: [ //使用默认规则
                        {required: true, message: &#39;请输入活动名称&#39;, trigger: &#39;blur&#39;},
                        {min: 3, max: 5, message: &#39;长度在 3 到 5 个字符&#39;, trigger: &#39;blur&#39;}
                    ],
                    phone:[  //使用自定义规则
                        {validator:validatePhone,trigger: &#39;blur&#39;}
                    ]
                },
                ruleForm:{
                    phone:&#39;&#39;,
                },
            }
        },
        methods: {
           
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;9消息提示&#34;&gt;9.消息提示&lt;/h2&gt;
&lt;h3 id=&#34;91警告提示&#34;&gt;9.1警告提示&lt;/h3&gt;
&lt;h4 id=&#34;11-创建警告提示&#34;&gt;1.1 创建警告提示&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-alert title=&amp;quot;成功信息提示&amp;quot; :closable=&amp;quot;false&amp;quot; type=&amp;quot;success&amp;quot;&amp;gt;
  &amp;lt;div slot&amp;gt;我是辅助信息&amp;lt;/div&amp;gt;
&amp;lt;/el-alert&amp;gt;
&amp;lt;el-alert title=&amp;quot;成功信息提示&amp;quot; type=&amp;quot;info&amp;quot;&amp;gt;&amp;lt;/el-alert&amp;gt;
&amp;lt;el-alert title=&amp;quot;成功信息提示&amp;quot; type=&amp;quot;warning&amp;quot;&amp;gt;&amp;lt;/el-alert&amp;gt;
&amp;lt;el-alert title=&amp;quot;成功信息提示&amp;quot; type=&amp;quot;error&amp;quot;&amp;gt;&amp;lt;/el-alert&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;12属性的使用&#34;&gt;1.2属性的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-alert title=&amp;quot;成功信息提示&amp;quot; effect=&amp;quot;dark&amp;quot; :show-icon=&amp;quot;true&amp;quot; center :closable=&amp;quot;false&amp;quot; type=&amp;quot;success&amp;quot;&amp;gt;
  &amp;lt;div slot&amp;gt;我是辅助信息&amp;lt;/div&amp;gt;
&amp;lt;/el-alert&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;92-message消息提示&#34;&gt;9.2 Message消息提示&lt;/h3&gt;
&lt;h4 id=&#34;21-创建组件&#34;&gt;2.1 创建组件&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;注意:这个组件的创建无须在页面中书写任何标签,他是一个js插件,在需要展示消息提示的位置直接调用提供的js插件方法即可&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;# 1.创建最简单的消息
	this.$message(&#39;这是一个消息提示!!&#39;)

# 2.自定义消息内容
	this.$message({
    message: h(&#39;p&#39;, null, [
      h(&#39;span&#39;, null, &#39;订单创建成功,您的订单编号为: &#39;),
      h(&#39;i&#39;, { style: &#39;color: teal&#39; }, &#39;87&#39;)
    ])
  });

# 3.不同主题的消息提示
	 this.$message({
     message:&#39;这是信息提示&#39;,
     type:&amp;quot;success&amp;quot;,
   })
		//主题样式:  success  info  warning  error

# 4.属性使用
	this.$message({
    message:&#39;这是信息提示&#39;,
    type:&amp;quot;success&amp;quot;,
    showClose:true,
    center:true,
    iconClass:&#39;el-icon-user-solid&#39;,
    duration:0
  })
# 5.方法的使用
	this.$message.closeAll();

&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;10table表格组件&#34;&gt;10.table表格组件&lt;/h2&gt;
&lt;h3 id=&#34;1组件的创建-2&#34;&gt;1.组件的创建&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-table :data=&amp;quot;tableData&amp;quot;&amp;gt;
  &amp;lt;el-table-column prop=&amp;quot;id&amp;quot; label=&amp;quot;编号&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
  &amp;lt;el-table-column prop=&amp;quot;name&amp;quot; label=&amp;quot;姓名&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
  &amp;lt;el-table-column prop=&amp;quot;age&amp;quot; label=&amp;quot;年龄&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
  &amp;lt;el-table-column prop=&amp;quot;email&amp;quot; label=&amp;quot;邮箱&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
&amp;lt;/el-table&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Tables&amp;quot;,
        data(){
            return {
                tableData:[
                    {id:21,name:&amp;quot;小陈&amp;quot;,age:23,email:&amp;quot;60037647@qq.com&amp;quot;},
                    {id:22,name:&amp;quot;小张&amp;quot;,age:25,email:&amp;quot;60038647@qq.com&amp;quot;},
                ]
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2表格中列属性&#34;&gt;2.表格中列属性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;el-table-column属性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-table-column prop=&amp;quot;id&amp;quot; :resizable=&amp;quot;false&amp;quot; header-align=&amp;quot;left&amp;quot; align=&amp;quot;center&amp;quot; fixed=&amp;quot;left&amp;quot; width=&amp;quot;200px;&amp;quot; label=&amp;quot;编号&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
&amp;lt;el-table-column prop=&amp;quot;name&amp;quot; label=&amp;quot;姓名&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
&amp;lt;el-table-column prop=&amp;quot;age&amp;quot; :sort-method=&amp;quot;sorts&amp;quot; sortable label=&amp;quot;年龄&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
&amp;lt;el-table-column prop=&amp;quot;email&amp;quot; label=&amp;quot;邮箱&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
&amp;lt;el-table-column prop=&amp;quot;dept.name&amp;quot; :formatter=&amp;quot;showDept&amp;quot; label=&amp;quot;部门&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Tables&amp;quot;,
        data() {
            return {
                tableData: [
                    {
                        id: 21, name: &amp;quot;小陈&amp;quot;, age: 23, email: &amp;quot;60037647@qq.com&amp;quot;,
                        dept: {id: 1, name: &amp;quot;研发部&amp;quot;}
                    },
                    {
                        id: 22, name: &amp;quot;小张&amp;quot;, age: 25, email: &amp;quot;60038647@qq.com&amp;quot;,
                        dept: {id: 1, name: &amp;quot;小卖部&amp;quot;}
                    },
                    {
                        id: 23, name: &amp;quot;小李&amp;quot;, age: 25, email: &amp;quot;60038657@qq.com&amp;quot;,
                        dept:{}
                    },
                ]
            }
        },
        methods: {
            sorts(a, b) {
                return a.age - b.age;
            },
            showDept(row, column, cellValue, index){
                console.log(row);
                console.log(column);
                console.log(cellValue);
                console.log(index);
                if(cellValue){
                    return cellValue
                }
                return &amp;quot;暂无部门&amp;quot;;
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3表格属性&#34;&gt;3.表格属性&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-table :data=&amp;quot;tableData&amp;quot; empty-text=&amp;quot;暂无数据&amp;quot; :row-class-name=&amp;quot;showCss&amp;quot; highlight-current-row :show-header=&amp;quot;true&amp;quot; :fit=&amp;quot;true&amp;quot;
              size=&amp;quot;mini&amp;quot; :height=&amp;quot;600&amp;quot; border&amp;gt;

&amp;lt;/el-table&amp;gt;
&amp;lt;script&amp;gt;
  .....
	methods: {
            showCss({row, rowIndex}) {
                if (rowIndex % 2 == 0) {
                    return &amp;quot;warning-row&amp;quot;;
                }
                return &amp;quot;success-row&amp;quot;;
            }
        }
 &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4组件事件使用&#34;&gt;4.组件事件使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-table @事件名=&amp;quot;事件处理函数名&amp;quot;&amp;gt;&amp;lt;el-table&amp;gt;

&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Tables&amp;quot;,
        data() {
            //....
        },
        methods: {
            //...事件处理函数
            selectRow(selection, row){
                console.log(selection);
                console.log(row);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5组件方法的使用&#34;&gt;5.组件方法的使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-table  ref=&amp;quot;mytable&amp;quot;&amp;gt;........&amp;lt;/el-table&amp;gt;
//调用方法
	this.$refs.mytable.方法名  
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6表格中定义操作列&#34;&gt;6.表格中定义操作列&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-table&amp;gt;
  ....
	 &amp;lt;el-table-column label=&amp;quot;操作&amp;quot;&amp;gt;
      &amp;lt;template slot-scope=&amp;quot;scope&amp;quot;&amp;gt;
        &amp;lt;el-button
          size=&amp;quot;mini&amp;quot;
          @click=&amp;quot;handleEdit(scope.$index, scope.row)&amp;quot;&amp;gt;编辑&amp;lt;/el-button&amp;gt;
        &amp;lt;el-button
          size=&amp;quot;mini&amp;quot;
          type=&amp;quot;danger&amp;quot;
          @click=&amp;quot;handleDelete(scope.$index, scope.row)&amp;quot;&amp;gt;删除&amp;lt;/el-button&amp;gt;
      &amp;lt;/template&amp;gt;
    &amp;lt;/el-table-column&amp;gt;
&amp;lt;/el-table&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Tables&amp;quot;,
        data() {
            .....
        },
        methods: {
						//用来处理编辑和删除的事件函数
            handleEdit(index,row){
                console.log(index);
                console.log(row);
            },
            handleDelete(index,row){
                console.log(index);
                console.log(row);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606975770913.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/h2&gt;
&lt;h3 id=&#34;7自定义表头&#34;&gt;7.自定义表头&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt; &amp;lt;el-table :data=&amp;quot;tableData.filter(data =&amp;gt; !search || data.name.toLowerCase().includes(search.toLowerCase()))&amp;quot; &amp;gt;
   .....
   &amp;lt;!--展示搜索和操作--&amp;gt;
   &amp;lt;el-table-column&amp;gt;
        &amp;lt;template slot=&amp;quot;header&amp;quot; slot-scope=&amp;quot;scope&amp;quot;&amp;gt;
          &amp;lt;el-input
            v-model=&amp;quot;search&amp;quot;
            size=&amp;quot;mini&amp;quot;
            placeholder=&amp;quot;输入关键字搜索&amp;quot;/&amp;gt;
        &amp;lt;/template&amp;gt;
        &amp;lt;template slot-scope=&amp;quot;scope&amp;quot;&amp;gt;
          &amp;lt;el-button
            size=&amp;quot;mini&amp;quot;
            @click=&amp;quot;handleEdit(scope.$index, scope.row)&amp;quot;&amp;gt;编辑&amp;lt;/el-button&amp;gt;
          &amp;lt;el-button
            size=&amp;quot;mini&amp;quot;
            type=&amp;quot;danger&amp;quot;
            @click=&amp;quot;handleDelete(scope.$index, scope.row)&amp;quot;&amp;gt;删除&amp;lt;/el-button&amp;gt;
        &amp;lt;/template&amp;gt;
      &amp;lt;/el-table-column&amp;gt;
&amp;lt;/el-table&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Tables&amp;quot;,
        data() {
            return {
                tableData: [
                    {
                        id: 21, name: &amp;quot;小陈&amp;quot;, age: 23, email: &amp;quot;60037647@qq.com&amp;quot;,
                        dept: {id: 1, name: &amp;quot;研发部&amp;quot;}
                    },
                    {
                        id: 22, name: &amp;quot;小张&amp;quot;, age: 25, email: &amp;quot;60038647@qq.com&amp;quot;,
                        dept: {id: 1, name: &amp;quot;小卖部&amp;quot;}
                    },
                    {
                        id: 23, name: &amp;quot;小李&amp;quot;, age: 25, email: &amp;quot;60038657@qq.com&amp;quot;,
                        dept: {}
                    },
                    {
                        id: 24, name: &amp;quot;小四&amp;quot;, age: 25, email: &amp;quot;60038657@qq.com&amp;quot;,
                        dept: {}
                    },
                ],
                search: &#39;&#39;
            }
        },
        methods: {
            sorts(a, b) {
                return a.age - b.age;
            },
            showDept(row, column, cellValue, index) {
                if (cellValue) {
                    return cellValue
                }
                return &amp;quot;暂无部门&amp;quot;;
            },
            showCss({row, rowIndex}) {
                if (rowIndex % 2 == 0) {
                    return &amp;quot;warning-row&amp;quot;;
                }
                return &amp;quot;success-row&amp;quot;;
            },
            selectRow(selection, row){
                console.log(selection);
                console.log(row);
            },
            clearSelect(){
                this.$refs.mytable.clearSelection();
            },
            handleEdit(index,row){
                console.log(index);
                console.log(row);
            },
            handleDelete(index,row){
                console.log(index);
                console.log(row);
            }
        }
    }
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606975779180.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;鸣谢：源自&lt;a href=&#34;https://www.bilibili.com/video/BV1NK4y187XH&#34;&gt;视频教程-陈老师&lt;/a&gt;&lt;/p&gt;
">Element UI 实战教程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/can-ting-lian-xi-css-xuan-ze-qi/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://github.com/Tyloo-code/Restaurant&#34;&gt;点此下载&lt;/a&gt;&lt;br&gt;
第一关&lt;br&gt;
plate&lt;br&gt;
plate元素&lt;/p&gt;
&lt;p&gt;第二关&lt;br&gt;
bento&lt;br&gt;
bento元素&lt;/p&gt;
&lt;p&gt;第三关&lt;br&gt;
#fancy&lt;br&gt;
id为fancy的元素&lt;/p&gt;
&lt;p&gt;第四关&lt;br&gt;
plate apple&lt;br&gt;
plate祖先元素下的apple后代元素&lt;/p&gt;
&lt;p&gt;第五关&lt;br&gt;
#fancy pickle&lt;br&gt;
id为#fancy的祖先元素下的pickle后代元素&lt;/p&gt;
&lt;p&gt;第六关&lt;br&gt;
.small&lt;br&gt;
组为small的元素&lt;/p&gt;
&lt;p&gt;第七关&lt;br&gt;
orange.small&lt;br&gt;
组为small的orange元素&lt;/p&gt;
&lt;p&gt;第八关&lt;br&gt;
bento&amp;gt;orange.small&lt;br&gt;
bento父元素下的组为small的orange子元素&lt;/p&gt;
&lt;p&gt;第九关&lt;br&gt;
plate,bento,div&lt;br&gt;
plate,bento兄弟元素在div元素中&lt;/p&gt;
&lt;p&gt;第十关&lt;br&gt;
*&lt;br&gt;
*代表所有元素&lt;/p&gt;
&lt;p&gt;第十一关&lt;br&gt;
plate&amp;gt;*&lt;br&gt;
plate父元素的所有子元素&lt;/p&gt;
&lt;p&gt;第十二关&lt;br&gt;
plate + apple&lt;br&gt;
兄弟元素选择器，plate元素的后一个元素&lt;/p&gt;
&lt;p&gt;第十三关&lt;br&gt;
bento~pickle&lt;br&gt;
兄弟元素选择器,bento元素后的多个pickle元素&lt;/p&gt;
&lt;p&gt;第十四关&lt;br&gt;
plate&amp;gt;apple&lt;br&gt;
plate父元素下的apple子元素&lt;/p&gt;
&lt;p&gt;第十五关&lt;br&gt;
plate orange:first-child&lt;br&gt;
子元素选择器，plate元素下的第一个orange元素&lt;/p&gt;
&lt;p&gt;第十六关&lt;br&gt;
plate :only-child&lt;br&gt;
所有plate元素下的元素&lt;/p&gt;
&lt;p&gt;第十七关&lt;br&gt;
.small:last-child&lt;br&gt;
id为fancy的元素的最后一个和pickle元素的最后一个&lt;/p&gt;
&lt;p&gt;第十八关&lt;br&gt;
plate:nth-child(3)&lt;br&gt;
div元素中的第三个plate元素&lt;/p&gt;
&lt;p&gt;第十九关&lt;br&gt;
bento:nth-of-type(1)&lt;br&gt;
第N个最后一个孩子选择器&lt;/p&gt;
&lt;p&gt;第二十关&lt;br&gt;
apple:first-of-type&lt;br&gt;
第一个apple元素&lt;/p&gt;
&lt;p&gt;第二十一关&lt;br&gt;
plate:nth-of-type(even)&lt;br&gt;
所有偶数个的plate元素&lt;/p&gt;
&lt;p&gt;第二十二关&lt;br&gt;
plate:nth-of-type(2n+3)&lt;br&gt;
同类型的，每2个选择一个plate，从第3 个开始，包括第3个&lt;/p&gt;
&lt;p&gt;第二十三关&lt;br&gt;
plate apple.small:only-of-type&lt;br&gt;
plate元素下满足apple.small元素的唯一一个元素&lt;/p&gt;
&lt;p&gt;第二十四关&lt;br&gt;
orange.small:last-of-type,apple.small:last-of-type&lt;br&gt;
是orange.samll和apple.small元素的最后一个元素&lt;/p&gt;
&lt;p&gt;第二十五关&lt;br&gt;
bento:empty&lt;br&gt;
bento元素里没有包括额外元素&lt;/p&gt;
&lt;p&gt;第二十六关&lt;br&gt;
apple:not(.small)&lt;br&gt;
apple里没有组是.small的元素&lt;/p&gt;
">餐厅练习-Css选择器</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/vue-cong-ru-men-dao-wei-wan-dai-xu/"" data-c="
          &lt;h1 id=&#34;vue-day-01&#34;&gt;Vue Day 01&lt;/h1&gt;
&lt;h3 id=&#34;一-邂逅vuejs&#34;&gt;一. 邂逅Vuejs&lt;/h3&gt;
&lt;h4 id=&#34;11-认识vuejs&#34;&gt;1.1. 认识Vuejs&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;为什么学习Vuejs&lt;/li&gt;
&lt;li&gt;Vue的读音&lt;/li&gt;
&lt;li&gt;Vue的渐进式&lt;/li&gt;
&lt;li&gt;Vue的特点&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;12-安装vue&#34;&gt;1.2. 安装Vue&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;CDN引入&lt;/li&gt;
&lt;li&gt;下载引入&lt;/li&gt;
&lt;li&gt;npm安装&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;13-vue的初体验&#34;&gt;1.3. Vue的初体验&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Hello Vuejs
&lt;ul&gt;
&lt;li&gt;mustache -&amp;gt; 体验vue响应式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Vue列表展示
&lt;ul&gt;
&lt;li&gt;v-for&lt;/li&gt;
&lt;li&gt;后面给数组追加元素的时候, 新的元素也可以在界面中渲染出来&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Vue计数器小案例
&lt;ul&gt;
&lt;li&gt;事件监听: click -&amp;gt; methods&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;14-vue中的mvvm&#34;&gt;1.4. Vue中的MVVM&lt;/h4&gt;
&lt;h4 id=&#34;15-创建vue时-options可以放那些东西&#34;&gt;1.5. 创建Vue时, options可以放那些东西&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;el:&lt;/li&gt;
&lt;li&gt;data:&lt;/li&gt;
&lt;li&gt;methods:&lt;/li&gt;
&lt;li&gt;生命周期函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二插值语法&#34;&gt;二.插值语法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;mustache语法&lt;/li&gt;
&lt;li&gt;v-once&lt;/li&gt;
&lt;li&gt;v-html&lt;/li&gt;
&lt;li&gt;v-text&lt;/li&gt;
&lt;li&gt;v-pre: {{}}&lt;/li&gt;
&lt;li&gt;v-cloak: 斗篷&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三-v-bind&#34;&gt;三. v-bind&lt;/h3&gt;
&lt;h4 id=&#34;31-v-bind绑定基本属性&#34;&gt;3.1. v-bind绑定基本属性&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;v-bind:sr&lt;/li&gt;
&lt;li&gt;:href&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;32-v-bind动态绑定class&#34;&gt;3.2. v-bind动态绑定class&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;对象语法: 作业 :class=&#39;{类名: boolean}&#39;&lt;/li&gt;
&lt;li&gt;数组语法:&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;33-v-bind动态绑定style&#34;&gt;3.3. v-bind动态绑定style&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;对象语法:&lt;/li&gt;
&lt;li&gt;数组语法:&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;四-计算属性&#34;&gt;四. 计算属性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;案例一: firstName+lastName&lt;/li&gt;
&lt;li&gt;案例二: books -&amp;gt; price&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;vue-day-02&#34;&gt;Vue Day 02&lt;/h1&gt;
&lt;h3 id=&#34;一-计算属性&#34;&gt;一. 计算属性&lt;/h3&gt;
&lt;h4 id=&#34;11-计算属性的本质&#34;&gt;1.1. 计算属性的本质&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;fullname: {set(), get()}&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;12-计算属性和methods对比&#34;&gt;1.2. 计算属性和methods对比&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;计算属性在多次使用时, 只会调用一次.&lt;/li&gt;
&lt;li&gt;它是由缓存的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二-事件监听&#34;&gt;二. 事件监听&lt;/h3&gt;
&lt;h4 id=&#34;21-事件监听基本使用&#34;&gt;2.1. 事件监听基本使用&lt;/h4&gt;
&lt;h4 id=&#34;22-参数问题&#34;&gt;2.2. 参数问题&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;btnClick&lt;/li&gt;
&lt;li&gt;btnClick(event)&lt;/li&gt;
&lt;li&gt;btnClick(abc, event) -&amp;gt; $event&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;23-修饰符&#34;&gt;2.3. 修饰符&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;stop&lt;/li&gt;
&lt;li&gt;prevent&lt;/li&gt;
&lt;li&gt;.enter&lt;/li&gt;
&lt;li&gt;.once&lt;/li&gt;
&lt;li&gt;.native&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三-条件判断&#34;&gt;三. 条件判断&lt;/h3&gt;
&lt;h4 id=&#34;31-v-ifv-else-ifv-else&#34;&gt;3.1. v-if/v-else-if/v-else&lt;/h4&gt;
&lt;h4 id=&#34;32-登录小案例&#34;&gt;3.2. 登录小案例&lt;/h4&gt;
&lt;h4 id=&#34;33-v-show&#34;&gt;3.3. v-show&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;v-show和v-if区别&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;四-循环遍历&#34;&gt;四. 循环遍历&lt;/h3&gt;
&lt;h4 id=&#34;41-遍历数组&#34;&gt;4.1. 遍历数组&lt;/h4&gt;
&lt;h4 id=&#34;42-遍历对象&#34;&gt;4.2. 遍历对象&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;value&lt;/li&gt;
&lt;li&gt;value, key&lt;/li&gt;
&lt;li&gt;value, key, index&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;43-数组哪些方法是响应式的&#34;&gt;4.3. 数组哪些方法是响应式的&lt;/h4&gt;
&lt;h4 id=&#34;44-作业完成&#34;&gt;4.4. 作业完成&lt;/h4&gt;
&lt;h3 id=&#34;五-书籍案例&#34;&gt;五. 书籍案例&lt;/h3&gt;
&lt;h3 id=&#34;六-v-model的使用&#34;&gt;六. v-model的使用&lt;/h3&gt;
&lt;h4 id=&#34;61-v-model的基本使用&#34;&gt;6.1. v-model的基本使用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;v-model =&amp;gt; v-bind:value v-on:input&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;62-v-model和radiocheckboxselect&#34;&gt;6.2. v-model和radio/checkbox/select&lt;/h4&gt;
&lt;h4 id=&#34;63-修饰符&#34;&gt;6.3. 修饰符&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;lazy&lt;/li&gt;
&lt;li&gt;number&lt;/li&gt;
&lt;li&gt;trim&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;七-组件化开发&#34;&gt;七. 组件化开发&lt;/h3&gt;
&lt;h4 id=&#34;71-认识组件化&#34;&gt;7.1. 认识组件化&lt;/h4&gt;
&lt;h4 id=&#34;72-组件的基本使用&#34;&gt;7.2. 组件的基本使用&lt;/h4&gt;
&lt;h4 id=&#34;73-全局组件和局部组件&#34;&gt;7.3. 全局组件和局部组件&lt;/h4&gt;
&lt;h4 id=&#34;74-父组件和子组件&#34;&gt;7.4. 父组件和子组件&lt;/h4&gt;
&lt;h4 id=&#34;75-注册的语法糖&#34;&gt;7.5. 注册的语法糖&lt;/h4&gt;
&lt;h4 id=&#34;76-模板的分类写法&#34;&gt;7.6. 模板的分类写法&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;script&lt;/li&gt;
&lt;li&gt;template&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;77-数据的存放&#34;&gt;7.7. 数据的存放&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;子组件不能直接访问父组件&lt;/li&gt;
&lt;li&gt;子组件中有自己的data, 而且必须是一个函数.&lt;/li&gt;
&lt;li&gt;为什么必须是一个函数.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;78-父子组件的通信&#34;&gt;7.8. 父子组件的通信&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;父传子: props&lt;/li&gt;
&lt;li&gt;子传父: $emit&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;79-项目&#34;&gt;7.9. 项目&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;npm install&lt;/li&gt;
&lt;li&gt;npm run serve&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;vue-day-03&#34;&gt;Vue Day 03&lt;/h1&gt;
&lt;h3 id=&#34;一-组件化开发&#34;&gt;一. 组件化开发&lt;/h3&gt;
&lt;h4 id=&#34;11-父子组件的访问&#34;&gt;1.1. 父子组件的访问&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;children/refs&lt;/li&gt;
&lt;li&gt;parent/root&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;12-slot的使用&#34;&gt;1.2. slot的使用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;基本使用&lt;/li&gt;
&lt;li&gt;具名插槽&lt;/li&gt;
&lt;li&gt;编译的作用域&lt;/li&gt;
&lt;li&gt;作用域插槽&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二-前端模块化&#34;&gt;二. 前端模块化&lt;/h3&gt;
&lt;h4 id=&#34;21-为什么要使用模块化&#34;&gt;2.1. 为什么要使用模块化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;简单写js代码带来的问题&lt;/li&gt;
&lt;li&gt;闭包引起代码不可复用.&lt;/li&gt;
&lt;li&gt;自己实现了简单的模块化&lt;/li&gt;
&lt;li&gt;AMD/CMD/CommonJS&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;22-es6中模块化的使用&#34;&gt;2.2. ES6中模块化的使用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;export&lt;/li&gt;
&lt;li&gt;import&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三-webpack&#34;&gt;三. webpack&lt;/h3&gt;
&lt;h4 id=&#34;31-什么是webpack&#34;&gt;3.1. 什么是webpack&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;webpack和gulp对比&lt;/li&gt;
&lt;li&gt;webpack依赖环境&lt;/li&gt;
&lt;li&gt;安装webpack&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;32-webpack的起步&#34;&gt;3.2. webpack的起步&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;webpack命令&lt;/li&gt;
&lt;li&gt;webpack配置: webpack.config.js/package.json(scripts)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;33-webpack的loader&#34;&gt;3.3. webpack的loader&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;css-loader/style-loader&lt;/li&gt;
&lt;li&gt;less-loader/less&lt;/li&gt;
&lt;li&gt;url-loader/file-loader&lt;/li&gt;
&lt;li&gt;babel-loader&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;34-webpack中配置vue&#34;&gt;3.4. webpack中配置Vue&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;vue-loader&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;35-webpack的plugin&#34;&gt;3.5. webpack的plugin&lt;/h4&gt;
&lt;h4 id=&#34;36-搭建本地服务器&#34;&gt;3.6. 搭建本地服务器&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;webpack-dev-server&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;37-配置文件的分离&#34;&gt;3.7. 配置文件的分离&lt;/h4&gt;
&lt;h3 id=&#34;四-vue-cli&#34;&gt;四. Vue CLI&lt;/h3&gt;
&lt;h4 id=&#34;41-什么是cli&#34;&gt;4.1. 什么是CLI&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;脚手架是什么东西.&lt;/li&gt;
&lt;li&gt;CLI依赖webpack,node,npm&lt;/li&gt;
&lt;li&gt;安装CLI3 -&amp;gt; 拉去CLI2模块&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;42-cli2初始化项目的过程&#34;&gt;4.2. CLI2初始化项目的过程&lt;/h4&gt;
&lt;h4 id=&#34;43-cli2生产的目录结构的解析&#34;&gt;4.3. CLI2生产的目录结构的解析&lt;/h4&gt;
&lt;p&gt;export(导出)/import(导入)&lt;/p&gt;
&lt;p&gt;.vue&lt;/p&gt;
&lt;p&gt;dist -&amp;gt; distribution(发布)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;webpack ./src/main.js ./dist/bundle.js&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;开发时依赖&lt;/p&gt;
&lt;p&gt;运行时依赖&lt;/p&gt;
&lt;h1 id=&#34;vue-day-04&#34;&gt;Vue Day 04&lt;/h1&gt;
&lt;h3 id=&#34;一-vue-cli&#34;&gt;一. Vue CLI&lt;/h3&gt;
&lt;h4 id=&#34;11-runtime-compiler和runtime-only的区别&#34;&gt;1.1. runtime-compiler和runtime-only的区别&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ESLint到底是什么?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;template -&amp;gt; ast -&amp;gt; render -&amp;gt; vdom -&amp;gt; 真实DOM&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;render: (h) =&amp;gt; h, -&amp;gt; createElement&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;12-vue-cli3&#34;&gt;1.2. Vue CLI3&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;如何通过CLI3创建项目&lt;/li&gt;
&lt;li&gt;CLI3的目录结构&lt;/li&gt;
&lt;li&gt;配置文件: 1.Vue UI 2.隐藏的配置文件 3.自定义vue.config.js&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二-vue-router&#34;&gt;二. Vue-Router&lt;/h3&gt;
&lt;h4 id=&#34;21-什么是前端路由&#34;&gt;2.1. 什么是前端路由&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;后端渲染\后端路由&lt;/li&gt;
&lt;li&gt;前后端分离&lt;/li&gt;
&lt;li&gt;SPA\前端路由&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;22-路由的基本配置&#34;&gt;2.2. 路由的基本配置&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;安装vue-router&lt;/li&gt;
&lt;li&gt;Vue.use -&amp;gt; 创建VueRouter对象 -&amp;gt; 挂在到Vue实例上&lt;/li&gt;
&lt;li&gt;配置映射关系: 1.创建组件 2.配置映射关系 3.使用router-link/router-view&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;23-细节处理&#34;&gt;2.3. 细节处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;默认路由: redirect&lt;/li&gt;
&lt;li&gt;mode: history&lt;/li&gt;
&lt;li&gt;router-link -&amp;gt; tag/replace/active-class&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;24-动态路由&#34;&gt;2.4. 动态路由&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;/user/:id&lt;/li&gt;
&lt;li&gt;this.$route.params.id&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;25-参数的传递&#34;&gt;2.5. 参数的传递&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;params&lt;/li&gt;
&lt;li&gt;query -&amp;gt; URL&lt;/li&gt;
&lt;li&gt;URL:
&lt;ul&gt;
&lt;li&gt;协议://主机:端口/路径?查询&lt;/li&gt;
&lt;li&gt;scheme://host:port/path?query#fragment&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;26-路由嵌套&#34;&gt;2.6. 路由嵌套&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;children: []&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;27-导航守卫&#34;&gt;2.7. 导航守卫&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;全局导航守卫&lt;/li&gt;
&lt;li&gt;路由独享守卫&lt;/li&gt;
&lt;li&gt;组件类守卫&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;28-keep-alive&#34;&gt;2.8. Keep-alive&lt;/h4&gt;
&lt;h4 id=&#34;29-tabbar的封装过程&#34;&gt;2.9. TabBar的封装过程&lt;/h4&gt;
&lt;p&gt;C:\Users\Administrator\AppData\Roaming&lt;/p&gt;
&lt;p&gt;vue init webpack project&lt;/p&gt;
&lt;p&gt;runtime+compiler和runtime-only&lt;/p&gt;
&lt;p&gt;template -&amp;gt; ast -&amp;gt; render -&amp;gt; virtual dom -&amp;gt; 真实DOM&lt;/p&gt;
&lt;p&gt;vue2.5.21 -&amp;gt; vue2.x -&amp;gt; flow-type(facebook)&lt;/p&gt;
&lt;p&gt;Vue3.x -&amp;gt; TypeScript(micro(微小)soft(软件))&lt;/p&gt;
&lt;p&gt;future: 将来/未来&lt;/p&gt;
&lt;p&gt;fut: 特性&lt;/p&gt;
&lt;p&gt;rc -&amp;gt; run command&lt;/p&gt;
&lt;p&gt;vcs -&amp;gt; version control system(版本控制git/svn)&lt;/p&gt;
&lt;p&gt;什么是前端渲染, 什么是后端渲染?&lt;/p&gt;
&lt;p&gt;什么是前后端分离?&lt;/p&gt;
&lt;p&gt;什么是前端路由, 什么是后端路由?&lt;/p&gt;
&lt;p&gt;href -&amp;gt; hyper reference&lt;/p&gt;
&lt;h1 id=&#34;vue-day-05&#34;&gt;Vue Day 05&lt;/h1&gt;
&lt;h3 id=&#34;一-promise&#34;&gt;一. Promise&lt;/h3&gt;
&lt;h4 id=&#34;11-promise的基本使用&#34;&gt;1.1. Promise的基本使用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;如何将异步操作放入到promise中&lt;/li&gt;
&lt;li&gt;(resolve, reject) =&amp;gt; then/catch&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;12-promise的链式调用&#34;&gt;1.2. Promise的链式调用&lt;/h4&gt;
&lt;h4 id=&#34;13-promise的all方法&#34;&gt;1.3. Promise的all方法&lt;/h4&gt;
&lt;h3 id=&#34;二-vuex&#34;&gt;二. Vuex&lt;/h3&gt;
&lt;h4 id=&#34;21-什么是状态管理&#34;&gt;2.1. 什么是状态管理&lt;/h4&gt;
&lt;h4 id=&#34;22-vuex的基本使用&#34;&gt;2.2. Vuex的基本使用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;state -&amp;gt; 直接修改state(错误)&lt;/li&gt;
&lt;li&gt;mutations -&amp;gt; devtools&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;23-核心概念&#34;&gt;2.3. 核心概念&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;state -&amp;gt; 单一状态树&lt;/li&gt;
&lt;li&gt;getters -&amp;gt;&lt;/li&gt;
&lt;li&gt;mutations -&amp;gt;&lt;/li&gt;
&lt;li&gt;actions -&amp;gt; 异步操作(Promise)&lt;/li&gt;
&lt;li&gt;modules&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;24-目录组织方式&#34;&gt;2.4. 目录组织方式&lt;/h4&gt;
&lt;h3 id=&#34;三-网络请求封装&#34;&gt;三. 网络请求封装&lt;/h3&gt;
&lt;h4 id=&#34;31-网络请求方式的选择&#34;&gt;3.1. 网络请求方式的选择&lt;/h4&gt;
&lt;h4 id=&#34;32-axios的基本使用&#34;&gt;3.2. axios的基本使用&lt;/h4&gt;
&lt;h4 id=&#34;33-axios的相关配置&#34;&gt;3.3. axios的相关配置&lt;/h4&gt;
&lt;h4 id=&#34;34-axios的创建实例&#34;&gt;3.4. axios的创建实例&lt;/h4&gt;
&lt;h4 id=&#34;35-axios的封装&#34;&gt;3.5. axios的封装&lt;/h4&gt;
&lt;h4 id=&#34;36-axios的拦截器&#34;&gt;3.6. axios的拦截器&lt;/h4&gt;
&lt;h3 id=&#34;四-项目开发&#34;&gt;四. 项目开发&lt;/h3&gt;
&lt;h4 id=&#34;41-划分目录结构&#34;&gt;4.1. 划分目录结构&lt;/h4&gt;
&lt;h4 id=&#34;42-引用了两个css文件&#34;&gt;4.2. 引用了两个css文件&lt;/h4&gt;
&lt;h4 id=&#34;43-vueconfigjs和editorconfig&#34;&gt;4.3. vue.config.js和.editorconfig&lt;/h4&gt;
&lt;h4 id=&#34;44-项目的模块划分-tabbar-路由映射关系&#34;&gt;4.4. 项目的模块划分: tabbar -&amp;gt; 路由映射关系&lt;/h4&gt;
&lt;h4 id=&#34;45-首页开发&#34;&gt;4.5. 首页开发&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;navbar 的封装&lt;/li&gt;
&lt;li&gt;网络数据的请求&lt;/li&gt;
&lt;li&gt;轮播图&lt;/li&gt;
&lt;li&gt;推荐信息&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;git remote add origin https://github.com/coderwhy/testmall.git
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sync -&amp;gt; 同步&lt;/p&gt;
&lt;p&gt;async -&amp;gt; 异步&lt;/p&gt;
&lt;p&gt;aysnc operation: 操作&lt;/p&gt;
&lt;p&gt;xcode/iphonex/xml&lt;/p&gt;
&lt;p&gt;token -&amp;gt;&lt;/p&gt;
&lt;p&gt;linus -&amp;gt; linux/git&lt;/p&gt;
&lt;h1 id=&#34;vue-day-06&#34;&gt;Vue Day 06&lt;/h1&gt;
&lt;p&gt;goods: (流行/新款/精选)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;goods: {
  &#39;pop&#39;: {page: 5, list: [150]},
  &#39;news&#39;: {page: 2, list: [60]},
  &#39;sell&#39;: {page: 1, list: [30]}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref如果是绑定在组件中的, 那么通过&lt;strong&gt;this.$refs.refname&lt;/strong&gt;获取到的是一个组件对象.&lt;/p&gt;
&lt;p&gt;ref如果是绑定在普通的元素中, 那么通过&lt;strong&gt;this.$refs.refname&lt;/strong&gt;获取到的是一个元素对象.&lt;/p&gt;
&lt;p&gt;44 + 49 = 93&lt;/p&gt;
&lt;p&gt;vh -&amp;gt; viewport height&lt;/p&gt;
&lt;p&gt;568(100%) - 98 = 470&lt;/p&gt;
&lt;p&gt;修饰.native修饰什么时候使用?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在我们需要监听一个组件的原生事件时, 必须给对应的事件加上.native修饰符, 才能进行监听.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计算机中没有黑魔法.&lt;/p&gt;
&lt;h1 id=&#34;vue-day-07&#34;&gt;Vue Day 07&lt;/h1&gt;
&lt;h3 id=&#34;一-featureview&#34;&gt;一. FeatureView&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;独立组件封装FeatureView
&lt;ul&gt;
&lt;li&gt;div&amp;gt;a&amp;gt;img&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二-tabcontrol&#34;&gt;二. TabControl&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;独立组件的封装
&lt;ul&gt;
&lt;li&gt;props -&amp;gt; titles&lt;/li&gt;
&lt;li&gt;div&amp;gt;根据titles v-for遍历 div -&amp;gt; span{{title}}&lt;/li&gt;
&lt;li&gt;css相关&lt;/li&gt;
&lt;li&gt;选中哪一个tab, 哪一个tab的文字颜色变色, 下面border-bottom
&lt;ul&gt;
&lt;li&gt;currentIndex&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三-首页商品数据的请求&#34;&gt;三. 首页商品数据的请求&lt;/h3&gt;
&lt;h4 id=&#34;31-设计数据结构-用于保存数据&#34;&gt;3.1. 设计数据结构, 用于保存数据&lt;/h4&gt;
&lt;p&gt;goods: {&lt;/p&gt;
&lt;p&gt;pop: page/list&lt;/p&gt;
&lt;p&gt;new: page/list&lt;/p&gt;
&lt;p&gt;sell: page/list&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h4 id=&#34;32-发送数据请求&#34;&gt;3.2. 发送数据请求&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在home.js中封装getHomeGoods(type, page)&lt;/li&gt;
&lt;li&gt;在Home.vue中, 又在methods中getHomeGoods(type)&lt;/li&gt;
&lt;li&gt;调用getHomeGoods(&#39;pop&#39;)/getHomeGoods(&#39;new&#39;)/getHomeGoods(&#39;sell&#39;)
&lt;ul&gt;
&lt;li&gt;page: 动态的获取对应的page&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;获取到数据: res
&lt;ul&gt;
&lt;li&gt;this.goods[type].list.push(...res.data.list)&lt;/li&gt;
&lt;li&gt;this.goods[type].page += 1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;goods: {&lt;/p&gt;
&lt;p&gt;pop: page1:/list[30]&lt;/p&gt;
&lt;p&gt;new: page1/list[30]&lt;/p&gt;
&lt;p&gt;sell: page1/list[30]&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h3 id=&#34;四-对商品数据进行展示&#34;&gt;四. 对商品数据进行展示&lt;/h3&gt;
&lt;h4 id=&#34;41-封装goodslistvue组件&#34;&gt;4.1. 封装GoodsList.vue组件&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;props: goods -&amp;gt; list[30]&lt;/li&gt;
&lt;li&gt;v-for goods -&amp;gt; GoodsListItem[30]&lt;/li&gt;
&lt;li&gt;GoodListItem(组件) -&amp;gt; GoodsItem(数据)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;42-封装goodslistitemvue组件&#34;&gt;4.2. 封装GoodsListItem.vue组件&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;props: goodsItem&lt;/li&gt;
&lt;li&gt;goodsItem 取出数据, 并且使用正确的div/span/img基本标签进行展示&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;五-对滚动进行重构-better-scroll&#34;&gt;五. 对滚动进行重构: Better-Scroll&lt;/h3&gt;
&lt;h4 id=&#34;51-在indexhtml中使用better-scroll&#34;&gt;5.1. 在index.html中使用Better-Scroll&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;const bscroll = new BScroll(el, {   })&lt;/li&gt;
&lt;li&gt;注意: wrapper -&amp;gt; content -&amp;gt; 很多内容&lt;/li&gt;
&lt;li&gt;1.监听滚动
&lt;ul&gt;
&lt;li&gt;probeType: 0/1/2(手指滚动)/3(只要是滚动)&lt;/li&gt;
&lt;li&gt;bscroll .on(&#39;scroll&#39;, (position) =&amp;gt; {})&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2.上拉加载
&lt;ul&gt;
&lt;li&gt;pullUpLoad: true&lt;/li&gt;
&lt;li&gt;bscroll .on(&#39;pullingUp&#39;, () =&amp;gt; {})&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3.click: false
&lt;ul&gt;
&lt;li&gt;button可以监听点击&lt;/li&gt;
&lt;li&gt;div不可以&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;52-在vue项目中使用better-scroll&#34;&gt;5.2. 在Vue项目中使用Better-Scroll&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在Profile.vue中简单的演示&lt;/li&gt;
&lt;li&gt;对Better-Scroll进行封装: Scroll.vue&lt;/li&gt;
&lt;li&gt;Home.vue和Scroll.vue之间进行通信
&lt;ul&gt;
&lt;li&gt;Home.vue将probeType设置为3&lt;/li&gt;
&lt;li&gt;Scroll.vue需要通过$emit, 实时将事件发送到Home.vue&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;六-回到顶部backtop&#34;&gt;六. 回到顶部BackTop&lt;/h3&gt;
&lt;h4 id=&#34;61-对backtopvue组件的封装&#34;&gt;6.1. 对BackTop.vue组件的封装&lt;/h4&gt;
&lt;h4 id=&#34;62-如何监听组件的点击&#34;&gt;6.2. 如何监听组件的点击&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;直接监听back-top的点击, 但是可以直接监听?
&lt;ul&gt;
&lt;li&gt;不可以, 必须添加修饰.native&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;回到顶部
&lt;ul&gt;
&lt;li&gt;scroll对象, scroll.scrollTo(x, y, time)&lt;/li&gt;
&lt;li&gt;this.$refs.scroll.scrollTo(0, 0, 500)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;63-backtop组件的显示和隐藏&#34;&gt;6.3. BackTop组件的显示和隐藏&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;isShowBackTop: false&lt;/li&gt;
&lt;li&gt;监听滚动, 拿到滚动的位置:
&lt;ul&gt;
&lt;li&gt;-position.y &amp;gt; 1000  -&amp;gt; isShowBackTop: true&lt;/li&gt;
&lt;li&gt;isShowBackTop = -position.y &amp;gt; 1000&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;七-解决首页中可滚动区域的问题&#34;&gt;七. 解决首页中可滚动区域的问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Better-Scroll在决定有多少区域可以滚动时, 是根据scrollerHeight属性决定&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scrollerHeight属性是根据放Better-Scroll的content中的子组件的高度&lt;/li&gt;
&lt;li&gt;但是我们的首页中, 刚开始在计算scrollerHeight属性时, 是没有将图片计算在内的&lt;/li&gt;
&lt;li&gt;所以, 计算出来的告诉是错误的(1300+)&lt;/li&gt;
&lt;li&gt;后来图片加载进来之后有了新的高度, 但是scrollerHeight属性并没有进行更新.&lt;/li&gt;
&lt;li&gt;所以滚动出现了问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何解决这个问题了?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监听每一张图片是否加载完成, 只要有一张图片加载完成了, 执行一次refresh()&lt;/li&gt;
&lt;li&gt;如何监听图片加载完成了?
&lt;ul&gt;
&lt;li&gt;原生的js监听图片: img.onload = function() {}&lt;/li&gt;
&lt;li&gt;Vue中监听: @load=&#39;方法&#39;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调用scroll的refresh()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何将GoodsListItem.vue中的事件传入到Home.vue中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为涉及到非父子组件的通信, 所以这里我们选择了&lt;strong&gt;事件总线&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;bus -&amp;gt;总线&lt;/li&gt;
&lt;li&gt;Vue.prototype.$bus = new Vue()&lt;/li&gt;
&lt;li&gt;this.bus.emit(&#39;事件名称&#39;, 参数)&lt;/li&gt;
&lt;li&gt;this.bus.on(&#39;事件名称&#39;, 回调函数(参数))&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;问题一: refresh找不到的问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一: 在Scroll.vue中, 调用this.scroll的方法之前, 判断this.scroll对象是否有值&lt;/li&gt;
&lt;li&gt;第二: 在mounted生命周期函数中使用 this.$refs.scroll而不是created中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;问题二: 对于refresh非常频繁的问题, 进行防抖操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;防抖debounce/节流throttle(课下研究一下)&lt;/li&gt;
&lt;li&gt;防抖函数起作用的过程:
&lt;ul&gt;
&lt;li&gt;如果我们直接执行refresh, 那么refresh函数会被执行30次.&lt;/li&gt;
&lt;li&gt;可以将refresh函数传入到debounce函数中, 生成一个新的函数.&lt;/li&gt;
&lt;li&gt;之后在调用非常频繁的时候, 就使用新生成的函数.&lt;/li&gt;
&lt;li&gt;而新生成的函数, 并不会非常频繁的调用, 如果下一次执行来的非常快, 那么会将上一次取消掉&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      debounce(func, delay) {
        let timer = null
        return function (...args) {
          if (timer) clearTimeout(timer)
          timer = setTimeout(() =&amp;gt; {
            func.apply(this, args)
          }, delay)
        }
      },
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;八-上拉加载更多的功能&#34;&gt;八. 上拉加载更多的功能&lt;/h3&gt;
&lt;p&gt;y  ifu&lt;/p&gt;
&lt;h3 id=&#34;九-tabcontrol的吸顶效果&#34;&gt;九. tabControl的吸顶效果&lt;/h3&gt;
&lt;h4 id=&#34;91-获取到tabcontrol的offsettop&#34;&gt;9.1. 获取到tabControl的offsetTop&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;必须知道滚动到多少时, 开始有吸顶效果, 这个时候就需要获取tabControl的offsetTop&lt;/li&gt;
&lt;li&gt;但是, 如果直接在mounted中获取tabControl的offsetTop, 那么值是不正确.&lt;/li&gt;
&lt;li&gt;如何获取正确的值了?
&lt;ul&gt;
&lt;li&gt;监听HomeSwiper中img的加载完成.&lt;/li&gt;
&lt;li&gt;加载完成后, 发出事件, 在Home.vue中, 获取正确的值.&lt;/li&gt;
&lt;li&gt;补充:
&lt;ul&gt;
&lt;li&gt;为了不让HomeSwiper多次发出事件,&lt;/li&gt;
&lt;li&gt;可以使用isLoad的变量进行状态的记录.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注意: 这里不进行多次调用和debounce的区别&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;92-监听滚动-动态的改变tabcontrol的样式&#34;&gt;9.2. 监听滚动, 动态的改变tabControl的样式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;问题:动态的改变tabControl的样式时, 会出现两个问题:
&lt;ul&gt;
&lt;li&gt;问题一: 下面的商品内容, 会突然上移&lt;/li&gt;
&lt;li&gt;问题二: tabControl虽然设置了fixed, 但是也随着Better-Scroll一起滚出去了.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;其他方案来解决停留问题.
&lt;ul&gt;
&lt;li&gt;在最上面, 多复制了一份PlaceHolderTabControl组件对象, 利用它来实现停留效果.&lt;/li&gt;
&lt;li&gt;当用户滚动到一定位置时, PlaceHolderTabControl显示出来.&lt;/li&gt;
&lt;li&gt;当用户滚动没有达到一定位置时, PlaceHolderTabControl隐藏起来.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;十-让home保持原来的状态&#34;&gt;十. 让Home保持原来的状态&lt;/h3&gt;
&lt;h4 id=&#34;101-让home不要随意销毁掉&#34;&gt;10.1. 让Home不要随意销毁掉&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;keep-alive&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;102-让home中的内容保持原来的位置&#34;&gt;10.2. 让Home中的内容保持原来的位置&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;离开时, 保存一个位置信息saveY.&lt;/li&gt;
&lt;li&gt;进来时, 将位置设置为原来保存的位置saveY信息即可.
&lt;ul&gt;
&lt;li&gt;注意: 最好回来时, 进行一次refresh()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非父子组件通信:&lt;/p&gt;
&lt;p&gt;https://www.jb51.net/article/132371.htm&lt;/p&gt;
">Vue从入门到未完待续</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/windows-xi-tong-xia-typora-wan-quan-shi-yong-xiang-jie/"" data-c="
          &lt;p&gt;最近在用这个软件，亲测确实觉得这个软件比较好用，所以写下这篇文章，分享给大家Typora 是一款极致简洁的 markdown 文本编辑器。 支持即时渲染技术 ，没有编辑工具栏！在快速文字排版以及代码编辑方面的效率是显而易见的，自己感觉比MarkdownPad好用。「它的功能之强大、设计之冷静、体验之美妙、理念之先进，我认为值得所有笔记应用厂商学习。」&lt;/p&gt;
&lt;h2 id=&#34;邂逅typora&#34;&gt;邂逅Typora&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.typora.io/#windows&#34; target=&#34;_blank&#34; style=&#34;&#34;&gt;初遇Typora&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;typora是什么&#34;&gt;Typora是什么？&lt;/h2&gt;
&lt;p&gt;Typora 是一款支持实时预览的 Markdown 文本编辑器。它有 OS X、Windows、Linux 三个平台的版本，并且由于仍在测试中，是完全免费的。&lt;/p&gt;
&lt;h2 id=&#34;一个-markdown-文本编辑器&#34;&gt;一个 Markdown 文本编辑器&lt;/h2&gt;
&lt;p&gt;Typora 首先是一个 Markdown 文本编辑器，它支持且仅支持 Markdown 语法的文本编辑。在 Typora 官网 上他们将 Typora 描述为 「A truly minimal markdown editor. 」。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606715264191.png&#34; alt=&#34;官网首页&#34; loading=&#34;lazy&#34;&gt;&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;官网首页&lt;/center&gt;&lt;/p&gt;
&lt;h2 id=&#34;关于markdown&#34;&gt;关于Markdown&lt;/h2&gt;
&lt;p&gt;Markdown 是用来编写结构化文档的一种纯文本格式，它使我们在双手不离开键盘的情况下，可以对文本进行一定程度的格式排版。你可以在&lt;a href=&#34;https://tyloo-code.github.io/post/markdown-ji-ben-yu-fa/&#34;&gt;这篇文章&lt;/a&gt;中快速入门 Markdown。&lt;/p&gt;
&lt;p&gt;由于目前还没有一个权威机构对 Markdown 的语法进行规范，各应用厂商制作时遵循的 Markdown 语法也是不尽相同的。其中比较受到认可的是&lt;a href=&#34;https://Tyloo-code.github.io/post-images/1606715866342.png&#34;&gt;GFM标准&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606718544020.png&#34; alt=&#34;严格模式&#34; loading=&#34;lazy&#34;&gt;&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;严格模式&lt;/center&gt;&lt;/p&gt;
&lt;h2 id=&#34;写得舒服&#34;&gt;写得舒服&lt;/h2&gt;
&lt;p&gt;一个文本编辑器，&lt;strong&gt;写得舒服&lt;/strong&gt;是关键。我曾说过，「更有趣的是，一个笔记应用不会因为它支持 Markdown 语法而高级或易用很多。」，细枝末节处的人性化考虑才是最重要的。而 Typora 的编辑体验显然是经过深思熟虑设计的产物。&lt;/p&gt;
&lt;p&gt;我认为：一个优秀的笔记应用应该给用户&lt;strong&gt;选择 Markdown 语法风格的权利&lt;/strong&gt;。而 Typora 在这一点上是我目前见过所有 Markdown 笔记应用中做得最好的。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606718646444.jpg&#34; alt=&#34;文本编辑设置&#34; loading=&#34;lazy&#34;&gt;&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;文本编辑设置&lt;/center&gt;&lt;br&gt;
通过打开 文件 - 偏好设置 你会发现 Typora 为编辑体验的考虑细致到了令人叹为观止的程度。Typora 中提供了大量有关 Markdown 偏好的设置，据此，你可以构建一个几乎完全适合自己的 Markdown 编辑器。下面我将依次介绍一些与文本编辑体验有关的功能亮点。&lt;/p&gt;
&lt;p&gt;##图片插入&lt;br&gt;
Typora 的图片插入功能是广受好评的。要知道，Markdown 原生不太注重图片插入的功能，但你可以在 Typora 中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接使用 右键 - 复制 Ctrl + V 将网络图片、剪贴板图片复制到文档中&lt;/li&gt;
&lt;li&gt;拖动本地图片到文档中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Typora 会自动帮你插入符合 Markdown 语法的图片语句，并给它加上标题。&lt;/p&gt;
&lt;p&gt;更强大的是，Typora 支持在拖动或 Ctrl + V 网络图片后自动将其保存到本地。你可以在 文件 - 偏好设置 - 编辑器 - 图片插入 中选择复制到哪个路径，什么情况下需要复制。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606719092672.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;图片插入&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;这一功能保证了即使网络图片源失效了，你还有本地的备份可用。同时也能使你的文档文件夹更合理、完整。&lt;/p&gt;
&lt;h2 id=&#34;打字机模式和专注模式&#34;&gt;打字机模式和专注模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;打字机模式&lt;/strong&gt;使得你所编辑的那一行永远处于屏幕正中。&lt;br&gt;
&lt;strong&gt;专注模式&lt;/strong&gt;使你正在编辑的那一行保留颜色，而其他行的字体呈灰色。&lt;/p&gt;
&lt;p&gt;你可以在 视图 - 专注模式 / 打字机模式 中勾选使用这两个模式。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606720738399.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;两种模式&lt;/center&gt; 
&lt;h2 id=&#34;实时预览&#34;&gt;实时预览&lt;/h2&gt;
&lt;p&gt;我想很果断地下这个结论：到现在还不支持编辑界面实时预览的 Markdown 编辑器基本可以退出市场了。Typora 在这一方面显然已经领先了一大步——他们连 Markdown 语法的标记都在实时预览中消去了。当你离开正在编辑的有格式的文本段后，Typora 会自动隐藏 Markdown 标记，只留下 &lt;strong&gt;所见即所得&lt;/strong&gt; 的美妙。他们把这称为&lt;em&gt;Hybrid View&lt;/em&gt; 。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606721116860.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;所见即所得&lt;/center&gt; 
&lt;p&gt;为了防止一些程序 bug 的发生（虽然在我使用下来感到是很少的）导致格式问题无法修改，Typora 保留了一个「源代码模式」。你可以通过 视图 - 源代码模式 或左下角的 &amp;lt;/&amp;gt; 按钮进入。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606721181434.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;源代码模式&lt;/center&gt; 
&lt;h2 id=&#34;大纲-文件侧边栏&#34;&gt;大纲 / 文件侧边栏&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606721243748.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;侧边栏&lt;/center&gt; 
&lt;p&gt;Typora 会根据你 Markdown 标记的 H1、H2、H3…… 各级标题为你呈现一个大纲。&lt;/p&gt;
&lt;p&gt;你也可以选择查看文件夹中的文件，但由于目前 Typora 只支持查看 md 文件，因此我认为文件侧边栏这个功能还是很鸡肋的。&lt;/p&gt;
&lt;h2 id=&#34;空格与换行&#34;&gt;空格与换行&lt;/h2&gt;
&lt;p&gt;Typora 在空格与换行部分主要是使用 &lt;a href=&#34;https://commonmark.org&#34;&gt;CommonMark&lt;/a&gt; 作为标注规范。与前文提到的 GFM 一样，CommonMark 也是比较流行的 Markdown 语言规范（解析器）之一。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;空格：&lt;/strong&gt;&lt;br&gt;
在输入连续的空格后，Typora 会在编辑器视图里为你保留这些空格，但当你打印或导出时，这些空格会被省略成一个。&lt;br&gt;
你可以在源代码模式下，为每个空格前加一个 \ 转义符，或者直接使用 HTML 风格的 &amp;amp;nbps; 来保持连续的空格。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;软换行：&lt;/strong&gt;&lt;br&gt;
需要说明的是，在 Markdown 语法中，换行（line break）与换段是不同的。且换行分为软换行和硬换行。在 Typora 中，你可以通过 Shift + Enter 完成一次软换行。软换行只在编辑界面可见，当文档被导出时换行会被省略。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;硬换行：&lt;/strong&gt;&lt;br&gt;
你可以通过 空格 + 空格 + Shift + Enter 完成一次硬换行，而这也是许多 Markdown 编辑器所原生支持的。硬换行在文档被导出时将被保留，且没有换段的段后距。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;换段：&lt;/strong&gt;&lt;br&gt;
你可以通过 Enter 完成一次换段。Typora 会自动帮你完成两次 Shift + Enter 的软换行，从而完成一次换段。这也意味着在 Markdown 语法下，换段是通过在段与段之间加入空行来实现的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Windows 风格（CR+LF）与 Unix 风格（CR）的换行符：&lt;/strong&gt;&lt;br&gt;
CR 表示回车 \r ，即回到一行的开头，而 LF 表示换行 \n ，即另起一行。&lt;br&gt;
所以 Windows 风格的换行符本质是「回车 + 换行」，而 Unix 风格的换行符是「换行」。这也是为什么 Unix / Mac 系统下的文件，如果在 Windows 系统直接打开会全部在同一行内。 你可以在 文件 - 偏好设置 - 编辑器 - 默认换行符 中对此进行切换。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下附以上各空格、换行、换段的测试结果图。具体内容你可以在官网的 &lt;a href=&#34;http://support.typora.io/Line-Break/&#34;&gt;这篇文档&lt;/a&gt; 中查阅。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606722389444.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;空格、换行、换段&lt;/center&gt; 
&lt;h2 id=&#34;一个学术文档编辑器&#34;&gt;一个学术文档编辑器&lt;/h2&gt;
&lt;p&gt;除了基本的文本编辑体验极佳之外，Typora 还是一个非常优秀的学术文档编辑器。当然作为一个轻量级的、基于 Markdown 的编辑器，它不能与那些 LaTeX 编辑器相提并论，但它仍支持了许多可用于学术写作的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LaTeX&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;LaTeX 是一种基于 TeX 的排版系统，由于它易于快速生成复杂表格和数学公式，非常适用于生成高印刷质量的科技和数学类文档。如果你常阅读数学、计算机等领域的学术论文，你一定对 LaTeX 不陌生。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Typora 原生支持 LaTeX 语法，你有两种方式输入 LaTeX 风格的数学公式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;行内公式（inline）：&lt;/strong&gt; 用 $...$ 括起公式，公式会出现在行内。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;块间公式（display）：&lt;/strong&gt; 用 $$...$$ 括起公式（注意 $$ 后需要换行），公式会默认显示在行中间。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体的 LaTeX 语法在此不赘述了，你可以在 &lt;a href=&#34;https://blog.csdn.net/happyday_d/article/details/83715440&#34;&gt;这篇文章&lt;/a&gt; 中查看。&lt;/p&gt;
&lt;h2 id=&#34;代码高亮&#34;&gt;代码高亮&lt;/h2&gt;
&lt;p&gt;Typora 中代码的插入也可以分为行内和块间两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;行内代码：用`...` 或``...`` 括起代码，代码会以主题中设置的样式出现在行内，但不会实现代码高亮。&lt;/li&gt;
&lt;li&gt;代码块：输入 ``` 后并输入语言名，换行，开始写代码，Typora 就会自动帮你实现代码高亮。Typora 原生支持许多编程语言代码块的语法高亮，基本日常常用的编程语言它都能很好地支持。&lt;br&gt;
除此以外，你也可以直接换行开始写，而后再选择语言。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;链接引用与脚注&#34;&gt;链接引用与脚注&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;链接引用&lt;/strong&gt;类似于我们常在论文末尾看到的「参考文献」的写法，你可以通过 []: 的语法来为你的文档加上链接引用。&lt;br&gt;
&lt;strong&gt;脚注&lt;/strong&gt;在少数派的文章中也很常见，即某段话结尾右上角标有数字标记，页面底部进行注释的写法。你可以在需要插入脚注标号的位置写 [^ number ] ，再在下方通过 [^ number ]: 在文档中插入脚注。注意不要遗漏了脚注编号 number 前后的空格。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606723891564.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;链接引用和脚注
&lt;/center&gt; 
&lt;h2 id=&#34;一个伪装成文本编辑器的浏览器&#34;&gt;一个伪装成文本编辑器的浏览器&lt;/h2&gt;
&lt;p&gt;当我的一个朋友问我「Typora 有什么好写的？」时，我回答「Typora 是一个伪装成文本编辑器的浏览器」。是的，事实上如果你有一定的计算机基础，你可以找到许多有关于「Typora 其实是一个浏览器」的蛛丝马迹。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606724542832.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;图片插入&lt;/p&gt;
&lt;/center&gt; 
&lt;p&gt;在图片插入的选项中，Typora 用了「复制图片到 ./${filename}.assets 文件夹」的说法，而这其实是网页前端常用的 Javascript 字符串模板语法的风格。&lt;/p&gt;
&lt;p&gt;再比如，Typora 将更遵循 GFM 标准的 Markdown 语法模式称为「严格模式 Strict Mode」，这一说法常见于 HTML 和 JavaScript 编程中。类似「源代码模式」的说法也是同理。&lt;/p&gt;
&lt;p&gt;当然，最明显的一点是当你按下 Shift + F12 快捷键时，页面会弹出一个基于 Chrome 的开发者工具栏，也就是我们在浏览器中常说的「审查元素」。&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606724640253.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;审查元素&lt;/p&gt;
&lt;/center&gt; 
&lt;h2 id=&#34;伪装从何而来&#34;&gt;伪装从何而来？&lt;/h2&gt;
&lt;p&gt;当我们把视角放在「Typora 是一个支持 Markdown 语言的文本编辑器」的出发点来考虑这个问题，一切就都显得很明白了。&lt;/p&gt;
&lt;p&gt;John Gruber 在 2004 年用 Perl 创造了 Markdown 语言，这个语言的目的是希望大家使用「易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的 XHTML（或是 HTML）」。也就是说，&lt;strong&gt;在 Markdown 诞生之初，它就是为了被浏览器阅读而设计的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们在用 Markdown 语言撰写文稿的时候，其实本质上是在借助某种编程语言的转化（解析器）来编写一个 HTML 网页。Markdown 从它诞生之初就与 Web 技术有着及其紧密的联系。&lt;/p&gt;
&lt;p&gt;如果我说，我们每一篇文稿都是一个网页，那就很好理解了。Typora 利用解析器先将我们写的 Markdown 文档解析成为 HTML 文档，再为它嵌入一个 CSS 样式，最后再加上可能需要的脚本等。&lt;/p&gt;
&lt;h2 id=&#34;html&#34;&gt;HTML&lt;/h2&gt;
&lt;p&gt;HTML 是一种标记语言，主要负责构成网页的骨架，它包含所有不加装饰的网页元素。在 Typora 的使用场景下则是所有的&lt;strong&gt;文本、段落、标题等&lt;/strong&gt;的记号。&lt;/p&gt;
&lt;p&gt;你可以把一张网页想象成一幅数字油画，HTML 就是那个黑白线条的底，上面写满了数字标记，示意你哪一块区域要涂什么颜色。而 CSS 则负责在对应的区域涂上颜色，甚至加上一些装饰等。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606724955000.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;数字油画
&lt;/center&gt; 
&lt;h3 id=&#34;html-标签&#34;&gt;HTML 标签&lt;/h3&gt;
&lt;p&gt;Typora 支持许多常用的 HTML 标签，如果你了解 HTML 语法的话，你可以写出十分美观丰富的文档页面。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606725029628.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;HTML 标签
&lt;/center&gt; 
&lt;p&gt;事实上你可以在 Typora 中完成许多基本的 HTML 风格的文本输入，例如 HTML 字符、HTML 块、HTML 风格的注释，甚至是视频和音频。具体支持的功能和限制请在 &lt;a href=&#34;http://support.typora.io/HTML/&#34;&gt;官方文档&lt;/a&gt; 中查阅。&lt;/p&gt;
&lt;h3 id=&#34;导出为-html&#34;&gt;导出为 HTML&lt;/h3&gt;
&lt;p&gt;有了这一功能，我们就可以在 Typora 中创造出远超普通 Markdown 文档的页面效果。&lt;/p&gt;
&lt;p&gt;Typora 原生支持将文档导出为 HTML 格式的文件，并选择是否要嵌入 style（也就是后文我将提到的 CSS 的部分）。&lt;/p&gt;
&lt;p&gt;除此之外，由于其本身「浏览器」的属性，你可以直接在实时预览界面用 Ctrl +C 复制到 HTML 代码。一个实用的用处是将这些 HTML 代码直接 Ctrl + V 黏贴到微信公众号后台，基本可以保证两边显示效果相同。这一点不仅使公众号推送可以有更自由、美观的样式，也让编辑、排版更轻松了。（由于微信自带浏览器的一些特性，可能有少部分 CSS style 不能生效，建议多多校对。）&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606725222158.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;公众号
&lt;/center&gt; 
&lt;p&gt;具体如何用 Typora 完成公众号写作，你可以在 &lt;a href=&#34;https://sspai.com/post/40524&#34;&gt;这篇文章&lt;/a&gt; 中进一步了解。&lt;/p&gt;
&lt;h2 id=&#34;css&#34;&gt;CSS&lt;/h2&gt;
&lt;p&gt;为了让文档更美观，我们可以为其加上 CSS style。我认为 Typora 对 CSS 的支持让它成为一众桌面笔记应用中最与众不同的一个。在 Typora 中 CSS 被称为「主题」，但其本质仍是 CSS 文件。你可以在 文件 - 偏好设置 - 主题 - 打开主题文件夹 看到这些 CSS 文件。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606725328223.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;主题&lt;/p&gt;
&lt;/center&gt; 
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606725342168.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;主题文件夹
&lt;/center&gt; 
&lt;p&gt;选择不同的主题可以使文档拥有不同的外观，但不会影响内容。Typora 自带了若干主题，你也可以在 &lt;a href=&#34;http://theme.typora.io&#34;&gt;官网&lt;/a&gt; 下载更多的主题。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606725423540.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;主题商店
&lt;/center&gt; 
&lt;p&gt;除此以外，如果你有一定的 Web 编程基础，你当然也可以自己修改、新建适合你使用需求的 CSS 文件。我自己就写了一份名为 WeChat 的 CSS 文件，来符合我公众号特定的排版需求，例如正文是 15px，页边距是 8，小标题是 18px 等等。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606725495732.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;CSS文件
&lt;/center&gt; 
&lt;p&gt;使用 Typora 的「主题」功能写公众号的一个好处是，只需要每次都套用同样的主题，我们就可以在保证每次排版规范都相同的同时，节省许多重复的工作。&lt;/p&gt;
&lt;h2 id=&#34;yaml-front-matter&#34;&gt;YAML front-matter&lt;/h2&gt;
&lt;p&gt;Typora 支持在文档头部加上基于 YAML 的 front-matter 信息，这一特性适用于把 Markdown 文档分类归档上传到用 Hexo 框架搭建的博客中。我对于这一点不太了解，这里就不误导大家了。有所了解的朋友可以在评论区谈谈！&lt;/p&gt;
&lt;h2 id=&#34;写在最后&#34;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;因为移动端生产效率低，所以只有桌面端应用。因为左顾右盼的两栏式预览影响思路，所以他们甚至去掉了 Markdown 语法标记，只留下最终呈现的样式。因为 Markdown 是为了 HTML 呈现而设计的，所以他们提供了从入门到高级的一系列 Web 辅助功能…… 这一切都只是为了纯粹的&lt;strong&gt;生产效率&lt;/strong&gt;。如果我们回头想想，Markdown 语言本身，当初不也是为了高效地生成简单网页而诞生的吗？&lt;/p&gt;
&lt;p&gt;最后，让我们一起期待这款&lt;strong&gt;顶级桌面文本生产力工具&lt;/strong&gt;的正式版的到来吧！😆&lt;/p&gt;
&lt;p&gt;文章转自：https://sspai.com/post/54912&lt;/p&gt;
">Windows系统下Typora 完全使用详解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/markdown-ji-ben-yu-fa/"" data-c="
          &lt;p&gt;Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;br&gt;
1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。&lt;br&gt;
2、操作简单。添加标题时Markdown只需要在标题内容前加#即可&lt;br&gt;
&lt;strong&gt;缺点：&lt;/strong&gt;&lt;br&gt;
1、需要记一些语法（当然，是很简单。五分钟学会）。&lt;br&gt;
2、有些平台不支持Markdown编辑模式。&lt;/p&gt;
&lt;h1 id=&#34;一-标题&#34;&gt;一、标题&lt;/h1&gt;
&lt;p&gt;在想要设置为标题的文字前面加#来表示&lt;br&gt;
一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。&lt;/p&gt;
&lt;p&gt;注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606703470701.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;h1 id=&#34;这是一级标题&#34;&gt;这是一级标题&lt;/h1&gt;
&lt;h2 id=&#34;这是二级标题&#34;&gt;这是二级标题&lt;/h2&gt;
&lt;h3 id=&#34;这是三级标题&#34;&gt;这是三级标题&lt;/h3&gt;
&lt;h4 id=&#34;这是四级标题&#34;&gt;这是四级标题&lt;/h4&gt;
&lt;h5 id=&#34;这是五级标题&#34;&gt;这是五级标题&lt;/h5&gt;
&lt;h6 id=&#34;这是六级标题&#34;&gt;这是六级标题&lt;/h6&gt;
&lt;h1 id=&#34;二-字体&#34;&gt;二、字体&lt;/h1&gt;
&lt;h3 id=&#34;加粗&#34;&gt;加粗&lt;/h3&gt;
&lt;p&gt;要加粗的文字左右分别用两个*号包起来&lt;/p&gt;
&lt;h3 id=&#34;斜体&#34;&gt;斜体&lt;/h3&gt;
&lt;p&gt;要倾斜的文字左右分别用一个*号包起来&lt;/p&gt;
&lt;h3 id=&#34;斜体加粗&#34;&gt;斜体加粗&lt;/h3&gt;
&lt;p&gt;要倾斜和加粗的文字左右分别用三个*号包起来&lt;/p&gt;
&lt;h3 id=&#34;删除线&#34;&gt;删除线&lt;/h3&gt;
&lt;p&gt;要加删除线的文字左右分别用两个~~号包起来&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606703939197.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;br&gt;
&lt;strong&gt;这是加粗的文字&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;这是倾斜的文字&lt;/em&gt;`&lt;br&gt;
&lt;em&gt;&lt;strong&gt;这是斜体加粗的文字&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
&lt;s&gt;这是加删除线的文字&lt;/s&gt;&lt;/p&gt;
&lt;h1 id=&#34;三-引用&#34;&gt;三、引用&lt;/h1&gt;
&lt;p&gt;在引用的文字前加&amp;gt;即可。引用也可以嵌套，如加两个&amp;gt;&amp;gt;三个&amp;gt;&amp;gt;&amp;gt;n个...&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606704234954.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是引用的内容&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是引用的内容&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这是引用的内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;四-分割线&#34;&gt;四、分割线&lt;/h1&gt;
&lt;p&gt;三个或者三个以上的 - 或者 * 都可以。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606704462750.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;效果如下&#34;&gt;效果如下：&lt;/h2&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;h1 id=&#34;五-图片&#34;&gt;五、图片&lt;/h1&gt;
&lt;p&gt;语法：![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)&lt;br&gt;
图片alt就是显示在图片下面的文字，相当于对图片内容的解释。&lt;br&gt;
图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606704900357.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;![]&lt;/p&gt;
&lt;p&gt;效果如下：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606717141216.svg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;Gridea-Markdown&lt;/center&gt; 
&lt;p&gt;&lt;strong&gt;上传本地图片直接点击导航栏的图片标志，选择图片即可&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;markdown格式追求的是简单、多平台统一。那么图片的存储就是一个问题，需要用图床，提供统一的外链，这样就不用在不同的平台去处理图片的问题了。才能做到书写一次，各处使用。&lt;/p&gt;
&lt;h1 id=&#34;六-超链接&#34;&gt;六、超链接&lt;/h1&gt;
&lt;p&gt;语法：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606708259670.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606708357274.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;br&gt;
&lt;a href=&#34;http://jianshu.com&#34;&gt;简书&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://baidu.com&#34;&gt;百度&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606708441292.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;七-列表&#34;&gt;七、列表&lt;/h1&gt;
&lt;h3 id=&#34;无序列表&#34;&gt;无序列表&lt;/h3&gt;
&lt;p&gt;语法：&lt;br&gt;
无序列表用 - + * 任何一种都可以&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606709101155.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列表内容&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;列表内容&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;列表内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;有序列表&#34;&gt;有序列表&lt;/h3&gt;
&lt;p&gt;语法：&lt;br&gt;
数字加点&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606709243091.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;列表内容&lt;/li&gt;
&lt;li&gt;列表内容&lt;/li&gt;
&lt;li&gt;列表内容&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;列表嵌套&#34;&gt;列表嵌套&lt;/h3&gt;
&lt;h4 id=&#34;上一级和下一级之间敲三个空格即可&#34;&gt;上一级和下一级之间敲三个空格即可&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606709356169.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;八-表格&#34;&gt;八、表格&lt;/h1&gt;
&lt;p&gt;语法：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606709722229.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606709789868.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;姓名&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;技能&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;排行&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;刘备&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;哭&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;大哥&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;关羽&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;打&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;二哥&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;张飞&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;骂&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;三弟&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;九-代码&#34;&gt;九、代码&lt;/h1&gt;
&lt;p&gt;语法：&lt;br&gt;
单行代码：代码之间分别用一个反引号包起来&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606709967461.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606709977762.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
单行代码&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606710064570.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;代码块&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606710077370.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;br&gt;
&lt;code&gt;create database hero;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    function fun(){
         echo &amp;quot;这是一句非常牛逼的代码&amp;quot;;
    }
    fun();
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;十-流程图&#34;&gt;十、流程图&lt;/h1&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-flow&#34;&gt;st=&amp;gt;start: 开始
op=&amp;gt;operation: My Operation
cond=&amp;gt;condition: Yes or No?
e=&amp;gt;end
st-&amp;gt;op-&amp;gt;cond
cond(yes)-&amp;gt;e
cond(no)-&amp;gt;op
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606710630750.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;文章转自：https://www.jianshu.com/p/191d1e21f7ed&lt;/p&gt;
">Markdown基本语法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/helloworld/"" data-c="
          &lt;p&gt;与Gridea的初次邂逅!😘&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606659885219.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Gridea 是一款麻雀虽小却五脏俱全的静态博客写作客户端，他能让你告别繁琐的 Git 操作，更加快速方便的管理你的个人 Blog，同时 Gridea 恰到好处的主题和实用的配置功能也能一定程度上帮助你美化 Blog，如果你的动手能力够强，甚至可以自己调教。作为一款免费的工具，如果你有任何的建议都可以去官方项目页面进行反馈，根据目前的版本迭代速度看，作者还是非常勤劳的，期待未来有更多的新鲜功能。&lt;/p&gt;
">HelloWorld</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;center style=&#34;font-size:16px;color:SlateGray;text-decoration:null;padding-bottom:4px&#34;&gt;在这个快、短社交时代，能够有一个独立的地方，一个属于自己的地方来记录下一些内容。能够让自己的声音不会随着各种信息流而流逝。&lt;/center&gt; 
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
 &lt;center style=&#34;font-size:16px;color:DarkOrange;text-decoration:underline;&#34;&gt;
1002705465@qq.com
&lt;/center&gt;">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/hello-gridea/"" data-c="
          &lt;p&gt;👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;
✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/getgridea/gridea&#34;&gt;Github&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://gridea.dev/&#34;&gt;Gridea 主页&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://fehey.com/&#34;&gt;示例网站&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性👇&lt;/h2&gt;
&lt;p&gt;📝  你可以使用最酷的 &lt;strong&gt;Markdown&lt;/strong&gt; 语法，进行快速创作&lt;/p&gt;
&lt;p&gt;🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片&lt;/p&gt;
&lt;p&gt;🏷️  你可以对文章进行标签分组&lt;/p&gt;
&lt;p&gt;📋  你可以自定义菜单，甚至可以创建外部链接菜单&lt;/p&gt;
&lt;p&gt;💻  你可以在 &lt;strong&gt;Windows&lt;/strong&gt;，&lt;strong&gt;MacOS&lt;/strong&gt; 或 &lt;strong&gt;Linux&lt;/strong&gt; 设备上使用此客户端&lt;/p&gt;
&lt;p&gt;🌎  你可以使用 &lt;strong&gt;𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌&lt;/strong&gt; 或 &lt;strong&gt;Coding Pages&lt;/strong&gt; 向世界展示，未来将支持更多平台&lt;/p&gt;
&lt;p&gt;💬  你可以进行简单的配置，接入 &lt;a href=&#34;https://github.com/gitalk/gitalk&#34;&gt;Gitalk&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/SukkaW/DisqusJS&#34;&gt;DisqusJS&lt;/a&gt; 评论系统&lt;/p&gt;
&lt;p&gt;🇬🇧  你可以使用&lt;strong&gt;中文简体&lt;/strong&gt;或&lt;strong&gt;英语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力&lt;/p&gt;
&lt;p&gt;🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步&lt;/p&gt;
&lt;p&gt;🌱 当然 &lt;strong&gt;Gridea&lt;/strong&gt; 还很年轻，有很多不足，但请相信，它会不停向前 🏃&lt;/p&gt;
&lt;p&gt;未来，它一定会成为你离不开的伙伴&lt;/p&gt;
&lt;p&gt;尽情发挥你的才华吧！&lt;/p&gt;
&lt;p&gt;😘 Enjoy~&lt;/p&gt;
">Hello Gridea</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>





</html>