<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="知行合一">
<meta name="theme-color" content="#000">
<title>【面】前端知识点梳理（服务端与网络） | Tyloo</title>
<link rel="shortcut icon" href="/favicon.ico?v=1629349037786">
<link rel="stylesheet" href="/media/css/pisces.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>





  <meta name="description" content="【面】前端知识点梳理（服务端与网络）" />
  <meta name="keywords" content="Interview" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="pisces">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Tyloo</span>
            </a>  
          
        </div>
        
          <p class="subtitle">知行合一</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 博客
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 分类
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout pisces ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body pisces" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">来碗鸡丁炒饭</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">48</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">9</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">9</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  



  <div style="width: 100%; position: relative;">
    <canvas id="canvasDiyBlock" style="width:100%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
    <script src="/media/js/magic/clock.js"></script>
  </div>

</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li><a href="#1-%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81">1. 常见状态码</a></li>
<li><a href="#2-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98">2. 浏览器缓存</a>
<ul>
<li><a href="#1-200-from-cache%E5%92%8C200-ok">1. 200 From cache和200 ok</a></li>
<li><a href="#2-http-304%E7%8A%B6%E6%80%81%E7%A0%81-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98">2. HTTP-304状态码--浏览器缓存</a>
<ul>
<li><a href="#1-%E5%BC%BA%E7%BC%93%E5%AD%98">1. 强缓存</a></li>
<li><a href="#2-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98">2. 协商缓存</a></li>
<li><a href="#3-%E7%9F%A5%E8%AF%86%E7%82%B9%E7%BB%86%E8%8A%82">3. 知识点细节</a></li>
<li><a href="#4-%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E7%9A%84%E9%97%AE%E9%A2%98">4. 刷新页面的问题：</a></li>
</ul>
</li>
<li><a href="#3-%E7%BC%93%E5%AD%98%E7%9A%84%E8%B5%84%E6%BA%90%E5%8E%BB%E5%93%AA%E9%87%8C%E4%BA%86">3. 缓存的资源去哪里了</a></li>
</ul>
</li>
<li><a href="#3-dns%E8%A7%A3%E6%9E%90">3. DNS解析</a>
<ul>
<li><a href="#1-%E4%BB%80%E4%B9%88%E6%98%AFdns">1. 什么是DNS</a></li>
<li><a href="#2-dns%E8%A7%A3%E6%9E%90">2. DNS解析</a></li>
</ul>
</li>
<li><a href="#4-cdn%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C">4. CDN（内容分发网络）</a>
<ul>
<li><a href="#1-%E4%BB%80%E4%B9%88%E6%98%AFcdn">1. 什么是CDN</a></li>
<li><a href="#2-cdn%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">2. CDN工作原理</a></li>
<li><a href="#3-cdn%E7%BC%93%E5%AD%98">3. CDN缓存</a></li>
<li><a href="#4-cdn-%E4%BC%98%E5%8A%BF">4. CDN 优势</a></li>
</ul>
</li>
<li><a href="#5-%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84-%E4%B8%8E-http-%E5%8D%8F%E8%AE%AE">5. 网络结构 与 HTTP 协议</a>
<ul>
<li><a href="#1-http%E8%BD%AE%E8%AF%A2%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF">1. HTTP轮询（即时通讯）</a>
<ul>
<li><a href="#1-%E8%BD%AE%E8%AF%A2">1. 轮询</a></li>
<li><a href="#2-%E9%95%BF%E8%BD%AE%E8%AF%A2ajax%E5%AE%9E%E7%8E%B0">2. 长轮询（ajax实现）</a></li>
</ul>
</li>
<li><a href="#2-http%E5%BB%BA%E7%AB%8B%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%84%8F%E4%B9%89">2. HTTP建立持久连接的意义</a>
<ul>
<li><a href="#1%E9%82%A3%E4%B9%88%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E9%87%8A%E6%94%BE%E5%91%A2">1.那么长连接什么时候会释放呢？</a></li>
<li><a href="#2-%E9%95%BF%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E5%AE%8C%E6%88%90%E8%AF%86%E5%88%AB">2. 长连接数据传送完成识别：</a></li>
</ul>
</li>
<li><a href="#3-http%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84">3. HTTP报文结构</a>
<ul>
<li><a href="#11-http%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87">1.1 HTTP请求报文</a></li>
<li><a href="#12-http%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87">1.2 HTTP响应报文</a></li>
</ul>
</li>
<li><a href="#4-http%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5">4. HTTP首部字段</a>
<ul>
<li><a href="#1-http%E9%80%9A%E7%94%A8%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5">1. HTTP通用首部字段</a></li>
<li><a href="#2-http%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5">2 HTTP请求首部字段</a></li>
<li><a href="#3-http%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5">3. HTTP响应首部字段</a></li>
<li><a href="#4-http%E5%AE%9E%E4%BD%93%E6%B6%88%E6%81%AF%E4%BD%93%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5">4 HTTP实体（消息体）首部字段</a></li>
</ul>
</li>
<li><a href="#5-http10%E4%B8%8Ehttp11%E4%BB%A5%E5%8F%8Ahttp20%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86">5. HTTP1.0与HTTP1.1以及HTTP2.0相关知识</a>
<ul>
<li><a href="#1-http-10">1. HTTP 1.0</a></li>
<li><a href="#2-http-11">2. HTTP 1.1</a></li>
<li><a href="#3-http-20">3. HTTP 2.0</a>
<ul>
<li><a href="#1-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-%E4%B8%8E-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%A0%E8%BE%93">1. 多路复用 与 二进制传输</a></li>
<li><a href="#2-header-%E5%8E%8B%E7%BC%A9">2. Header 压缩</a></li>
</ul>
</li>
<li><a href="#3-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81">3. 服务器推送</a></li>
</ul>
</li>
<li><a href="#6-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-%E5%85%AC%E9%92%A5-%E7%A7%81%E9%92%A5-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6">6. 对称加密、非对称加密、公钥、私钥、数字签名、数字证书</a>
<ul>
<li><a href="#1-%E5%AF%B9%E7%A7%B0%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86">1. 对称数据加密</a></li>
<li><a href="#2-rsa%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">2. RSA：非对称加密</a></li>
<li><a href="#3-%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">3. 非对称加密+对称加密</a></li>
<li><a href="#4-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB">4. 中间人攻击</a></li>
<li><a href="#5-%E4%BF%A1%E6%81%AF%E6%91%98%E8%A6%81-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6">5. 信息摘要、数字签名、数字证书</a></li>
</ul>
</li>
<li><a href="#7-http%E4%B8%8Ehttps%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">7. HTTP与HTTPS的区别及实现方式</a>
<ul>
<li><a href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1. 基本概念</a></li>
<li><a href="#2-http%E7%9A%84%E6%97%A0%E7%8A%B6%E6%80%81">2. HTTP的无状态</a></li>
<li><a href="#3-http-%E4%B8%8E-https-%E7%9A%84%E5%8C%BA%E5%88%AB">3. HTTP 与 HTTPS 的区别</a></li>
<li><a href="#4-https-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F">4. HTTPS 的工作方式</a></li>
<li><a href="#5-ssl-%E7%9A%84%E4%BD%8D%E7%BD%AE">5. SSL 的位置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-tcpip-%E5%92%8C-udp-%E5%8D%8F%E8%AE%AE">6. TCP/IP 和 UDP 协议</a>
<ul>
<li><a href="#1-tcpip-%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82%E7%AE%A1%E7%90%86">1. TCP/IP 协议分层管理</a></li>
<li><a href="#2-tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%8E%9F%E5%9B%A0">2. TCP三次握手四次挥手机制及原因</a>
<ul>
<li><a href="#1-%E8%BF%9E%E6%8E%A5%E4%B8%AD%E6%80%8E%E4%B9%88%E6%89%BE%E5%88%B0%E5%AF%B9%E6%96%B9">1. 连接中怎么找到对方？</a></li>
<li><a href="#2-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">2. 三次握手</a></li>
<li><a href="#3-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">3. 四次挥手</a></li>
</ul>
</li>
<li><a href="#3tcpudp-%E7%9A%84%E5%8C%BA%E5%88%AB">3.TCP/UDP 的区别</a></li>
</ul>
</li>
<li><a href="#7-getpostputdeleteoptions%E7%AD%89%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F">7. GET,POST,PUT,DELETE,OPTIONS等请求方式</a>
<ul>
<li><a href="#1-%E4%B8%8D%E5%90%8C%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E5%8C%BA%E5%88%AB">1. 不同请求方式区别</a>
<ul>
<li><a href="#1-get">1. GET</a></li>
<li><a href="#2-post">2. POST</a></li>
<li><a href="#3-put">3. PUT</a></li>
<li><a href="#4-delete">4. DELETE</a></li>
<li><a href="#5-options">5. OPTIONS</a></li>
</ul>
</li>
<li><a href="#2-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84get%E5%92%8Cpost">2. 浏览器的GET和POST</a>
<ul>
<li><a href="#1-get-2">1. GET</a></li>
<li><a href="#2-post-2">2. POST</a></li>
<li><a href="#3-%E5%8C%BA%E5%88%AB">3. 区别</a></li>
</ul>
</li>
<li><a href="#3-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84get%E5%92%8Cpost">3. 接口中的GET和POST</a></li>
<li><a href="#4-%E5%85%B3%E4%BA%8E%E5%AE%89%E5%85%A8%E6%80%A7">4. 关于安全性</a></li>
<li><a href="#5-%E5%85%B3%E4%BA%8Eurl%E7%9A%84%E9%95%BF%E5%BA%A6">5. 关于URL的长度</a></li>
</ul>
</li>
<li><a href="#8-ajax-axios%E5%BA%93">8. ajax、 axios库</a>
<ul>
<li><a href="#1-ajax">1. ajax</a></li>
<li><a href="#2-axios-api">2. Axios API</a></li>
</ul>
</li>
<li><a href="#9-%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8xss-csrf">9. 前端安全XSS、CSRF</a>
<ul>
<li><a href="#1-xss">1. XSS</a>
<ul>
<li><a href="#1-%E5%8F%8D%E5%B0%84%E6%80%A7">1. 反射性</a></li>
<li><a href="#2-%E5%AD%98%E5%82%A8%E5%9E%8B">2. 存储型</a></li>
<li><a href="#3-%E5%9F%BA%E4%BA%8Edom">3. 基于DOM</a></li>
</ul>
</li>
<li><a href="#2-xss%E6%94%BB%E5%87%BB%E7%9A%84%E9%98%B2%E8%8C%83">2. XSS攻击的防范</a>
<ul>
<li><a href="#1-httponly-%E9%98%B2%E6%AD%A2%E5%8A%AB%E5%8F%96-cookie">1. HttpOnly 防止劫取 Cookie</a></li>
<li><a href="#2-%E8%BE%93%E5%85%A5%E6%A3%80%E6%9F%A5">2. 输入检查</a></li>
<li><a href="#3-%E8%BE%93%E5%87%BA%E6%A3%80%E6%9F%A5">3. 输出检查</a></li>
</ul>
</li>
<li><a href="#3-csrf">3. CSRF</a>
<ul>
<li><a href="#1-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84-cookie-%E7%AD%96%E7%95%A5">1. 浏览器的 Cookie 策略</a></li>
<li><a href="#2-%E9%80%9A%E8%BF%87-cookie-%E8%BF%9B%E8%A1%8C-csrf-%E6%94%BB%E5%87%BB">2. 通过 Cookie 进行 CSRF 攻击</a></li>
</ul>
</li>
<li><a href="#4-csrf-%E6%94%BB%E5%87%BB%E7%9A%84%E9%98%B2%E8%8C%83">4. CSRF 攻击的防范</a>
<ul>
<li><a href="#1-%E9%AA%8C%E8%AF%81%E7%A0%81">1. 验证码</a></li>
<li><a href="#2-referer-check">2. Referer Check</a></li>
<li><a href="#3-%E6%B7%BB%E5%8A%A0-token-%E9%AA%8C%E8%AF%81token%E4%BB%A4%E7%89%8C">3. 添加 token 验证(token==令牌)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#10-websocket">10. Websocket</a>
<ul>
<li><a href="#1-websocket%E7%AE%80%E4%BB%8B">1. Websocket简介</a></li>
<li><a href="#2-websocket%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A4%BA%E4%BE%8B">2. Websocket客户端示例</a></li>
<li><a href="#3-websocket%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">3. websocket应用场景</a></li>
</ul>
</li>
<li><a href="#11-%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1">11. 即时通信</a>
<ul>
<li><a href="#sse">SSE</a></li>
</ul>
</li>
<li><a href="#12-%E6%A8%A1%E5%9D%97%E5%8C%96commonjses6cmdamd">12. 模块化，commonJS，es6，cmd，amd</a>
<ul>
<li><a href="#1-es6-moudle">1. ES6 Moudle</a></li>
<li><a href="#2-commonjs">2. CommonJS</a></li>
<li><a href="#3-commonjs%E5%92%8Ces6-module%E7%9A%84%E5%8C%BA%E5%88%AB">3. CommonJS和ES6 Module的区别</a></li>
<li><a href="#4-amd">4. AMD</a></li>
<li><a href="#cmd">CMD</a></li>
</ul>
</li>
<li><a href="#13-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">13. 负载均衡</a>
<ul>
<li><a href="#1-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%A6%82%E5%BF%B5">1. 负载均衡概念</a></li>
<li><a href="#2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">2. 服务器负载均衡</a></li>
<li><a href="#3-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">3. 客户端负载均衡</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="http://localhost:4000/post/mian-qian-duan-zhi-shi-dian-shu-li-fu-wu-duan-yu-wang-luo/">
      【面】前端知识点梳理（服务端与网络）
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2021-03-11 13:56:39">2021-03-11</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="http://localhost:4000/tag/UEfKsNsBO/">
        <span>Interview</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>72<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>19838<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
    
    
    <span id="/post/mian-qian-duan-zhi-shi-dian-shu-li-fu-wu-duan-yu-wang-luo/" data-flag-title="【面】前端知识点梳理（服务端与网络）" class="meta-item pc-show leancloud_visitors">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-eye"></i>
      <span><span class="language" data-lan="view">浏览量</span>：<span class="leancloud-visitors-count"></span></span>
    </span>
    
  </div>
</section>
            <div class="post-body next-md-body" id="post_body">
              <h1 id="1-常见状态码">1. 常见状态码</h1>
<p><code>1XX 信息</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">消息:</th>
<th style="text-align:center">描述:</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">100 Continue</td>
<td style="text-align:center">服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。</td>
</tr>
<tr>
<td style="text-align:center">101 Switching Protocols</td>
<td style="text-align:center">服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。</td>
</tr>
</tbody>
</table>
<p><code>2XX 成功</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">消息:</th>
<th style="text-align:center">描述:</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">200 OK</td>
<td style="text-align:center">请求成功（其后是对GET和POST请求的应答文档。）</td>
</tr>
<tr>
<td style="text-align:center">201 Created</td>
<td style="text-align:center">请求被创建完成，同时新的资源被创建。</td>
</tr>
<tr>
<td style="text-align:center">202 Accepted</td>
<td style="text-align:center">供处理的请求已被接受，但是处理未完成。</td>
</tr>
<tr>
<td style="text-align:center">203 Non-authoritative Information</td>
<td style="text-align:center">文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。</td>
</tr>
<tr>
<td style="text-align:center">204 No Content</td>
<td style="text-align:center">没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。</td>
</tr>
</tbody>
</table>
<p><code>3XX 重定向</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">消息:</th>
<th style="text-align:center">描述:</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">300 Multiple Choices</td>
<td style="text-align:center">多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。</td>
</tr>
<tr>
<td style="text-align:center">301 Moved Permanently</td>
<td style="text-align:center">所请求的页面已经转移至新的url。</td>
</tr>
<tr>
<td style="text-align:center">302 Found</td>
<td style="text-align:center">所请求的页面已经临时转移至新的url。</td>
</tr>
<tr>
<td style="text-align:center">303 See Other</td>
<td style="text-align:center">所请求的页面可在别的url下被找到。</td>
</tr>
<tr>
<td style="text-align:center">304 Not Modified</td>
<td style="text-align:center">未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</td>
</tr>
</tbody>
</table>
<p><code>4XX 客户端错误</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">消息:</th>
<th style="text-align:center">描述:</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">400 Bad Request</td>
<td style="text-align:center">服务器未能理解请求。</td>
</tr>
<tr>
<td style="text-align:center">401 Unauthorized</td>
<td style="text-align:center">被请求的页面需要用户名和密码。</td>
</tr>
<tr>
<td style="text-align:center">403 Forbidden</td>
<td style="text-align:center">对被请求页面的访问被禁止。</td>
</tr>
<tr>
<td style="text-align:center">404 Not Found</td>
<td style="text-align:center">服务器无法找到被请求的页面。</td>
</tr>
<tr>
<td style="text-align:center">405 Method Not Allowed</td>
<td style="text-align:center">请求中指定的方法不被允许。</td>
</tr>
<tr>
<td style="text-align:center">406 Not Acceptable</td>
<td style="text-align:center">服务器生成的响应无法被客户端所接受。</td>
</tr>
<tr>
<td style="text-align:center">407 Proxy Authentication Required</td>
<td style="text-align:center">用户必须首先使用代理服务器进行验证，这样请求才会被处理。</td>
</tr>
<tr>
<td style="text-align:center">408 Request Timeout</td>
<td style="text-align:center">请求超出了服务器的等待时间。</td>
</tr>
<tr>
<td style="text-align:center">409 Conflict</td>
<td style="text-align:center">由于冲突，请求无法被完成。</td>
</tr>
<tr>
<td style="text-align:center">413 Request Entity Too Large</td>
<td style="text-align:center">由于所请求的实体的太大，服务器不会接受请求。</td>
</tr>
<tr>
<td style="text-align:center">414 Request-url Too Long</td>
<td style="text-align:center">由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。</td>
</tr>
</tbody>
</table>
<p><code>5XX 服务器错误</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">消息:</th>
<th style="text-align:center">描述:</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">500 Internal Server Error</td>
<td style="text-align:center">请求未完成。服务器遇到不可预知的情况。</td>
</tr>
<tr>
<td style="text-align:center">501 Not Implemented</td>
<td style="text-align:center">请求未完成。服务器不支持所请求的功能。</td>
</tr>
<tr>
<td style="text-align:center">502 Bad Gateway</td>
<td style="text-align:center">请求未完成。服务器从上游服务器收到一个无效的响应。</td>
</tr>
<tr>
<td style="text-align:center">503 Service Unavailable</td>
<td style="text-align:center">请求未完成。服务器临时过载或当机。</td>
</tr>
<tr>
<td style="text-align:center">504 Gateway Timeout</td>
<td style="text-align:center">网关超时。</td>
</tr>
<tr>
<td style="text-align:center">505 HTTP Version Not Supported</td>
<td style="text-align:center">服务器不支持请求中指明的HTTP协议版本。</td>
</tr>
</tbody>
</table>
<h1 id="2-浏览器缓存">2. 浏览器缓存</h1>
<h2 id="1-200-from-cache和200-ok">1. 200 From cache和200 ok</h2>
<p>为什么有的缓存是 200 OK (from cache)，有的缓存是 304 Not Modified 呢？很简单，看运维是否移除了 Entity Tag。移除了，就总是 200 OK (from cache)。没有移除，就两者交替出现。</p>
<p>其实， 200 OK (from cache)  是浏览器没有跟服务器确认，直接用了浏览器缓存；而 304 Not Modified 是浏览器和服务器多确认了一次缓存有效性，再用的缓存。</p>
<p><strong>它们都是在设置了缓存的情况下触发的。</strong></p>
<p>200 OK (from cache) 是直接点击链接访问，输入网址按回车访问也能触发；而 304 Not Modified 是刷新页面时触发，或是设置了长缓存、但 Entity Tags 没有移除时触发。</p>
<h2 id="2-http-304状态码-浏览器缓存">2. HTTP-304状态码--浏览器缓存</h2>
<p>304状态码是在协商缓存，缓存命中的时候服务器返回的，告诉客户端，<strong>服务器资源没有修改，可以使用客户端自己的缓存。</strong></p>
<p>浏览器缓存分为<code>强缓存</code>（本地缓存）和<code>协商缓存</code>（弱缓存）。<br>
<img src="http://localhost:4000/post-images/1617850748410.png" alt="" loading="lazy"></p>
<h3 id="1-强缓存">1. 强缓存</h3>
<p>如上图所示，在浏览器第一次发出请求之后，需要再次发送请求的时候，浏览器首先获取该资源缓存的 header 信息，然后根据 Cache-Control 和 Expires 字段判断缓存是否过期。如果没有过期，直接使用浏览器缓存，并不会与服务器通信。该过程为判断是否使用<code>强缓存</code>，即本地缓存。</p>
<ol>
<li><strong>Cache-Control</strong><br>
该字段是 HTTP1.1 规范，一般利用该字段的 max-age 属性来判断，这个值是一个相对时间，单位为 s，代表资源的有效期。例如：</li>
</ol>
<pre><code>Cache-Control:max-age=3600
</code></pre>
<p>除此之外还有几个常用的值：</p>
<ul>
<li>no-cache：表示<strong>不使用强缓存</strong>，需要使用协商缓存</li>
<li>no-store：禁止<strong>浏览器缓存</strong>数据，每次请求下载完整的资源</li>
<li>public：可以被所有用户缓存，包括终端用户和中间代理服务器</li>
<li>private：只能被终端用户的浏览器缓存</li>
</ul>
<ol start="2">
<li><strong>Expires</strong><br>
该字段是 HTTP1.0 规范，他是一个绝对时间的 GMT 格式的时间字符串。例如：</li>
</ol>
<pre><code>expires:Mar, 06 Apr 2021 10:57:09 GMT
</code></pre>
<p>这个时间代表资源的失效时间，只要发送请求的时间在这之前，都会使用强缓存。</p>
<p>由于失效时间是一个绝对时间，因此当<strong>服务器时间与客户端时间偏差较大</strong>时，就会导致<strong>缓存混乱</strong>。</p>
<h3 id="2-协商缓存">2. 协商缓存</h3>
<p>如果缓存过期，浏览器会向服务器发送请求，即使用<code>协商缓存</code>。本次请求会带着第一次请求返回的有关缓存的 header 字段信息，比如以下两个字段：</p>
<ol>
<li>
<p><strong>Etag/If-None-Match</strong><br>
判断响应头中是否存在 Etag 字段，如果存在，浏览器则发送一个带有 If-None-Match 字段的请求头的请求，该字段的值为 Etag 值。服务器通过对比<strong>客户端发过来的Etag值是否与服务器相同</strong>。如果相同，说明缓存命中，服务器<strong>返回 304</strong> 状态码，并将 If-None-Match 设为 false，客户端继续使用本地缓存。如果<strong>不相同</strong>，说明缓存未命中，服务器**返回 200 **状态码，并将 If-None-Match 设为 true，并且返回请求的数据。</p>
</li>
<li>
<p>Last-Modified/If-Modified-Since<br>
除了 Etag 字段之外，客户端还会通过服务器返回的 Last-Modified 字段判断是否继续使用缓存，该字段为服务器返回的资源的最后修改时间，为UMT时间。浏览器发送一个带有 If-Modified-Since 字段的请求头的请求给服务器，该字段的值为 Last-Modified 值。服务器收到之后，通过这个时间判断，在该时间之后，资源有无修改，如果未修改，缓存命中，返回 304 状态码；如果未命中，返回 200 状态码，并返回最新的内容。</p>
</li>
</ol>
<h3 id="3-知识点细节">3. 知识点细节</h3>
<p><code>Cache-Control 与 Expires 的优先级：</code></p>
<p>两者可以在服务端配置同时使用，<strong>Cache-Control 的优先级高于 Expires。</strong></p>
<p><code>为什么有了Last-Modified还要Etag</code></p>
<p>Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p>
<ul>
<li>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</li>
<li>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存</li>
<li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li>
</ul>
<p>Last-Modified 和 Etag 可以一起使用，<strong>Etag 的优先级更高。</strong></p>
<h3 id="4-刷新页面的问题">4. 刷新页面的问题：</h3>
<p>F5刷新：不使用强缓存，使用协商缓存</p>
<p>ctrl+F5：二者都不使用</p>
<h2 id="3-缓存的资源去哪里了">3. 缓存的资源去哪里了</h2>
<p><code>memory cache</code>JS等派生资源</p>
<blockquote>
<p>MemoryCache顾名思义，就是将资源缓存到内存中，等待下次访问时不需要重新下载资源，而直接从内存中获取。Webkit早已支持memoryCache。<br>
目前Webkit资源分成两类，一类是主资源，比如HTML页面，或者下载项，一类是派生资源，比如HTML页面中内嵌的图片或者脚本链接，分别对应代码中两个类：MainResourceLoader和SubresourceLoader。虽然Webkit支持memoryCache，但是也只是针对派生资源，它对应的类为CachedResource，用于保存原始数据（比如CSS，JS等），以及解码过的图片数据。</p>
</blockquote>
<p><code>disk cache</code>保存CSS等不频繁读取资源<br>
DiskCache顾名思义，就是将资源缓存到磁盘中，等待下次访问时不需要重新下载资源，而直接从磁盘中获取，它的直接操作对象为CurlCacheManager。</p>
<table>
<thead>
<tr>
<th style="text-align:center">*</th>
<th style="text-align:center">memory cache</th>
<th style="text-align:center">disk cache</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">相同点</td>
<td style="text-align:center">只能存储一些派生类资源文件</td>
<td style="text-align:center">只能存储一些派生类资源文件</td>
</tr>
<tr>
<td style="text-align:center">不同点</td>
<td style="text-align:center">退出进程时数据会被清除</td>
<td style="text-align:center">退出进程时数据不会被清除</td>
</tr>
<tr>
<td style="text-align:center">存储资源</td>
<td style="text-align:center">一般脚本、字体、图片会存在内存当中</td>
<td style="text-align:center">一般非脚本会存在内存当中，如css等</td>
</tr>
</tbody>
</table>
<p><strong>因为CSS文件加载一次就可渲染出来,我们不会频繁读取它,所以它不适合缓存到内存中,但是js之类的脚本却随时可能会执行,如果脚本在磁盘当中,我们在执行脚本的时候需要从磁盘取到内存中来,这样IO开销就很大了,有可能导致浏览器失去响应。</strong></p>
<p><strong>三级缓存原理 (访问缓存优先级)</strong></p>
<ol>
<li>先在内存中查找,如果有,直接加载。</li>
<li>如果内存中不存在,则在硬盘中查找,如果有直接加载。</li>
<li>如果硬盘中也没有,那么就进行网络请求。</li>
<li>请求获取的资源缓存到硬盘和内存。</li>
</ol>
<p><strong>浏览器缓存的优点</strong></p>
<ol>
<li>减少了冗余的数据传输</li>
<li>减少了服务器的负担，大大提升了网站的性能</li>
<li>加快了客户端加载网页的速度</li>
</ol>
<p><strong>总结</strong><br>
当浏览器再次访问一个已经访问过的资源时，它会这样做：</p>
<p>1.看看是否命中强缓存，如果命中，就直接使用缓存了。</p>
<p>2.如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存。</p>
<p>3.如果命中协商缓存，服务器会返回 304 告诉浏览器使用本地缓存。</p>
<p>4.否则，返回最新的资源。</p>
<h1 id="3-dns解析">3. DNS解析</h1>
<h2 id="1-什么是dns">1. 什么是DNS</h2>
<p>全称 Domain Name System ,即域名系统。</p>
<blockquote>
<p>万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。DNS协议运行在UDP协议之上，使用端口号53。</p>
</blockquote>
<h2 id="2-dns解析">2. DNS解析</h2>
<p>通过域名,最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。</p>
<pre><code>www.dnscache.com (域名) - DNS解析 -&gt; 11.222.33.444 (IP地址)
</code></pre>
<p><code>DNS解析步骤（缓存）</code></p>
<p>1） 浏览器缓存　　<br>
当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）；</p>
<p>2） 系统缓存　　<br>
当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP；</p>
<p>3） 路由器缓存　　<br>
当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查，以上三步均为客服端的DNS缓存；</p>
<p>4） DNS缓存　　<br>
当在用户客服端查找不到域名对应IP地址，则将进入DNS缓存中进行查询。比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查找；</p>
<p>5） 根域名服务器　　<br>
当以上均未完成，则进入根服务器进行查询。全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器IP告诉本地DNS服务器；</p>
<p>6） 顶级域名服务器　　<br>
顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的IP地址告诉本地DNS服务器；</p>
<p>7） 主域名服务器　　<br>
主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录；</p>
<p>8）保存结果至缓存　　<br>
本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个IP地址与web服务器建立链接。</p>
<h1 id="4-cdn内容分发网络">4. CDN（内容分发网络）</h1>
<h2 id="1-什么是cdn">1. 什么是CDN</h2>
<p>简单的理解CDN就是这些缓存服务器，帮助在最近的CDN节点，用最短的请求时间拿到资源，这样排队的人也就少了。也就起到分流作用，减轻服务器负载压力。</p>
<h2 id="2-cdn工作原理">2. CDN工作原理</h2>
<p><code>资源上传cdn之后，当用户访问cdn的资源地址之后会经历下面的步骤：</code></p>
<ol>
<li>首先经过本地的dns解析，请求cname指向的那台cdn专用的dns服务器。</li>
<li>dns服务器返回全局负载均衡的服务器ip给用户</li>
<li>用户请求全局负载均衡服务器，服务器根据ip返回所在区域的负载均衡服务器ip给用户</li>
<li>用户请求区域负载均衡服务器，负载均衡服务器根据用户ip选择距离近的，并且存在用户所需内容的，负载比较合适的一台缓存服务器ip给用户。当没有对应内容的时候，会去上一级缓存服务器去找，直到找到资源所在的源站服务器，并且缓存在缓存服务器中。用户下一次在请求该资源，就可以就近拿缓存了。</li>
</ol>
<p><img src="http://localhost:4000/post-images/1626742657399.png" alt="" loading="lazy"><br>
cdn的原理主要答出<code>负载均衡</code>和<code>缓存</code>再就是<code>dns解析</code>这三部分就行了吧，通过<code>dns解析</code>到<code>全局负载均衡服务器</code>，然后再到<code>区域的负载均衡</code>，之后根据一些条件来找合适的<code>缓存服务器</code>，如果第一次访问就从源站拿过来缓存。 需要注意的是一切都是根据请求的ip来的，如果ip不合理，那么可能起不到加速效果。缓存和负载均衡的思想在减轻服务器压力方面其实是很常见的。</p>
<p><strong>从这个例子可以了解到：</strong><br>
（1）CDN的加速资源是跟域名绑定的。<br>
（2）通过域名访问资源，首先是通过DNS分查找离用户最近的CDN节点（边缘服务器）的IP<br>
（3）通过IP访问实际资源时，如果CDN上并没有缓存资源，则会到源站请求资源，并缓存到CDN节点上，这样，用户下一次访问时，该CDN节点就会有对应资源的缓存了。</p>
<h2 id="3-cdn缓存">3. CDN缓存</h2>
<p>关于CDN缓存,在浏览器本地缓存失效后,浏览器会向CDN边缘节点发起请求。类似浏览器缓存,CDN边缘节点也存在着一套缓存机制。CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循http标准协议，通过http响应头中的</p>
<pre><code>Cache-control: max-age //后面会提到
</code></pre>
<p>的字段来设置CDN边缘节点数据缓存时间。</p>
<h2 id="4-cdn-优势">4. CDN 优势</h2>
<p>CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低。<br>
大部分请求在CDN边缘节点完成，CDN起到了分流作用，减轻了源服务器的负载。</p>
<h1 id="5-网络结构-与-http-协议">5. 网络结构 与 HTTP 协议</h1>
<p><img src="http://localhost:4000/post-images/1616399158170.gif" alt="" loading="lazy"><br>
有两套参考模型：</p>
<ul>
<li>OSI参考模型（Open Systems Interconnection Reference Model，七层）：模型过于理想化，未能在因特网上进行广泛推广。</li>
<li>TCP/IP参考模型(或TCP/IP协议，四层)：事实上的国际标准。<br>
<img src="http://localhost:4000/post-images/1615458129735.png" alt="" loading="lazy"></li>
</ul>
<h2 id="1-http轮询即时通讯">1. HTTP轮询（即时通讯）</h2>
<h3 id="1-轮询">1. 轮询</h3>
<p>短轮询的基本思路就是<strong>浏览器每隔一段时间向浏览器发送http请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应</strong>。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。</p>
<p>这种方式的优点是比较简单，易于理解，实现起来也没有什么技术难点。缺点是显而易见的，这种方式由于需要不断的建立http连接，<strong>严重浪费了服务器端和客户端的资源</strong>。尤其是在客户端，距离来说，如果有数量级想对比较大的人同时位于基于短轮询的应用中，那么每一个用户的客户端都会疯狂的向服务器端发送http请求，而且不会间断。人数越多，服务器端压力越大，这是很不合理的。</p>
<p>因此短轮询不适用于那些同时在线用户数量比较大，并且很注重性能的Web应用。</p>
<pre><code>var xhr = new XMLHttpRequest();
    setInterval(function(){
        xhr.open('GET','/user');
        xhr.onreadystatechange = function(){

        };
        xhr.send();
    },1000)
</code></pre>
<h3 id="2-长轮询ajax实现">2. 长轮询（ajax实现）</h3>
<p>当服务器收到客户端发来的请求后，<strong>服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新</strong>。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制(服务器端设置)才返回。客户端JavaScript响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。</p>
<p>长轮询和短轮询比起来，明显减少了很多不必要的http请求次数，相比之下节约了资源。<strong>长轮询的缺点在于，连接挂起也会导致资源的浪费</strong>。</p>
<pre><code>   function ajax(){
        var xhr = new XMLHttpRequest();
        xhr.open('GET','/user');
        xhr.onreadystatechange = function(){
              ajax();
        };
        xhr.send();
    }
</code></pre>
<p>轮询与长轮询都是基于HTTP的，两者本身存在着缺陷：轮询需要更快的处理速度；长轮询则更要求处理并发的能力；两者都是“<strong>被动型服务器</strong>”的体现：服务器不会主动推送信息，而是在客户端发送ajax请求后进行返回的响应。而理想的模型是&quot;在服务器端数据有了变化后，可以主动推送给客户端&quot;，这种&quot;<strong>主动型</strong>&quot;服务器是解决这类问题的很好的方案。</p>
<h2 id="2-http建立持久连接的意义">2. HTTP建立持久连接的意义</h2>
<p>在 HTTP1.0 中每发送一次请求都要重新建立 TCP 连接并且关闭连接。这样做是很耗费时间的。而在HTTP1.1 中默认开启长连接，一次TCP连接可以发送多个HTTP请求，避免了重复建立释放连接的开销，加速了数据的传输，节省了时间和带宽。</p>
<h3 id="1那么长连接什么时候会释放呢">1.那么长连接什么时候会释放呢？</h3>
<p>客户端的长连接不可能一直拿着，会有一个超时时间，服务器会告诉客户端超时时间，譬如：</p>
<pre><code>Access-Control-Allow-Origin: http://mall.sillywa.com
Connection: keep-alive
Content-Length: 43574
Content-Type: application/json; charset=utf-8
Date: Wed, 03 Mar 2021 07:34:49 GMT
Keep-Alive: timeout=5
Vary: Origin
</code></pre>
<p><strong>Keep-Alive: timeout=5</strong> <strong>表示这个 TCP 通道可以保持 5s</strong>。另外还可能有 max=xxx，表示这个长连接<strong>最多接受xxx次请求就断开</strong>。对于客户端来说，如果服务端没有告诉是客户端超时时间也没关系，服务端可能主动发起四次挥手断开TCP连接，客户端就能够知道该TCP连接已经无效。</p>
<h3 id="2-长连接数据传送完成识别">2. 长连接数据传送完成识别：</h3>
<ol>
<li>判断传输的数据是否达到了 Content-Length 指示的大小</li>
<li>没有 Content-Length，由于数据是分块传输的，这时候就要根据块的编码来判断了，最后一个一个编码的数据是一个空块，表明本次传输结束</li>
</ol>
<h2 id="3-http报文结构">3. HTTP报文结构</h2>
<p>HTTP报文由<strong>报文首部</strong>和<strong>报文主体</strong>构成，中间由一个<strong>空行分隔</strong>。<strong>报文首部包含请求行和请求头部</strong>，报文主体主要包含被发送的信息。</p>
<p>报文首部是客户端或服务端需要处理请求或响应的内容及属性，可以传递额外的信息。</p>
<h3 id="11-http请求报文">1.1 HTTP请求报文</h3>
<p>HTTP请求报文由3部分组成（请求行+请求头+请求体）：<br>
<img src="http://localhost:4000/post-images/1617847556323.jpg" alt="" loading="lazy"></p>
<p><strong>请求行：</strong><br>
①是<code>请求方法</code>，GET和POST是最常见的HTTP方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE。<br>
②为请求对应的<code>URL地址</code>，它和报文头的Host属性组成完整的请求URL。<br>
③是<code>协议名称及版本号</code>。</p>
<p><strong>请求头：</strong><br>
④是<code>HTTP的报文头</code>，报文头包含若干个属性，格式为“属性名:属性值”，服务端据此获取客户端的信息。<br>
与缓存相关的规则信息，均包含在header中</p>
<p><strong>请求体：</strong><br>
⑤是<code>报文体</code>，它将一个页面表单中的组件值通过param1=value1&amp;param2=value2的键值对形式编码成一个格式化串，它承载多个请求参数的数据。不但报文体可以传递请求参数，请求URL也可以通过类似于“/chapter15/user.html? param1=value1&amp;param2=value2”的方式传递请求参数。</p>
<h3 id="12-http响应报文">1.2 HTTP响应报文</h3>
<p>HTTP的响应报文也由三部分组成（响应行+响应头+响应体）<br>
<img src="http://localhost:4000/post-images/1617847696959.jpg" alt="" loading="lazy"></p>
<p><strong>响应行：</strong><br>
①报文协议及版本；<br>
②状态码及状态描述；</p>
<p><strong>响应头：</strong><br>
③响应报文头，也是由多个属性组成；</p>
<p><strong>响应体：</strong><br>
④响应报文体，即我们真正要的“干货”</p>
<h2 id="4-http首部字段">4. HTTP首部字段</h2>
<h3 id="1-http通用首部字段">1. HTTP通用首部字段</h3>
<p>通用首部字段是请求报文和响应报文都会使用的字段，例如：</p>
<table>
<thead>
<tr>
<th style="text-align:center">通用头部字段</th>
<th style="text-align:center">HTTP1.0</th>
<th style="text-align:center">HTTP1.1</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Date</td>
<td style="text-align:center">有</td>
<td style="text-align:center"></td>
<td style="text-align:center">表示请求和响应生成的日期，GTM时间。例如 Tue, 02 Mar 2021 12:31:25 GMT</td>
</tr>
<tr>
<td style="text-align:center">Pragma</td>
<td style="text-align:center">有</td>
<td style="text-align:center"></td>
<td style="text-align:center">表示数据是否允许被缓存的通信选项</td>
</tr>
<tr>
<td style="text-align:center">Cache-Control</td>
<td style="text-align:center"></td>
<td style="text-align:center">有</td>
<td style="text-align:center">控制缓存的相关信息</td>
</tr>
<tr>
<td style="text-align:center">Connection</td>
<td style="text-align:center"></td>
<td style="text-align:center">有</td>
<td style="text-align:center">设置发送响应之后 TCP 连接是否继续保持</td>
</tr>
<tr>
<td style="text-align:center">Transfer-Encoding</td>
<td style="text-align:center"></td>
<td style="text-align:center">有</td>
<td style="text-align:center">表示消息主体的编码格式</td>
</tr>
<tr>
<td style="text-align:center">Via</td>
<td style="text-align:center"></td>
<td style="text-align:center">有</td>
<td style="text-align:center">记录途中经过的代理和网关</td>
</tr>
</tbody>
</table>
<h3 id="2-http请求首部字段">2 HTTP请求首部字段</h3>
<table>
<thead>
<tr>
<th style="text-align:center">请求头部字段</th>
<th style="text-align:center">HTTP1.0</th>
<th style="text-align:center">HTTP1.1</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Host</td>
<td style="text-align:center"></td>
<td style="text-align:center">有</td>
<td style="text-align:center">接受请求的服务器IP地址和端口号</td>
</tr>
<tr>
<td style="text-align:center">Accept</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
<td style="text-align:center">客户端可支持的数据类型</td>
</tr>
<tr>
<td style="text-align:center">User-Agent</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
<td style="text-align:center">客户端软件的名称和版本号等相关信息</td>
</tr>
<tr>
<td style="text-align:center">If-Modified-Since</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
<td style="text-align:center">UMT时间，表示该时间之后资源是否修改</td>
</tr>
<tr>
<td style="text-align:center">If-None-Match</td>
<td style="text-align:center"></td>
<td style="text-align:center">有</td>
<td style="text-align:center">返回服务器响应头的 Etag 值</td>
</tr>
<tr>
<td style="text-align:center">Referer</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
<td style="text-align:center">通过点击超链接进入下一个页面时，在这里会记录上一个页面的 URI</td>
</tr>
<tr>
<td style="text-align:center">Accept-Encoding</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
<td style="text-align:center">客户端可支持的编码格式</td>
</tr>
<tr>
<td style="text-align:center">Accept-Language</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
<td style="text-align:center">客户端可支持的语言</td>
</tr>
<tr>
<td style="text-align:center">If-Match</td>
<td style="text-align:center"></td>
<td style="text-align:center">有</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">If-Unmodified-Since</td>
<td style="text-align:center"></td>
<td style="text-align:center">有</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Range</td>
<td style="text-align:center"></td>
<td style="text-align:center">有</td>
<td style="text-align:center">当只需要回去部分数据时，可通过这个字段指定要获取的数据范围</td>
</tr>
</tbody>
</table>
<h3 id="3-http响应首部字段">3. HTTP响应首部字段</h3>
<table>
<thead>
<tr>
<th style="text-align:center">响应头部字段</th>
<th style="text-align:center">HTTP1.0</th>
<th style="text-align:center">HTTP1.1</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Location</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
<td style="text-align:center">表示信息的准确位置，绝对路径</td>
</tr>
<tr>
<td style="text-align:center">Server</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
<td style="text-align:center">服务器程序的名称和版本号相关信息</td>
</tr>
</tbody>
</table>
<h3 id="4-http实体消息体首部字段">4 HTTP实体（消息体）首部字段</h3>
<table>
<thead>
<tr>
<th style="text-align:center">实体头部字段</th>
<th style="text-align:center">HTTP1.0</th>
<th style="text-align:center">HTTP1.1</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Allow</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
<td style="text-align:center">表示指定的 URI 支持的方法</td>
</tr>
<tr>
<td style="text-align:center">Content-Encoding</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
<td style="text-align:center">消息的编码格式</td>
</tr>
<tr>
<td style="text-align:center">Content-Length</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
<td style="text-align:center">消息体的长度</td>
</tr>
<tr>
<td style="text-align:center">Content-Type</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
<td style="text-align:center">消息体的数据类型</td>
</tr>
<tr>
<td style="text-align:center">Expires</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
<td style="text-align:center">消息体的有效期，UMT 时间</td>
</tr>
<tr>
<td style="text-align:center">Last-Modified</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
<td style="text-align:center">数据最后更新的日期</td>
</tr>
<tr>
<td style="text-align:center">Etag</td>
<td style="text-align:center"></td>
<td style="text-align:center">有</td>
<td style="text-align:center">资源的唯一标识符，控制是否使用缓存</td>
</tr>
</tbody>
</table>
<h2 id="5-http10与http11以及http20相关知识">5. HTTP1.0与HTTP1.1以及HTTP2.0相关知识</h2>
<h3 id="1-http-10">1. HTTP 1.0</h3>
<p>HTTP 协议老的标准是HTTP/1.0，是一种无状态，无连接的应用层协议。 为了提高系统的效率，HTTP 1.0规定浏览器与服务器只保持<strong>短暂的连接</strong>，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。</p>
<p>在HTTP1.0默认是短连接；简单来说就是：每次与服务器交互，都需要新开一个连接！<br>
<img src="http://localhost:4000/post-images/1626872405629.jpg" alt="" loading="lazy"><br>
<img src="http://localhost:4000/post-images/1626872408887.jpg" alt="" loading="lazy"></p>
<p>基于此会发现，http1.0被抱怨最多的就是<strong>连接无法复用</strong>和<strong>队头阻塞（head of line blocking）</strong></p>
<blockquote>
<p>由于HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。</p>
</blockquote>
<h3 id="2-http-11">2. HTTP 1.1</h3>
<p>在HTTP1.1中默认就使用持久化连接来解决：<strong>建立一次连接，多次请求均由这个连接完成！</strong>(如果阻塞了，还是会开新的TCP连接的)</p>
<p>HTTP1.1增加Connection字段，通过设置<strong>Keep-Alive</strong>保持HTTP连接不断。避免每次客户端与服务器请求都要重复建立释放建立TCP连接。提高了网络的利用率。</p>
<p>如果客户端想关闭HTTP连接，可以在请求头中携带Connection:false来告知服务器关闭请求。<br>
<img src="http://localhost:4000/post-images/1626872730153.png" alt="" loading="lazy"></p>
<p>HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。</p>
<p>相对于持久化连接还有另外比较重要的改动：</p>
<ul>
<li>HTTP 1.1增加host字段</li>
<li>HTTP 1.1中引入了Chunked transfer-coding，范围请求，实现断点续传(实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输)</li>
<li>HTTP 1.1管线化(pipelining)理论，客户端可以同时发出多个HTTP请求，而不用一个个等待响应之后再请求</li>
</ul>
<h3 id="3-http-20">3. HTTP 2.0</h3>
<p>在说HTTP2之前，不如先直观比较一下HTTP2和HTTP1.1的区别：<br>
<img src="http://localhost:4000/post-images/1626874953559.gif" alt="" loading="lazy"><br>
上面也已经说了，HTTP 1.1提出了<strong>管线化(pipelining)理论</strong>，但是仅仅是限于理论的阶段上，这个功能默认还是<code>关闭</code>了的。</p>
<p>所以说，无论是HTTP1.0还是HTTP1.1提出了Pipelining理论，还是会出现阻塞的情况。从专业的名词上说这种情况，叫做<strong>线头阻塞</strong>（Head of line blocking）简称：HOLB</p>
<h4 id="1-多路复用-与-二进制传输">1. 多路复用 与 二进制传输</h4>
<p>HTTP2与HTTP1.1最重要的区别就是解决了线头阻塞的问题！其中最重要的改动是：<strong>多路复用 (Multiplexing)</strong></p>
<p>而HTTP2所有性能增强的<code>核心</code>在于新的<code>二进制分帧</code>层(不再以文本格式来传输了)，它定义了如何封装http消息并在客户端与服务器之间传输。</p>
<p>HTTP/2 采用二进制格式传输数据，而非HTTP/1.x 里纯文本形式的报文 ，二进制协议解析起来更高效。<strong>HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。</strong></p>
<p>它把TCP协议的部分特性挪到了应用层，把原来的&quot;Header+Body&quot;的消息&quot;打散&quot;为数个小片的二进制&quot;帧&quot;(Frame)，用&quot;HEADERS&quot;帧存放头数据、&quot;DATA&quot;帧存放实体数据。HTP/2数据分帧后&quot;Header+Body&quot;的报文结构就完全消失了，协议看到的只是一个个的&quot;碎片&quot;。<br>
<img src="http://localhost:4000/post-images/1626875923219.png" alt="" loading="lazy"><br>
<img src="http://localhost:4000/post-images/1626875879453.png" alt="" loading="lazy"><br>
HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。<strong>多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装</strong>。</p>
<p><img src="http://localhost:4000/post-images/1616381290207.jpg" alt="" loading="lazy"><br>
如上图所示，多路复用的技术可以只通过一个 TCP 连接就可以传输所有的请求数据。</p>
<h4 id="2-header-压缩">2. Header 压缩</h4>
<p>HTTP/2并没有使用传统的压缩算法，而是开发了专门的&quot;HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。</p>
<p><strong>具体来说:</strong></p>
<ul>
<li>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送；</li>
<li>每次只发送改变的（需要更新的）数据字段即可</li>
</ul>
<p>例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销<br>
<img src="http://localhost:4000/post-images/1616380864613.png" alt="" loading="lazy"><br>
<img src="http://localhost:4000/post-images/1626876168090.png" alt="" loading="lazy"></p>
<h3 id="3-服务器推送">3. 服务器推送</h3>
<p>服务器除了最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确的需求。</p>
<p>可以在客户端请求index.html的时候，就主动推送后面需要用到的所有静态资源给客户端，并存储在缓存中，大大改善加载时间。<br>
<img src="http://localhost:4000/post-images/1617865820470.jpg" alt="" loading="lazy"></p>
<h2 id="6-对称加密-非对称加密-公钥-私钥-数字签名-数字证书">6. 对称加密、非对称加密、公钥、私钥、数字签名、数字证书</h2>
<h3 id="1-对称数据加密">1. 对称数据加密</h3>
<p><img src="http://localhost:4000/post-images/1619659703397.png" alt="" loading="lazy"><br>
就像上图所示， 这加密和解密算法是公开的，那个密钥是保密的， 只有两人才知道， 这样生成的加密消息（密文） 别人就无法得知了。这叫对称加密算法，因为加密和解密用的是同一个密钥。</p>
<p>问题来了，这个密钥的双方必须得知道，但是通过网络发送又不安全，这该怎么办呢？这时候就出现了非对称数据加密。</p>
<h3 id="2-rsa非对称加密">2. RSA：非对称加密</h3>
<p>这个RSA算法非常有意思，它不是像之前的算法， 双方必须协商一个保密的密钥， 而是有一对儿钥匙， 一个是保密的，称为私钥，另外一个是公开的，称为公钥。</p>
<p>更有意思的是，用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据， 只有对应的私钥才能解密。<br>
<img src="http://localhost:4000/post-images/1619659810918.png" alt="" loading="lazy"><br>
当张大胖给Bill发消息的时候， 就可以先用Bill的公钥去加密（反正Bill的公钥是公开的，地球人都知道）， 等到消息被Bill 收到后， 他就可以用自己的私钥去解密（只有Bill才能解开，私钥是保密的 ）【也就是A发送消息给B时候，利用B的公钥，然后B收到后利用私钥解密接收。】<br>
<img src="http://localhost:4000/post-images/1619659898143.png" alt="" loading="lazy"><br>
反过来也是如此， 当Bill 想给张大胖发消息的时候，就用张大胖的公钥加密， 张大胖收到后，就用自己的私钥解密。</p>
<h3 id="3-非对称加密对称加密">3. 非对称加密+对称加密</h3>
<p>因为RSA的加密和解密的速度比较慢，RSA的算法比之前的对称密钥算法要慢上百倍。</p>
<p>回到咱们最初的问题，我们想用一个密钥来加密通信，那个对称加密算法是非常快的，但是苦于密钥无法安全传输， 现在有了RSA ，我想可以结合一下， 分两步走　(1) 我生成一个对称加密算法的密钥， 用RSA的方式安全发给你， (2) 我们随后就不用RSA了， 只用这个密钥，利用对称加密算法来通信，这样即可以保证安全又可以加快速度。【也就是只利用RSA传输密钥，保证密钥的安全。然后利用对称加密进行信息传输。】</p>
<p>这样以来既解决了密钥的传递问题， 又解决了RSA速度慢的问题，不错。</p>
<p>于是两人就安全地传递了对称加密的密钥， 用它来加密解密，果然快多了！</p>
<p><code>HTTPS就是使用上述混合加密的方法。</code></p>
<h3 id="4-中间人攻击">4. 中间人攻击</h3>
<p><img src="http://localhost:4000/post-images/1619660545440.png" alt="" loading="lazy"><br>
<strong>看来问题出现在公钥的分发上</strong>虽然这个东西是公开的，但是在别有用心的人看来，截取以后还可以干坏事 ！<br>
但是怎么安全地分发公钥呢？ 似乎又回到了最初的问题： 怎么安全的保护密钥（之前是利用非对称保护私钥的传输，现在是考虑如何保证公钥的发送方）？</p>
<p>可是似乎和最初的问题还不一样，这一次的公钥不用保密，但是一定得有个办法声明这个公钥确实是Bill的， 而不是别人的。</p>
<h3 id="5-信息摘要-数字签名-数字证书">5. 信息摘要、数字签名、数字证书</h3>
<p>简单来讲是这样的， Bill可以把他的公钥和个人信息用一个Hash算法生成一个消息摘要， 这个Hash算法有个极好的特性，只要输入数据有一点点变化，那生成的消息摘要就会有巨变，这样就可以防止别人修改原始内容。<br>
<img src="http://localhost:4000/post-images/1619660931513.png" alt="" loading="lazy"><br>
我们会让有公信力的认证中心（简称CA）用它的私钥对消息摘要加密，形成签名：<br>
<img src="http://localhost:4000/post-images/1619660885193.png" alt="" loading="lazy"><br>
这还不算， 还把<strong>原始信息</strong>和<strong>数据签名</strong>合并， 形成一个全新的东西，叫做“数字证书”<br>
<img src="http://localhost:4000/post-images/1619660980624.png" alt="" loading="lazy"><br>
张大胖接着说：当Bill把他的证书发给我的时候， 我就用同样的Hash 算法， 再次生成消息摘要，然后用CA的公钥对数字签名解密， 得到CA创建的消息摘要， 两者一比，就知道有没有人篡改了！</p>
<p>如果没人篡改， 我就可以安全的拿到Bill的公钥喽，有了公钥， 后序的加密工作就可以开始了。<br>
<img src="http://localhost:4000/post-images/1619661151582.png" alt="" loading="lazy"><br>
那么这个CA的公钥怎么保证他的安全性？</p>
<p>附注：我们利用上面数字证书保证传输安全的前提就是，我们默认CA的公钥是安全的。因为CA的公钥安全，所以得出的消息摘要是安全的，这就可以与Hash算法得出的消息摘要比较是否相同，从而确保消息的安全的。</p>
<h2 id="7-http与https的区别及实现方式">7. HTTP与HTTPS的区别及实现方式</h2>
<h3 id="1-基本概念">1. 基本概念</h3>
<p><strong>HTTP是超文本传输协议</strong>，是一个简单的<code>请求-响应协议</code>，它默认工作在TCP的80端口。<strong>它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应</strong>。协议以明文的方式进行发送，不提供任何方式的数据加密。因此HTTP协议不适合传输一些敏感信息</p>
<p><strong>HTTPS是超文本传输安全协议</strong>，是一种<code>安全通信</code>的传输协议。<strong>HTTPS经由HTTP进行通信，但利用 SSL/TSL 来进行加密数据包</strong>。HTTPS开发的主要目的是提供网站服务器的身份认证，保护数据交换的隐私与完整性。</p>
<p>HTTPS默认工作在 TCP 的443 端口，它的工作方式如下：</p>
<ul>
<li>TCP三次同步握手</li>
<li>客户端验证服务端数字证书</li>
<li>DH 算法协商对称加密加密算法的密钥、hash 算法的密钥</li>
<li>SSL 安全加密隧道协商完成</li>
<li>网页以加密的方式进行传输，用协商的对称加密算法和密钥加密，保障数据机密性；用协商的 hash 算法进行数据完整性保护，保证数据不被篡改。</li>
</ul>
<h3 id="2-http的无状态">2. HTTP的无状态</h3>
<p><strong>就是第二次来你无法识别它曾经来过</strong></p>
<p><strong>http的每次请求，在事务上和前后http请求没有任何关联，对上一次请求，下一次请求没有任何影响。这个是定义，从宏观上说的，实际上把无状态说成请求独立，无关联也对</strong></p>
<p>HTTP 是一个无状态协议，这意味着<code>每个请求都是独立</code>的，Keep-Alive 没能改变这个结果。</p>
<p>缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
<p>HTTP 协议这种特性有优点也有缺点，优点在于解放了服务器，每一次请求“点到为止”不会造成不必要连接占用，缺点在于每次请求会传输大量重复的内容信息。</p>
<p>HTTP 无状态的特性严重阻碍了这些应用程序的实现，于是两种用于保持 HTTP 连接状态的技术就应运而生了，一个是 <code>Cookie</code>，而另一个则是 <code>Session</code>。</p>
<p><img src="http://localhost:4000/post-images/1619491336853.png" alt="" loading="lazy"><br>
<img src="http://localhost:4000/post-images/1619491341437.png" alt="" loading="lazy"></p>
<h3 id="3-http-与-https-的区别">3. HTTP 与 HTTPS 的区别</h3>
<ul>
<li>HTTP 使用明文传输，数据都是<strong>未加密</strong>的，安全性较差；HTTPS 数据传输过程是加密的，安全性较好；</li>
<li>使用 HTTPS 一般需要到 <strong>CA 申请证书</strong></li>
<li>HTTP页面的响应比 HTTPS <strong>快</strong>，主要是因为 HTTPS 除了 TCP 的三个包之外，还要加上 ssl 握手的 9 个包</li>
<li>HTTP 和 HTTPS 是完全不同连接方式，用的端口也不一样， 前者是80， 后者是 443</li>
<li>HTTPS 其实就是建构在 SSL/TSL 之上的 HTTP 协议，所以要比 HTTP <strong>更消耗服务器资源</strong></li>
</ul>
<h3 id="4-https-的工作方式">4. HTTPS 的工作方式</h3>
<figure data-type="image" tabindex="1"><img src="http://localhost:4000/post-images/1617862416374.png" alt="" loading="lazy"></figure>
<ol>
<li>客户端发起 HTTPS 请求<br>
建立TCP连接之后，客户端发起请求</li>
<li>服务端的配置<br>
服务端收到请求之后，会有一套公钥和私钥，这对公钥和私钥其实就是一套数字证书，一般都是由受信任的证书颁发机构进行签发。</li>
<li>传送公钥<br>
服务端将公钥传递给客户端，里面包含很多信息，如证书的颁发机构，证书的过期时间</li>
<li>客户端解析证书<br>
这部分工作由客户端的 TSL 来完成，首先验证证书是否有效。如果没有问题，就会随机生成一个 key，然后利用公钥对 key 的值进行加密。</li>
<li>传送加密的信息（key）<br>
将加密过后的 key 传递给服务器</li>
<li>使用私钥解析加密信息（key）<br>
服务器使用自己的私钥解密加密信息得到 key</li>
<li>使用客户端的 key，利用对称加密加密信息，并发送给客户端<br>
把内容通过该 key 进行对称加密，并传输给客户端</li>
<li>客户端使用 key 解密信息<br>
客户端收到信息之后利用 key 进行解密</li>
</ol>
<p><strong>重点：客户端会生成 key，key 的传输使用非对称加密，而数据的传输使用 key 进行对称加密。</strong><br>
<strong>对称加密：加密密钥和解密密钥是同一个，效率较高</strong><br>
<strong>非对称加密：加密密钥和解密密钥不是同一个，效率较低</strong></p>
<p>由于<code>非对称加密的效率比较低</code>，因此我们通常不使用非对称加密对整个文件进行加密，而采用<code>对称加密对文件加密</code>，<code>非对称加密对对称加密的密钥加密</code>，然后将<code>对称加密后的文件和非对称加密后的密钥</code>一起在网上传送。</p>
<h3 id="5-ssl-的位置">5. SSL 的位置</h3>
<p><img src="http://localhost:4000/post-images/1617863364032.png" alt="" loading="lazy"><br>
在发送方，SSL接受应用层的数据（如HTTP或者IMAP报文），对数据进行加密，然后把加了密的数据送往TCP套接字。</p>
<p>在接收方，SSL从TCP套接字读取数据，解密后把数据交给应用层。</p>
<p>使用非对称加密进行文件传输。通信双方在传输时需要交换各自的公钥。</p>
<p><strong>SSL提供以下三个功能：</strong><br>
（1）SSL服务器鉴别：允许用户证实服务器的身份。具有SSL功能的浏览器维持一个表，上面有一些可信赖的认证中心CA（Certificate Authority）和它们的公钥。<br>
（2）加密的SSL会话：客户和服务器交互的所有数据都在发送方加密，在接收方解密。<br>
（3）SSL客户鉴别：允许服务器证实客户的身份。</p>
<h1 id="6-tcpip-和-udp-协议">6. TCP/IP 和 UDP 协议</h1>
<h2 id="1-tcpip-协议分层管理">1. TCP/IP 协议分层管理</h2>
<p><img src="http://localhost:4000/post-images/1617869165303.png" alt="" loading="lazy"><br>
传输层：可靠传输（丢包重发） 、流量控制、不可靠传输（只需要发送一个数据包）</p>
<p>网络层：负责选择最佳路径、规划 IP 地址</p>
<p>数据链路层：帧的开始和结束、透明传输（数据中出现了帧的结束标志，需要采用转义字符）、差错校验（循环冗余检测）</p>
<h2 id="2-tcp三次握手四次挥手机制及原因">2. TCP三次握手四次挥手机制及原因</h2>
<h3 id="1-连接中怎么找到对方">1. 连接中怎么找到对方？</h3>
<p><strong>TCP头部为20字节</strong></p>
<ul>
<li>源端口号（16位）和目的端口号（16位）：<code>再加上Ip首部的源IP地址和目的IP地址可以唯一确定一个TCP连接</code></li>
<li>数据序号（16位）：表示在这个报文段中的第一个数据字节序号</li>
<li>确认序号：仅当ACK标志为1时有效，确认号表示期望收到的下一个字节的序号</li>
<li>偏移：就是头部长度，有4位，跟IP头部一样，以4字节为单位。最大是60个字节</li>
<li>保留位：6位，必须为0</li>
<li>6个标志位：URG-紧急指针有效；ACK-确认序号有效；PSH-接收方应尽快将这个报文交给应用层；RST-连接重置；SYN-同步序号用来发起一个连接；FIN-终止一个连接。</li>
<li>窗口字段：16位，代表的是窗口的字节容量，也就是TCP的标准窗口最大为2^16 - 1 = 65535个字节</li>
<li>校验和：源机器基于数据内容计算一个数值，收信息机要与源机器数值结果完全一样，从而证明数据的有效性。检验和覆盖了整个的TCP报文段：这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证的。</li>
</ul>
<h3 id="2-三次握手">2. 三次握手</h3>
<figure data-type="image" tabindex="2"><img src="http://localhost:4000/post-images/1617869541484.png" alt="" loading="lazy"></figure>
<p><strong>为什么需要三次握手，两次行不行？</strong></p>
<p>假设是两次握手，客户端刚开始发送第一个建立连接的请求，但是由于该请求在某一个路由器中停留时间过长，客户端一段时间没收到服务器的响应消息，就会再发一个建立连接的请求，这个请求达到服务器，并成功建立连接，之后数据传输完成，关闭连接。这时候先前发送的第一个建立连接的请求，终于通过网络传到了服务器，服务器收到请求，返回一个数据包，并立即打开连接，这是客户端已经关闭了，对服务端的数据包不予理睬，这样就会导致服务端资源的浪费。</p>
<p><strong>为什么不能四次握手？</strong><br>
四次握手的流程：</p>
<ol>
<li>客户端发送：SYN=1,ACK=0,seq=x</li>
<li>服务端收到客户端消息，发送：ACK = 1, 确认号=x+1,seq=y</li>
<li>服务端发送同步建立连接，发送：SYN=1，确认号=x+1，seq = w</li>
<li>客户端收到发送：ACK=1，确认号=w+1,seq = x+1</li>
</ol>
<p>在这个过程中，显然第二步和第三步可以合并，不需要单独发送一个 SYN</p>
<h3 id="3-四次挥手">3. 四次挥手</h3>
<p><img src="http://localhost:4000/post-images/1617870529977.png" alt="" loading="lazy"><br>
既然握手的时候，服务端发送的两个请求可以合并，<strong>那么释放连接的时候，是否也能合并，只需三次握手呢？</strong></p>
<p>我们的回答是不能够，因为当服务器收到客户端关闭连接的请求的时候，服务端可能还在继续发送数据，但是他又必须先给客户端一个回应，说我收到了请求。等服务端的数据发送完毕之后，再发一个数据包说我已经可以关闭请求了。客户端收到之后再作出回应。</p>
<p><strong>客户端为什么要有TIME-WAIT阶段</strong>？</p>
<p>防止最后一个数据包丢失而导致服务器接收不到，一段时间后服务器会重新发送第三个数据包。如果此时客户端已经关闭了，则收不到第三个数据包，服务端也就无法正常关闭了。</p>
<h2 id="3tcpudp-的区别">3.TCP/UDP 的区别</h2>
<table>
<thead>
<tr>
<th style="text-align:center">TCP</th>
<th style="text-align:center">UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">面向连接，是指发送数据之前必须在两端建立TCP连接，连接方式为三次握手</td>
<td style="text-align:center">不面向连接</td>
</tr>
<tr>
<td style="text-align:center">可靠传输，流量控制与拥塞控制</td>
<td style="text-align:center">不可靠传输，尽最大努力交付</td>
</tr>
<tr>
<td style="text-align:center">传输方式上以字节流的形式传输</td>
<td style="text-align:center">以报文形式传输</td>
</tr>
<tr>
<td style="text-align:center">只能是一对一通信</td>
<td style="text-align:center">支持一对一、一对多、多对多、多对一交互通信</td>
</tr>
<tr>
<td style="text-align:center">最小20字节，最多60字节</td>
<td style="text-align:center">首部开销较小，只有 8 字节</td>
</tr>
<tr>
<td style="text-align:center">适用于要求可靠传输的应用</td>
<td style="text-align:center"><strong>适用于实时应用，如视频会议、直播等</strong></td>
</tr>
</tbody>
</table>
<h1 id="7-getpostputdeleteoptions等请求方式">7. GET,POST,PUT,DELETE,OPTIONS等请求方式</h1>
<h2 id="1-不同请求方式区别">1. 不同请求方式区别</h2>
<h3 id="1-get">1. GET</h3>
<p>get请求是用来获取数据的，只是用来<code>查询数据</code>，不对服务器的数据做任何的修改，新增，删除等操作。</p>
<p>在这里我们认为get请求是<code>安全的</code>，以及<code>幂等的</code>。安全就是指不影响服务器的数据，幂等是指同一个请求发送多次返回的结果应该相同。</p>
<p><strong>特点：</strong></p>
<ol>
<li>get请求会把请求的参数附加在URL后面，这样会产生安全问题，如果是系统的登陆接口采用的get请求，需要对请求的参数做一个加密。</li>
<li>get请求其实本身HTTP协议并没有限制它的URL大小，但是不同的浏览器对其有不同的大小长度限制</li>
</ol>
<h3 id="2-post">2. POST</h3>
<p>post请求一般是对服务器的数据做改变，常用来数据的提交，新增操作。</p>
<p><strong>特点：</strong></p>
<ol>
<li>post请求的请求参数都是请求体中</li>
<li>post请求本身HTTP协议也是没有限制大小的，限制它的是服务器的处理能力</li>
</ol>
<h3 id="3-put">3. PUT</h3>
<p>put请求与post一样都会改变服务器的数据，但是put的侧重点在于对于数据的修改操作，但是post侧重于对于数据的增加。</p>
<h3 id="4-delete">4. DELETE</h3>
<p>delete请求用来删除服务器的资源。</p>
<h3 id="5-options">5. OPTIONS</h3>
<p>options请求属于浏览器的<code>预检请求</code>，查看服务器是否接受请求，预检通过后，浏览器才会去发get，post，put，delete等请求。至于什么情况下浏览器会发预检请求，浏览器会会将请求分为两类，简单请求与非简单请求，<code>非简单请求</code>会产生预检options请求。(结合CORS跨域)</p>
<h2 id="2-浏览器的get和post">2. 浏览器的GET和POST</h2>
<p>浏览器用GET请求来获取一个html页面/图片/css/js等资源；用POST来提交一个<form>表单，并得到一个结果的网页。</p>
<h3 id="1-get-2">1. GET</h3>
<p>“读取“一个资源。比如Get到一个html文件。反复读取不应该对访问的数据有副作用。没有副作用被称为“幂等“（Idempotent)。因为GET因为是读取，就可以对GET请求的数据做缓存。这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），或者做到server端（用Etag，至少可以减少带宽消耗）</p>
<h3 id="2-post-2">2. POST</h3>
<p>在页面里&lt;form&gt; 标签会定义一个表单。点击其中的submit元素会发出一个POST请求让服务器做一件事。这件事往往是有副作用的，<code>不幂等</code>的。不幂等也就意味着不能随意多次执行。因此也就不能缓存。</p>
<p>此外如果尝试重新执行POST请求，浏览器也会弹一个框提示下这个刷新可能会有副作用，询问要不要继续。<br>
<img src="http://localhost:4000/post-images/1618324396186.jpg" alt="" loading="lazy"></p>
<h3 id="3-区别">3. 区别</h3>
<p><code>GET和POST携带数据的格式也有区别</code>。当浏览器发出一个GET请求时，就意味着要么是用户自己在浏览器的地址栏输入，要不就是点击了html里a标签的href中的url。所以其实并不是GET只能用url，而是浏览器直接发出的GET只能由一个url触发。所以没办法，GET上要在url之外带一些参数就只能依靠url上附带querystring。但是HTTP协议本身并没有这个限制。</p>
<p><code>浏览器的POST请求都来自表单提交</code>。每次提交，表单的数据被浏览器用编码到HTTP请求的body里。浏览器发出的POST请求的body主要有有两种格式，一种是application/x-www-form-urlencoded用来传输简单的数据，大概就是&quot;key1=value1&amp;key2=value2&quot;这样的格式。另外一种是传文件，会采用multipart/form-data格式。采用后者是因为application/x-www-form-urlencoded的编码方式对于文件这种二进制的数据非常低效。</p>
<p>浏览器在POST一个表单时，url上也可以带参数，只要&lt;form action=&quot;url&quot; &gt;里的url带querystring就行。只不过表单里面的那些用&lt;input&gt; 等标签经过用户操作产生的数据都在会在body里。</p>
<h2 id="3-接口中的get和post">3. 接口中的GET和POST</h2>
<p>这里是指通过浏览器的Ajax api，或者iOS/Android的App的http client，java的commons-httpclient/okhttp或者是curl，postman之类的工具发出来的GET和POST请求。此时GET/POST不光能用在前端和后端的交互中，还能用在后端各个子服务的调用中（即当一种RPC协议使用）。尽管RPC有很多协议，比如thrift，grpc，但是http本身已经有大量的现成的支持工具可以使用，并且对人类很友好，容易debug。HTTP协议在微服务中的使用是相当普遍的。</p>
<p>当用HTTP实现接口发送请求时，就<code>没有浏览器中那么多限制</code>了，只要是符合HTTP格式的就可以发。HTTP请求的格式，大概是这样的一个字符串（为了美观，我在\r\n后都换行一下）：</p>
<pre><code>&lt;METHOD&gt; &lt;URL&gt; HTTP/1.1\r\n
&lt;Header1&gt;: &lt;HeaderValue1&gt;\r\n
&lt;Header2&gt;: &lt;HeaderValue2&gt;\r\n
...
&lt;HeaderN&gt;: &lt;HeaderValueN&gt;\r\n
\r\n
&lt;Body Data....&gt;
</code></pre>
<p>接口规范/风格。其中名气最大的当属REST。REST充分运用GET、POST、PUT和DELETE，约定了这4个接口分别获取、创建、替换和删除“资源”，REST最佳实践还推荐在请求体使用json格式。这样仅仅通过看HTTP的method就可以明白接口是什么意思，并且解析格式也得到了统一。</p>
<blockquote>
<p>json相对于x-www-form-urlencoded的优势在于<br>
1）可以有嵌套结构；<br>
2）可以支持更丰富的数据类型。通过一些框架，json可以直接被服务器代码映射为业务实体。用起来十分方便。但是如果是写一个接口支持上传文件，那么还是multipart/form-data格式更合适。</p>
</blockquote>
<p>REST中GET和POST不是随便用的。在REST中, 【GET】 + 【资源定位符】被专用于获取资源或者资源列表，比如：</p>
<pre><code>GET http://foo.com/books          获取书籍列表
GET http://foo.com/books/:bookId  根据bookId获取一本具体的书
</code></pre>
<p>REST 【POST】+ 【资源定位符】则用于“创建一个资源”，比如：</p>
<pre><code>POST http://foo.com/books
{
  &quot;title&quot;: &quot;大宽宽的碎碎念&quot;,
  &quot;author&quot;: &quot;大宽宽&quot;,
  ...
}
</code></pre>
<p>这里你就能留意到<strong>浏览器中用来实现表单提交的POST</strong>，和REST里实现创建资源的POST语义上的不同。</p>
<h2 id="4-关于安全性">4. 关于安全性</h2>
<p>我们常听到GET不如POST安全，因为POST用body传输数据，而GET用url传输，更加容易看到。但是从攻击的角度，无论是GET还是POST都不够安全，因为HTTP本身是<code>明文协议</code>。<code>每个HTTP请求和返回的每个byte都会在网络上明文传播，不管是url，header还是body</code>。这完全不是一个“是否容易在浏览器地址栏上看到“的问题。</p>
<p>为了避免传输中数据被窃取，<code>必须做从客户端到服务器的端端加密。业界的通行做法就是https</code>——即用SSL协议协商出的密钥加密明文的http数据。这个加密的协议和HTTP协议本身相互独立。如果是利用HTTP开发公网的站点/App，要保证安全，https是最最基本的要求。</p>
<p>从客户端到服务器端，有大量的中间节点，包括网关，代理等。他们的access log通常会输出完整的url，比如nginx的默认access log就是如此。如果url上携带敏感数据，就会被记录下来。但请注意，<code>就算私密数据在body里，也是可以被记录下来的</code>，因此如果请求要经过不信任的公网，避免泄密的<code>唯一手段就是https</code>。这里说的“避免access log泄漏“仅仅是指避免可信区域中的http代理的默认行为带来的安全隐患。<br>
<img src="http://localhost:4000/post-images/1618325278742.jpg" alt="" loading="lazy"></p>
<h2 id="5-关于url的长度">5. 关于URL的长度</h2>
<p>因为上面提到了不论是GET和POST都可以使用URL传递数据，所以我们常说的“GET数据有长度限制“其实是指”URL的长度限制“。</p>
<p>HTTP协议本身对URL长度并没有做任何规定。实际的限制是由客户端/浏览器以及服务器端决定的。</p>
<p>先说浏览器。不同浏览器不太一样。比如我们常说的2048个字符的限制，其实是IE8的限制。并且原始文档的说的其实是“URL的最大长度是2083个字符，path的部分最长是2048个字符“。Chrome的URL限制是2MB</p>
<p>除了浏览器，服务器这边也有限制，比如apache的LimieRequestLine指令。</p>
<p>apache实际上限制的是HTTP请求第一行“Request Line“的长度，即&lt;METHOD&gt;&lt;URL&gt; &lt;VERSION&gt;那一行。再比如nginx用<code>large_client_header_buffers</code> 指令来分配请求头中的很长数据的buffer。这个buffer可以用来处理url，header value等。</p>
<p>为啥要限制呢？如果写过解析一段字符串的代码就能明白，解析的时候要分配内存。对于一个字节流的解析，必须分配buffer来保存所有要存储的数据。而URL这种东西必须当作一个整体看待，无法一块一块处理，于是就处理一个请求时必须分配一整块足够大的内存。如果URL太长，而并发又很高，就容易挤爆服务器的内存；同时，超长URL的好处并不多，我也只有处理老系统的URL时因为不敢碰原来的逻辑，又得追加更多数据，才会使用超长URL。</p>
<h1 id="8-ajax-axios库">8. ajax、 axios库</h1>
<h2 id="1-ajax">1. ajax</h2>
<ul>
<li>创建XMLHttpRequest类型的对象</li>
<li>准备发送，打开与网址之间的连接</li>
<li>执行发送动作</li>
<li>指定xhr状态变化事件处理函数</li>
</ul>
<pre><code>// 1.创建一个 XMLHttpRequest 类型的对象  --- 相当于打开了一个浏览器
var xhr = new XMLHttpRequest();
// 2.打开一个与网址之间的连接  --- 相当于在地址栏输入网址
xhr.open(&quot;GET&quot;,&quot;https://jsonplaceholder.typicode.com/users&quot;);
// 3.通过连接发送一次请求 --- 相当于点击回车或者超链接
xhr.send(null);
// 4.指定 xhr 状态变化事件处理函数   --- 相当于处理网页呈现后的操作
xhr.onreadystatechange = function () {
  // 通过判断 xhr 的 readyState ，确定此次请求是否完成
  if (this.readyState === 4) {
    console.log(this.responseText)
  }
}
</code></pre>
<h2 id="2-axios-api">2. Axios API</h2>
<ul>
<li>可以通过向axios()传递相关配置来创建请求</li>
<li>axios(config) config为对象格式的配置选项</li>
<li>axios(url,config) config可选</li>
</ul>
<p><strong>常用配置选项</strong></p>
<ul>
<li>url 用于请求服务器的URL</li>
<li>method 创建请求时使用的方法</li>
<li>baseURL 传递相对URL前缀，将自动加在url前面</li>
<li>headers 即将被发送的自定义请求头</li>
<li>params 即将与请求一起发送的URL参数</li>
<li>data 作为请求主体被发送的数据</li>
<li>timeout 请求超时的毫秒数</li>
<li>responseType 表示服务器响应的数据类型，默认json</li>
</ul>
<pre><code>axios({
  url: &quot;/posts&quot;,
  method: &quot;get&quot;,
  baseURL: &quot;http://localhost:3000&quot;,
  params: {
    id: 1
  }
}).then(function(res){
  console.log(res.data)
})
</code></pre>
<h1 id="9-前端安全xss-csrf">9. 前端安全XSS、CSRF</h1>
<h2 id="1-xss">1. XSS</h2>
<blockquote>
<p>跨网站指令码（英语：Cross-site scripting，通常简称为：XSS）XSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。</p>
</blockquote>
<p>攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。有很多种方式进行 XSS 攻击，但它们的共同点为：将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。</p>
<p>XSS 分为三种：<strong>反射型，存储型和 DOM-based</strong></p>
<h3 id="1-反射性">1. 反射性</h3>
<p>反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。</p>
<p>看一个示例。我先准备一个如下的静态页：<br>
<img src="http://localhost:4000/post-images/1616308450110.png" alt="" loading="lazy"><br>
当用户点击恶意链接时，页面跳转到攻击者预先准备的页面，会发现在攻击者的页面执行了 js 脚本：<br>
<img src="http://localhost:4000/post-images/1616308453096.png" alt="" loading="lazy"><br>
这样就产生了反射型 XSS 攻击。攻击者可以注入任意的恶意脚本进行攻击，可能注入恶作剧脚本，或者注入能获取用户隐私数据(如cookie)的脚本，这取决于攻击者的目的。</p>
<h3 id="2-存储型">2. 存储型</h3>
<p>存储型 XSS 会把用户输入的数据 “存储” 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。</p>
<p>比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。</p>
<p>当用户点击提交按钮将输入信息提交到服务端时，服务端通过 userInput 变量保存了输入内容。当用户通过 http://localhost:8001/${id} 访问时，服务端会返回与 id 对应的内容(本示例简化了处理)。如果用户输入了恶意脚本内容，则其他用户访问该内容时，恶意脚本就会在浏览器端执行：<br>
<img src="http://localhost:4000/post-images/1616308560547.png" alt="" loading="lazy"></p>
<h3 id="3-基于dom">3. 基于DOM</h3>
<p>基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。</p>
<p>点击 Submit 按钮后，会在当前页面插入一个链接，其地址为用户的输入内容。如果用户在输入时构造了如下内容：</p>
<pre><code>'' onclick=alert(/xss/)
</code></pre>
<p>用户提交之后，页面代码就变成了：</p>
<pre><code>&lt;a href onlick=&quot;alert(/xss/)&quot;&gt;testLink&lt;/a&gt;
</code></pre>
<p>此时，用户点击生成的链接，就会执行对应的脚本：<br>
<img src="http://localhost:4000/post-images/1616308646010.png" alt="" loading="lazy"></p>
<h2 id="2-xss攻击的防范">2. XSS攻击的防范</h2>
<p>现在主流的浏览器内置了防范 XSS 的措施，例如 CSP。但对于开发者来说，也应该寻找可靠的解决方案来防止 XSS 攻击。</p>
<h3 id="1-httponly-防止劫取-cookie">1. HttpOnly 防止劫取 Cookie</h3>
<p>浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。</p>
<p>上文有说到，攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。</p>
<h3 id="2-输入检查">2. 输入检查</h3>
<p>不要相信用户的任何输入。 对于用户的任何输入要进行检查、过滤和转义。建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。</p>
<p>在 XSS 防御中，输入检查一般是检查用户输入的数据中是否包含 &lt;，&gt; 等特殊字符，如果存在，则对特殊字符进行过滤或编码，这种方式也称为 XSS Filter。</p>
<p>而在一些前端框架中，都会有一份 decodingMap， 用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 &lt;，&gt;，script，防止 XSS 攻击：</p>
<pre><code>// vuejs 中的 decodingMap
// 在 vuejs 中，如果输入带 script 标签的内容，会直接过滤掉
const decodingMap = {
  '&amp;lt;': '&lt;',
  '&amp;gt;': '&gt;',
  '&amp;quot;': '&quot;',
  '&amp;amp;': '&amp;',
  '
  ': '\n'
}
</code></pre>
<h3 id="3-输出检查">3. 输出检查</h3>
<p>用户的输入会存在问题，服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。例如利用 sanitize-html 对输出内容进行有规则的过滤之后再输出到页面中。</p>
<h2 id="3-csrf">3. CSRF</h2>
<blockquote>
<p>跨站请求伪造（英语：Cross-site request forgery），中译是跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。</p>
</blockquote>
<p>通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。<br>
<img src="http://localhost:4000/post-images/1615455801140.jpg" alt="" loading="lazy"></p>
<h3 id="1-浏览器的-cookie-策略">1. 浏览器的 Cookie 策略</h3>
<p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。Cookie 主要用于以下两个方面：</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
</ul>
<p>而浏览器所持有的 Cookie 分为两种：</p>
<ul>
<li>Session Cookie(会话期 Cookie)：会话期 Cookie 是最简单的Cookie，它不需要指定过期时间（Expires）或者有效期（Max-Age），它仅在会话期内有效，浏览器关闭之后它会被自动删除。</li>
<li>Permanent Cookie(持久性 Cookie)：与会话期 Cookie 不同的是，持久性 Cookie 可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。</li>
</ul>
<pre><code>res.setHeader('Set-Cookie', ['mycookie=222', 'test=3333; expires=Sat, 21 Jul 2018 00:00:00 GMT;']);
</code></pre>
<p>上述代码创建了两个 Cookie：mycookie 和 test，前者属于会话期 Cookie，后者则属于持久性 Cookie。当我们去查看 Cookie 相关的属性时，不同的浏览器对会话期 Cookie 的 Expires 属性值会不一样：<br>
<img src="http://localhost:4000/post-images/1616309731128.png" alt="" loading="lazy"><br>
每个 Cookie 都会有与之关联的域，这个域的范围一般通过 donmain 属性指定。如果 Cookie 的域和页面的域相同，那么我们称这个 Cookie 为第一方 Cookie（first-party cookie），如果 Cookie 的域和页面的域不同，则称之为第三方 Cookie（third-party cookie）。一个页面包含图片或存放在其他域上的资源（如图片）时，第一方的 Cookie 也只会发送给设置它们的服务器。</p>
<h3 id="2-通过-cookie-进行-csrf-攻击">2. 通过 Cookie 进行 CSRF 攻击</h3>
<p>假设有一个 bbs 站点：http://www.c.com，当登录后的用户发起如下 GET 请求时，会删除 ID 指定的帖子：</p>
<pre><code>http://www.c.com:8002/content/delete/:id
</code></pre>
<p>如发起 http://www.c.com:8002/content/delete/87343 请求时，会删除 id 为 87343 的帖子。当用户登录之后，会设置如下 cookie：</p>
<pre><code>res.setHeader('Set-Cookie', ['user=22333; expires=Sat, 21 Jul 2018 00:00:00 GMT;']);
</code></pre>
<p><img src="http://localhost:4000/post-images/1616309827160.png" alt="" loading="lazy"><br>
user 对应的值是用户 ID。然后构造一个页面 A：</p>
<p>CSRF 攻击者准备的网站：</p>
<pre><code>&lt;p&gt;CSRF 攻击者准备的网站：&lt;/p&gt;
&lt;img src=&quot;http://www.c.com:8002/content/delete/87343&quot;&gt;
页面 A 使用了一个 img 标签，其地址指向了删除用户帖子的链接：
</code></pre>
<p><img src="http://localhost:4000/post-images/1616309871152.png" alt="" loading="lazy"><br>
可以看到，当登录用户访问攻击者的网站时，会向 www.c.com 发起一个删除用户帖子的请求。此时若用户在切换到 www.c.com 的帖子页面刷新，会发现ID 为 87343 的帖子已经被删除。</p>
<p>由于 Cookie 中包含了用户的认证信息，当用户访问攻击者准备的攻击环境时，攻击者就可以对服务器发起 CSRF 攻击。在这个攻击过程中，攻击者借助受害者的 Cookie 骗取服务器的信任，但并不能拿到 Cookie，也看不到 Cookie 的内容。而对于服务器返回的结果，由于浏览器同源策略的限制，攻击者也无法进行解析。因此，攻击者无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。</p>
<p>但若 CSRF 攻击的目标并不需要使用 Cookie，则也不必顾虑浏览器的 Cookie 策略了。</p>
<h2 id="4-csrf-攻击的防范">4. CSRF 攻击的防范</h2>
<p>当前，对 CSRF 攻击的防范措施主要有如下几种方式。</p>
<h3 id="1-验证码">1. 验证码</h3>
<p>验证码被认为是对抗 CSRF 攻击最简洁而有效的防御方法。</p>
<p>从上述示例中可以看出，CSRF 攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。因为通常情况下，验证码能够很好地遏制 CSRF 攻击。</p>
<p>但验证码并不是万能的，因为出于用户考虑，不能给网站所有的操作都加上验证码。因此，验证码只能作为防御 CSRF 的一种辅助手段，而不能作为最主要的解决方案。</p>
<h3 id="2-referer-check">2. Referer Check</h3>
<p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的”源”。</p>
<p>比如，如果用户要删除自己的帖子，那么先要登录 www.c.com，然后找到对应的页面，发起删除帖子的请求。此时，Referer 的值是 http://www.c.com；当请求是从 www.a.com 发起时，Referer 的值是 http://www.a.com 了。因此，要防御 CSRF 攻击，只需要对于每一个删帖请求验证其 Referer 值，如果是以 www.c.com 开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是 CSRF 攻击，可以拒绝该请求。</p>
<p>Referer Check 不仅能防范 CSRF 攻击，另一个应用场景是 “防止图片盗链”。</p>
<h3 id="3-添加-token-验证token令牌">3. 添加 token 验证(token==令牌)</h3>
<p>CSRF 攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie 中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>
<h1 id="10-websocket">10. Websocket</h1>
<p>webSocket是一项可以让服务器将数据主动推送给客户端的技术。</p>
<h2 id="1-websocket简介">1. Websocket简介</h2>
<p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。<br>
<img src="http://localhost:4000/post-images/1617946374224.png" alt="" loading="lazy"><br>
<strong>其他特点包括：</strong></p>
<ol>
<li>建立在 TCP 协议之上，服务器端的实现比较容易。</li>
<li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li>
<li>数据格式比较轻量，性能开销小，通信高效。</li>
<li>可以发送文本，也可以发送二进制数据。</li>
<li>没有同源限制，客户端可以与任意服务器通信。</li>
<li>协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>），服务器网址就是 URL。</li>
</ol>
<pre><code>ws://example.com:80/some/path
</code></pre>
<figure data-type="image" tabindex="3"><img src="http://localhost:4000/post-images/1617946965265.jpg" alt="" loading="lazy"></figure>
<h2 id="2-websocket客户端示例">2. Websocket客户端示例</h2>
<pre><code>var ws = new WebSocket(&quot;wss://echo.websocket.org&quot;);

ws.onopen = function(evt) { 
  console.log(&quot;Connection open ...&quot;); 
  ws.send(&quot;Hello WebSockets!&quot;);
};

ws.onmessage = function(evt) {
  console.log( &quot;Received Message: &quot; + evt.data);
  ws.close();
};

ws.onclose = function(evt) {
  console.log(&quot;Connection closed.&quot;);
};      
</code></pre>
<h2 id="3-websocket应用场景">3. websocket应用场景</h2>
<p>1、社交订阅<br>
2、多玩家游戏<br>
3、协同编辑文档<br>
4、数据流状态<br>
5、多人聊天</p>
<h1 id="11-即时通信">11. 即时通信</h1>
<h2 id="sse">SSE</h2>
<p>ajax和JSONP 都是 client-fetch的操作. 但是有时候, 我们更需要服务器主动给我们发信息. 比如，现在的APP应用，完全可以实现服务器发送, 然后Client再处理。而SSE就是帮助我们向webapp靠近</p>
<p><strong>SSE 全称就是 Server-Sent Events</strong>，，中译为 <code>服务器推送</code><br>
他的技术并不是很难，和websocket不同，他依赖原生的HTTP，所以对于开发者来说更好理解。<br>
比如，在nodeJS， 只要我不执行res.end()，并且一定时间持续发送信息的话，那么该连接就会持续打开(keep-alive)<br>
其实通俗来说，就是一个长连接。 所以，以前我们通常使用ajax，iframe长轮询来代替他。但是这样有个缺点就是，可操控性弱， 错误率高。<br>
所以，正对于这点W3C, 觉得需要在客户端另外指定一个机制–能够保证服务器推送, 实现连接的keep-alive，操作简单… 在这样背景下SSE诞生了</p>
<h1 id="12-模块化commonjses6cmdamd">12. 模块化，commonJS，es6，cmd，amd</h1>
<h2 id="1-es6-moudle">1. ES6 Moudle</h2>
<p>这个是目前前端小伙伴接触的最多的，是浏览器和服务端通用的模块化解决方案，主要命令为：export和import<br>
export用于导出本模块对外的接口，import用于导入某个模块的功能。</p>
<blockquote>
<ol>
<li>如果单独导出一个变量或方法则是往将要导出{}对象里面添加属性。<br>
2.如果导出的是{}，则和已生成的导出{}对象合并。</li>
</ol>
</blockquote>
<p>然后说一下特例<code>export default</code>，这个是在导出对象里面加一个<code>default</code>属性，还有一点值得注意的是<code>export default</code>后面不能跟变量表达式。</p>
<h2 id="2-commonjs">2. CommonJS</h2>
<p><code>CommonJS</code>最主要的代表就是<code>Node.js</code>，主要命令：<code>module、exports、require</code>。其中有个令人疑惑的点是exports和module.exports，其实理解起来也很简单，就是在模块里面加了一句： <code>exports = module.exports = {};</code> exports和module.exports指向同一个内存区域，只要在exports加了属性，则module.exports会跟着变化，但是最终导出对外的接口是以module.exports为准，所以不推荐直接使用exports。</p>
<p>对于<code>CommonJS</code>规范来说，很重要的一点是<code>CommonJS</code>输出的是一个值拷贝，并且是运行时加载。</p>
<h2 id="3-commonjs和es6-module的区别">3. CommonJS和ES6 Module的区别</h2>
<ul>
<li>引用方式：CommonJS模块输出是值的拷贝，ES6 Module模块输出的值是引用</li>
<li>时机：CommonJS是运行时加载，ES6 Module是编译是输出</li>
<li>前者支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案</li>
<li>前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li>
<li>前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li>
<li>后者会编译成 require/exports 来执行的</li>
</ul>
<h2 id="4-amd">4. AMD</h2>
<p><code>AMD</code>规范是采用异步方式，依赖前置必须一开始就写好，所有的依赖加载完成后才会执行回调函数里的内容，模块的加载不影响它后面语句的运行。</p>
<p>这里异步指的是不堵塞浏览器其他任务（dom构建，css渲染等），而加载内部是同步的（加载完模块后立即执行回调）。</p>
<p>AMD也采用require命令加载模块，但是不同于CommonJS，它要求两个参数：</p>
<pre><code>require([module], callback);
</code></pre>
<h2 id="cmd">CMD</h2>
<p>CMD推崇<code>依赖就近，延迟执行</code>。可以把你的依赖写进代码的任意一行，如下：</p>
<pre><code>define(factory)
</code></pre>
<p>factory为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。factory 方法在执行时，默认会传入三个参数：require、exports 和 module.</p>
<h1 id="13-负载均衡">13. 负载均衡</h1>
<h2 id="1-负载均衡概念">1. 负载均衡概念</h2>
<p>是指单台服务器性能达到极限时通过服务器集群来横向增加系统的吞吐量和性能。<br>
<img src="http://localhost:4000/post-images/1628733553835.jpeg" alt="" loading="lazy"></p>
<h2 id="2-服务器负载均衡">2. 服务器负载均衡</h2>
<p>服务器负载均衡就是我们平时说的负载均衡，是指在服务器上游做服务分发，常用的方式有一下几种：</p>
<ul>
<li><strong>DNS域名解析负载均衡</strong>：假设我们的域名指向了多个IP地址，当一个域名请求来时，DNS服务器机进行域名解析将域名转换为IP地址是，在1:N的映射转换中实现负载均衡。DNS服务器提供简单的负载均衡算法，但当其中某台服务器出现故障时，通知DNS服务器移除当前故障IP。</li>
<li><strong>反向代理负载均衡</strong>：反向代理只值对服务器的代理，代理服务器接受请求，通过负载均衡算法，将请求转发给后端服务器，后端服务返回给代理服务器然后代理服务器返回到客户端。反向代理服务器的优点是隔离后端服务器和客户端，使用双网卡屏蔽真实服务器网络，安全性更好，相比较于DNS域名解决负载均衡，反向代理在故障处理方面更灵活，支持负载均衡算法的横向扩展。目前使用非常广泛。当然反向代理也需要考虑很多问题，比如单点故障，集群部署等。</li>
<li><strong>IP负载均衡</strong>：我们都知道反向代理工作到HTTP层，本身开销相对大一些，对性能有一定影响，LVS-NAT是一种卫浴传输层的负载均衡，它通过修改接受的数据包目标地址的方式实现负载均衡。Linux2.6.x以后版本内置了IPVS，专注用于实现IP负载均衡，故而在Linux上IP负载均衡使用非常广泛。LVS-DR工作在数据链路层，比LVS-NAT更霸道的时候它直接修改数据包的MAC地址。LVS-TUN——基于IP隧道的请求转发机制，将调度器收到的IP数据包进行封装，转交给服务器，然后服务器返回数据，通过调度器实现负载均衡。这种方式支持跨网段调度。总结一下，LVS-DR和LVS-TUN都适合响应和请求不对称的Web服务器，如何从它们中做出选择，取决于你的网络部署需要，因为LVS-TUN可具有跨地域性，有类似这种需求的，就应该选择LVS-TUN。</li>
</ul>
<h2 id="3-客户端负载均衡">3. 客户端负载均衡</h2>
<p>相比较服务器负载均衡而言，客户端负载均衡是一个非常小众的概念，但是面试在问道负载均衡相关知识的时候却会刻意了解候选人的知识广度。客户端负载均衡是在spring-cloud分布式框架组件Ribbon中定义的。我们在使用spring-cloud分布式框架时，同一个service大概率同时启动多个，当一个请求奔过来时，那么这多个service，Ribbon通过策略决定本次请求使用哪个service的方式就是客户端负载均衡。在spring-cloud分布式框架中客户端负载均衡对开发者是透明的，添加@LoadBalanced注解就可以了。客户端负载均衡和服务器负载均衡的核心差异在服务列表本身，客户端负载均衡服务列表在通过客户端维护，服务器负载均衡服务列表由中间服务单独维护。</p>
<p>通过对以上知识的理解，大家能够对负载均衡有的较为全面的认识，下来我再简单的和面试官聊一聊常见的负载均衡算法：</p>
<ul>
<li>随机，通过随机选择服务进行执行，一般这种方式使用较少;</li>
<li>轮训，负载均衡默认实现方式，请求来之后排队处理;</li>
<li>加权轮训，通过对服务器性能的分型，给高配置，低负载的服务器分配更高的权重，均衡各个服务器的压力;</li>
<li>地址Hash，通过客户端请求的地址的HASH值取模映射进行服务器调度。</li>
<li>最小链接数;即使请求均衡了，压力不一定会均衡，最小连接数法就是根据服务器的情况，比如请求积压数等参数，将请求分配到当前压力最小的服务器上。</li>
</ul>

            </div>
            
              <div class="reward-btn">
                <div class="reward-btn-text">赞赏</div>
              </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      来碗鸡丁炒饭
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="http://localhost:4000/post/mian-qian-duan-zhi-shi-dian-shu-li-fu-wu-duan-yu-wang-luo/" title="【面】前端知识点梳理（服务端与网络）">http://localhost:4000/post/mian-qian-duan-zhi-shi-dian-shu-li-fu-wu-duan-yu-wang-luo/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="http://localhost:4000/tag/UEfKsNsBO/"># Interview</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="【面】前端知识点梳理（Vue）" href="http://localhost:4000/post/mian-qian-duan-zhi-shi-dian-shu-li-vue/">【面】前端知识点梳理（Vue）</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="【面】前端知识点梳理（Vue）" href="http://localhost:4000/post/mian-qian-duan-zhi-shi-dian-shu-li-vue/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="【面】前端知识点梳理（浏览器）" href="http://localhost:4000/post/mian-qian-duan-zhi-shi-dian-shu-li-liu-lan-qi/">【面】前端知识点梳理（浏览器）</a>
        <a class="nav-mobile-next" title="【面】前端知识点梳理（浏览器）" href="http://localhost:4000/post/mian-qian-duan-zhi-shi-dian-shu-li-liu-lan-qi/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  
    
      <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>
  var gitalk = new Gitalk({
    clientID: '1d7311971e46d3cb2b7f',
    clientSecret: '825202727778b1d14410ce66b7952398e1213211',
    repo: 'tyloo-code.github.io',
    owner: 'tyloo-code',
    admin: ['tyloo-code'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container')
</script>
    
    
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a
        href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      <a href="http://beian.miit.gov.cn/" target="_blank">京ICP备2020046098号-1</a>
    </div>
  </footer>
  
  
  <div class="pisces back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.onresize = function () {
    calcuHeight();
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, transitionDir, {});
          }
        })
        window.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = "";
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px;border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
            <img id="zfb" class="reward-img" src="\media\images\custom-zfbImg.png" alt="赞赏码">
          
          
            <img id="wx" class="reward-img" src="\media\images\custom-wxImg.png" alt="赞赏码">
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip">打开微信扫一扫，即可进行扫码打赏哦</p>
    </div>
    <div class="bottom">
      
      <div id="zfbBtn" class="pay-text">
        支付宝
      </div>
      
      
      <div id="wxBtn" class="pay-text">
        微信支付
      </div>
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        window.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        window.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        window.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        window.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      window.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      window.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/diary-ru-he-yong-event-loop-li-jie-yi-bu/"" data-c="
          &lt;h2 id=&#34;零-前言&#34;&gt;零. 前言&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Event Loop&lt;/code&gt;即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用&lt;strong&gt;异步&lt;/strong&gt;的原理。&lt;/p&gt;
&lt;h2 id=&#34;一-进程和线程&#34;&gt;一. 进程和线程&lt;/h2&gt;
&lt;p&gt;线程，是程序执行流的最小单位。线程可与同属一个进程的其他线程共享所拥有的全部资源，同一进程中的多个线程之间可以并发执行。线程有&lt;code&gt;就绪&lt;/code&gt;，&lt;code&gt;阻塞&lt;/code&gt;，&lt;code&gt;运行&lt;/code&gt;三种基本状态。&lt;/p&gt;
&lt;p&gt;阮一峰大神针对进程和线程的类比，很是形象：&lt;code&gt;计算机的核心CPU&lt;/code&gt;，是个工厂，时刻运转着，工厂里有很多个车间（进程），一个车间开工其他车间不能开工，就是说：&lt;code&gt;单核CPU一次只能运行一个进程。任何时候，CPU总是运行一个进程&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;而一个车间里面有很多工人（线程），协同完成一个任务。所以：&lt;code&gt;一个进程可以包括多个线程&lt;/code&gt;。车间空间是工人共享的，&lt;code&gt;一个进程中的内存空间是所有线程共享的&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是房间大小不同个，容纳量不同，有些线程进去了，其他线程就不能再进去使用了。这就是：&lt;code&gt;一个线程使用某些共享内存时，其他线程得等它结束后才能使用共享内存&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;内存可以上锁，防止其他线程进来，【互斥锁】也就是防止多个线程读写同一块内存区域。&lt;/p&gt;
&lt;p&gt;还有些共享内存比较大，可以容纳多个线程，但是也是有限的，只能容纳固定数目的线程使用。如何保证多个线程不冲突呢？内存门口有个钥匙架，如果发现钥匙架空了，那就不能再进去了【信号量】。&lt;/p&gt;
&lt;h2 id=&#34;二-堆-栈-队列&#34;&gt;二. 堆、栈、队列&lt;/h2&gt;
&lt;h3 id=&#34;堆heap&#34;&gt;堆（Heap）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;堆&lt;/strong&gt;是一种数据结构，是利用完全二叉树维护的一组数据，堆分为&lt;strong&gt;两种&lt;/strong&gt;，一种为&lt;strong&gt;最大堆&lt;/strong&gt;，一种为&lt;strong&gt;最小堆&lt;/strong&gt;，将&lt;code&gt;根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆&lt;/code&gt;。堆是&lt;code&gt;线性数据结构&lt;/code&gt;，&lt;code&gt;相当于一维数组&lt;/code&gt;，有唯一后继。&lt;/p&gt;
&lt;p&gt;如最大堆&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1625984818364.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;栈stack&#34;&gt;栈（Stack）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;栈&lt;/strong&gt;在计算机科学中是限定仅在&lt;strong&gt;表尾&lt;/strong&gt;进行&lt;code&gt;插入&lt;/code&gt;或&lt;code&gt;删除&lt;/code&gt;操作的线性表。 栈是一种数据结构，它按照&lt;code&gt;后进先出&lt;/code&gt;的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据。&lt;code&gt;栈&lt;/code&gt;是只能在&lt;strong&gt;某一端插入&lt;/strong&gt;和&lt;strong&gt;删除&lt;/strong&gt;的特殊线性表。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1625984901213.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;队列queue&#34;&gt;队列（Queue）&lt;/h3&gt;
&lt;p&gt;特殊之处在于它只允许在表的&lt;strong&gt;前端&lt;/strong&gt;（&lt;code&gt;front&lt;/code&gt;）进行&lt;code&gt;删除&lt;/code&gt;操作，而在表的&lt;strong&gt;后端&lt;/strong&gt;（&lt;code&gt;rear&lt;/code&gt;）进行&lt;code&gt;插入&lt;/code&gt;操作，和栈一样，队列是一种操作受限制的线性表。进行&lt;strong&gt;插入&lt;/strong&gt;操作的端称为&lt;strong&gt;队尾&lt;/strong&gt;，进行&lt;strong&gt;删除&lt;/strong&gt;操作的端称为&lt;strong&gt;队头&lt;/strong&gt;。 队列中没有元素时，称为&lt;strong&gt;空队列&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;队列&lt;/strong&gt;的数据元素又称为&lt;strong&gt;队列元素&lt;/strong&gt;。在队列中插入一个队列元素称为&lt;strong&gt;入队&lt;/strong&gt;，从队列中删除一个队列元素称为&lt;strong&gt;出队&lt;/strong&gt;。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为&lt;strong&gt;先进先出&lt;/strong&gt;（FIFO—first in first out）&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1625985003579.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;三-函数调用栈与任务队列&#34;&gt;三. 函数调用栈与任务队列&lt;/h2&gt;
&lt;p&gt;Javascript有一个main thread &lt;strong&gt;主进程&lt;/strong&gt;和call-stack（一个&lt;strong&gt;调用堆栈&lt;/strong&gt;），在对一个调用堆栈中的task处理的时候，其他的都要等着。当在执行过程中遇到一些类似于setTimeout等异步操作的时候，会交给浏览器的其他模块(以webkit为例，是webcore模块)进行处理，当到达setTimeout指定的延时执行的时间之后，task(&lt;strong&gt;回调函数&lt;/strong&gt;)会放入到任务队列之中。一般不同的异步任务的回调函数会放入不同的任务队列之中。等到调用栈中所有task执行完毕之后，接着去执行任务队列之中的task(回调函数)。&lt;/p&gt;
&lt;p&gt;任务队列是“先进先出”的数据结构，先来的优先被主线程读取。&lt;/p&gt;
&lt;p&gt;调用栈中遇到DOM操作、ajax请求以及setTimeout等WebAPIs的时候就会交给浏览器内核的其他模块进行处理，webkit内核在Javasctipt执行引擎之外，有一个重要的模块是webcore模块。对于图中WebAPIs提到的三种API，webcore分别提供了DOM Binding、network、timer模块来处理底层实现。等到这些模块处理完这些操作的时候将回调函数放入任务队列中，之后等栈中的task执行完之后再去执行任务队列之中的回调函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小结：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有的代码都要通过函数调用栈中调用执行。&lt;/li&gt;
&lt;li&gt;当遇到前文中提到的APIs的时候，会交给浏览器内核的其他模块进行处理。&lt;/li&gt;
&lt;li&gt;任务队列中存放的是回调函数。&lt;/li&gt;
&lt;li&gt;等到调用栈中的task执行完之后再回去执行任务队列之中的task。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四-宏任务与微任务&#34;&gt;四. 宏任务与微任务&lt;/h2&gt;
&lt;p&gt;其中setTimeout叫做&lt;strong&gt;macro-task&lt;/strong&gt;(宏任务)，当然如我们所想，还有如promise的&lt;strong&gt;micro-task&lt;/strong&gt;(微任务)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。&lt;/li&gt;
&lt;li&gt;micro-task包括：process.nextTick, Promise, Object.observe, MutationObserver&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;事件循环的顺序是从script开始第一次循环，随后全局上下文进入函数调用栈，碰到macro-task就将其交给处理它的模块处理完之后将回调函数放进macro-task的队列之中，碰到micro-task也是将其回调函数放进micro-task的队列之中。直到函数调用栈清空只剩全局执行上下文，然后开始执行所有的micro-task。当所有可执行的micro-task执行完毕之后。循环再次执行macro-task中的一个任务队列，执行完之后再执行所有的micro-task，就这样一直循环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不同的任务会放进不同的任务队列之中。&lt;/li&gt;
&lt;li&gt;先执行macro-task，等到函数调用栈清空之后再执行所有在队列之中的micro-task。&lt;/li&gt;
&lt;li&gt;等到所有micro-task执行完之后再从macro-task中的一个任务队列开始执行，就这样一直循环。&lt;/li&gt;
&lt;li&gt;当有多个macro-task(micro-task)队列时，事件循环的顺序是按上文macro-task(micro-task)的分类中书写的顺序执行的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;五-浏览器中的event-loop&#34;&gt;五. 浏览器中的Event Loop&lt;/h2&gt;
&lt;h3 id=&#34;一-同步任务和异步任务&#34;&gt;一. 同步任务和异步任务&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Javascript&lt;/code&gt;单线程任务被分为&lt;strong&gt;同步任务&lt;/strong&gt;和&lt;strong&gt;异步任务&lt;/strong&gt;，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1625986142169.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
任务队列&lt;code&gt;Task Queue&lt;/code&gt;，即队列，是一种先进先出的一种数据结构。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1625986190795.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;二-事件循环的进程模型&#34;&gt;二. 事件循环的进程模型&lt;/h3&gt;
&lt;p&gt;执行栈在执行完&lt;strong&gt;同步任务&lt;/strong&gt;后，查看&lt;strong&gt;执行栈&lt;/strong&gt;是否为空，如果执行栈为空，就会去检查&lt;strong&gt;微任务&lt;/strong&gt;(&lt;code&gt;microTask&lt;/code&gt;)队列是否为空，如果为空的话，就执行&lt;strong&gt;宏任务&lt;/strong&gt;（&lt;code&gt;Task&lt;/code&gt;），否则就一次性执行完所有微任务。每次单个&lt;strong&gt;宏任务&lt;/strong&gt;执行完毕后，检查&lt;strong&gt;微任务&lt;/strong&gt;(microTask)队列是否为空，如果不为空的话，会按照&lt;strong&gt;先入先出&lt;/strong&gt;的规则全部执行完&lt;code&gt;微任务&lt;/code&gt;(microTask)后，设置&lt;code&gt;微任务&lt;/code&gt;(microTask)队列为&lt;code&gt;null&lt;/code&gt;，然后再执行&lt;code&gt;宏任务&lt;/code&gt;，如此循环。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1625986819310.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;先执行同步阻塞任务，同步任务会等待上一个执行完毕以后执行下一个，当同步任务执行完毕，再执行异步任务，遇到异步任务会将异步任务的回调函数注册在异步任务队列里。注意，如果主线程上没有同步任务会直接调用异步任务的微任务。&lt;/li&gt;
&lt;li&gt;执行宏任务，遇到微任务将都添加到微任务队列里。&lt;/li&gt;
&lt;li&gt;开始执行微任务队列，当宏任务执行完后执行微任务队列，直到微任务队列全部执行完，微任务队列为空。&lt;/li&gt;
&lt;li&gt;执行宏任务，如果在执行宏任务期间有微任务，将微任务添加到微任务队列里，执行完宏任务之后执行微任务，直到微任务队列全部执行完。&lt;/li&gt;
&lt;li&gt;继续执行宏任务队列。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;重复2, 3, 4，5……直到宏微任务为空&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;六-nexttick-的实现原理&#34;&gt;六. $nextTick 的实现原理&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;从字面意思理解，next 下一个，tick 滴答（钟表）来源于定时器的周期性中断（输出脉冲），一次中断表示一个 tick，也被称做一个“时钟滴答”），nextTick 顾名思义就是下一个时钟滴答。看源码，在 Vue 2.x 版本中，nextTick 在 src\core\util 中的一个单独的文件 next-tick.js ，可见 nextTick 的重要性，虽然短短 200 多行，尤大却单独创建一个文件去维护。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来我们来看整个文件。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;声明了三个全局变量，&lt;strong&gt;callbacks: []&lt;/strong&gt;，&lt;strong&gt;pending: Boolean&lt;/strong&gt;，&lt;strong&gt;timerFunc: undefined&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;声明了一个函数** flushCallbacks**。&lt;/li&gt;
&lt;li&gt;一堆 &lt;strong&gt;if，else if&lt;/strong&gt; 判断。&lt;/li&gt;
&lt;li&gt;抛出了一个函数 &lt;strong&gt;nextTick&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;一-nexttick-函数&#34;&gt;一. nextTick 函数&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1625988595919.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;声明一个局部变量 &lt;strong&gt;_resolve&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;把所有回调函数压进 &lt;strong&gt;callbacks&lt;/strong&gt; 中，以栈的形式的存储所有 &lt;strong&gt;callback&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;当 &lt;strong&gt;pending&lt;/strong&gt; 为 &lt;strong&gt;false&lt;/strong&gt; 时，执行 &lt;strong&gt;timerFunc&lt;/strong&gt; 函数。&lt;/li&gt;
&lt;li&gt;当没有 &lt;strong&gt;callback&lt;/strong&gt; 的时候，返回一个 &lt;strong&gt;Promise&lt;/strong&gt; 的调用方式，可以用 &lt;strong&gt;.then&lt;/strong&gt; 接收。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二-timerfunc-函数&#34;&gt;二. timerFunc 函数&lt;/h3&gt;
&lt;p&gt;我们开始说了，timerFunc 为全局变量，现在调用 timerFunc ，timerFunc 是什么时候被赋值为一个函数，并且函数里执行代码又是什么？&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1625988797925.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
我们看到，这段判断代码总共有四个分支，四个分支里对 timerFunc 有不同的赋值，我们先来看第一个分支。&lt;br&gt;
&lt;strong&gt;Promise 分支&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (typeof Promise !== &#39;undefined&#39; &amp;amp;&amp;amp; isNative(Promise)) {
  const p = Promise.resolve()
  timerFunc = () =&amp;gt; {
    p.then(flushCallbacks)
    // In problematic UIWebViews, Promise.then doesn&#39;t completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn&#39;t being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // &amp;quot;force&amp;quot; the microtask queue to be flushed by adding an empty timer.
    if (isIOS) setTimeout(noop)
  }
  isUsingMicroTask = true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;判断环境是否支持 Promise 并且 &lt;strong&gt;Promise&lt;/strong&gt; 是否为原生。&lt;/li&gt;
&lt;li&gt;使用 &lt;strong&gt;Promise&lt;/strong&gt; 异步调用 &lt;strong&gt;flushCallbacks&lt;/strong&gt; 函数。&lt;/li&gt;
&lt;li&gt;当执行环境是 &lt;strong&gt;iPhone&lt;/strong&gt; 等，使用 &lt;strong&gt;setTimeout&lt;/strong&gt; 异步调用 &lt;strong&gt;noop&lt;/strong&gt; ，&lt;strong&gt;iOS 中在一些异常的webview&lt;/strong&gt; 中，&lt;strong&gt;promise&lt;/strong&gt; 结束后任务队列并没有刷新所以强制执行 &lt;strong&gt;setTimeout&lt;/strong&gt; 刷新任务队列。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;MutationObserver 分支&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;else if (!isIE &amp;amp;&amp;amp; typeof MutationObserver !== &#39;undefined&#39; &amp;amp;&amp;amp; (
  isNative(MutationObserver) ||
  // PhantomJS and iOS 7.x
  MutationObserver.toString() === &#39;[object MutationObserverConstructor]&#39;
)) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  let counter = 1
  const observer = new MutationObserver(flushCallbacks)
  const textNode = document.createTextNode(String(counter))
  observer.observe(textNode, {
    characterData: true
  })
  timerFunc = () =&amp;gt; {
    counter = (counter + 1) % 2
    textNode.data = String(counter)
  }
  isUsingMicroTask = true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;对非IE浏览器和是否可以使用 &lt;strong&gt;HTML5&lt;/strong&gt; 新特性 &lt;strong&gt;MutationObserver&lt;/strong&gt; 进行判断。&lt;/li&gt;
&lt;li&gt;实例一个 &lt;strong&gt;MutationObserver&lt;/strong&gt; 对象，这个对象主要是对浏览器 &lt;strong&gt;DOM&lt;/strong&gt; 变化进行监听，当实例化 &lt;strong&gt;MutationObserver&lt;/strong&gt; 对象并且执行对象 &lt;strong&gt;observe&lt;/strong&gt;，设置 &lt;strong&gt;DOM&lt;/strong&gt; 节点发生改变时自动触发回调。&lt;/li&gt;
&lt;li&gt;把 &lt;strong&gt;timerFunc&lt;/strong&gt; 赋值为一个改变 &lt;strong&gt;DOM&lt;/strong&gt; 节点的方法，当 &lt;strong&gt;DOM&lt;/strong&gt; 节点发生改变，触发 &lt;strong&gt;flushCallbacks&lt;/strong&gt; 。（这里其实就是想用利用 &lt;strong&gt;MutationObserver&lt;/strong&gt; 的特性进行异步操作）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;setImmediate 分支&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;else if (typeof setImmediate !== &#39;undefined&#39; &amp;amp;&amp;amp; isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Technically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = () =&amp;gt; {
    setImmediate(flushCallbacks)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;判断 &lt;strong&gt;setImmediate&lt;/strong&gt; 是否存在，&lt;strong&gt;setImmediate&lt;/strong&gt; 是高版本 IE （IE10+） 和 edge 才支持的。&lt;/li&gt;
&lt;li&gt;如果存在，传入 &lt;strong&gt;flushCallbacks&lt;/strong&gt; 执行 &lt;strong&gt;setImmediate&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;setTimeout 分支&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;else {
  // Fallback to setTimeout.
  timerFunc = () =&amp;gt; {
    setTimeout(flushCallbacks, 0)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当以上所有分支异步 &lt;strong&gt;api&lt;/strong&gt; 都不支持的时候，使用 &lt;strong&gt;macro task&lt;/strong&gt;（宏任务）的 &lt;strong&gt;setTimeout&lt;/strong&gt; 执行 &lt;strong&gt;flushCallbacks&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;执行降级&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;我们可以发现，给 timerFunc 赋值是一个降级的过程。为什么呢，因为 Vue 在执行的过程中，执行环境不同，所以要适配环境。&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1625989069791.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这张图便于我们更清晰的了解到降级的过程。&lt;/p&gt;
&lt;h3 id=&#34;三-flushcallbacks-函数&#34;&gt;三. flushCallbacks 函数&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function flushCallbacks () {
  pending = false
  const copies = callbacks.slice(0)
  callbacks.length = 0
  for (let i = 0; i &amp;lt; copies.length; i++) {
    copies[i]()
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;四-总结&#34;&gt;四. 总结&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;nextTick&lt;/strong&gt; 的原理就是利用** Event loop** 事件线程去异步重新渲染，分支判断首要选择 &lt;strong&gt;Promise&lt;/strong&gt; 的原因是当同步JS代码执行完毕，执行栈清空会首先查看 &lt;strong&gt;micro task&lt;/strong&gt; （微任务）队列是否为空，不为空首先执行微任务。在我们 &lt;strong&gt;DOM&lt;/strong&gt; 依赖数据发生变化的时候，会异步重新渲染 &lt;strong&gt;DOM&lt;/strong&gt; ，但是比如像 &lt;strong&gt;echarts&lt;/strong&gt; ，&lt;strong&gt;canvas&lt;/strong&gt;……这些 Vue 无法在初始状态下收集依赖的 DOM ，我们就需要手动执行 &lt;strong&gt;nextTick&lt;/strong&gt; 方法使其重新渲染。&lt;/p&gt;
">【Diary】如何用 Event Loop 理解异步</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/diary-ru-he-yong-git-dai-chuan-yi-lu/"" data-c="
          &lt;h2 id=&#34;零-前言&#34;&gt;零. 前言&lt;/h2&gt;
&lt;p&gt;最近在网上有个真实发生的案例比较火，说的是一个新入职的员工，不会用 Git 拉代码，第二天被开除。由此，可见 Git 对我们工作的重要性，无论是前端后端，都是离不开 Git 的，下面就让我们一探究竟吧。&lt;/p&gt;
&lt;p&gt;上面的案例引申出一个问题，入职一家新公司，你的 leader 给你分配了仓库的权限后，如何配置本地的 Git 环境并拉取代码？莫慌，按照下面我讲的四个步骤走，保证你可以顺利使用 Git 进行拉取代码！&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下载 Git 下载地址 (https://git-scm.com/downloads) ，选择自己系统对应的版本下载即可。&lt;/li&gt;
&lt;li&gt;在你的电脑上生成 &lt;code&gt;ssh&lt;/code&gt; 秘钥，打开终端，执行 &lt;code&gt;ssh-keygen -t rsa -C &amp;quot;你公司内部邮箱地址&amp;quot;&lt;/code&gt;，如果执行成功，切换到 &lt;code&gt;~/.ssh&lt;/code&gt; 目录下，此时目录应该如下所示。复制 &lt;code&gt;id_rsa.pub&lt;/code&gt; 的内容。&lt;/li&gt;
&lt;li&gt;这里以 Github 为例，如下图所示，进入 &lt;code&gt;settings -&amp;gt; SSH and GPG keys&lt;/code&gt; 通过 &lt;code&gt;cat&lt;/code&gt; 命令查看文件 &lt;code&gt;id_rsa.pub&lt;/code&gt; 的内容，然后复制过来，点击 &lt;code&gt;add ssh key&lt;/code&gt;，这一步等于说把你的公钥放到了 Github 上进行托管。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624949967724.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;全局配置 Git 的用户名和邮箱&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git config --global user.name &amp;quot;xxx&amp;quot;
git config --global user.email &amp;quot;xxx@xx.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完成以上四步，你就可以愉快 pull 代码开发了。和 &lt;code&gt;https&lt;/code&gt; 拉取方式不同的是，https 方式需要每次提交前都&lt;code&gt;手动输入用户名和密码&lt;/code&gt;，&lt;code&gt;ssh&lt;/code&gt; 的方式配置完毕后 Git 都会使用你本地的私钥和远程仓库的公钥进行验证是否是一对秘钥，从而&lt;code&gt;简化了操作&lt;/code&gt;流程。&lt;/p&gt;
&lt;h2 id=&#34;一-git简介&#34;&gt;一. Git简介&lt;/h2&gt;
&lt;p&gt;在介绍 Git 的相关操作前，我觉得非常有必要了解 Git 的由来，以及 Git 是用来解决什么问题的。Git（读音为/gɪt/）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Linus Torvalds ，这个人我相信大家都知道吧，开源 Linux 系统的发明人。如今，你看到的大部分服务器其实都是运行在 Linux 系统上，令人感到称叹的是，这位大神级别的程序员不仅创造了 Linux 系统。那 Linux 的代码是如何管理的呢？2002年之前，世界各地的志愿者把源代码文件通过 diff 的方式发给 Linus，然后由 Linus 本人通过手工方式合并代码！要知道，当时的 Linux 的代码量已经很大了，通过人工管理的方式，一是容易出错，二是效率低。于是 Linus 选择了一个商业的版本控制系统 BitKeeper，BitKeeper 的东家 BitMover 公司出于人道主义精神，授权 Linux 社区免费使用这个版本控制系统。最后，出于某种原因，BitMover 公司收回了 Linux 社区的免费使用权，于是 Linus 花了两周时间自己用 C 语言写了一个分布式版本控制系统，这就是 Git 的由来了。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624952157608.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;Git的定义是：&lt;strong&gt;分布式版本控制系统&lt;/strong&gt;，用于项目开发中的版本控制。&lt;/p&gt;
&lt;p&gt;从本质上来讲 Git 是一个&lt;strong&gt;内容寻址（content-addressable）文件系统&lt;/strong&gt;，并在此之上提供了一个版本控制系统的用户界面。&lt;/p&gt;
&lt;p&gt;Git 的核心部分是一个简单的&lt;strong&gt;键值对数据库&lt;/strong&gt;（key-value data store）。你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索（retrieve）该内容。&lt;/p&gt;
&lt;p&gt;git管理的项目工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;已跟踪的文件&lt;/strong&gt;是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。&lt;/li&gt;
&lt;li&gt;工作目录中除已跟踪文件以外的所有其它文件都属于&lt;strong&gt;未跟踪文件&lt;/strong&gt;，它们既不存在于上次快照的记录中，也没有放入暂存区。&lt;/li&gt;
&lt;li&gt;初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在进行提交操作时，Git 会保存一个&lt;strong&gt;提交对象&lt;/strong&gt;（commit object）。该提交对象会包含一个指向暂存内容快照的指针。但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。&lt;/p&gt;
&lt;h2 id=&#34;二-git-的工作区域和流程&#34;&gt;二. Git 的工作区域和流程&lt;/h2&gt;
&lt;p&gt;要想弄懂 Git 是怎么对我们的代码进行管理的，那首当其冲的是了解 Git 的工作区域是如何构成的。因为，只有彻底弄懂了 Git 工作区域的构成，你才可以在适当的区域使用合适的命令。如下图所示，此图包含了 Git 的 4 个工作区和一些常见的操作。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624952803223.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Workspace&lt;/strong&gt;：工作区，就是平时进行开发改动的地方，是当前看到最新的内容，在开发的过程也就是对工作区的操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Index&lt;/strong&gt;：暂存区，当执行 &lt;code&gt;git add&lt;/code&gt; 的命令后，工作区的文件就会被移入暂存区，暂存区标记了当前工作区中哪些内容是被 Git 管理的，当完成某个需求或者功能后需要提交代码，第一步就是通过 &lt;code&gt;git add&lt;/code&gt; 先提交到暂存区。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Repository&lt;/strong&gt;：本地仓库，位于自己的电脑上，通过 &lt;code&gt;git commit&lt;/code&gt; 提交暂存区的内容，会进入本地仓库。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Remote&lt;/strong&gt;：远程仓库，用来托管代码的服务器，远程仓库的内容能够被分布在多个地点的处于协作关系的本地仓库修改，本地仓库修改完代码后通过 &lt;code&gt;git push&lt;/code&gt; 命令同步代码到远程仓库。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;一般来说，Git 的工作流程分为以下几步&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在工作区开发，添加，修改文件。&lt;/li&gt;
&lt;li&gt;将修改后的文件放入暂存区。&lt;/li&gt;
&lt;li&gt;将暂存区域的文件提交到本地仓库。&lt;/li&gt;
&lt;li&gt;将本地仓库的修改推送到远程仓库。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;三-git-基本操作&#34;&gt;三. Git 基本操作&lt;/h2&gt;
&lt;h3 id=&#34;1-git-add&#34;&gt;1. git add&lt;/h3&gt;
&lt;p&gt;添加文件到暂存区&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 添加某个文件到暂存区，后面可以跟多个文件，以空格区分
git add xxx
# 添加当前更改的所有文件到暂存区。
git add .
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-git-commit&#34;&gt;2. git commit&lt;/h3&gt;
&lt;p&gt;提交代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 提交暂存的更改，会新开编辑器进行编辑
git commit 
# 提交暂存的更改，并记录下备注
git commit -m &amp;quot;you message&amp;quot;
# 等同于 git add . &amp;amp;&amp;amp; git commit -m
git commit -am
# 对最近一次的提交的信息进行修改,此操作会修改 commit 的 hash 值
git commit --amend
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-git-pull&#34;&gt;3. git pull&lt;/h3&gt;
&lt;p&gt;拉取代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 从远程仓库拉取代码并合并到本地，可简写为 git pull 等同于 git fetch &amp;amp;&amp;amp; git merge 
git pull &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;
# 使用 rebase 的模式进行合并
git pull --rebase &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-git-fetch&#34;&gt;4. git fetch&lt;/h3&gt;
&lt;p&gt;与 &lt;code&gt;git pull&lt;/code&gt;不同的是 &lt;code&gt;git fetch&lt;/code&gt; 操作仅仅只会拉取远程的&lt;code&gt;更改&lt;/code&gt;，不会自动进行 &lt;code&gt;merge&lt;/code&gt; 操作。对你当前的代码没有影响&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 获取远程仓库特定分支的更新
git fetch &amp;lt;远程主机名&amp;gt; &amp;lt;分支名&amp;gt;
# 获取远程仓库所有分支的更新
git fetch --all
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-git-branch&#34;&gt;5. git branch&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 新建本地分支，但不切换
git branch &amp;lt;branch-name&amp;gt; 
# 查看本地分支
git branch
# 查看远程分支
git branch -r
# 查看本地和远程分支
git branch -a
# 删除本地分支
git branch -D &amp;lt;branch-nane&amp;gt;
# 重新命名分支
git branch -m &amp;lt;old-branch-name&amp;gt; &amp;lt;new-branch-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;四-工作中使用-git-解决问题的场景&#34;&gt;四. 工作中使用 Git 解决问题的场景&lt;/h2&gt;
&lt;h3 id=&#34;1-git-rebase-让你的提交记录更加清晰可读&#34;&gt;1. git rebase 让你的提交记录更加清晰可读&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;git rebase 的使用&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;rebase&lt;/code&gt; 翻译为变基，他的作用和 &lt;code&gt;merge&lt;/code&gt; 很相似，用于把一个分支的修改合并到当前分支上。&lt;br&gt;
如下图所示，下图介绍了经过 &lt;code&gt;rebase&lt;/code&gt; 后提交历史的变化情况。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624954131955.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
现在我们来用一个例子来解释一下上面的过程。&lt;/p&gt;
&lt;p&gt;假设我们现在有 2 条分支，一个为 master，一个为 feature/1，他们都基于初始的一个提交 add readme 进行检出分支，之后，master 分支增加了 3.js ,和 4.js 的文件，分别进行了 2 次提交，feature/1 也增加了 1.js 和 2.js 的文件，分别对应以下 2 条提交记录。&lt;/p&gt;
&lt;p&gt;此时，对应分支的提交记录如下。&lt;/p&gt;
&lt;p&gt;master 分支如下图：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624955213531.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
feature/1 分支如下图:&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624955223788.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
结合起来看是这样的&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624955240607.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
此时，切换到 feature/1 分支下，执行 &lt;code&gt;git rebase master&lt;/code&gt;，成功之后，通过 &lt;code&gt;git log&lt;/code&gt; 查看记录。&lt;/p&gt;
&lt;p&gt;如下图所示：可以看到先是逐个应用了 mater 分支的更改，然后以 master 分支最后的提交作为基点，再逐个应用 feature/1 的每个更改。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624955270432.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;所以，我们的提交记录就会非常清晰，没有分叉，上面演示的是比较顺利的情况，但是大部分情况下，rebase 的过程中会产生冲突的，此时，就需要手动解决冲突，然后使用依次 &lt;code&gt;git add&lt;/code&gt; 、&lt;code&gt;git rebase --continue&lt;/code&gt; 的方式来处理冲突，完成 rebase 的过程，如果不想要某次 rebase 的结果，那么需要使用 &lt;code&gt;git rebase --skip&lt;/code&gt; 来跳过这次 rebase 操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;git merge 和 git rebase 的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不同于 &lt;code&gt;git rebase&lt;/code&gt; 的是，&lt;code&gt;git merge&lt;/code&gt; 在不是 fast-forward（快速合并）的情况下，会产生一条额外的合并记录，类似 &lt;code&gt;Merge branch &#39;xxx&#39; into &#39;xxx&#39;&lt;/code&gt; 的一条提交信息。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624955493449.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
另外，在解决冲突的时候，用 merge 只需要解决一次冲突即可，简单粗暴，而用 rebase 的时候 ，需要依次解决每次的冲突，才可以提交。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;git rebase 交互模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在开发中，常会遇到在一个分支上产生了很多的无效的提交，这种情况下使用 rebase 的交互式模式可以把已经发生的多次提交压缩成一次提交，得到了一个干净的提交历史，例如某个分支的提交历史情况如下：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624955745963.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
进入交互式模式的方式是执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git rebase -i &amp;lt;base-commit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数 &lt;code&gt;base-commit&lt;/code&gt; 就是指明操作的基点提交对象，基于这个基点进行 rebase 的操作，对于上述提交历史的例子，我们要把最后的一个提交对象（ ac18084 ）之前的提交压缩成一次提交，我们需要执行的命令格式是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git rebase -i ac18084
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时会进入一个 vim 的交互式页面，编辑器列出的信息像下列这样。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624955780038.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
想要合并这一堆更改，我们要使用 Squash 策略进行合并，即把当前的 commit 和它的上一个 commit 内容进行合并， 大概可以表示为下面这样，在交互模式的 rebase 下，至少保留一个 pick，，否则命令会执行失败。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pick  ... ...
s     ... ... 
s     ... ... 
s     ... ... 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改文件后 按下 &lt;code&gt;:&lt;/code&gt; 然后 &lt;code&gt;wq&lt;/code&gt; 保存退出，此时又会弹出一个编辑页面，这个页面是用来编辑提交的信息，修改为 &lt;code&gt;feat: 更正&lt;/code&gt;，最后保存一下，接着使用 &lt;code&gt;git branch&lt;/code&gt; 查看提交的 commit 信息，rebase 后的提交记录如下图所示，是不是清爽了很多？rebase 操作可以让我们的提交历史变得更加清晰。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624955816867.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;特别注意，只能在自己使用的 feature 分支上进行 rebase 操作，不允许在集成分支上进行 rebase，因为这种操作会修改集成分支的历史记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2-使用-git-cherry-pick-获取指定的-commit&#34;&gt;2. 使用 git cherry-pick 获取指定的 commit&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git cherry-pick&lt;/code&gt; 可以理解为”挑拣”提交，和 merge 合并一个分支的所有提交不同的是，它会获取某一个分支的单笔提交，并作为一个新的提交引入到你当前分支上。当我们需要在本地合入其他分支的提交时，如果我们不想对整个分支进行合并，而是只想将某一次提交合入到本地当前分支上，那么就要使用 &lt;code&gt;git cherry-pick&lt;/code&gt; 了。&lt;/p&gt;
&lt;p&gt;如下场景，以下有三条分支，feature/cherry-pick1 和 feature/cherry-pick2 都是基于 master 检出的两条功能性分支，对应的分支 log 记录如下&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624955876350.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624955881190.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
master 分支的提交如下&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624955889975.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;现在 master 只需要 feature/cherry-pick1 和 feature/cherry-pick2 有关 change 的修改，并不关心有关 fix 内容的修改。此时就可以用 cherry-pick 指令了。&lt;/p&gt;
&lt;p&gt;语法：&lt;code&gt;git cherry-pick [commit-hash]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;commit-hash 表示的是某次 commit 的 hash 值。现在，依次执行以下两条指令&lt;code&gt;git cherry-pick e0bb7f3&lt;/code&gt;、&lt;code&gt;git cherry-pick c9a3101&lt;/code&gt;，过程中，如果出现冲突，解决冲突后 进行 &lt;code&gt;git add&lt;/code&gt;，接着执行 &lt;code&gt;git cherry-pick --continue&lt;/code&gt;，最后，master 上的提交如下&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624956129071.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;此时，master 分支上应用了需要的提交，就达到了我们想要的效果。如果需要多个 cherry-pick 需要同步到目标分支，可以简写为&lt;code&gt;git cherry-pick &amp;lt;first-commit-id&amp;gt;...&amp;lt;last-commit-id&amp;gt;&lt;/code&gt;，这是一个左开右闭的区间，也就时说 first-commit-id 提交带来的代码的改动不会被合并过去，如果需要合并过去，可以使用 &lt;code&gt;git cherry-pick &amp;lt;first-commit-id&amp;gt;^...&amp;lt;last-commit-id&amp;gt;&lt;/code&gt;，它表示包含 &lt;code&gt;first-commit-id&lt;/code&gt; 到 &lt;code&gt;last-commit-id&lt;/code&gt; 在内的提交都会被合并过去。&lt;/p&gt;
&lt;h3 id=&#34;3-使用-git-revert-回滚某次的提交&#34;&gt;3. 使用 git revert 回滚某次的提交&lt;/h3&gt;
&lt;p&gt;想象这么一个场景，你的项目最近有2个版本要上线，这两个版本还伴随着之前遗留的 bug 的修复，一开始的时候，你将 bug 修复在了第一个版本的 release 分支上，突然在发版前一天，测试那边反馈，需要把第一个版本修复 bug 的内容改在第二个版本上，这个时候，第一个版本的集成分支的提交应该包括了第一个版本的功能内容，遗留 bug 修复的提交和其他同事提交的内容，想要通过 reset 的方式粗暴摘除之前的关于 bug 修复的 commit 肯定是不行的，同时，这种做法比较危险，此时，我们既不想破坏之前的提交记录，又想撤回我们遗留 bug 的 commit 记录应该怎么做呢？git revert 就派上了用场。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;git revert&lt;/code&gt; 撤销某次操作，此操作不会修改原本的提交记录，而是会新增一条提交记录来抵消某次操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git revert &amp;lt;commit-id&amp;gt;&lt;/code&gt; 针对普通 commit&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git revert &amp;lt;commit-id&amp;gt; -m&lt;/code&gt; 针对 merge 的 commit&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面就用一个案例来理解一下这个命令，如下图所示，假设被红框框起来的地方是会引起 bug 的一次提交，在他的提交之后，又进行了 2 次提交，其中包含了其它同事的提交。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624956264728.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;此时想把引起提交的 bug 的干掉，执行 &lt;code&gt;git revert 1121932&lt;/code&gt;，执行操作后，再打开查看日志，如下图所示，可以看到是新增了一条 commit 记录，这个 commit 的产生的 msg 是自动生成的，Revert 开头，后面跟撤回的 commit-msg 信息之前的 commit 记录并没有消失，此时也达到了代码回退的效果&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624956436866.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
此外 git revert 也可以回滚多次的提交&lt;/p&gt;
&lt;p&gt;语法：&lt;code&gt;git revert [commit-id1] [commit-id2] ...&lt;/code&gt; 注意这是一个前开后闭区间，即不包括 commit1 ，但包括 commit2 。&lt;/p&gt;
&lt;p&gt;回滚我们的提交有二种方式，一种是上文提到的&lt;code&gt;git revert&lt;/code&gt;命令外，还可以使用 &lt;code&gt;git reset&lt;/code&gt; 命令，那么它们两者有什么区别呢？&lt;br&gt;
&lt;code&gt;git revert&lt;/code&gt; 会新建一条 commit 信息，来撤回之前的修改。&lt;br&gt;
&lt;code&gt;git reset&lt;/code&gt; 会直接将提交记录退回到指定的 commit 上。&lt;/p&gt;
&lt;p&gt;对于个人的 feature 分支而言，可以使用 &lt;code&gt;git reset&lt;/code&gt; 来回退历史记录，之后使用 &lt;code&gt;git push --force&lt;/code&gt; 进行推送到远程，但是如果是在多人协作的集成分支上，不推荐直接使用 &lt;code&gt;git reset&lt;/code&gt; 命令，而是使用更加安全的 &lt;code&gt;git revert&lt;/code&gt; 命令进行撤回提交。这样，提交的历史记录不会被抹去，可以安全的进行撤回。&lt;/p&gt;
&lt;h3 id=&#34;4-使用-git-stash-来暂存文件&#34;&gt;4. 使用 git stash 来暂存文件&lt;/h3&gt;
&lt;p&gt;会有这么一个场景，现在你正在用你的 feature 分支上开发新功能。这时，生产环境上出现了一个 bug 需要紧急修复，但是你这部分代码还没开发完，不想提交，怎么办？这个时候可以用 &lt;code&gt;git stash&lt;/code&gt; 命令先把工作区已经修改的文件暂存起来，然后切换到 hotfix 分支上进行 bug 的修复，修复完成后，切换回 feature 分支，从堆栈中恢复刚刚保存的内容。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git stash //把本地的改动暂存起来
git stash save &amp;quot;message&amp;quot; 执行存储时，添加备注，方便查找。
git stash pop // 应用最近一次暂存的修改，并删除暂存的记录
git stash apply  // 应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即 stash@{0}，如果要使用其他个，git stash apply stash@{$num} 。
git stash list // 查看 stash 有哪些存储
git stash clear // 删除所有缓存的 stash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面通过几幅图对 stash 的命令做进一步了解。&lt;/p&gt;
&lt;p&gt;此时，我正在开发一个新功能，修改了 1.js 文件里的内容&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624956848229.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
还没开发完成，这个时候，我想切换到 hotfix 分支上修复 bug，得暂停下开发切换到 hotfix 分支，但是现在工作区还有内容，此时如果切换分支 Git 会报出下面的错误&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: Your local changes to the following files would be overwritten by checkout:        1.jsPlease commit your changes or stash them before you switch branches.Aborting
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面那句话的意思就是说工作区有文件修改，不能提交，需要先进行 commit 或者 stash 操作，执行 &lt;code&gt;git stash&lt;/code&gt;，结果如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Saved working directory and index state WIP on stash: 22e561c feat: add 1.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时，我们的工作区已经干净了，可以切换到 hotfix 分支进行 bug 修复的工作，假设我们现在 bug 修复完成了，继续切回 feature 分支进行原本功能的开发，此时只需要执行 &lt;code&gt;git stash pop&lt;/code&gt;，之前我们暂存的修改就会恢复到工作区，如下图所示。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624956908826.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当我们想要暂存文件，切换分支做某些事的时候，可以用 &lt;code&gt;git stash&lt;/code&gt; 这种机制帮助开发。&lt;/p&gt;
&lt;p&gt;推荐在使用 stash 的相关命令时，每一次暂存的时候，不要直接使用 &lt;code&gt;git stash&lt;/code&gt; 命令进行暂存下来，而是使用&lt;code&gt;git stash save &amp;quot;message...&amp;quot;&lt;/code&gt; 这种方式，给本次的提交做一个信息的记录。这样，想应用更改的时候，先通过&lt;code&gt;git stash list&lt;/code&gt; 查看一下所有的暂存列表。之后，推荐使用 &lt;code&gt;git stash apply stash@${num}&lt;/code&gt; 的方式进行应用对应的 stash，这样不会清空已有的 stash 的列表项，并且能应用到当前的工作区，不需要这个暂存的话，再手动清除就可以了。&lt;/p&gt;
&lt;h3 id=&#34;5-不同的工作区域撤销更改&#34;&gt;5. 不同的工作区域撤销更改&lt;/h3&gt;
&lt;p&gt;开发中，我们经常需要回退代码的操作，在不同的工作区域中，回退代码的方式也是不相同的。如下图所示，假设现在要在 feature/revoke 分支上进行开发,&lt;/p&gt;
&lt;p&gt;首先通过 &lt;code&gt;git status&lt;/code&gt; 查看下现在的状态。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624957014180.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
目前我们的工作区是很干净的，没有任何修改的操作，此时，修改一下代码再次查看状态，可以看到，1.js 这个文件被修改了。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624958714729.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
现在我们想把 1.js 这个文件恢复到修改前的状态，即撤回工作区的修改，就可以使用 &lt;code&gt;git checkout -- &amp;lt;filename&amp;gt;&lt;/code&gt; 的命令，如果要撤回多个文件的修改，文件之间使用空格隔开，如下图所示，我们撤回了 1.js 文件的修改，工作区也恢复干净了。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624958738833.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果说现在我们对文件进行了修改，并且已经提交到暂存区了，这部分文件我们不想要的话，那么就可以通过 &lt;code&gt;git reset &amp;lt;filename&amp;gt;&lt;/code&gt; 的命令来对特定的文件进行撤销，&lt;code&gt;git reset&lt;/code&gt; 会撤回所有存在暂存区的文件，如下图所示，查看前后的状态可知，文件最后成功撤回到工作区了。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624958768134.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;6-配置-git-alias-提升工作效率&#34;&gt;6. 配置 git alias 提升工作效率&lt;/h3&gt;
&lt;p&gt;一般我们在工作中，接到开发任务后，需要新创建一个分支进行开发 此时需要 用到 &lt;code&gt;git branch&lt;/code&gt;、&lt;code&gt;git checkout&lt;/code&gt;、 &lt;code&gt;git pull&lt;/code&gt; 等命令，在我们一顿操作后，开发完成，到了提交代码的阶段，又要诸如此类 &lt;code&gt;git add&lt;/code&gt; 、&lt;code&gt;git commit&lt;/code&gt;、&lt;code&gt;git push&lt;/code&gt; 等命令，虽然简单，但是输入起来也是不够简洁，作为一个程序员，开发程序就是为了提高我们的效率的，懒是人类进步的源泉，所以我们可以通过配置别名的方式，简化这些命令。&lt;/p&gt;
&lt;p&gt;它的基本用法是 &lt;code&gt;git config --global alias.&amp;lt;简化的字符&amp;gt; 原始命令&lt;/code&gt;&lt;br&gt;
如下面的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git config --global alias.co checkout
$ git config --global alias.ci commit
$ git config --global alias.br branch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里将 co 表示 checkout，ci 表示 commit，br 表示 branch，以后提交就可以简写成&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624958918235.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;--global&lt;/code&gt; 是全局参数，也就是配置一次后，这些命令可以在这台电脑下的所有仓库都适用。这些命令其实是更新你全局的 .gitconfig 文件，该文件用来保存全局的 git 配置，&lt;code&gt;vim ~/.gitconfig&lt;/code&gt;，执行这段命令后，显示如下，下图展示了刚才通过 &lt;code&gt;git config --global alias&lt;/code&gt; 添加的 &lt;code&gt;alias&lt;/code&gt;。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624958960798.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;除了上面那种直接通过命令的方式外，也可以通过修改这个文件的 &lt;code&gt;alias&lt;/code&gt; 项来设置别名。&lt;/p&gt;
&lt;p&gt;这里分享一个我自己常用的别名设置，把以下配置替换到 .gitconfig 文件里的 &lt;code&gt;[alias]&lt;/code&gt; 所属的区域，然后就可以愉快的使用了~&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[alias]
st = status -sb
co = checkout
br = branch
mg = merge
ci = commit
ds = diff --staged
dt = difftool
mt = mergetool
last = log -1 HEAD
latest = for-each-ref --sort=-committerdate --format=\&amp;quot;%(committername)@%(refname:short) [%(committerdate:short)] %(contents)\&amp;quot;
ls = log --pretty=format:\&amp;quot;%C(yellow)%h %C(blue)%ad %C(red)%d %C(reset)%s %C(green)[%cn]\&amp;quot; --decorate --date=short
hist = log --pretty=format:\&amp;quot;%C(yellow)%h %C(red)%d %C(reset)%s %C(green)[%an] %C(blue)%ad\&amp;quot; --topo-order --graph --date=short
type = cat-file -t
dump = cat-file -p
lg = log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&amp;lt;%an&amp;gt;%Creset&#39; --abbrev-commit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样，我们每次想查看 Git 的历史记录,就不用输入那么一长串命令 直接使用 &lt;code&gt;git lg&lt;/code&gt; ，下图是 axios 源码里的提交记录，使用封装后的 &lt;code&gt;git lg&lt;/code&gt; 查看的效果图&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624959011554.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
分支之间的关系一眼就很明了，在哪个 commit 上进行的 merge 操作也很清晰，可以帮助我们很好的追溯历史的提交和解决问题。&lt;/p&gt;
&lt;h2 id=&#34;五-总结&#34;&gt;五. 总结&lt;/h2&gt;
&lt;p&gt;本文由浅入深的的讲解了 Git 的环境搭建，基本用法，以及工作中使用较为高频的 Git 命令的用法，无论你是前端后端还是其它端的开发，日常工作中少不了对 Git 的使用，我们不仅要会用，还要用的漂亮，用的灵活，用的稳健。这样才能在和同事协作项目的时候更加得心应手，学会了本文这些 Git 的使用技巧后，在日常工作中多多练习，相信会给你带来很大的收获！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;来源 https://mp.weixin.qq.com/s/v9p9f9Cz_Hetcgn94GuUjw&lt;br&gt;
https://zhuanlan.zhihu.com/p/94008510&lt;/p&gt;
&lt;/blockquote&gt;
">【Diary】如何用 Git 带穿一路</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/diary-zhan-sha-js-yuan-xing-yu-yuan-xing-lian/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;说说你对JS原型和原型链的理解？&lt;br&gt;
这句话和“谈谈你对闭包的理解”在面试中出现频率几乎都是拉满 (这儿挖个坑，下次填)&lt;br&gt;
网络上对此答案可谓百花齐放，在广泛阅读整理之后，总结此文仅供自己复习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1624867988861.png&#34; alt=&#34;JS原型链经典老图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;JS原型链经典老图&lt;/center&gt; 
&lt;h2 id=&#34;零-从三个重要属性开始&#34;&gt;零. 从三个重要属性开始&lt;/h2&gt;
&lt;p&gt;见名知意，所谓的&amp;quot;&lt;strong&gt;链&lt;/strong&gt;&amp;quot;描述的其实是一种关系，加上&lt;strong&gt;原型&lt;/strong&gt;两个字，可以理解为原型之间的关系，既然是一种关系，就需要维系，就好比我们走亲访友，亲情就是一种纽带，类比在JavaScript当中——&lt;strong&gt;函数&lt;/strong&gt;、&lt;strong&gt;对象实例&lt;/strong&gt;、&lt;strong&gt;实例原型&lt;/strong&gt;&lt;br&gt;
也有自身的联系，而他们之间的纽带就是下面这三个重要的属性：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三个重要的属性&lt;/strong&gt;：&lt;code&gt;prototype&lt;/code&gt;、&lt;code&gt;__proto__&lt;/code&gt;、&lt;code&gt;constructor&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614923904668.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;三个属性间关系&lt;/center&gt; 
&lt;p&gt;&lt;code&gt;原型链的作用是用来实现继承,比如我们新建一个数组,数组的方法就是从数组的原型上继承而来的&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当访问对象a.b的时候，首先会查找当前对象的b属性，如果没有，然后依次按照prototype往上找直到找到Object.prototype为止，没有则返回undefined，所以说无处不在。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;一-普通对象与函数对象&#34;&gt;一. 普通对象与函数对象&lt;/h2&gt;
&lt;p&gt;JavaScript 中，万物皆对象！但对象也是有区别的。分为&lt;strong&gt;普通对象&lt;/strong&gt;和&lt;strong&gt;函数对象&lt;/strong&gt;，Object 、Function 是 JS 自带的函数对象。下面举例说明&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var o1 = {}; 
var o2 =new Object();
var o3 = new f1();

function f1(){}; 
var f2 = function(){};
var f3 = new Function(&#39;str&#39;,&#39;console.log(str)&#39;);

console.log(typeof Object); //function 
console.log(typeof Function); //function  

console.log(typeof f1); //function 
console.log(typeof f2); //function 
console.log(typeof f3); //function   

console.log(typeof o1); //object 
console.log(typeof o2); //object 
console.log(typeof o3); //object
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的例子中 o1 o2 o3 为普通对象，f1 f2 f3 为函数对象。&lt;br&gt;
怎么区分，其实很简单，&lt;strong&gt;凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。f1,f2,归根结底都是通过 new Function()的方式进行创建的。Function Object 也都是通过 New Function()创建的&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;二-构造函数&#34;&gt;二. 构造函数&lt;/h2&gt;
&lt;p&gt;我们先复习一下构造函数的知识：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Person(name, age, job) {
 this.name = name;
 this.age = age;
 this.job = job;
 this.sayName = function() { alert(this.name) } 
}
var person1 = new Person(&#39;Zaxlct&#39;, 28, &#39;Software Engineer&#39;);
var person2 = new Person(&#39;Mick&#39;, 23, &#39;Doctor&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的例子中 person1 和 person2 都是 Person 的&lt;strong&gt;实例&lt;/strong&gt;。这两个&lt;strong&gt;实例&lt;/strong&gt;都有一个 constructor （构造函数）属性，该属性（是一个指针）指向 Person。 即：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(person1.constructor == Person); //true
console.log(person2.constructor == Person); //true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们要记住两个概念（&lt;code&gt;构造函数&lt;/code&gt;，&lt;code&gt;实例&lt;/code&gt;）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;person1 和 person2 都是 &lt;strong&gt;构造函数&lt;/strong&gt; Person 的&lt;strong&gt;实例&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;一个公式：&lt;strong&gt;实例&lt;/strong&gt;的&lt;strong&gt;构造函数属性&lt;/strong&gt;（constructor）指向&lt;strong&gt;构造函数&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三-原型对象&#34;&gt;三. 原型对象&lt;/h2&gt;
&lt;p&gt;在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个&lt;strong&gt;函数对象&lt;/strong&gt;都有一个prototype 属性，这个属性指向函数的&lt;strong&gt;原型对象&lt;/strong&gt;。（先用不管什么是 _&lt;em&gt;proto&lt;/em&gt;_ 第二节的课程会详细的剖析）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Person() {}
Person.prototype.name = &#39;Zaxlct&#39;;
Person.prototype.age  = 28;
Person.prototype.job  = &#39;Software Engineer&#39;;
Person.prototype.sayName = function() {
  alert(this.name);
}
  
var person1 = new Person();
person1.sayName(); // &#39;Zaxlct&#39;

var person2 = new Person();
person2.sayName(); // &#39;Zaxlct&#39;

console.log(person1.sayName == person2.sayName); //true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们得到了本文第一个「定律」：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;每个对象都有 __proto__ 属性，但只有函数对象才有 prototype 属性&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;那什么是&lt;strong&gt;原型对象&lt;/strong&gt;呢？ 我们把上面的例子改一改你就会明白了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Person.prototype = {
   name:  &#39;Zaxlct&#39;,
   age: 28,
   job: &#39;Software Engineer&#39;,
   sayName: function() {
     alert(this.name);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原型对象，顾名思义，它就是一个普通对象。从现在开始你要牢牢记住&lt;code&gt;原型对象&lt;/code&gt;就是 &lt;code&gt;Person.prototype&lt;/code&gt; ，如果你还是害怕它，那就把它想想成一个字母 A： var A = Person.prototype&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在上面我们给 A 添加了 四个属性：name、age、job、sayName。其实它还有一个默认的属性：&lt;code&gt;constructor&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在默认情况下，所有的&lt;strong&gt;原型对象&lt;/strong&gt;都会&lt;strong&gt;自动获得&lt;/strong&gt;一个 &lt;code&gt;constructor&lt;/code&gt;（构造函数）属性，这个属性（是一个指针）指向 &lt;code&gt;prototype&lt;/code&gt; 属性所在的函数（Person）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面这句话有点拗口，我们「翻译」一下：A 有一个默认的 &lt;code&gt;constructor&lt;/code&gt; 属性，这个属性是一个指针，指向 Person。即：&lt;code&gt;Person.prototype.constructor == Person&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在上面第二小节《构造函数》里，我们知道&lt;strong&gt;实例的构造函数属性（constructor）指向构造函数&lt;/strong&gt;  ：&lt;code&gt;person1.constructor == Person&lt;/code&gt;&lt;br&gt;
这两个「公式」好像有点联系：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;person1.constructor == Person
Person.prototype.constructor == Person
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;person1 为什么有 constructor 属性？那是因为 person1 是 Person 的实例。 那 Person.prototype 为什么有 constructor 属性？？同理， Person.prototype （你把它想象成 A） 也是Person 的实例。 也就是在 Person 创建的时候，创建了一个它的实例对象并赋值给它的 prototype，基本过程如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; var A = new Person();
 Person.prototype = A;
// 注：上面两行代码只是帮助理解，并不能正常运行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结论：原型对象（Person.prototype）是 构造函数（Person）的一个实例&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;原型对象&lt;/strong&gt;其实就是普通对象（但 Function.prototype 除外，它是函数对象，但它很特殊，他没有prototype属性（前面说道函数对象都有prototype属性））。看下面的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; function Person(){};
 console.log(Person.prototype) //Person{}
 console.log(typeof Person.prototype) //Object
 console.log(typeof Function.prototype) // Function，这个特殊
 console.log(typeof Object.prototype) // Object
 console.log(typeof Function.prototype.prototype) //undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Function.prototype&lt;/code&gt; 为什么是函数对象呢？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; var A = new Function ();
Function.prototype = A;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上文提到凡是通过 new Function( ) 产生的对象都是&lt;strong&gt;函数对象&lt;/strong&gt;。因为 A 是函数对象，所以&lt;code&gt;Function.prototype&lt;/code&gt; 是函数对象。&lt;/p&gt;
&lt;p&gt;那原型对象是用来做什么的呢？主要作用是用于&lt;strong&gt;继承&lt;/strong&gt;。举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; var Person = function(name){
    this.name = name; // tip: 当函数执行时这个 this 指的是谁？
  };
  Person.prototype.getName = function(){
    return this.name;  // tip: 当函数执行时这个 this 指的是谁？
  }
  var person1 = new person(&#39;Mick&#39;);
  person1.getName(); //Mick
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从这个例子可以看出，通过给 &lt;code&gt;Person.prototype&lt;/code&gt; 设置了一个函数对象的属性，那有 Person 的实例（person1）出来的普通对象就继承了这个属性。具体是怎么实现的继承，就要讲到下面的原型链了。&lt;/p&gt;
&lt;p&gt;小问题，上面两个 this 都指向谁？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; var person1 = new person(&#39;Mick&#39;);
 person1.name = &#39;Mick&#39;; // 此时 person1 已经有 name 这个属性了
 person1.getName(); //Mick  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;故两次 this  在函数执行时都指向 person1&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;四-proto&#34;&gt;四. proto&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;person1._&lt;em&gt;proto&lt;/em&gt;_ == Person.prototype;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做&lt;code&gt;__proto__&lt;/code&gt;的内置属性，用于指向创建它的构造函数的原型对象。 对象 person1 有一个&lt;code&gt;__proto__&lt;/code&gt;属性，创建它的构造函数是 Person，构造函数的原型对象是 Person.prototype ，所以：&lt;code&gt;person1.__proto__ == Person.prototype&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;请看下图：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624888821003.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
根据上面这个连接图，我们能得到：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Person.prototype.constructor == Person;
person1.__proto__ == Person.prototype;
person1.constructor == Person;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不过，要明确的真正重要的一点就是，这个连接存在于实例（&lt;code&gt;person1&lt;/code&gt;）与构造函数（&lt;code&gt;Person&lt;/code&gt;）的原型对象（&lt;code&gt;Person.prototype&lt;/code&gt;）之间，而不是存在于实例（&lt;code&gt;person1&lt;/code&gt;）与构造函数（&lt;code&gt;Person&lt;/code&gt;）之间。&lt;/p&gt;
&lt;h2 id=&#34;五-构造器&#34;&gt;五. 构造器&lt;/h2&gt;
&lt;p&gt;熟悉 Javascript 的童鞋都知道，我们可以这样创建一个对象：&lt;code&gt;var obj = {}&lt;/code&gt; 它等同于下面这样：&lt;code&gt;var obj = new Object()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;obj 是构造函数（Object）的一个实例。所以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;obj.constructor === Object&lt;/li&gt;
&lt;li&gt;obj._&lt;em&gt;proto&lt;/em&gt;_ === Object.prototype&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新对象 obj 是使用 new 操作符后跟一个&lt;strong&gt;构造函数&lt;/strong&gt;来创建的。构造函数（Object）本身就是一个函数（就是上面说的函数对象），它和上面的构造函数 Person 差不多。只不过该函数是出于创建新对象的目的而定义的。所以不要被 Object 吓倒。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;同理，可以创建对象的构造器不仅仅有 Object，也可以是 Array，Date，Function等。 所以我们也可以构造函数来创建 Array、 Date、Function&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var b = new Array();
b.constructor === Array;
b.__proto__ === Array.prototype;

var c = new Date(); 
c.constructor === Date;
c.__proto__ === Date.prototype;

var d = new Function();
d.constructor === Function;
d.__proto__ === Function.prototype;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这些构造器都是函数对象：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624889415132.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;六-原型链&#34;&gt;六.  原型链&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;原型链的作用是用来实现继承,比如我们新建一个数组,数组的方法就是从数组的原型上继承而来的&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;小测试来检验一下你理解的怎么样：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;person1._&lt;em&gt;proto&lt;/em&gt;_ 是什么？&lt;/li&gt;
&lt;li&gt;Person._&lt;em&gt;proto&lt;/em&gt;_ 是什么？&lt;/li&gt;
&lt;li&gt;Person.prototype._&lt;em&gt;proto&lt;/em&gt;_ 是什么？&lt;/li&gt;
&lt;li&gt;Object._&lt;em&gt;proto&lt;/em&gt;_ 是什么？&lt;/li&gt;
&lt;li&gt;Object.prototype_&lt;em&gt;proto&lt;/em&gt;_ 是什么？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一题：因为 person1的构造函数 === Person 所以 person1._&lt;em&gt;proto&lt;/em&gt;_ === Person.prototype&lt;/li&gt;
&lt;li&gt;第二题： 因为 Person的构造函数 === Function所以 Person._&lt;em&gt;proto&lt;/em&gt;_ === Function.prototype&lt;/li&gt;
&lt;li&gt;第三题：Person.prototype 是一个普通对象，我们无需关注它有哪些属性，只要记住它是一个普通对象。 因为一个普通对象的构造函数 === Object 所以 Person.prototype._&lt;em&gt;proto&lt;/em&gt;_ === Object.prototype&lt;/li&gt;
&lt;li&gt;第四题，参照第二题，因为 Person 和 Object 一样都是构造函数&lt;/li&gt;
&lt;li&gt;第五题：Object.prototype 对象也有proto属性，但它比较特殊，为 null 。因为 null 处于原型链的顶端，这个只能记住。Object.prototype._&lt;em&gt;proto&lt;/em&gt;_ === null&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;七-函数对象-复习一下前面的知识点&#34;&gt;七. 函数对象 （复习一下前面的知识点）&lt;/h2&gt;
&lt;p&gt;所有&lt;strong&gt;函数对象&lt;/strong&gt;的&lt;code&gt;proto&lt;/code&gt;都指向&lt;code&gt;Function.prototype&lt;/code&gt;，它是一个空函数（Empty function）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Number.__proto__ === Function.prototype  // true
Number.constructor == Function //true
Boolean.__proto__ === Function.prototype // true
Boolean.constructor == Function //true
String.__proto__ === Function.prototype  // true
String.constructor == Function //true
// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身Object.__proto__ === Function.prototype  // true
Object.constructor == Function // true
// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身Function.__proto__ === Function.prototype // true
Function.constructor == Function //true
Array.__proto__ === Function.prototype   // true
Array.constructor == Function //true
RegExp.__proto__ === Function.prototype  // true
RegExp.constructor == Function //true
Error.__proto__ === Function.prototype   // true
Error.constructor == Function //true
Date.__proto__ === Function.prototype    // true
Date.constructor == Function //true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这说明什么呢？&lt;br&gt;
&lt;strong&gt;所有的构造器都来自于 Function.prototype，甚至包括根构造器Object及Function自身。所有构造器都继承了·Function.prototype·的属性及方法。如length、call、apply、bind&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Function.prototype&lt;/code&gt;也是唯一一个&lt;code&gt;typeof XXX.prototype&lt;/code&gt;为 &lt;code&gt;function&lt;/code&gt;的&lt;code&gt;prototype&lt;/code&gt;。其它的构造器的&lt;code&gt;prototype&lt;/code&gt;都是一个对象（原因第三节里已经解释过了）。如下（又复习了一遍）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(typeof Function.prototype) // function
console.log(typeof Object.prototype)   // object
console.log(typeof Number.prototype)   // object
console.log(typeof Boolean.prototype)  // object
console.log(typeof String.prototype)   // object
console.log(typeof Array.prototype)    // object
console.log(typeof RegExp.prototype)   // object
console.log(typeof Error.prototype)    // object
console.log(typeof Date.prototype)     // object
console.log(typeof Object.prototype)   // object
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;噢，上面还提到它是一个空的函数，&lt;code&gt;console.log(Function.prototype)&lt;/code&gt; 下看看（留意，下一节会再说一下这个）&lt;/p&gt;
&lt;p&gt;知道了所有构造器（含内置及自定义）的&lt;code&gt;__proto__&lt;/code&gt;都是&lt;code&gt;Function.prototype&lt;/code&gt;，那&lt;code&gt;Function.prototype&lt;/code&gt;的&lt;code&gt;__proto__&lt;/code&gt;是谁呢？ 相信都听说过JavaScript中函数也是一等公民，那从哪能体现呢？如下&lt;code&gt;console.log(Function.prototype.__proto__ === Object.prototype) // true&lt;/code&gt;这说明所有的构造器也都是一个普通 JS 对象，可以给构造器添加/删除属性等。同时它也继承了&lt;code&gt;Object.prototype&lt;/code&gt;上的所有方法：toString、valueOf、hasOwnProperty等。&lt;/p&gt;
&lt;p&gt;最后&lt;code&gt;Object.prototype&lt;/code&gt;的&lt;code&gt;proto&lt;/code&gt;是谁？&lt;code&gt;Object.prototype.__proto__ === null // true&lt;/code&gt;已经到顶了，为null。(读到现在，再回过头看第五章，能明白吗？)&lt;/p&gt;
&lt;h2 id=&#34;八-prototype&#34;&gt;八. Prototype&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在 ECMAScript 核心所定义的全部属性中，最耐人寻味的就要数 &lt;code&gt;prototype&lt;/code&gt; 属性了。对于 ECMAScript 中的引用类型而言，&lt;code&gt;prototype&lt;/code&gt; 是保存着它们所有实例方法的真正所在。换句话所说，诸如 &lt;code&gt;toString()&lt;/code&gt;和 &lt;code&gt;valuseOf()&lt;/code&gt; 等方法实际上都保存在 &lt;code&gt;prototype&lt;/code&gt; 名下，只不过是通过各自对象的实例访问罢了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们知道 JS 内置了一些方法供我们使用，比如： 对象可以用 &lt;code&gt;constructor/toString()/valueOf()&lt;/code&gt; 等方法; 数组可以用 &lt;code&gt;map()/filter()/reducer()&lt;/code&gt; 等方法； 数字可用用 &lt;code&gt;parseInt()/parseFloat()&lt;/code&gt;等方法； Why ？？？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当我们创建一个函数时：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var Person = new Object()&lt;/code&gt; Person 是 Object 的实例，所以 &lt;code&gt;Person&lt;/code&gt; &lt;strong&gt;继承&lt;/strong&gt;了&lt;code&gt;Object&lt;/code&gt; 的原型对象&lt;code&gt;Object.prototype&lt;/code&gt;上所有的方法&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624890289296.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;Object 的每个实例都具有以上的属性和方法&lt;/strong&gt;。所以我可以用 &lt;code&gt;Person.constructor&lt;/code&gt; 也可以用 &lt;code&gt;Person.hasOwnProperty&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当我们创建一个数组时：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var num = new Array()&lt;/code&gt; num 是 Array 的实例，所以 &lt;code&gt;num&lt;/code&gt; &lt;strong&gt;继承&lt;/strong&gt;了&lt;code&gt;Array&lt;/code&gt; 的原型对象&lt;code&gt;Array.prototype&lt;/code&gt;上所有的方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们可以用一个 ES5 提供的新方法：&lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt;获取所有（&lt;strong&gt;包括不可枚举的属性&lt;/strong&gt;）的属性名&lt;strong&gt;不包括&lt;/strong&gt; &lt;code&gt;prototy&lt;/code&gt; &lt;strong&gt;中的属性&lt;/strong&gt;，返回一个数组：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;var arrayAllKeys = Array.prototype; // [] 空数组
// 只得到 arrayAllKeys 这个对象里所有的属性名(不会去找 arrayAllKeys.prototype 中的属性)
console.log(Object.getOwnPropertyNames(arrayAllKeys)); 
/* 输出：
[&amp;quot;length&amp;quot;, &amp;quot;constructor&amp;quot;, &amp;quot;toString&amp;quot;, &amp;quot;toLocaleString&amp;quot;, &amp;quot;join&amp;quot;, &amp;quot;pop&amp;quot;, &amp;quot;push&amp;quot;, 
&amp;quot;concat&amp;quot;, &amp;quot;reverse&amp;quot;, &amp;quot;shift&amp;quot;, &amp;quot;unshift&amp;quot;, &amp;quot;slice&amp;quot;, &amp;quot;splice&amp;quot;, &amp;quot;sort&amp;quot;, &amp;quot;filter&amp;quot;, &amp;quot;forEach&amp;quot;, 
&amp;quot;some&amp;quot;, &amp;quot;every&amp;quot;, &amp;quot;map&amp;quot;, &amp;quot;indexOf&amp;quot;, &amp;quot;lastIndexOf&amp;quot;, &amp;quot;reduce&amp;quot;, &amp;quot;reduceRight&amp;quot;, 
&amp;quot;entries&amp;quot;, &amp;quot;keys&amp;quot;, &amp;quot;copyWithin&amp;quot;, &amp;quot;find&amp;quot;, &amp;quot;findIndex&amp;quot;, &amp;quot;fill&amp;quot;]
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样你就明白了随便声明一个数组，它为啥能用那么多方法了。&lt;/p&gt;
&lt;p&gt;细心的你肯定发现了&lt;code&gt;Object.getOwnPropertyNames(arrayAllKeys)&lt;/code&gt; 输出的数组里并没有 &lt;code&gt;constructor/hasOwnPrototype&lt;/code&gt;等&lt;strong&gt;对象的&lt;/strong&gt;方法（你肯定没发现）。 但是随便定义的数组也能用这些方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var num = [1];
console.log(num.hasOwnPrototype()) // false (输出布尔值而不是报错)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为 &lt;code&gt;Array.prototype&lt;/code&gt; 虽然没这些方法，但是它有原型对象（&lt;code&gt;__proto__&lt;/code&gt;）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 上面我们说了 Object.prototype 就是一个普通对象。Array.prototype.__proto__ == Object.prototype
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以&lt;code&gt;Array.prototype&lt;/code&gt; 继承了对象的所有方法，当你用&lt;code&gt;num.hasOwnPrototype()&lt;/code&gt;时，JS 会先查一下它的构造函数 （Array） 的原型对象 &lt;code&gt;Array.prototype&lt;/code&gt; 有没有&lt;code&gt;hasOwnPrototype()&lt;/code&gt;方法，没查到的话继续查一下 &lt;code&gt;Array.prototype&lt;/code&gt; 的原型对象 &lt;code&gt;Array.prototype.__proto__&lt;/code&gt;有没有这个方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当我们创建一个函数时：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var f = new Function(&amp;quot;x&amp;quot;,&amp;quot;return x*x;&amp;quot;);
console.log(f.arguments) // arguments 方法从哪里来的？
console.log(f.call(window)) // call 方法从哪里来的？
console.log(Function.prototype) // function() {} （一个空的函数）
console.log(Object.getOwnPropertyNames(Function.prototype)); 
/* 输出
[&amp;quot;length&amp;quot;, &amp;quot;name&amp;quot;, &amp;quot;arguments&amp;quot;, &amp;quot;caller&amp;quot;, &amp;quot;constructor&amp;quot;, &amp;quot;bind&amp;quot;, &amp;quot;toString&amp;quot;, &amp;quot;call&amp;quot;, &amp;quot;apply&amp;quot;]
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们再复习第八小节这句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所有函数对象&lt;code&gt;__proto__&lt;/code&gt;都指向 &lt;code&gt;Function.prototype&lt;/code&gt;，它是一个空函数（Empty function）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;嗯，我们验证了它就是空函数。不过不要忽略前半句。我们枚举出了它的所有的方法，所以所有的&lt;strong&gt;函数对象&lt;/strong&gt;都能用，比如:&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624894908254.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果你还没搞懂啥是函数对象？&lt;/p&gt;
&lt;p&gt;还有，我建议你可以再复习下为什么：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Function.prototype 是唯一一个typeof XXX.prototype为 “function”的prototype&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;九-复习一下&#34;&gt;九. 复习一下&lt;/h2&gt;
&lt;p&gt;第八小节我们总结了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;所有`函数`对象的 __proto__ 都指向 Function.prototype，它是一个空函数（Empty function）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是你可别忘了在第三小节我们总结的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;所有对象的 __proto__ 都指向其构造器的 prototype
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们下面再复习下这句话。&lt;/p&gt;
&lt;p&gt;先看看 JS 内置构造器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var obj = {name: &#39;jack&#39;}
var arr = [1,2,3]
var reg = /hello/g
var date = new Date
var err = new Error(&#39;exception&#39;)
 
console.log(obj.__proto__ === Object.prototype) // true
console.log(arr.__proto__ === Array.prototype)  // true
console.log(reg.__proto__ === RegExp.prototype) // true
console.log(date.__proto__ === Date.prototype)  // true
console.log(err.__proto__ === Error.prototype)  // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再看看自定义的构造器，这里定义了一个 Person：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Person(name) {
  this.name = name;
}
var p = new Person(&#39;jack&#39;)
console.log(p.__proto__ === Person.prototype) // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;p&lt;/code&gt; 是 &lt;code&gt;Person&lt;/code&gt; 的实例对象，&lt;code&gt;p&lt;/code&gt; 的内部原型总是指向其构造器&lt;code&gt;Person&lt;/code&gt; 的原型对象 &lt;code&gt;prototype&lt;/code&gt;。&lt;br&gt;
每个对象都有一个 &lt;code&gt;constructor&lt;/code&gt; 属性，可以获取它的构造器，因此以下打印结果也是恒等的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Person(name) {
    this.name = name
}
var p = new Person(&#39;jack&#39;)
console.log(p.__proto__ === p.constructor.prototype) // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的&lt;code&gt;Person&lt;/code&gt;没有给其原型添加属性或方法，这里给其原型添加一个&lt;code&gt;getName&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Person(name) {
    this.name = name
}
// 修改原型
Person.prototype.getName = function() {}
var p = new Person(&#39;jack&#39;)
console.log(p.__proto__ === Person.prototype) // true
console.log(p.__proto__ === p.constructor.prototype) // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到&lt;code&gt;p.__proto__&lt;/code&gt;与&lt;code&gt;Person.prototype&lt;/code&gt;，&lt;code&gt;p.constructor.prototype&lt;/code&gt;都是恒等的，即都指向同一个对象。&lt;/p&gt;
&lt;p&gt;如果换一种方式设置原型，结果就有些不同了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Person(name) {
    this.name = name
}
// 重写原型
Person.prototype = {
    getName: function() {}
}
var p = new Person(&#39;jack&#39;)
console.log(p.__proto__ === Person.prototype) // true
console.log(p.__proto__ === p.constructor.prototype) // false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里直接重写了 &lt;code&gt;Person.prototype&lt;/code&gt;（注意：上一个示例是修改原型）。输出结果可以看出&lt;code&gt;p.__proto__&lt;/code&gt;仍然指向的是&lt;code&gt;Person.prototype&lt;/code&gt;，而不是&lt;code&gt;p.constructor.prototype&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这也很好理解，给&lt;code&gt;Person.prototype&lt;/code&gt;赋值的是一个对象直接量{getName: function(){}}，使用对象直接量方式定义的对象其构造器（&lt;code&gt;constructor&lt;/code&gt;）指向的是根构造器&lt;code&gt;Object&lt;/code&gt;，&lt;code&gt;Object.prototype&lt;/code&gt;是一个空对象{}，{}自然与{getName: function(){}}不等。如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var p = {}
console.log(Object.prototype) // 为一个空的对象{}
console.log(p.constructor === Object) // 对象直接量方式定义的对象其constructor为Object
console.log(p.constructor.prototype === Object.prototype) // 为true，不解释
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;十-原型链再复习一下&#34;&gt;十. 原型链（再复习一下：）&lt;/h2&gt;
&lt;p&gt;下面这个例子你应该能明白了！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Person(){}
var person1 = new Person();
console.log(person1.__proto__ === Person.prototype); // true
console.log(Person.prototype.__proto__ === Object.prototype) //true
console.log(Object.prototype.__proto__) //null

Person.__proto__ == Function.prototype; //true
console.log(Function.prototype)// function(){} (空函数)

var num = new Array()
console.log(num.__proto__ == Array.prototype) // true
console.log( Array.prototype.__proto__ == Object.prototype) // true
console.log(Array.prototype) // [] (空数组)
console.log(Object.prototype.__proto__) //null

console.log(Array.__proto__ == Function.prototype)// true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;疑点解惑：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Object.__proto__ === Function.prototype&lt;/code&gt; // true&lt;br&gt;
Object 是函数对象，是通过new Function()创建的，所以&lt;code&gt;Object.__proto__&lt;/code&gt;指向&lt;code&gt;Function.prototype&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Function.__proto__ === Function.prototype&lt;/code&gt; // true&lt;br&gt;
Function 也是对象函数，也是通过new Function()创建，所以&lt;code&gt;Function.__proto__&lt;/code&gt;指向&lt;code&gt;Function.prototype&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Function.prototype.__proto__ === Object.prototype&lt;/code&gt; //true&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;十一-总结&#34;&gt;十一. 总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;原型和原型链是JS实现继承的一种模型。&lt;/li&gt;
&lt;li&gt;原型链的形成是真正是靠&lt;code&gt;__proto__&lt;/code&gt;而非&lt;code&gt;prototype&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要深入理解这句话，我们再举个例子，看看前面你真的理解了吗？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; var animal = function(){};
 var dog = function(){};

 animal.price = 2000;
 dog.prototype = animal;
 var tidy = new dog();
 console.log(dog.price) //undefined
 console.log(tidy.price) // 2000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里解释一下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var dog = function(){};
dog.prototype.price = 2000;
var tidy = new dog();
console.log(tidy.price); // 2000
console.log(dog.price); //undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; var dog = function(){};
var tidy = new dog();
tidy.price = 2000;
console.log(dog.price); //undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个明白吧？想一想我们上面说过这句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实例（tidy）和 原型对象（dog.prototype）存在一个连接。不过，要明确的真正重要的一点就是，这个连接存在于实例（tidy）与构造函数的原型对象（dog.prototype）之间，而不是存在于实例（tidy）与构造函数（dog）之间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;来源 https://www.jianshu.com/p/a4e1e7b6f4f8&lt;br&gt;
https://www.jianshu.com/p/dee9f8b14771&lt;br&gt;
https://segmentfault.com/a/1190000018070678&lt;/p&gt;
&lt;/blockquote&gt;
">【Diary】如何用 JS原型链 打出优势</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/fu-wu-qi-ruan-jian-zheng-li/"" data-c="
          &lt;h1 id=&#34;1-总结&#34;&gt;1. 总结&lt;/h1&gt;
&lt;p&gt;静态服务：主要提供静态资源，不同用户访问到的资源相同&lt;br&gt;
动态服务：提供动态服务，不同用户访问到的资源不同&lt;/p&gt;
&lt;p&gt;服务器的几个叫法：&lt;br&gt;
web服务器：广义上来说，就是响应用户的需求，提供服务，当下所有的服务器软件都可以称之为web服务器软件&lt;br&gt;
HTTP服务器(静态服务)：使用HTTP协议传输资源，提供服务&lt;br&gt;
应用服务器(动态服务)：一个特定应用的承载容器&lt;/p&gt;
&lt;p&gt;常见的轻量级服务器软件：&lt;br&gt;
1、Nginx：典型的静态服务器，可做反向代理、负载均衡，一般放在最前面直面用户，和后端Tomcat打配合；纯C写的，性能贼高、内存消耗极少、稳定性也相当好，互联网公司重度使用&lt;br&gt;
2、Tengine：阿里出品，基于Nginx服务器做的改造(加强和封装)，对大流量场景做了很多高级功能，性能、稳定性优秀&lt;br&gt;
3、Apache http server：也是静态服务器，但是不如Nginx&lt;br&gt;
4、IIS：微软开发，只能用在Windows下，具有应用服务器能力的http服务器&lt;br&gt;
5、Tomcat：Apache出品，典型的应用服务器软件，符合Servlet标准的应用容器，也可以提供http服务，但一般不会作为http服务器；是Spring Boot框架默认的内置服务器&lt;br&gt;
6、Jetty：跟Tomcat是一个性质的东西，符合Servlet标准的应用容器，也是Spring Boot框架支持的服务器，但不是默认的&lt;br&gt;
7、Undertow：红帽子出品，跟Tomcat、Jetty一样也是Spring Boot框架支持的服务器，但不是默认的；高并发时性能优于Tomcat、Jetty&lt;/p&gt;
&lt;p&gt;几款商用重量级的服务器软件：&lt;br&gt;
1、JBoss(从8版开始更名为WildFly)：不仅是Servlet应用容器，更是EJB的应用容器，整套JavaEE框架部署的解决方案&lt;br&gt;
2、WebLogic：Oracle公司出品，用于部署企业级JavaEE应用，全能型，几乎支持JavaEE所有的应用规范&lt;br&gt;
3、WebSphere：IBM公司出品，支持更多JavaEE的应用规范的综合应用服务器&lt;/p&gt;
&lt;h1 id=&#34;2-nginx-配置详解&#34;&gt;2. Nginx 配置详解&lt;/h1&gt;
&lt;h2 id=&#34;1-序言&#34;&gt;1. 序言&lt;/h2&gt;
&lt;p&gt;Nginx是lgor Sysoev为俄罗斯访问量第二的rambler.ru站点设计开发的。从2004年发布至今，凭借开源的力量，已经接近成熟与完善。&lt;/p&gt;
&lt;p&gt;Nginx功能丰富，可作为HTTP服务器，也可作为反向代理服务器，邮件服务器。支持FastCGI、SSL、Virtual Host、URL Rewrite、Gzip等功能。并且支持很多第三方的模块扩展。&lt;/p&gt;
&lt;p&gt;Nginx的稳定性、功能集、示例配置文件和低系统资源的消耗让他后来居上，在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。&lt;/p&gt;
&lt;p&gt;牛逼吹的差不多啦，如果你还不过瘾，你可以百度百科或者一些书上找到这样的夸耀，比比皆是。&lt;/p&gt;
&lt;h2 id=&#34;2-nginx常用功能&#34;&gt;2. Nginx常用功能&lt;/h2&gt;
&lt;h3 id=&#34;1-反向代理&#34;&gt;1. 反向代理&lt;/h3&gt;
&lt;p&gt;Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理。&lt;br&gt;
这里我给来2张图，对正向代理与反响代理做个诠释，具体细节，大家可以翻阅下资料。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1622467906232.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Nginx在做反向代理时，提供性能稳定，并且能够提供配置灵活的转发功能。Nginx可以根据不同的正则匹配，采取不同的转发策略，比如图片文件结尾的走文件服务器，动态页面走web服务器，只要你正则写的没问题，又有相对应的服务器解决方案，你就可以随心所欲的玩。并且Nginx对返回结果进行错误页跳转，异常判断等。如果被分发的服务器存在异常，他可以将请求重新转发给另外一台服务器，然后自动去除异常服务器。&lt;/p&gt;
&lt;h3 id=&#34;2-负载均衡&#34;&gt;2. 负载均衡&lt;/h3&gt;
&lt;p&gt;Nginx提供的负载均衡策略有2种：内置策略和扩展策略。内置策略为轮询，加权轮询，Ip hash。扩展策略，就天马行空，只有你想不到的没有他做不到的啦，你可以参照所有的负载均衡算法，给他一一找出来做下实现。&lt;br&gt;
上3个图，理解这三种负载均衡算法的实现&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1622468014536.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Ip hash算法，对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1622468056716.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-web缓存&#34;&gt;3. web缓存&lt;/h3&gt;
&lt;p&gt;Nginx可以对不同的文件做不同的缓存处理，配置灵活，并且支持FastCGI_Cache，主要用于对FastCGI的动态程序进行缓存。配合着第三方的ngx_cache_purge，对制定的URL缓存内容可以的进行增删管理。&lt;/p&gt;
&lt;h3 id=&#34;4-nginx相关地址&#34;&gt;4. Nginx相关地址&lt;/h3&gt;
&lt;p&gt;源码：&lt;a href=&#34;https://trac.nginx.org/nginx/browser&#34;&gt;https://trac.nginx.org/nginx/browser&lt;/a&gt;&lt;br&gt;
官网：&lt;a href=&#34;http://www.nginx.org/&#34;&gt;http://www.nginx.org/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-nginx配置文件结构&#34;&gt;3. Nginx配置文件结构&lt;/h2&gt;
&lt;p&gt;如果你下载好啦，你的安装文件，不妨打开conf文件夹的nginx.conf文件，Nginx服务器的基础配置，默认的配置也存放在此。&lt;br&gt;
在 nginx.conf 的注释符号为： #&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nginx 文件结构&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...              #全局块

events {         #events块
   ...
}

http      #http块
{
    ...   #http全局块
    server        #server块
    { 
        ...       #server全局块
        location [PATTERN]   #location块
        {
            ...
        }
        location [PATTERN] 
        {
            ...
        }
    }
    server
    {
      ...
    }
    ...     #http全局块
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;1、&lt;strong&gt;全局块&lt;/strong&gt;：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。&lt;/li&gt;
&lt;li&gt;2、&lt;strong&gt;events块&lt;/strong&gt;：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。&lt;/li&gt;
&lt;li&gt;3、&lt;strong&gt;http块&lt;/strong&gt;：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。&lt;/li&gt;
&lt;li&gt;4、&lt;strong&gt;server块&lt;/strong&gt;：配置虚拟主机的相关参数，一个http中可以有多个server。&lt;/li&gt;
&lt;li&gt;5、&lt;strong&gt;location块&lt;/strong&gt;：配置请求的路由，以及各种页面的处理情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面给大家上一个配置文件，作为理解。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;########### 每个指令必须有分号结束。#################
#user administrator administrators;  #配置用户或者组，默认为nobody nobody。
#worker_processes 2;  #允许生成的进程数，默认为1
#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址
error_log log/error.log debug;  #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg
events {
    accept_mutex on;   #设置网路连接序列化，防止惊群现象发生，默认为on
    multi_accept on;  #设置一个进程是否同时接受多个网络连接，默认为off
    #use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport
    worker_connections  1024;    #最大连接数，默认为512
}
http {
    include       mime.types;   #文件扩展名与文件类型映射表
    default_type  application/octet-stream; #默认文件类型，默认为text/plain
    #access_log off; #取消服务日志    
    log_format myFormat &#39;$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&#39;; #自定义格式
    access_log log/access.log myFormat;  #combined为日志格式的默认值
    sendfile on;   #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。
    sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。
    keepalive_timeout 65;  #连接超时时间，默认为75s，可以在http，server，location块。

    upstream mysvr {   
      server 127.0.0.1:7878;
      server 192.168.10.121:3333 backup;  #热备
    }
    error_page 404 https://www.baidu.com; #错误页
    server {
        keepalive_requests 120; #单连接请求上限次数。
        listen       4545;   #监听端口
        server_name  127.0.0.1;   #监听地址       
        location  ~*^.+$ {       #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。
           #root path;  #根目录
           #index vv.txt;  #设置默认页
           proxy_pass  http://mysvr;  #请求转向mysvr 定义的服务器列表
           deny 127.0.0.1;  #拒绝的ip
           allow 172.18.5.54; #允许的ip           
        } 
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1622468631794.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;3-nginx-反向代理与负载均衡详解&#34;&gt;3. Nginx 反向代理与负载均衡详解&lt;/h1&gt;
&lt;h2 id=&#34;1-nginx-代理服务的配置说明&#34;&gt;1. Nginx 代理服务的配置说明&lt;/h2&gt;
&lt;h3 id=&#34;1-设置-404-页面导向地址&#34;&gt;1. 设置 404 页面导向地址&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;error_page 404 https://www.runnob.com; #错误页
proxy_intercept_errors on;    #如果被代理服务器返回的状态码为400或者大于400，设置的error_page配置起作用。默认为off。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-如果我们的代理只允许接受getpost请求方法的一种&#34;&gt;2. 如果我们的代理只允许接受get，post请求方法的一种&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;proxy_method get;    #支持客户端的请求方法。post/get；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-设置支持的http协议版本&#34;&gt;3. 设置支持的http协议版本&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;proxy_http_version 1.0 ; #Nginx服务器提供代理服务的http协议版本1.0，1.1，默认设置为1.0版本
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-负载均衡&#34;&gt;4. 负载均衡&lt;/h3&gt;
&lt;p&gt;如果你的nginx服务器给2台web服务器做代理，&lt;code&gt;负载均衡算法采用轮询&lt;/code&gt;，那么当你的一台机器web程序iis关闭，也就是说web不能访问，那么nginx服务器分发请求还是会给这台不能访问的web服务器，如果这里的响应连接时间过长，就会导致客户端的页面一直在等待响应，对用户来说体验就打打折扣，这里我们怎么避免这样的情况发生呢。这里我配张图来说明下问题。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1622469336373.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如果负载均衡中其中web2发生这样的情况，nginx首先会去web1请求，但是nginx在配置不当的情况下会继续分发请求道web2，然后等待web2响应，直到我们的响应时间超时，才会把请求重新分发给web1，这里的响应时间如果过长，用户等待的时间就会越长。&lt;/p&gt;
&lt;p&gt;下面的配置是解决方案之一。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;proxy_connect_timeout 1;   #nginx服务器与被代理的服务器建立连接的超时时间，默认60秒
proxy_read_timeout 1; #nginx服务器想被代理服务器组发出read请求后，等待响应的超时间，默认为60秒。
proxy_send_timeout 1; #nginx服务器想被代理服务器组发出write请求后，等待响应的超时间，默认为60秒。
proxy_ignore_client_abort on;  #客户端断网时，nginx服务器是否终端对被代理服务器的请求。默认为off。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-反向代理&#34;&gt;5. 反向代理&lt;/h3&gt;
&lt;p&gt;如果使用&lt;code&gt;upstream&lt;/code&gt;指令配置啦一组服务器作为被代理服务器，服务器中的访问算法遵循配置的负载均衡规则，同时可以使用该指令配置在发生哪些异常情况时，将请求顺次交由下一组服务器处理。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;proxy_next_upstream timeout;  #反向代理upstream中设置的服务器组，出现故障时，被代理服务器返回的状态值。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;状态值可以是：error|timeout|invalid_header|http_500|http_502|http_503|http_504|http_404|off&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;error：建立连接或向被代理的服务器发送请求或读取响应信息时服务器发生错误。&lt;/li&gt;
&lt;li&gt;timeout：建立连接，想被代理服务器发送请求或读取响应信息时服务器发生超时。&lt;/li&gt;
&lt;li&gt;invalid_header:被代理服务器返回的响应头异常。&lt;/li&gt;
&lt;li&gt;off:无法将请求分发给被代理的服务器。&lt;/li&gt;
&lt;li&gt;http_400，....:被代理服务器返回的状态码为400，500，502，等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;6-获取真实ip&#34;&gt;6. 获取真实ip&lt;/h3&gt;
&lt;p&gt;如果你想通过http获取客户的真是ip而不是获取代理服务器的ip地址，那么要做如下的设置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;proxy_set_header Host $host; #只要用户在浏览器中访问的域名绑定了 VIP VIP 下面有RS；则就用$host ；host是访问URL中的域名和端口  www.taobao.com:80
proxy_set_header X-Real-IP $remote_addr;  #把源IP 【$remote_addr,建立HTTP连接header里面的信息】赋值给X-Real-IP;这样在代码中 $X-Real-IP来获取 源IP
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;#在nginx 作为代理服务器时，设置的IP列表，会把经过的机器ip，代理机器ip都记录下来，用 【，】隔开；代码中用 echo $x-forwarded-for |awk -F, &#39;{print $1}&#39; 来作为源IP
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;7-具体配置&#34;&gt;7. 具体配置&lt;/h3&gt;
&lt;p&gt;下面是我的一个关于代理配置的配置文件部分，仅供参考。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;include       mime.types;   #文件扩展名与文件类型映射表
default_type  application/octet-stream; #默认文件类型，默认为text/plain
#access_log off; #取消服务日志    
log_format myFormat &#39; $remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&#39;; #自定义格式
access_log log/access.log myFormat;  #combined为日志格式的默认值
sendfile on;   #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。
sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。
keepalive_timeout 65;  #连接超时时间，默认为75s，可以在http，server，location块。
proxy_connect_timeout 1;   #nginx服务器与被代理的服务器建立连接的超时时间，默认60秒
proxy_read_timeout 1; #nginx服务器想被代理服务器组发出read请求后，等待响应的超时间，默认为60秒。
proxy_send_timeout 1; #nginx服务器想被代理服务器组发出write请求后，等待响应的超时间，默认为60秒。
proxy_http_version 1.0 ; #Nginx服务器提供代理服务的http协议版本1.0，1.1，默认设置为1.0版本。
#proxy_method get;    #支持客户端的请求方法。post/get；
proxy_ignore_client_abort on;  #客户端断网时，nginx服务器是否终端对被代理服务器的请求。默认为off。
proxy_ignore_headers &amp;quot;Expires&amp;quot; &amp;quot;Set-Cookie&amp;quot;;  #Nginx服务器不处理设置的http相应投中的头域，这里空格隔开可以设置多个。
proxy_intercept_errors on;    #如果被代理服务器返回的状态码为400或者大于400，设置的error_page配置起作用。默认为off。
proxy_headers_hash_max_size 1024; #存放http报文头的哈希表容量上限，默认为512个字符。
proxy_headers_hash_bucket_size 128; #nginx服务器申请存放http报文头的哈希表容量大小。默认为64个字符。
proxy_next_upstream timeout;  #反向代理upstream中设置的服务器组，出现故障时，被代理服务器返回的状态值。error|timeout|invalid_header|http_500|http_502|http_503|http_504|http_404|off
#proxy_ssl_session_reuse on; 默认为on，如果我们在错误日志中发现“SSL3_GET_FINSHED:digest check failed”的情况时，可以将该指令设置为off。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-nginx-负载均衡详解&#34;&gt;2. Nginx 负载均衡详解&lt;/h2&gt;
&lt;p&gt;首先给大家说下upstream这个配置的，这个配置是写一组被代理的服务器地址，然后配置负载均衡的算法。这里的&lt;code&gt;被代理服务器&lt;/code&gt;地址有2中写法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;upstream mysvr { 
    server 192.168.10.121:3333;
    server 192.168.10.122:3333;
}
server {
    ....
    location  ~*^.+$ {         
        proxy_pass  http://mysvr;  #请求转向mysvr 定义的服务器列表         
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，就来点实战的东西。&lt;/p&gt;
&lt;h3 id=&#34;1-热备&#34;&gt;1. 热备&lt;/h3&gt;
&lt;p&gt;如果你有2台服务器，当一台服务器发生事故时，才启用第二台服务器给提供服务。服务器处理请求的顺序：AAAAAA突然A挂啦，BBBBBBBBBBBBBB.....&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;upstream mysvr { 
    server 127.0.0.1:7878; 
    server 192.168.10.121:3333 backup;  #热备     
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-轮询&#34;&gt;2. 轮询&lt;/h3&gt;
&lt;p&gt;nginx默认就是轮询其权重都默认为1，服务器处理请求的顺序：ABABABABAB....&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;upstream mysvr { 
    server 127.0.0.1:7878;
    server 192.168.10.121:3333;       
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-加权轮询&#34;&gt;3. 加权轮询&lt;/h3&gt;
&lt;p&gt;跟据配置的权重的大小而分发给不同服务器不同数量的请求。如果不设置，则默认为1。下面服务器的请求顺序为：ABBABBABBABBABB....&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;upstream mysvr { 
    server 127.0.0.1:7878 weight=1;
    server 192.168.10.121:3333 weight=2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-ip_hash&#34;&gt;4. ip_hash&lt;/h3&gt;
&lt;p&gt;nginx会让相同的客户端ip请求相同的服务器。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;upstream mysvr { 
    server 127.0.0.1:7878; 
    server 192.168.10.121:3333;
    ip_hash;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-关于nginx负载均衡配置的几个状态参数讲解&#34;&gt;5. 关于nginx负载均衡配置的几个状态参数讲解&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;down，表示当前的server暂时不参与负载均衡。&lt;/li&gt;
&lt;li&gt;backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。&lt;/li&gt;
&lt;li&gt;max_fails，允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误。&lt;/li&gt;
&lt;li&gt;fail_timeout，在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;upstream mysvr { 
    server 127.0.0.1:7878 weight=2 max_fails=2 fail_timeout=2;
    server 192.168.10.121:3333 weight=1 max_fails=2 fail_timeout=1;    
}
&lt;/code&gt;&lt;/pre&gt;
">服务器软件整理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/js-shou-si-jian-zhi-offerii/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;本文题目源自&lt;a href=&#34;https://www.nowcoder.com/ta/coding-interviews?page=1&#34;&gt;牛客网&lt;/a&gt;，与&lt;a href=&#34;https://leetcode-cn.com/problemset/lcof/&#34;&gt;Leetcode&lt;/a&gt;上有些许差异&lt;br&gt;
文章部分内容来自互联网，如有版权问题欢迎与我联系~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;特别鸣谢 以下几位大佬的图解和思路(包括但不完全)&lt;br&gt;
&lt;a href=&#34;https://leetcode-cn.com/u/jyd/&#34;&gt;Krahets&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://leetcode-cn.com/u/xin-tan/&#34;&gt;心谭&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://leetcode-cn.com/u/xiao_ben_zhu/&#34;&gt;笨猪爆破组&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://leetcode-cn.com/u/sweetiee/&#34;&gt;Sweetiee&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://leetcode-cn.com/u/sdwwld/&#34;&gt;数据结构和算法&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://leetcode-cn.com/u/liweiwei1419/&#34;&gt;liweiwei1419&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://leetcode-cn.com/u/fuxuemingzhu/&#34;&gt;负雪明烛&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;1-二维数组中的查找&#34;&gt;1. 二维数组中的查找&lt;/h1&gt;
&lt;h2 id=&#34;1题目描述&#34;&gt;1.🎨题目描述&lt;/h2&gt;
&lt;p&gt;在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;br&gt;
[&lt;br&gt;
[1,2,8,9],&lt;br&gt;
[2,4,9,12],&lt;br&gt;
[4,7,10,13],&lt;br&gt;
[6,8,11,15]&lt;br&gt;
]&lt;br&gt;
给定 target = 7，返回 true。&lt;br&gt;
给定 target = 3，返回 false。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;从矩阵 matrix &lt;code&gt;左下角&lt;/code&gt;元素（索引设为 (i, j) ）开始遍历，并与目标值对比：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 matrix[i][j] &amp;gt; target 时，执行 i-- ，即消去第 i 行元素；&lt;/li&gt;
&lt;li&gt;当 matrix[i][j] &amp;lt; target 时，执行 j++ ，即消去第 j 列元素；&lt;/li&gt;
&lt;li&gt;当 matrix[i][j] = target 时，返回 true，代表找到目标值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若行索引或列索引越界，则代表矩阵中无目标值，返回 false。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-复杂度与代码&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt; O(M+N)：其中，N 和 M 分别为矩阵行数和列数，此算法最多循环 M+N 次。&lt;br&gt;
&lt;strong&gt;空间复杂度&lt;/strong&gt; O(1) : i, j 指针使用常数大小额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Find(target, array)
{
   let i = array.length - 1, 
       j = 0;
   while(i &amp;gt;= 0 &amp;amp;&amp;amp; j &amp;lt; array[0].length){
     if(array[i][j] &amp;gt; target) i--;
     else if(array[i][j] &amp;lt; target) j++;
     else return true;
   }
   return false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2-替换空格&#34;&gt;2. 替换空格&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-2&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;h3 id=&#34;1-原生api法&#34;&gt;1. 原生API法&lt;/h3&gt;
&lt;p&gt;JavaScript有replace方法，所以一行正则就搞定&lt;/p&gt;
&lt;h3 id=&#34;2-数组方法遍历添加&#34;&gt;2. 数组方法（遍历添加）&lt;/h3&gt;
&lt;p&gt;利用js的split()和join()方法，自己模拟&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-2&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt; O(N)&lt;br&gt;
&lt;strong&gt;空间复杂度&lt;/strong&gt; O(N)&lt;/p&gt;
&lt;h3 id=&#34;1-原生api法-2&#34;&gt;1. 原生API法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function replaceSpace( s ) {
  return s.replace(/ /g,&#39;%20&#39;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-数组遍历法&#34;&gt;2. 数组遍历法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;var replaceSpace = function(s) {
  return  s.split(&#39; &#39;).join(&amp;quot;%20&amp;quot;);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3-从尾到头打印链表&#34;&gt;3. 从尾到头打印链表&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-2&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;输入一个链表，按链表从尾到头的顺序返回一个ArrayList。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-3&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;利用数组特性，使用unshift()方法，将链表的每一项从数组头插入数组，形成倒叙&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-3&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;时间复杂度 O(N)： 遍历链表，递归 N 次。&lt;br&gt;
空间复杂度 O(N)： 系统递归需要使用 O(N)) 的栈空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function printListFromTailToHead(head)
{
    let nums = []
    let node = head
    //遍历链表
    while(node !== null) {
        nums.unshift(node.val)
        node = node.next
    }
    return nums
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;4-重建二叉树&#34;&gt;4. 重建二叉树&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-3&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-4&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;根据以上性质，可得出以下推论：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前序遍历的首元素 为 树的根节点 node 的值。&lt;/li&gt;
&lt;li&gt;在中序遍历中搜索根节点 node 的索引 ，可将 中序遍历 划分为 [ 左子树 | 根节点 | 右子树 ] 。&lt;/li&gt;
&lt;li&gt;根据中序遍历中的左 / 右子树的节点数量，可将 前序遍历 划分为 [ 根节点 | 左子树 | 右子树 ] 。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1621341323924.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;通过以上三步，可确定&lt;strong&gt;三个节点&lt;/strong&gt; ：1.树的根节点、2.左子树根节点、3.右子树根节点。&lt;br&gt;
对于树的左、右子树，仍可使用以上步骤划分子树的左右子树。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意：本文方法只适用于 “无重复节点值” 的二叉树。&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-4&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;时间复杂度 O(N) ： 其中 N 为树的节点数量。&lt;br&gt;
空间复杂度 O(N) ：最差情况下，树退化为链表，递归深度达到 NN ，占用 O(N)O(N) 额外空间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function reConstructBinaryTree(preorder, inorder){
  if(!preorder.length || !inorder.length) return null;
  const rootVal = preorder[0];                //定义根节点，前序遍历第一个数
  const node = new TreeNode(rootVal);
    // i有两个含义，一个是根节点在中序遍历结果中的下标，另一个是当前左子树的节点个数
  for(var i = 0; i &amp;lt; inorder.length; i++){
    if(inorder[i] === rootVal) break;
  }

  node.left = reConstructBinaryTree(preorder.slice(1, i + 1), inorder.slice(0, i));
  node.right = reConstructBinaryTree(preorder.slice(i + 1), inorder.slice(i + 1));
  return node;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5-两个栈实现队列&#34;&gt;5. 两个栈实现队列&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-4&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-5&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1621342330291.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;函数设计：&lt;br&gt;
题目只要求实现 &lt;strong&gt;加入队尾&lt;/strong&gt;appendTail() 和 &lt;strong&gt;删除队首&lt;/strong&gt;deleteHead() 两个函数的正常工作，因此我们可以设计栈 A 用于加入队尾操作，栈 B 用于将元素倒序，从而实现删除队首元素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;加入队尾&lt;/strong&gt; appendTail()函数： 将数字 val 加入栈 A 即可。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;删除队首&lt;/strong&gt; deleteHead()函数： 有以下三种情况。
&lt;ol&gt;
&lt;li&gt;当栈 B 不为空： B中仍有已完成倒序的元素，因此直接返回 B 的栈顶元素。&lt;/li&gt;
&lt;li&gt;否则，当 A 为空： 即两个栈都为空，无元素，因此返回 -1−1 。&lt;/li&gt;
&lt;li&gt;否则： 将栈 A 元素全部转移至栈 B 中，实现元素倒序，并返回栈 B 的栈顶元素。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-复杂度与代码-5&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;时间复杂度O(N)&lt;br&gt;
空间复杂度 O(N) ： 最差情况下，栈 A 和 B 共保存 N 个元素。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const inStack = [];
const outStack = [];

function push(node)
{
   inStack.push(node);
}

function pop()
{
   if (outStack.length) {
       return outStack.pop()
   }else {
       while(inStack.length){
           outStack.push(inStack.pop());
       }
       return outStack.pop();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;6-旋转数组的最小数字&#34;&gt;6.  旋转数组的最小数字&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-5&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。&lt;br&gt;
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。&lt;br&gt;
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-6&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;首先，创建两个指针 left, right 分别指向 numbers 首尾数字，然后计算出两指针之间的中间索引值 middle，然后我们会遇到以下三种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;middle &amp;gt; right ：代表最小值一定在 middle 右侧，所以 left 移到 middle + 1的位置。&lt;/li&gt;
&lt;li&gt;middle&amp;lt; right ：代表最小值一定在 middle左侧或者就是 middle，所以 right移到 middle 的位置。&lt;/li&gt;
&lt;li&gt;middle 既不大于 left 指针的值，也不小于 right 指针的值，代表着 middle 可能等于 left 指针的值，或者 right 指针的值，我们这时候只能让 right 指针递减，来一个一个找最小值了。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-复杂度与代码-6&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;时间复杂度：平均时间复杂度为 O(log n)&lt;br&gt;
空间复杂度：平均时间复杂度为 O(1)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function minNumberInRotateArray(rotateArray) {
  let left = 0,
      right = rotateArray.length - 1;
  while(left &amp;lt; right){
    // Math.floor 等价于 ~~ 双取反去掉小数部分
    let middle = left + Math.floor((right - left) / 2);
    if(rotateArray[middle] &amp;gt; rotateArray[right]) left = middle + 1;
    else if(rotateArray[middle] &amp;lt; rotateArray[right]) right = middle;
    else right--;
  }
  return rotateArray[left];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;7-斐波那契数列&#34;&gt;7. 斐波那契数列&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-6&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。n≤39&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-7&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;动态规划&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原理： 以斐波那契数列性质 f(n + 1) = f(n) + f(n - 1) 为转移方程。&lt;/li&gt;
&lt;li&gt;从计算效率、空间复杂度上看，动态规划是本题的最佳解法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;动态规划解析&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态定义： 设 dp 为一维数组，其中 dp[i] 的值代表 斐波那契数列第 i 个数字 。&lt;/li&gt;
&lt;li&gt;转移方程： dp[i + 1] = dp[i] + dp[i - 1]，即对应数列定义 f(n + 1) = f(n) + f(n - 1) ；&lt;/li&gt;
&lt;li&gt;初始状态： dp[0] = 0, dp[1] = 1 ，即初始化前两个数字；&lt;/li&gt;
&lt;li&gt;返回值： dp[n] ，即斐波那契数列的第 n 个数字。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;空间复杂度优化&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;若新建长度为 nn 的 dpdp 列表，则空间复杂度为 O(N)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;由于 dp 列表第 i 项只与第 i-1 和第 i-2 项有关，因此只需要初始化三个整形变量 sum, a, b ，利用辅助变量 sum 使 a, b 两数字交替前进即可 （具体实现见代码） 。&lt;/li&gt;
&lt;li&gt;节省了 dp 列表空间，因此空间复杂度降至 O(1) 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-复杂度与代码-7&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt; O(N) ： 计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1) 。&lt;br&gt;
&lt;strong&gt;空间复杂度&lt;/strong&gt; O(1)： 几个标志变量使用常数大小的额外空间。&lt;br&gt;
&lt;code&gt;动态规划&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;每一次计算结果都能得到利用，易于理解，只保存前两个计算结果，性能最优
function Fibonacci(n)
{
  let a = 0, b = 1;
  let sum = 0;
  for(let i = 0; i &amp;lt; n; i++){
      sum = a + b;
      a = b;
      b = sum;
  }
    return a;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;备忘录算法&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Fibonacci(n)
{
    const cache = {
        0: 0,
        1: 1
    };
    return _Fibonacci(n);
    
    function _Fibonacci(n){
        if(cache[n] !== undefined){
            return cache[n];
        }
        cache[n] = _Fibonacci(n-1) + _Fibonacci(n-2);
        return cache[n]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;8-跳台阶&#34;&gt;8. 跳台阶&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-7&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-8&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;此类求 多少种可能性 的题目一般都有&lt;strong&gt;递推性质&lt;/strong&gt; ，即 f(n) 和 f(n-1)…f(1) 之间是有联系的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;设跳上 n 级台阶有 f(n) 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 1 级或 2 级台阶。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当为 1 级台阶： 剩 n-1 个台阶，此情况共有 f(n-1) 种跳法；&lt;/li&gt;
&lt;li&gt;当为 2 级台阶： 剩 n-2 个台阶，此情况共有 f(n-2) 种跳法。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;f(n) 为以上两种情况之和，即 f(n)=f(n-1)+f(n-2) ，以上递推性质为斐波那契数列。本题可转化为 &lt;strong&gt;求斐波那契数列第 n 项的值&lt;/strong&gt; ，与 斐波那契数列 等价，唯一的不同在于起始数字不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;青蛙跳台阶问题： f(0)=1 , f(1)=1 , f(2)=2 ；&lt;/li&gt;
&lt;li&gt;斐波那契数列问题： f(0)=0 , f(1)=1 , f(2)=1 。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1621384519106.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-复杂度与代码-8&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt; O(N) ： 计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1) 。&lt;br&gt;
&lt;strong&gt;空间复杂度&lt;/strong&gt; O(1)： 几个标志变量使用常数大小的额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var numWays = function(n) {
    let a = 1, b = 1;
    let sum = 0;
    for(let i = 0; i &amp;lt; n; i++){
        sum = a + b;
        a = b;
        b = sum;
    }
    return a;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;9-跳台阶扩展问题&#34;&gt;9. 跳台阶扩展问题&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-8&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-9&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;假设跳 n 级台阶的跳法数量是 f(n)个。&lt;/p&gt;
&lt;p&gt;那么根据题意，青蛙可能从 n-1 级直接跳上来，也可能从 n-2 级直接跳上来，依次类推：f(n) = f(n - 1) + f(n - 2) + ... + f(1)&lt;br&gt;
同理：f(n - 1) = f(n - 2) + f(n - 3) + ... + f(1)&lt;br&gt;
所以，将公式 1 中的f(n - 2) + f(n - 3) + ... + f(1)替换为f(n - 1)。公式 1 变为：f(n) = f(n - 1) + f(n - 1) = f(n - 1) * 2 （公式 3）&lt;br&gt;
同理：f(n - 1) = f(n - 2) + f(n - 2) = f(n - 2) * 2（公式 4）&lt;/p&gt;
&lt;p&gt;结合公式 3 和公式 4: f(n) = f(n - 2) * 2 * 2。因此可以推出：f(n) = 2^(n - 1)&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-9&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;function jumpFloorII(number)
{
    return Math.pow(2,number - 1)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;10-矩形覆盖&#34;&gt;10. 矩形覆盖&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-9&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，从同一个方向看总共有多少种不同的方法？&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-10&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;迭代&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;涂掉最后一级矩形的时候，是用什么方式完成的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;n = 1 的时候
&lt;ul&gt;
&lt;li&gt;只能横着覆盖，一种&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;n = 2 的时候
&lt;ul&gt;
&lt;li&gt;可以横着和竖着覆盖，两种&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;n = 3 的时候
&lt;ul&gt;
&lt;li&gt;第三级横着覆盖，用了一级，剩下 n = 2，有两种覆盖方法&lt;/li&gt;
&lt;li&gt;第三季竖着覆盖，用了两级，剩下 n = 1，有一种覆盖方法&lt;/li&gt;
&lt;li&gt;总共有 3 种&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;n = 4 的时候
&lt;ul&gt;
&lt;li&gt;第 4 级横着覆盖，用了一级，剩下 n = 3，有三种覆盖方法&lt;/li&gt;
&lt;li&gt;第 4 级竖着覆盖，用了两级，剩下 n = 2，有两种覆盖方法&lt;/li&gt;
&lt;li&gt;总共有 5 种方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;n = n 的时候
&lt;ul&gt;
&lt;li&gt;第 n 级横着覆盖，用了一级，剩下 n = n - 1，所以关注第 n - 1 种有几种覆盖方法&lt;/li&gt;
&lt;li&gt;第 n 级竖着覆盖，用了两级，剩下 n = n - 2，所以关注第 n - 2 种有几种覆盖方法&lt;/li&gt;
&lt;li&gt;总和为两种情况的总和&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从 n = 3 和 n = 4 的示意图如下：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1621386677240.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1621386681434.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-10&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;：O（n）&lt;br&gt;
&lt;strong&gt;空间复杂度&lt;/strong&gt;：O（1）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function rectCover(number)
{
 if(number&amp;lt;=2)
     return number
  let a = 1
  let b = 2
  let sum = 0
  for(let i=3;i&amp;lt;=number;i++){
      sum = a+b;
      a = b;
      b = sum
  }
    return sum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;11-二进制中1的个数&#34;&gt;11. 二进制中1的个数&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-10&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-11&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;巧用 n&amp;amp;(n−1)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(n−1) 解析： 二进制数字 n 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1 。&lt;/li&gt;
&lt;li&gt;n&amp;amp;(n−1) 解析： 二进制数字 n &lt;strong&gt;最右边的 1 变成 0&lt;/strong&gt; ，其余不变。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1621390431142.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;算法流程&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化数量统计变量 res 。&lt;/li&gt;
&lt;li&gt;循环消去最右边的 1 ：当 n = 0 时跳出。
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;res += 1&lt;/strong&gt; ： 统计变量加 1 ；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;n &amp;amp;= n - 1&lt;/strong&gt; ： 消去数字 n 最右边的 1 。&lt;br&gt;
返回统计数量 res 。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-复杂度与代码-11&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt; O(M) ： n&amp;amp;(n−1) 操作仅有减法和与运算，占用 O(1) ；设 M 为二进制数字 n 中 1 的个数，则需循环 M 次（每轮消去一个 1 ），占用 O(M) 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt; O(1) ： 变量 res 使用常数大小额外空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;var hammingWeight = function(n) {
    let count = 0;
    while(n){
        n = n &amp;amp; (n - 1);
        count++;
    }
    return count;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;12-数值的整数次方&#34;&gt;12. 数值的整数次方&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-11&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，x^n）。不得使用库函数，同时不需要考虑大数问题。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-12&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;快速幂解析（二分法角度）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;快速幂实际上是二分思想的一种应用。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1621392122524.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1621392145517.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;转化为位运算&lt;/strong&gt;：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;向下整除 n // 2 等价于 右移一位 n &amp;gt;&amp;gt; 1 ；&lt;/li&gt;
&lt;li&gt;取余数 n % 2 等价于 判断二进制最右一位值 n&amp;amp;1 ；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1621392947278.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-复杂度与代码-12&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt; O(log2n)​ ： 二分的时间复杂度为对数级别。&lt;br&gt;
&lt;strong&gt;空间复杂度&lt;/strong&gt; O(logn) ： 采用递归结构。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var myPow = function(x, n) {
  if(x === 0) return 0;
  let res = 1;
  if(n &amp;lt; 0){
    x = 1 / x;
    n = -n;
  }
  while(n &amp;gt; 0){
    // 等价于n%2取余数 余1为奇数
    if(n &amp;amp; 1) res *= x;
    x *= x;
    n = n &amp;gt;&amp;gt;&amp;gt; 1;
  }
  return res;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/jsjie-ti-yu-dao-de-keng-he-ji-by-wangfei-cc6w/&#34;&gt;js位运算与超时&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;13-调整数组顺序使奇数位于偶数前面&#34;&gt;13. 调整数组顺序使奇数位于偶数前面&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-12&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-13&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;h3 id=&#34;解法-1开辟新空间&#34;&gt;解法 1:开辟新空间&lt;/h3&gt;
&lt;p&gt;此过程需要循环 2 次，时间复杂度 O(N), 空间复杂度 O(N)。过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一次循环依次找到偶数和奇数，并且将其分别存放到新开辟的空间中&lt;/li&gt;
&lt;li&gt;第二次循环将存放偶数和奇数的空间“连接”在一起&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;解法-2-双指针交换&#34;&gt;解法 2: 双指针交换&lt;/h3&gt;
&lt;p&gt;可以利用“双指针”，分别是指向数组头部的指针 i，与指向数组尾部的指针 j。过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;i 向右移动，直到遇到偶数；j 向左移动，直到遇到奇数&lt;/li&gt;
&lt;li&gt;检查 i 是否小于 j，若小于，交换 i 和 j 的元素，回到上一步骤继续移动；否则结束循环&lt;br&gt;
时间复杂度是 O(N),空间复杂度是 O(1)。代码如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-复杂度与代码-13&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;开辟新空间&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function reOrderArray( array ) {
  const ji = [];      // 奇数数组
  const ou = [];      // 奇数数组
  array.forEach((item) =&amp;gt; {
    item % 2 ? ji.push(item) : ou.push(item);
  });
  return ji.concat(ou);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;双指针交换&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var exchange = function(nums) {
  const length = nums.length;
  if(!length) return [];
  let i = 0,
      j = length - 1;
  while(i &amp;lt; j){
    while(i &amp;lt; length &amp;amp;&amp;amp; nums[i] % 2) i++;
    while(j &amp;gt;= 0 &amp;amp;&amp;amp; nums[j] % 2 === 0) j--;

    if(i &amp;lt; j){
      [nums[i],nums[j]] = [nums[j],nums[i]];
      i++;
      j--;
    }
  }
  return nums;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;14-链表中倒数第k个结点&#34;&gt;14.  链表中倒数第k个结点&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-13&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;输入一个链表，输出该链表中倒数第k个结点。&lt;br&gt;
如果该链表长度小于k，请返回空。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-14&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;基本思路：双指针/快慢指针&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当快指针 fast 走了k步的时候慢指针slow 开始走&lt;/li&gt;
&lt;li&gt;当快指针 fast 走出的时候（即超出边界）此时的 slow 位置即为链表中倒数第k个节点&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-复杂度与代码-14&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt; ： N 为链表长度；总体看， former 走了 N 步， latter 走了(N−k) 步。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(1)&lt;/strong&gt; ： 双指针 former , latter 使用常数大小的额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function FindKthToTail( head ,  k ) {
  let fast = head, slow = head;
  while(k &amp;amp;&amp;amp; fast){
      fast = fast.next;
      k--;
  }
  if(k) return null;
  while(fast){
      fast = fast.next;
      slow = slow.next;
  }
  return slow;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;15-反转链表&#34;&gt;15. 反转链表&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-14&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;输入一个链表，反转链表后，输出新链表的表头。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-15&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;单链表只能依次通过 next 访问 不能通过索引访问&lt;br&gt;
链表的交换需要扩展一个指针 即next&lt;br&gt;
cur 当前项&lt;br&gt;
prev 上一项&lt;br&gt;
cur.next 当前指针指向&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1621771696118.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-15&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;：O(n)，其中 n 是链表的长度。需要遍历链表一次。&lt;br&gt;
&lt;strong&gt;空间复杂度&lt;/strong&gt;：O(1)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function ReverseList(head)
{
   let [p, c] = [null, head]
   while (c) [c.next, p, c] = [p, c, c.next]
   return p
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;16-合并两个排序的链表&#34;&gt;16.  合并两个排序的链表&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-15&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-16&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;根据题目描述， 链表 l1 , l2 是&lt;strong&gt;递增&lt;/strong&gt;的，因此容易想到使用双指针l1和l2 遍历两链表，根据l1.val和l2.val的大小关系确定节点添加顺序，两节点指针交替前进，直至遍历完毕。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引入伪头节点&lt;/strong&gt;： 由于初始状态合并链表中无节点，因此循环第一轮时无法将节点添加到合并链表中。解决方案：初始化一个辅助节点 dum 作为合并链表的伪头节点，将各节点添加至 dum 之后。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1622540001340.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1622540086651.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-复杂度与代码-16&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(M+N)&lt;/strong&gt; ： M, N分别为链表 l1 , l2 的长度，合并操作需遍历两链表。&lt;br&gt;
**空间复杂度 O(1) **： 节点引用 dum , cur 使用常数大小的额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var mergeTwoLists = function(l1, l2) {
  let dum = new ListNode(-1);
  let cur = dum;
  while(l1 &amp;amp;&amp;amp; l2){
    if(l1.val &amp;lt; l2.val){
      dum.next = l1;
      l1 = l1.next;
    }else{
      dum.next = l2;
      l2 = l2.next;
    }
    dum = dum.next;
  }
  if(l1) dum.next = l1;
  if(l2) dum.next = l2;
  return cur.next;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;17-树的子结构&#34;&gt;17. 树的子结构&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-16&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-17&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;若树 B 是树 A 的子结构，则子结构的根节点可能为树 A 的任意一个节点。因此，判断树 B 是否是树 A 的子结构，需设计两个函数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;isSubStructure 的职能：判断 B 是否是 A 的子结构。是，返回 true；否则，尝试 A 的左右子树&lt;/li&gt;
&lt;li&gt;isSubTree 的职能：封装“判断 B 是否是 A 的子结构”的具体逻辑。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624626358399.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-复杂度与代码-17&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(MN)&lt;/strong&gt; ： 其中 M,N 分别为树 A 和 树 B 的节点数量；先序遍历树 A 占用 O(M)，每次调用 recur(A, B) 判断占用 O(N) 。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(M)&lt;/strong&gt;： 当树 A 和树 B 都退化为链表时，递归调用深度最大。当 M≤N 时，遍历树 A 与递归判断的总递归深度为 M ；当 M&amp;gt;N 时，最差情况为遍历至树 A 叶子节点，此时总递归深度为 M。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 判断 B 是否是 A 的子结构。是，返回 true；否则，尝试 A 的左右子树
function HasSubtree(pRoot1, pRoot2)
{
   if(!pRoot1 || !pRoot2) return false;    // 题目约定：约定空树不是任意一个树的子结构
   return (
     isSubTree(pRoot1, pRoot2) ||          //比较当前节点值
     HasSubtree(pRoot1.left, pRoot2) ||    //比较左右节点值
     HasSubtree(pRoot1.right, pRoot2)
   );
}

// 封装“判断 B 是否是 A 的子结构”的具体逻辑。
function isSubTree(pRoot1, pRoot2){
   if (!pRoot2) return true;          // B树遍历完了，说明B是A的子结构
   if (!pRoot1) return false;         // A遍历完了，但是B还没有遍历完，那么B肯定不是A的子结构
   if (pRoot1.val !== pRoot2.val) return false;
   return isSubTree(pRoot1.left, pRoot2.left) &amp;amp;&amp;amp; isSubTree(pRoot1.right, pRoot2.right);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;18-二叉树的镜像&#34;&gt;18. 二叉树的镜像&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-17&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;请完成一个函数，输入一个二叉树，该函数输出它的镜像。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-18&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;根据二叉树镜像的定义，考虑递归遍历（dfs）二叉树，交换每个节点的左 / 右子节点，即可生成二叉树的镜像。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;递归解析：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;终止条件： 当节点 root 为空时（即越过叶节点），则返回 null ；&lt;/li&gt;
&lt;li&gt;递推工作：&lt;br&gt;
* 初始化节点 tmp ，用于暂存 root 的左子节点；&lt;br&gt;
* 开启递归 右子节点 mirrorTree(root.right) ，并将返回值作为 root 的左子节点 。&lt;br&gt;
* 开启递归 mirrorTree(tmp) ，并将返回值作为 root 的 右子节点 。&lt;/li&gt;
&lt;li&gt;返回值：返回当前节点 root；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-复杂度与代码-18&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt;： 其中 N 为二叉树的节点数量，建立二叉树镜像需要遍历树的所有节点，占用 O(N) 时间。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(N)&lt;/strong&gt; ： 最差情况下（当二叉树退化为链表），递归时系统需使用 O(N) 大小的栈空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Mirror( root ) {
  if(!root) return null;
  Mirror(root.left);
  Mirror(root.right);
  [root.left, root.right] = [root.right, root.left];
  return root;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;19-顺时针打印矩阵&#34;&gt;19. 顺时针打印矩阵&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-18&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-19&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;遍历到底&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1624785685872.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;循环的条件是 top &amp;lt;= bottom &amp;amp;&amp;amp; left &amp;lt;= right 。&lt;/li&gt;
&lt;li&gt;每遍历完一条边，下一条边遍历的起点被“挤占”，所以要更新相应的边界。&lt;/li&gt;
&lt;li&gt;因为要在循环过程中更新边界，所以可能出现：循环的条件在中途不再满足，即 top &amp;gt; bottom || left &amp;gt; right ，其中一对边界彼此交错了。&lt;/li&gt;
&lt;li&gt;这代表此时所有项都遍历完了，如果不马上 break，就会重复遍历，造成元素重复地进入结果数组。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每遍历完一条边，更新完相应的边界后，都加一句if (top &amp;gt; bottom || left &amp;gt; right) break&lt;/li&gt;
&lt;li&gt;但其实发现，遍历结束要么发生在遍历完“上边”，要么发生在遍历完“右边”，只需在这两步操作之后加 if (top &amp;gt; bottom || left &amp;gt; right) break 即可，不用每一条后面都加。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-复杂度与代码-19&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(mn)&lt;/strong&gt;，m、n 分别是行数和列数。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(mn)&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function printMatrix(matrix)
{
  if(matrix.length === 0) return [];
  const res = [];
  let top = 0, left = 0, bottom = matrix.length - 1, right = matrix[0].length - 1;  //初始化变量
  while(top &amp;lt;= bottom &amp;amp;&amp;amp; left &amp;lt;= right){          //当上不超过下 左不超过右时
    for(let i = left; i &amp;lt;= right; i++) res.push(matrix[top][i]);        //遍历上边一行
    top++;
    for(let i = top; i &amp;lt;= bottom; i++) res.push(matrix[i][right]);      //遍历右边一行
    right--;
    
    if(top &amp;gt; bottom || left &amp;gt; right) break;       //超过边界退出

    for(let i = right; i &amp;gt;= left; i--) res.push(matrix[bottom][i]);     //遍历下边一行
    bottom--;
    for(let i = bottom; i &amp;gt;= top; i--) res.push(matrix[i][left]);       //遍历左边一行
    left++;
  } 
  return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;20-包含min函数的栈&#34;&gt;20. 包含min函数的栈&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-19&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数，并且调用 min函数、push函数 及 pop函数 的时间复杂度都是 O(1)&lt;br&gt;
push(value):将value压入栈中&lt;br&gt;
pop():弹出栈顶元素&lt;br&gt;
top():获取栈顶元素&lt;br&gt;
min():获取栈中最小元素&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-20&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;普通栈的 push() 和 pop() 函数的复杂度为 O(1) ；而获取栈最小值 min() 函数需要遍历整个栈，复杂度为 O(N) 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本题难点&lt;/strong&gt;： 将 min() 函数复杂度降为 O(1) ，可通过建立辅助栈实现；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据栈 A ： 栈 A 用于存储所有元素，保证入栈 push() 函数、出栈 pop() 函数、获取栈顶 top() 函数的正常逻辑。&lt;/li&gt;
&lt;li&gt;辅助栈 B ： 栈 B 中存储栈 A 中所有 非严格降序 的元素，则栈 A 中的最小元素始终对应栈 B 的栈顶元素，即 min() 函数只需返回栈 B 的栈顶元素即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;因此&lt;/strong&gt;，只需设法维护好 栈 B 的元素，使其保持非严格降序，即可实现 min() 函数的 O(1) 复杂度。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1625038523972.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-20&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(1)&lt;/strong&gt; ： push(), pop(), top(), min() 四个函数的时间复杂度均为常数级别。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(N)&lt;/strong&gt;： 当共有 N 个待入栈元素时，辅助栈 B 最差情况下存储 N 个元素，使用 O(N) 额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const data_Stack = [];
const min_Stack = [];

function push(x){
  data_Stack.push(x);
  if(!min_Stack.length || x &amp;lt;= min_Stack[min_Stack.length - 1]) min_Stack.push(x);
}

function pop(){
  if(min_Stack[min_Stack.length - 1] === data_Stack[data_Stack.length - 1]) min_Stack.pop();
  data_Stack.pop();
}

function top(){
  return data_Stack[data_Stack.length - 1];
}

function min(){
  return min_Stack[min_Stack.length - 1];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;21-栈的压入-弹出序列&#34;&gt;21. 栈的压入、弹出序列&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-20&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-21&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;解题思路构造一个辅助栈 stack 模拟出栈行为&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;入栈操作： 按照压栈序列的顺序执行&lt;/li&gt;
&lt;li&gt;出栈操作： 每次入栈后，循环判断 “栈顶元素 = 弹出序列的当前元素” 是否成立，将符合弹出序列顺序的栈顶元素全部弹出&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-复杂度与代码-21&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt; ： 其中 N 为列表 pushed 的长度；每个元素最多入栈与出栈一次，即最多共 2N 次出入栈操作。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(N)&lt;/strong&gt; ： 辅助栈 stack 最多同时存储 N 个元素。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var validateStackSequences = function(pushed, popped) {
  const stack = [];                 //辅助栈
  let index = 0,                    //指向popped当前的下标
      len = pushed.length;
  for (let i = 0; i &amp;lt; len; i++) {
    stack.push(pushed[i]);          //把pushed的元素一个一个入栈
    //把入栈的当前元素和pushed当前指向的元素进行对比 相等话就把辅助栈出栈 pushed下标往右移动
    while(stack.length &amp;amp;&amp;amp; stack[stack.length - 1] === popped[index]){
      stack.pop();
      index++;
    }                              
  }
  return !stack.length;             //如果stack为空，说明符合题目
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;22-从上往下打印二叉树&#34;&gt;22. 从上往下打印二叉树&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-21&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-22&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;层序遍历需要使用一个队列来存储有用的节点。整体的思路如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将 root 放入队列&lt;/li&gt;
&lt;li&gt;取出队首元素，将 val 放入返回的数组中&lt;/li&gt;
&lt;li&gt;检查队首元素的子节点，若不为空，则将子节点放入队列&lt;/li&gt;
&lt;li&gt;检查队列是否为空，为空，结束并返回数组；不为空，回到第二步&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-复杂度与代码-22&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt; ： N 为二叉树的节点数量，即 BFS 需循环 N 次。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(N)&lt;/strong&gt; ： 最差情况下，即当树为平衡二叉树时，最多有 N/2 个树节点同时在 queue 中，使用 O(N) 大小的额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function PrintFromTopToBottom(root)
{
  if(!root) return [];
  const res = [];
  const queue = [root];
  while(queue.length){
    const first = queue.shift();
    res.push(first.val);
    first.left &amp;amp;&amp;amp; queue.push(first.left);
    first.right &amp;amp;&amp;amp; queue.push(first.right);
  }
  return res;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;23-二叉搜索树的后序遍历序列&#34;&gt;23. 二叉搜索树的后序遍历序列&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-22&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。（ps：我们约定空树不是二叉搜索树）&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-23&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1625453305346.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在题目没有重复数字的前提下，二叉搜索树的左子树均小于根节点，右子树均大于根节点。&lt;br&gt;
判断二叉搜索树的后续遍历是否合法，只需判断右子树是否均大于根节点，左子树是否均小于根节点。&lt;br&gt;
显然对于每个节点的操作都是一样的(问题拆解成子问题))，所以使用递归来实现。&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-23&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N^2)&lt;/strong&gt;： 每次调用 递归函数 减去一个根节点，因此递归占用 O(N) ；最差情况下（即当树退化为链表），每轮递归都需遍历树所有节点，占用 O(N) 。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(N)&lt;/strong&gt; ： 最差情况下（即当树退化为链表），递归深度将达到 N 。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function VerifySquenceOfBST(postorder){
  if(!postorder || postorder.length === 0) return false;
    else return _VerifySquenceOfBST(postorder);
}
function _VerifySquenceOfBST(postorder){
  let len = postorder.length;
  if(len &amp;lt; 2) return true;          // 若为叶子节点，则返回 true
  let root = postorder[len - 1];    // 后序遍历的最后一个元素为根节点
  for(var i = 0; i &amp;lt; len - 1; i++){
    if(postorder[i] &amp;gt; root) break;  //postorder[0,i]为左子树   postorder[i,len-1]为右子树 
  }
  // 判断右子树中的元素是否都大于 root，此处用到 every (数组 API，数组的每个元素都返回 true 则整体返回 true)
  let result = postorder.slice(i, len - 1).every(item =&amp;gt; item &amp;gt; root);
  if(result){
    // 对左右子树进行递归调用,左右子树通过 i 进行分割
    return _VerifySquenceOfBST(postorder.slice(0, i)) &amp;amp;&amp;amp; _VerifySquenceOfBST(postorder.slice(i, len - 1));
  }else{
    return false;
  }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;24-二叉树中和为某一值的路径&#34;&gt;24. 二叉树中和为某一值的路径&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-23&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-24&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;先序遍历&lt;/strong&gt;： 按照 “根、左、右” 的顺序，遍历树的所有节点。&lt;br&gt;
&lt;strong&gt;路径记录&lt;/strong&gt;： 在先序遍历中，记录从根节点到当前节点的路径。当路径为 ① 根节点到叶节点形成的路径 且 ② 各节点值的和等于目标值 sum 时，将此路径加入结果列表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;递推参数&lt;/strong&gt;： 当前节点 root ，当前目标值 sum - root.val 。&lt;br&gt;
&lt;strong&gt;终止条件&lt;/strong&gt;： 若节点 root 为空，则直接返回。&lt;br&gt;
&lt;strong&gt;递推工作&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;路径更新： 将当前节点值 root.val 加入路径 tmp ；&lt;/li&gt;
&lt;li&gt;目标值更新： sum = sum - root.val（即目标值 从 sum 减至 0 ）；&lt;/li&gt;
&lt;li&gt;路径记录： 当 ① root 为叶节点 且 ② 路径和等于目标值 ，则将此路径 tmp[] 加入 res 。&lt;/li&gt;
&lt;li&gt;先序遍历： 递归左 / 右子节点。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-复杂度与代码-24&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt; ： N 为二叉树的节点数，先序遍历需要遍历所有节点。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(N)&lt;/strong&gt; ： 最差情况下，即树退化为链表时，tmp 存储所有树节点，使用 O(N) 额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var pathSum = function(root, sum) {
  if(!root) return [];
  const res = [];
  const dfs = (root, sum, tmp) =&amp;gt; {
    if(root.val === sum &amp;amp;&amp;amp; !root.left &amp;amp;&amp;amp; !root.right) res.push(tmp)  // 如果满足节点值等于目标值，且该节点为叶子节点时，添加结果
    tmp.push(root.val);
    if(root.left) dfs(root.left, sum - root.val, [...tmp]);
    if(root.right) dfs(root.right, sum - root.val, [...tmp]);
  }
  dfs(root, sum, []);
  return res;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;25-复杂链表的复制&#34;&gt;25. 复杂链表的复制&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-24&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）。 下图是一个含有5个结点的复杂链表。图中实线箭头表示next指针，虚线箭头表示random指针。为简单起见，指向null的指针没有画出。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1625465310051.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-25&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;利用哈希表的查询特点，考虑构建 原链表节点 和 新链表对应节点 的键值对映射关系，再遍历构建新链表各节点的 next 和 random 引用指向即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法流程：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若头节点 head 为空节点，直接返回 null ；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化&lt;/strong&gt;： 哈希表 dic ， 节点 cur 指向头节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;复制链表&lt;/strong&gt;：&lt;br&gt;
* 建立新节点，并向 dic 添加键值对 (原 cur 节点, 新 cur 节点） ；&lt;br&gt;
* cur 遍历至原链表下一节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;构建新链表的引用指向&lt;/strong&gt;：&lt;br&gt;
* 构建新节点的 next 和 random 引用指向；&lt;br&gt;
* cur 遍历至原链表下一节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;： 新链表的头节点 dic[cur] ；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-复杂度与代码-25&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt;： 两轮遍历链表，使用 O(N) 时间。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(N)&lt;/strong&gt; ： 哈希表 dic 使用线性大小的额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Clone(head)
{
 if(!head) return null;
  let m = new Map();
  let node = head;
  while(node){                         // 复制节点
    m.set(node, new RandomListNode(node.label));   // 构建源节点，新节点的键值对
    node = node.next;
  }
  node = head;
  while(node){
    m.get(node).next = node.next ? m.get(node.next) : null;
    m.get(node).random = node.random ? m.get(node.random) : null;
    node = node.next;
  }
  return m.get(head);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;26-二叉搜索树与双向链表&#34;&gt;26. 二叉搜索树与双向链表&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-25&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1625468801097.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-26&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;将 二叉搜索树 转换成一个 “排序的循环双向链表” ，其中包含两个要素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;排序链表&lt;/strong&gt;： 节点应从小到大排序，因此应使用 &lt;strong&gt;中序遍历&lt;/strong&gt; “从小到大”访问树的节点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;双向链表&lt;/strong&gt;： 在构建相邻节点的引用关系时，设前驱节点 pre 和当前节点 cur ，不仅应构建 pre.right = cur ，也应构建 cur.left = pre 。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-复杂度与代码-26&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt;： N 为二叉树的节点数，中序遍历需要访问所有节点。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(N)&lt;/strong&gt; ： 最差情况下，即树退化为链表时，递归深度达到 N，系统使用 O(N) 栈空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Convert(root)
{
  let pre = null;
  let head = null;
  dfs(root);
  function dfs(cur) {
    if(!cur) return null;
    dfs(cur.left);             // 中序遍历 左根右
    if(!pre) head = cur;       // 初始化head
    else pre.right = cur;      // 如果存在pre 向右添加 下一个节点
    cur.left = pre;            // 双向链表 向左添加前一个节点指针
    pre = cur;                 // pre next 向下继续 递归
    dfs(cur.right);
  };
  return head;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;27-字符串的排列&#34;&gt;27. 字符串的排列&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-26&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-27&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;首先给定一个字符串，这个字符串里每一个字符是构成排列的元素之一，我们的回溯代码里，选择和回退就确定了是这每个字符。&lt;br&gt;
给定的字符串有几个字符，那么我们的结束条件就应该是当前选择的字符串的字符数量等于给定的字符串的数量。&lt;br&gt;
由于要求不能有重复元素，我们还需要过滤剪枝掉可能会重复的选择，这里由于给定的字符串里面可能也会包含重复的字符，那么我们用字符串来是否出现过这个字符来判断显然是不合理的，参考我们上一道题单词搜索，我们可以采用一个bool数组来记录是否访问过。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1625538744355.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-27&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N!N)&lt;/strong&gt; ： N 为字符串 s 的长度；时间复杂度和字符串排列的方案数成线性关系，方案数为 N×(N−1)×(N−2)…×2×1 ，即复杂度为 O(N!) ；字符串拼接操作 join() 使用 O(N) ；因此总体时间复杂度为 O(N!N) 。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(N^2)&lt;/strong&gt; ： 全排列的递归深度为 N ，系统累计使用栈空间大小为 O(N) ；递归中辅助 Set 累计存储的字符数量最多为 N+(N−1)+...+2+1=(N+1)N/2 ，即占用 O(N^2) 的额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Permutation(str)
{
  const res = new Set();
  const visit = [];
  function dfs(path){
    if (path.length === str.length) return res.add(path);     //结束条件，如果当前选择字符串和题目给定字符串的长度一致则结束。
    for(let i = 0; i &amp;lt; str.length; i++){
      if(visit[i]) continue;       //过滤掉已经选择的。
      visit[i] = true;             //做出选择
      dfs(path + str[i]);          // 进入下一层， 需要注意path这里也是做了选择和回退选择，因为是直接path + chars[i]，等递归结束之后path还是path，默认也就做了回退，比较取巧。
      visit[i] = false;            //回退选择
    }
  }
  dfs(&#39;&#39;);
  return [...res]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;28-数组中出现次数超过一半的数字&#34;&gt;28. 数组中出现次数超过一半的数字&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-27&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。你可以假设数组是非空的，并且给定的数组总是存在多数元素。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-28&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;想象一下，假如数组是一个投票箱，数组元素是一张写了选举人编号的一张选票。&lt;br&gt;
题目要求我们找出哪个数字，超过了数组的一半！&lt;br&gt;
是否就可以想象为，哪个人成为了最终选举的胜利者呢？&lt;br&gt;
那么，接下来我们要做的事情，就是找到票数最多的那个人的编号即可。&lt;/p&gt;
&lt;p&gt;经过以上实例分析，我们可以得出 3 个要点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不同候选人的选票之间，可以一一抵消。&lt;/li&gt;
&lt;li&gt;若当前胜利者存在多张选票时，不同的候选人的票，只能抵消一张当前胜利者的票。&lt;/li&gt;
&lt;li&gt;若当前双方的选票被抵消为零，下一次抽出的候选人，将作为暂时的胜利者领先。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-复杂度与代码-28&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt; ： N 为数组 nums 长度。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(1)&lt;/strong&gt; ： count 变量使用常数大小的额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function MoreThanHalfNum_Solution(nums)
{
  let ans = 0, count = 0;
  for(let i = 0; i &amp;lt; nums.length; i++){
    if(!count){
      ans = nums[i];
      count++;
    }else{
      count += nums[i] === ans ? 1 : -1;
    }
  }
  return ans;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;28_番外-回文链表&#34;&gt;28_番外.  回文链表&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-28&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;请判断一个链表是否为回文链表。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-29&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;快慢指针，起初都指向表头，快指针一次走两步，慢指针一次走一步，遍历结束时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要么，slow 正好指向中间两个结点的后一个。&lt;/li&gt;
&lt;li&gt;要么，slow 正好指向中间结点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用 prev 保存 slow 的前一个结点，通过prev.next = null断成两个链表。&lt;/p&gt;
&lt;p&gt;将后半段链表翻转，和前半段从头比对。空间复杂度降为O(1)。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1625707829215.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;如何翻转单链表&lt;/strong&gt;&lt;br&gt;
可以这么思考：一次迭代中，有哪些指针需要变动：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个结点的 next 指针要变动。&lt;/li&gt;
&lt;li&gt;指向表头的 slow 指针要变动。&lt;/li&gt;
&lt;li&gt;需要有指向新链表表头的 head2 指针，它也要变。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1625707850174.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;3-复杂度与代码-29&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度O(N)&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;空间复杂度O(1)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const isPalindrome = (head) =&amp;gt; {
  if (head == null || head.next == null) {
    return true;
  }
  let fast = head;
  let slow = head;
  let prev;
  while (fast &amp;amp;&amp;amp; fast.next) {
    prev = slow;
    slow = slow.next;
    fast = fast.next.next;
  }
  prev.next = null;  // 断成两个链表
  // 翻转后半段
  let head2 = null;
  while (slow) {
    const tmp = slow.next;
    slow.next = head2;
    head2 = slow;
    slow = tmp;
  }
  // 比对
  while (head &amp;amp;&amp;amp; head2) {
    if (head.val != head2.val) {
      return false;
    }
    head = head.next;
    head2 = head2.next;
  }
  return true;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;29-最小的k个数&#34;&gt;29. 最小的K个数&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-29&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;给定一个数组，找出其中最小的K个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。如果K&amp;gt;数组的长度，那么返回一个空的数组&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-30&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;题目只要求返回最小的 k 个数，对这 k 个数的顺序并没有要求。因此，只需要将数组划分为 &lt;strong&gt;最小的 k 个数&lt;/strong&gt; 和 &lt;strong&gt;其他数字&lt;/strong&gt; 两部分即可，而快速排序的哨兵划分可完成此目标。&lt;/p&gt;
&lt;p&gt;根据快速排序原理，如果某次哨兵划分后 &lt;strong&gt;基准数正好是第 k+1k+1 小的数字&lt;/strong&gt; ，那么此时基准数左边的所有数字便是题目所求的 &lt;strong&gt;最小的 k 个数&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;根据此思路，考虑在每次哨兵划分后，判断基准数在数组中的索引是否等于 kk ，若 truetrue 则直接返回此时数组的前 kk 个数字即可。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1625713224386.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1625713229853.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;哨兵划分：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;划分完毕后，基准数为 arr[i] ，左 / 右子数组区间分别为 [l, i - 1] , [i + 1, r]；&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;递归或返回：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;若 k &amp;lt; i ，代表第 k + 1 小的数字在 &lt;strong&gt;左子数组&lt;/strong&gt; 中，则递归左子数组；&lt;/li&gt;
&lt;li&gt;若 k &amp;gt; i ，代表第 k + 1 小的数字在 &lt;strong&gt;右子数组&lt;/strong&gt; 中，则递归右子数组；&lt;/li&gt;
&lt;li&gt;若 k = i ，代表此时 arr[k] 即为第 k + 1 小的数字，则直接返回数组前 k 个数字即可；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1625713286563.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-复杂度与代码-30&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt; ： 其中 N 为数组元素数量；对于长度为 N 的数组执行哨兵划分操作的时间复杂度为 O(N)&lt;br&gt;
&lt;strong&gt;空间复杂度 O(logN)&lt;/strong&gt; ： 划分函数的平均递归深度为 O(logN) 。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function GetLeastNumbers_Solution(input, k){
    if(input.length == 0 || k &amp;gt; input.length) return [];
    quickSort(input, 0, input.length - 1);
    return input.slice(0, k);
}
function quickSort(input, left, right){
    if(left &amp;gt;= right) return;
    let i = left, j = right;
    while(i &amp;lt; j){
        while(i &amp;lt; j &amp;amp;&amp;amp; input[j] &amp;gt;= input[left]) j--;
        while(i &amp;lt; j &amp;amp;&amp;amp; input[i] &amp;lt;= input[left]) i++;
        [input[i], input[j]] = [input[j], input[i]];          // 根据基准交换大小，左小右大
    }
    [input[left], input[i]] = [input[i], input[left]];        //交换基准
    quickSort(input, left, i-1);
    quickSort(input, i+1, right);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;30-连续子数组的最大和&#34;&gt;30. 连续子数组的最大和&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-30&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n).&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-31&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1625727249997.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1625727254778.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-31&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt; ： 线性遍历数组 nums 即可获得结果，使用 O(N) 时间。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(1)&lt;/strong&gt; ： 使用常数大小的额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var maxSubArray = function(nums) {
  let res = nums[0];
  for(let i = 1; i &amp;lt; nums.length; i++){
    nums[i] = Math.max(0, nums[i - 1]) + nums[i];
    res = Math.max(res, nums[i]);
  } 
  return res;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;31-整数中1出现的次数&#34;&gt;31.  整数中1出现的次数&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-31&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-32&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1626080722601.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;3-复杂度与代码-32&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;**时间复杂度 O(logn) **： 循环内的计算操作使用 O(1) 时间；循环次数为数字 n 的位数，即 log10^n ，因此循环使用 O(logn) 时间。&lt;br&gt;
**空间复杂度 O(1) **： 几个变量使用常数大小的额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var countDigitOne = function(n) {
  let count = 0;
  for (let i = 1; i &amp;lt;= n; i *= 10) {
      let divide = i * 10;
      let p = Math.floor(n / divide), k = n % divide, rest = 0;
      count += p * i;
      rest = (k &amp;gt; (2 * i - 1)) ? i : ((k &amp;lt; i) ? 0 : k - i + 1);
      count += rest;
  }
  return count;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;32-把数组排成最小的数&#34;&gt;32. 把数组排成最小的数&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-32&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-33&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;此题求拼接起来的最小数字，本质上是一个排序问题。设数组 nums 中任意两数字的字符串为 x 和 y ，则规定 &lt;strong&gt;排序判断规则&lt;/strong&gt; 为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若拼接字符串 x + y &amp;gt; y + x ，则 x 大于”y ；&lt;/li&gt;
&lt;li&gt;反之，若 x + y &amp;lt; y + x ，则 x“小于”y ；&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1626082655702.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;3-复杂度与代码-33&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度是O(NlogN)&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;空间复杂度是O(1)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var minNumber = function(numbers) {
  numbers.sort((a, b) =&amp;gt; {
      const s1 = a + &amp;quot;&amp;quot; + b;
      const s2 = b + &amp;quot;&amp;quot; + a;
      if (s1 &amp;lt; s2) return -1;   // 表示 &#39;ab&#39; &amp;lt; &#39;ba&#39;，即 a &amp;lt; b ，a 在 b 前边
      if (s1 &amp;gt; s2) return 1;    // 表示 &#39;ab&#39; &amp;gt; &#39;ba&#39;，即 a &amp;gt; b ，a 在 b 后边
      return 0;
  });
  return numbers.join(&amp;quot;&amp;quot;);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;33-丑数&#34;&gt;33. 丑数&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-33&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;把只包含质因子2、3和5的数称作丑数（Ugly Number）。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-34&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;设置3个索引a, b, c，分别记录前几个数已经被乘2， 乘3， 乘5了，比如a表示前(a-1)个数都已经乘过一次2了，下次应该乘2的是第a个数；b表示前(b-1)个数都已经乘过一次3了，下次应该乘3的是第b个数；c表示前(c-1)个数都已经乘过一次5了，下次应该乘5的是第c个数；&lt;/p&gt;
&lt;p&gt;对于某个状态下的丑数序列，我们知道此时第a个数还没有乘2(有没有乘3或者乘5不知道）， 第b个数还没有乘3(有没有乘2或者乘5不知道），第c个数还没有乘5(有没有乘2或者乘3不知道), 下一个丑数一定是从第a丑数乘2， 第b个数乘3， 第c个数乘5中获得，他们三者最小的那个就是下个丑数。&lt;/p&gt;
&lt;p&gt;求得下个丑数后就得判断这个丑数是谁，是某个数通过乘2得到的，还是某个数乘3得到的，又或是说某个数通过乘5得到的。我们可以比较一下这个新的丑数等于究竟是等于第a个丑数乘2, 还是第b个数乘3， 还是第c个数乘5， 通过比较我们肯定可以知道这个新的丑数到底是哪个数通过乘哪个数得到的。假设这个新的丑数是通过第a个数乘2得到的，说明此时第a个数已经通过乘2得到了一个新的丑数，那下个通过乘2得到一个新的丑数的数应该是第(a+1)个数，此时我们可以说前 a 个数都已经乘过一次2了，下次应该乘2的是第 （a+1） 个数, 所以a++；如果新的丑数是通过第b个数乘3得到的, 说明此时第 b个数已经通过乘3得到了一个新的丑数，那下个需要通过乘3得到一个新的丑数的数应该是第(b+1)个数，此时我们可以说前 b 个数都已经乘过一次3了，下次应该乘3的是第 （b+1） 个数, 所以 b++；同理，如果这个这个新的丑数是通过第c个数乘5得到的, 那么c++;&lt;/p&gt;
&lt;p&gt;但是注意，如果第a个数乘2后等于第b个数乘3，或者等于第c个数乘5， 说明这个新的丑数是有两种或者三种方式可以得到，这时应该给得到这个新丑数的组合对应的索引都加一，比如新丑数是第a个数乘2后和第b个数乘3得到的，那么 a 和 b都应该加一， 因为此时第a个数已经通过乘2得到了一个新的丑数，第b个数已经通过乘3得到了一个新的丑数, 只不过这两个数相等而已。所以我们给计数器加一的时候不能使用 if else else if， 而应该使用if, if, if, 这样才不会把应该加一的计数器漏掉&lt;/p&gt;
&lt;p&gt;经过n次循环，就能得到第n 个丑数了。&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-34&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt;： 其中 N=n ，动态规划需遍历计算 dp 列表。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(N)&lt;/strong&gt; ： 长度为 N 的 dp 列表使用 O(N) 的额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function GetUglyNumber_Solution(n){
  if(n === 0) return 0;
  const dp = new Array(n);             // 使用dp数组来存储丑数序列
  dp[0] = 1;                           // dp[0]已知为1
  let pt2 = 0, pt3 = 0, pt5 = 0;       // 下个应该通过乘2来获得新丑数的数据
  for(let i = 1; i &amp;lt; n; i++){
    dp[i] = Math.min(dp[pt2] * 2, dp[pt3] * 3, dp[pt5] * 5);
    if(dp[i] === dp[pt2] * 2) pt2++;   // 第pt2个数已经通过乘2得到了一个新的丑数，那下个需要通过乘2得到一个新的丑数的数应该是第(pt2+1)个数
    if(dp[i] === dp[pt3] * 3) pt3++;
    if(dp[i] === dp[pt5] * 5) pt5++;
  }
  return dp[n - 1];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;34-第一个只出现一次的字符&#34;&gt;34. 第一个只出现一次的字符&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-34&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;在一个字符串(0&amp;lt;=字符串长度&amp;lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-35&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;遍历字符串，通过 indexOf 和 lastindexOf 获取字符第一次和最后一次出现的位置，如果不同则说明该字符在字符串中出现次数不唯一，如果相同则说明该字符只出现一次。&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-35&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;**时间复杂度 O(N^2) **： N 为字符串 s 的长度；需遍历 s 两轮，使用 O(N) ；indexOf 查找操作的复杂度为 O(N)；&lt;br&gt;
&lt;strong&gt;空间复杂度 O(1)&lt;/strong&gt; ： 由于题目指出 s 只包含小写字母，因此最多有 26 个不同字符，HashMap 存储需占用 O(26)=O(1) 的额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function FirstNotRepeatingChar(str){
  for(let i=0;i&amp;lt;str.length;i++){
    if(str.indexOf(str[i]) === str.lastIndexOf(str[i])){
        return i;
    }
  }
  return -1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;35-数组中的逆序对&#34;&gt;35. 数组中的逆序对&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-35&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-36&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;说明：理解这个算法需要对「归并排序」比较熟悉。掌握如果编写递归函数，每一次都一分为二拆分数组的子区间，然后在方法栈弹出的时候，一步一步合并两个有序数组，最后完成排序工作。&lt;/p&gt;
&lt;p&gt;而计算逆序数就发生在排序的过程中，利用了「排序」以后数组的有序性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用「归并排序」计算逆序对，是非常经典的做法；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关键在于「合并两个有序数组」的步骤，利用数组的部分有序性&lt;/strong&gt;，一下子计算出一个数之前或者之后元素的逆序的个数；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;前面「分」的时候什么都不做，「合」的过程中计算「逆序对」的个数&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;「排序」的工作是必要的，正是因为「排序」才能在下一轮利用顺序关系加快逆序数的计算，也能避免重复计算；&lt;/li&gt;
&lt;li&gt;在代码实现上，只需要在「归并排序」代码的基础上，加上「逆序对」个数的计算，计算公式需要自己在草稿纸上推导。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;思想是「分治算法」，所有的「逆序对」来源于 3 个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左边区间的逆序对；&lt;/li&gt;
&lt;li&gt;右边区间的逆序对；&lt;/li&gt;
&lt;li&gt;横跨两个区间的逆序对。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1626266797275.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;3-复杂度与代码-36&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;时间复杂度：O(NlogN)，这里 N 是数组的长度。复杂度是归并排序的时间复杂度，直接看递归树的结点个数或者使用主定理分析，归并的回收每一步计算逆序对的个数是 O(1) 的；&lt;br&gt;
空间复杂度：O(N)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function InversePairs(nums) {
  let sum = 0;            // 定义变量存储逆序对的数量
  mergeSort(nums);        // 归并排序的返回结果赋值给sum
  return sum % 1000000007;
  // 归并排序函数(分)
  function mergeSort (nums) {
    if(nums.length &amp;lt; 2) return nums;                        // 一个元素的时候，我们返回这个数组，即递归的结束条件
    let mid = Math.floor(nums.length / 2);                  // 如果数组的长度不小于2，说明还没有分彻底 ，下面继续分
    let left = nums.slice(0, mid);                          // 左边的子数组
    let right = nums.slice(mid);                            // 右边的子数组
    return merge(mergeSort(left), mergeSort(right));    // 将拆分好的左右子数组投入到合并函数中
  }
  // 合并函数（用户将拆分好的子数组进行合并）
  function merge(left, right) {
    const res = [];                   // 定义一个存储合并排好顺序的总数组（包含左右子数组的）
    const leftLen = left.length;
    const rightLen = right.length;
    // 开始循环遍历，是以res的下标为基础进行遍历的(i是左子数组的下标，j是右子树组的下标，index是res的下标)
    for(let i = 0, j = 0, index = 0; index &amp;lt; leftLen + rightLen; index++) {
      if(i &amp;gt;= leftLen) res.push(right[j++]); // 如果i越界说明，左子数组已经遍历完，此时res直接添加右子数组的下标指向的元素即可
      else if(j &amp;gt;= rightLen) res.push(left[i++]); // 如果j越界，说明右子数组已经遍历完了，此时res直接添加左子数组下标指向的元素即可
      else if(left[i] &amp;lt;= right[j]) res.push(left[i++]);  // 如果左子数组下标指向的元素小于等于右子数组下标指向的元素，此时不存在逆序对，将左子数组对应的结果加到res数组即可
      else {
        res.push(right[j++]); // 如果左子数组下标指向的元素大于右子数组下标指向的元素，此时是存在逆序对的
        sum += leftLen - i;
      }
    }
    return res; 
  }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;36-两个链表的第一个公共结点&#34;&gt;36. 两个链表的第一个公共结点&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-36&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;输入两个无环的单链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-37&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;我们使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。&lt;/p&gt;
&lt;p&gt;这样，当它们相遇时，所指向的结点就是第一个公共结点。&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-37&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;：O(M+N)。&lt;br&gt;
&lt;strong&gt;空间复杂度&lt;/strong&gt;：O(1)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function FindFirstCommonNode(pHead1, pHead2)
{
    let h1 = pHead1;
    let h2 = pHead2;
    while(h1 !== h2){
      h1 = h1 === null ? pHead2 : h1.next;
      h2 = h2 === null ? pHead1 : h2.next;
    }
    return h1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;37-数字在升序数组中出现的次数&#34;&gt;37. 数字在升序数组中出现的次数&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-37&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;统计一个数字在升序数组中出现的次数。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-38&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;显然是利用二分查找。因为有序，所以目标值target如果有多个，肯定是连在一起。又已知我们可以在有序数组中查找任意一个值，因此我们可以先查找目标范围的下界和上界。&lt;br&gt;
下界定义为：如果存在目标值，则指向第一个目标值，否则，如果不存在， 则指向大于目标值的第一个值。&lt;br&gt;
上界定义为：不管目标值存在与否，都指向大于目标值的第一个值。&lt;br&gt;
如下图所示：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626271708852.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626271712155.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
最后的结果就是：right - left&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-38&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度O(logN)&lt;/strong&gt;,&lt;br&gt;
&lt;strong&gt;空间复杂度 O(1)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function GetNumberOfK(data, k)
{
  if(!data.length) return 0;
  let left = 0, right = data.length - 1;
  while(left &amp;lt; right){
    let mid = Math.floor((left + right) / 2);
    if(data[mid] &amp;gt;= k) right = mid;
    else left = mid + 1;
  }
  while(data[right] === k) right++;
  return right - left;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;38-二叉树的深度&#34;&gt;38. 二叉树的深度&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-38&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-39&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;树的后序遍历 / 深度优先搜索往往利用 &lt;strong&gt;递归&lt;/strong&gt; 或 &lt;strong&gt;栈&lt;/strong&gt; 实现，本文使用递归实现。&lt;br&gt;
&lt;strong&gt;关键点：&lt;/strong&gt; 此树的深度和其左（右）子树的深度之间的关系。显然，&lt;strong&gt;此树的深度&lt;/strong&gt; 等于 &lt;strong&gt;左子树的深度&lt;/strong&gt; 与** 右子树的深度** 中的 最大值 &lt;strong&gt;+1&lt;/strong&gt; 。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626271942911.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-39&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt; ： N 为树的节点数量，计算树的深度需要遍历所有节点。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(N)&lt;/strong&gt; ： 最差情况下（当树退化为链表时），递归深度可达到 N 。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function TreeDepth(pRoot){
  return pRoot === null ? 0 : Math.max(TreeDepth(pRoot.left),TreeDepth(pRoot.right)) + 1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;39-平衡二叉树&#34;&gt;39. 平衡二叉树&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-39&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;输入一棵二叉树，判断该二叉树是否是平衡二叉树。&lt;br&gt;
在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树&lt;br&gt;
平衡二叉树（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-40&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;思路是对二叉树做后序遍历，从底至顶返回子树深度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法流程&lt;/strong&gt;：&lt;br&gt;
&lt;strong&gt;recur(root) 函数&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回值：
&lt;ol&gt;
&lt;li&gt;当节点root 左 / 右子树的深度差 ≤1 ：则返回当前子树的深度，即节点 root 的左 / 右子树的深度最大值 +1 （ max(left, right) + 1 ）；&lt;/li&gt;
&lt;li&gt;当节点root 左 / 右子树的深度差 &amp;gt; 2 ：则返回 -1，代表 &lt;strong&gt;此子树不是平衡树&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;终止条件：
&lt;ol&gt;
&lt;li&gt;当 root 为空：说明越过叶节点，因此返回高度 0 ；&lt;/li&gt;
&lt;li&gt;当左（右）子树深度为 -1 ：代表此树的 &lt;strong&gt;左（右）子树&lt;/strong&gt; 不是平衡树，因此&lt;code&gt;剪枝&lt;/code&gt;，直接返回 -1；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;isBalanced(root) 函数&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;： 若 recur(root) != -1 ，则说明此树平衡，返回 true ； 否则返回 false 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-复杂度与代码-40&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt;： N 为树的节点数；最差情况下，需要递归遍历树的所有节点。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(N)&lt;/strong&gt;： 最差情况下（树退化为链表时），系统递归需要使用 O(N) 的栈空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var isBalanced = function(root) {
  return recur(root) != -1;
};

const recur = root =&amp;gt; {
  if(root === null) return 0;
  let left = recur(root.left);
  let right = recur(root.right);
  if(left === -1) return -1;
  if(right === -1) return -1;
  return Math.abs(left - right) &amp;lt; 2 ? Math.max(left, right) + 1 : -1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;40-数组中只出现一次的两个数字&#34;&gt;40. 数组中只出现一次的两个数字&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-40&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-41&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;遍历 numsnums 执行异或&lt;/strong&gt;：&lt;br&gt;
设整型数组 nums = [a, a, b, b, ..., x, y] ，对 nums 中所有数字执行异或，得到的结果为 x⊕y&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;循环左移计算 m&lt;/strong&gt; ：&lt;br&gt;
初始化一个辅助变量 m = 1 ，通过与运算从右向左循环判断，可 &lt;strong&gt;获取整数 x⊕y 首位 1&lt;/strong&gt; ，记录于 m 中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拆分 nums 为两个子数组&lt;/strong&gt;：&lt;br&gt;
通过遍历判断 nums 中各数字和 m 做与运算的结果，可将数组拆分为两个子数组，并分别对两个子数组遍历求异或，则可得到两个只出现一次的数字&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分别遍历两个子数组执行异或&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626328358988.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-复杂度与代码-41&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;//因为相同的数字异或为0，任何数字与0异或结果是其本身。
//所以遍历异或整个数组最后得到的结果就是两个只出现一次的数字异或的结果：即 z = x ^ y
//我们根据异或的性质可以知道：z中至少有一位是1，否则x与y就是相等的。
//我们通过一个辅助变量m来保存z中哪一位为1.（可能有多个位都为1，我们找到最低位的1即可）。
//举个例子：z = 10 ^ 2 = 1010 ^ 0010 = 1000,第四位为1.
//我们将m初始化为1，如果（z &amp;amp; m）的结果等于0说明z的最低为是0
//我们每次将m左移一位然后跟z做与操作，直到结果不为0.
//此时m应该等于1000，同z一样，第四位为1.
//我们遍历数组，将每个数跟m进行与操作，结果为0的作为一组，结果不为0的作为一组
//例如对于数组：[1,2,10,4,1,4,3,3]，我们把每个数字跟1000做与操作，可以分为下面两组：
//nums1存放结果为0的: [1, 2, 4, 1, 4, 3, 3]
//nums2存放结果不为0的: [10] (碰巧nums2中只有一个10，如果原数组中的数字再大一些就不会这样了)
//此时我们发现问题已经退化为数组中有一个数字只出现了一次
//分别对nums1和nums2遍历异或就能得到我们预期的x和y
function FindNumsAppearOnce( nums ) {
  let x = 0, y = 0, z = 0, m = 1;
  for(let num of nums) z ^= num;
  while((z &amp;amp; m) === 0) m &amp;lt;&amp;lt;= 1;
  for(let num of nums) {
    if((num &amp;amp; m) != 0) x ^= num;
    else y ^= num;
  }
  return x &amp;gt; y ? [y, x] : [x, y]
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;41-和为s的连续正数序列&#34;&gt;41. 和为S的连续正数序列&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-41&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列?&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-42&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;什么是滑动窗口？&lt;/strong&gt;&lt;br&gt;
顾名思义，首先是一个窗口，既然是一个窗口，就需要用窗口的左边界i和右边界j来唯一表示一个窗口，其次，滑动代表，窗口始终从左往右移动，这也表明左边界i和右边界j始终会往后移动，而不会往左移动。&lt;br&gt;
这里我用左闭右开区间来表示一个窗口。比如&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626331149464.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;滑动窗口的操作&lt;/strong&gt;&lt;br&gt;
扩大窗口，j += 1&lt;br&gt;
缩小窗口，i += 1&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;算法步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化，i=1,j=1, 表示窗口大小为0&lt;/li&gt;
&lt;li&gt;如果窗口中值的和小于目标值sum， 表示需要扩大窗口，j += 1&lt;/li&gt;
&lt;li&gt;否则，如果狂口值和大于目标值sum，表示需要缩小窗口，i += 1&lt;/li&gt;
&lt;li&gt;否则，等于目标值，存结果，缩小窗口，继续进行步骤2,3,4&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-复杂度与代码-42&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;：O(N)&lt;br&gt;
&lt;strong&gt;空间复杂度&lt;/strong&gt;：O(1)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function FindContinuousSequence(sum) {
  let l = 1, r = 1;
  let res = [];
  let tmp = 0;
  while(l &amp;lt; sum / 2) {
    if(tmp &amp;lt; sum){
      tmp += r;                //如果窗口中值的和小于目标值sum， 表示需要扩大窗口，j += 1
      r++                      //扩大窗口，j += 1
    }else if(tmp &amp;gt; sum) {
      tmp -= l;                //否则，如果窗口值和大于目标值sum，表示需要缩小窗口，i += 1
      l++;                     //缩小窗口，i += 1
    }else{
      let ans = [];
      for(let i = l; i &amp;lt; r; i++) ans.push(i);
      res.push(ans);
      tmp -= l;                //否则，等于目标值，存结果，缩小窗口，继续进行步骤
      ++l;
    }
  }
  return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;42-和为s的两个数字&#34;&gt;42. 和为S的两个数字&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-42&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，返回两个数的乘积最小的，如果无法找出这样的数字，返回一个空数组即可。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-43&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;既然是递增数组，那么我们可以利用双指针来做这道题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;指针 i 指向数组首位数字，指针 j 指向数组末位数字。&lt;/li&gt;
&lt;li&gt;若两数字之和大于了 target，则指针 j 往左移一位。&lt;/li&gt;
&lt;li&gt;若两数字之和小于了 target，则指针 i 往右移一位。&lt;/li&gt;
&lt;li&gt;若两数字之和等于了 target，返回结果 [i, j] 即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-复杂度与代码-43&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N&lt;/strong&gt;)： N 为数组 nums 的长度；双指针共同线性遍历整个数组。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(1)&lt;/strong&gt;： 变量 i, j 使用常数大小的额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function FindNumbersWithSum(nums, target){
  let l = 0, r = nums.length - 1;
  while(l &amp;lt; r){
      if(nums[l] + nums[r] === target) return [nums[l], nums[r]];
      else if (nums[l] + nums[r] &amp;gt; target) r--;
      else l++;
  }
  return [];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;43-左旋转字符串&#34;&gt;43. 左旋转字符串&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-43&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列 S，请你把其循环左移 K 位后的序列输出（保证 K 小于等于 S 的长度）。例如，字符序列S=”abcXYZdef”,要求输出循环左移 3 位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-44&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;应用字符串切片函数，可方便实现左旋转字符串。&lt;br&gt;
获取字符串 s[n:] 切片和 s[:n] 切片，使用 &amp;quot;+&amp;quot; 运算符拼接并返回即可。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626333828951.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-44&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt; ： 其中 N 为字符串 s 的长度，字符串切片函数为线性时间复杂度；&lt;br&gt;
&lt;strong&gt;空间复杂度 O(N)&lt;/strong&gt;： 两个字符串切片的总长度为 N 。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function LeftRotateString(str, n){
  return str ? str.slice(n) + str.slice(0,n) : &#39;&#39;   
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;44-翻转单词序列&#34;&gt;44. 翻转单词序列&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-44&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“nowcoder. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a nowcoder.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-45&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;我们发现其实不需要两次反转，一次就够了，还是以&amp;quot; hello world! &amp;quot;为例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据清理， 即将左右空格去掉， 变为&amp;quot;hello world!&amp;quot;&lt;/li&gt;
&lt;li&gt;按空格拆分单词，变为&amp;quot; [&amp;quot;hello&amp;quot;, &amp;quot;world!&amp;quot;]&lt;/li&gt;
&lt;li&gt;单词列表执行一次反转，变为 [world!&amp;quot;, &amp;quot;hello&amp;quot;]&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-复杂度与代码-45&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;：O(N)&lt;br&gt;
&lt;strong&gt;空间复杂度&lt;/strong&gt;：O(N)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function ReverseSentence(s){
    return s.split(&#39; &#39;).filter(item =&amp;gt; item !== &#39;&#39;).reverse().join(&#39; &#39;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;45-扑克牌顺子&#34;&gt;45. 扑克牌顺子&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-45&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-46&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;根据题意，此 5 张牌是顺子的 &lt;strong&gt;充分条件&lt;/strong&gt; 如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;除大小王外，所有牌 无重复 ；&lt;/li&gt;
&lt;li&gt;设此 5 张牌中最大的牌为 max ，最小的牌为 min （大小王除外），则需满足：&lt;br&gt;
max - min &amp;lt; 5&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626336802028.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;集合 Set + 遍历&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;遍历五张牌，遇到大小王（即 0 ）直接跳过。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;判别重复&lt;/strong&gt;： 利用 Set 实现遍历判重， Set 的查找方法的时间复杂度为 O(1)；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;获取最大 / 最小的牌&lt;/strong&gt;： 借助辅助变量 max 和 min ，遍历统计即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-复杂度与代码-46&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt; = O(5) = O(1)： 其中 N 为 nums 长度，本题中 N≡5 ；遍历数组使用 O(N)时间。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(N)&lt;/strong&gt; = O(5) = O(1)： 用于判重的辅助 Set 使用 O(N) 额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var isStraight = function(nums) {
  const set = new Set();
  let min = 14, max = 0;            // min和max的初始值是两个边界值[0, 13]
  for(const num of nums){
    if(!num) continue               // 遇到大小王 跳过
    if(set.has(num)) return false;  // 遇到重复则直接 返回false
    set.add(num);
    min = Math.min(min, num);
    max = Math.max(max, num);
  }
  return max - min &amp;lt; 5;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;46-圆圈中最后剩下的数字&#34;&gt;46. 圆圈中最后剩下的数字&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-46&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-47&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1626340197825.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
总结一下反推的过程，就是 (当前index + m) % 上一轮剩余数字的个数。&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-47&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(n)&lt;/strong&gt; ： 状态转移循环 n - 1 次使用 O(n) 时间，状态转移方程计算使用 O(1) 时间；&lt;br&gt;
&lt;strong&gt;空间复杂度 O(1)&lt;/strong&gt; ： 使用常数大小的额外空间；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function LastRemaining_Solution(n, m){
    let ans = 0;
    for(let i = 2; i &amp;lt;= n; i++){
      ans = (ans + m) % i;
    }
    return ans;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;47-求123n&#34;&gt;47. 求1+2+3+...+n&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-47&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-48&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1626344611159.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
本题需要实现 “&lt;strong&gt;当 n = 1 时终止递归&lt;/strong&gt;” 的需求，可通过短路效应实现。&lt;br&gt;
n &amp;gt; 1 &amp;amp;&amp;amp; sumNums(n - 1) // 当 n = 1 时 n &amp;gt; 1 不成立 ，此时 “短路” ，终止后续递归&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-48&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(n)&lt;/strong&gt; ： 计算 n + (n-1) + ... + 2 + 1 需要开启 n 个递归函数。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(n)&lt;/strong&gt; ： 递归深度达到 n ，系统使用 O(n) 大小的额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Sum_Solution(n){
    return n &amp;amp;&amp;amp; Sum_Solution(n - 1) + n;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;47-不用加减乘除做加法&#34;&gt;47. 不用加减乘除做加法&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-48&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-49&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;观察发现，&lt;strong&gt;无进位和&lt;/strong&gt; 与 &lt;strong&gt;异或运算&lt;/strong&gt; 规律相同，&lt;strong&gt;进位&lt;/strong&gt; 和 &lt;strong&gt;与运算&lt;/strong&gt; 规律相同（并需左移一位）。因此，无进位和 n 与进位 c 的计算公式如下；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626353011855.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626353020936.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-49&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(1)&lt;/strong&gt; ： 最差情况下（例如 a = 0x7fffffff , b = 1 时），需循环 32 次，使用 O(1) 时间；每轮中的常数次位操作使用 O(1)时间。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(1)&lt;/strong&gt;： 使用常数大小的额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Add(num1, num2){
    while(num2){
      let c = (num1 &amp;amp; num2) &amp;lt;&amp;lt; 1;     // c = 进位
      num1 ^= num2;                   // num1 = 非进位和
      num2 = c;                       // num2 = 进位
    }
    return num1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;48-把字符串转换成整数&#34;&gt;48. 把字符串转换成整数&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-49&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-50&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1626354461073.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;3-复杂度与代码-50&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt; ： 其中 N 为字符串长度，线性遍历字符串占用 O(N) 时间。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(N)&lt;/strong&gt; ： 删除首尾空格后需建立新字符串，最差情况下占用 O(N) 额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function StrToInt(str){
    let reg =/^(\-|\+)?\d+?$/
    return reg.test(str)?Number(str):0
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;47-数组中重复的数字&#34;&gt;47. 数组中重复的数字&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-50&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任一一个重复的数字。 例如，如果输入长度为7的数组[2,3,1,0,2,5,3]，那么对应的输出是2或者3。存在不合法的输入的话输出-1&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-51&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;通过题意，我们可以使用哈希表来实现，分析如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;遍历数组，若当前数字不存在与哈希表，则添加到哈希表即可。&lt;/li&gt;
&lt;li&gt;若当前数字哈希表中已存在，则返回结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-复杂度与代码-51&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt; ： 遍历数组使用 O(N) ，HashSet 添加与查找元素皆为 O(1) 。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(N)&lt;/strong&gt; ： HashSet 占用 O(N) 大小的额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function duplicate( nums ) {
  let map = new Map();
  for(let i of nums){
    if(map.has(i)) return i;
    map.set(i, 1);
  }
  return -1;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;51-构建乘积数组&#34;&gt;51. 构建乘积数组&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-51&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-52&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;这题要求的是&lt;strong&gt;每个元素的值是除自己以外其他所有元素的乘积&lt;/strong&gt;。最简单的一种方式就是把所有元素都相乘，然后再用这个乘积除以每一个元素即可。但题中要求的是不能使用除法，所以这种方式是行不通的。&lt;/p&gt;
&lt;p&gt;如果我们能计算&lt;strong&gt;每个元素左边所有元素的乘积和右边所有元素的乘积&lt;/strong&gt;，只需要把他们相乘就可以满足这题的要求，就像下面这样，如果我们要求元素4的值&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626358044698.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-52&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt; ： 其中 N 为数组长度，两轮遍历数组 a ，使用 O(N) 时间。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(1)&lt;/strong&gt; ： 变量 tmp 使用常数大小额外空间（数组 b 作为返回值，不计入复杂度考虑）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function multiply(array) {
  if (array === null || array.length === 0)  return array;
    // 先乘这个数的左边，在成这个数的右边，最后相成，避免掉当前数
    let n = array.length;
    let res = new Array(n);
    res[0] = 1;
    for(let i = 1; i &amp;lt; n; i++){             //当前元素左边的所有元素乘积（不包含当前元素）
      res[i] = res[i - 1] * array[i - 1];
    }
    let right = 1;                          //right表示当前元素右边所有元素的乘积（不包含当前元素）,
    for(let i = n - 1; i &amp;gt;= 0; i--){
      res[i] *= right;                      //res[i]表示的是左边的乘积，他俩相乘就是除了自己以外数组的乘积
      right *= array[i];
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;51-正则表达式匹配&#34;&gt;51. 正则表达式匹配&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-52&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;请实现一个函数用来匹配包含&#39;. &#39;和&#39;&lt;em&gt;&#39;的正则表达式。模式中的字符&#39;.&#39;表示任意一个字符，而&#39;&lt;/em&gt;&#39;表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&amp;quot;aaa&amp;quot;与模式&amp;quot;a.a&amp;quot;和&amp;quot;ab&lt;em&gt;ac&lt;/em&gt;a&amp;quot;匹配，但与&amp;quot;aa.a&amp;quot;和&amp;quot;ab*a&amp;quot;均不匹配。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-53&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1626398679406.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;3-复杂度与代码-53&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(MN)&lt;/strong&gt; ： 其中 M, N 分别为 s 和 p 的长度，状态转移需遍历整个 dp 矩阵。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(MN)&lt;/strong&gt; ： 状态矩阵 dp 使用 O(MN) 的额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function match( str ,  pattern ) {
  // let pat = new RegExp(&#39;^&#39; + pattern + &#39;$&#39;, &#39;g&#39;);
  // return pat.test(str);
  let m = str.length + 1, n = pattern.length + 1;
  let dp = Array.from({length: m + 1},x =&amp;gt; new Array(n + 1).fill(false));
  dp[0][0] = true;
  for(let j = 2; j &amp;lt; n; j += 2){
    dp[0][j] = dp[0][j-2] &amp;amp;&amp;amp; pattern.charAt(j-1) === &#39;*&#39;;
  }
  for(let i = 1; i &amp;lt; m; i++){
    for(let j = 1; j &amp;lt; n; j++){
      dp[i][j] = pattern.charAt(j-1) === &#39;*&#39; ? 
      dp[i][j-2] || dp[i-1][j] &amp;amp;&amp;amp; (str.charAt(i-1) === pattern.charAt(j-2) || pattern.charAt(j-2) === &#39;.&#39;) 
      : dp[i-1][j-1] &amp;amp;&amp;amp; (pattern.charAt(j-1) === &#39;.&#39; || str.charAt(i-1) === pattern.charAt(j-1));
    }
  }
  return dp[m-1][n-1]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;51-表示数值的字符串&#34;&gt;51. 表示数值的字符串&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-53&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&amp;quot;+100&amp;quot;,&amp;quot;5e2&amp;quot;,&amp;quot;-123&amp;quot;,&amp;quot;3.1416&amp;quot;和&amp;quot;-1E-16&amp;quot;都表示数值。 但是&amp;quot;12e&amp;quot;,&amp;quot;1a3.14&amp;quot;,&amp;quot;1.2.3&amp;quot;,&amp;quot;+-5&amp;quot;和&amp;quot;12e+4.3&amp;quot;都不是。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-54&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1626399377728.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;我首先想到的是判断否false而不是判断是true，毕竟有这么多条件满足才能判断true，但是只要有一个条件不满足就可以判断false&lt;/strong&gt;，最后代码的效率也还可以，那么接下来进入正题吧：&lt;/p&gt;
&lt;p&gt;首先定义了四个flag，对应四种字符&lt;br&gt;
是否有数字：hasNum&lt;br&gt;
是否有e：hasE&lt;br&gt;
是否有正负符号：hasSign&lt;br&gt;
是否有点：hasDot&lt;br&gt;
其余还定义了字符串长度n以及字符串索引index&lt;br&gt;
先处理一下开头的空格，index相应的后移&lt;br&gt;
然后进入循环，遍历字符串&lt;br&gt;
如果当前字符c是数字：将hasNum置为true，index往后移动一直到非数字或遍历到末尾位置；如果已遍历到末尾(index == n)，结束循环&lt;br&gt;
如果当前字符c是&#39;e&#39;或&#39;E&#39;：如果e已经出现或者当前e之前没有出现过数字，返回false；否则令hasE = true，并且将其他3个flag全部置为false，因为要开始遍历e后面的新数字了&lt;br&gt;
如果当前字符c是+或-：如果已经出现过+或-或者已经出现过数字或者已经出现过&#39;.&#39;，返回false；否则令hasSign = true&lt;br&gt;
如果当前字符c是&#39;.&#39;：如果已经出现过&#39;.&#39;或者已经出现过&#39;e&#39;或&#39;E&#39;，返回false；否则令hasDot = true&lt;br&gt;
如果当前字符c是&#39; &#39;：结束循环，因为可能是末尾的空格了，但也有可能是字符串中间的空格，在循环外继续处理&lt;br&gt;
如果当前字符c是除了上面5种情况以外的其他字符，直接返回false&lt;br&gt;
处理空格，index相应的后移&lt;br&gt;
如果当前索引index与字符串长度相等，说明遍历到了末尾，但是还要满足hasNum为true才可以最终返回true，因为如果字符串里全是符号没有数字的话是不行的，而且e后面没有数字也是不行的，但是没有符号是可以的，所以4个flag里只要判断一下hasNum就行；所以最后返回的是hasNum &amp;amp;&amp;amp; index == n&lt;br&gt;
如果字符串中间有空格，按以上思路是无法遍历到末尾的，index不会与n相等，返回的就是false&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-54&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt; ： 其中 N 为字符串 s 的长度，判断需遍历字符串，每轮状态转移的使用 O(1) 时间。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(1)&lt;/strong&gt; ： states 和 p 使用常数大小的额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function isNumeric( str ) {
  // return str.match(/^[\+-]?\d*(\.\d+)?([eE][-\+]?\d+)?$/)
  // return !isNaN(str)
   let n = str.length;
   let index = 0;
   let hasNum = false, hasE = false, hasSign = false, hasDot = false;
   while(index &amp;lt; n &amp;amp;&amp;amp; str.charAt(index) === &#39; &#39;) index++;
   while(index &amp;lt; n){
     while(index &amp;lt; n &amp;amp;&amp;amp; str.charAt(index) &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; str.charAt(index) &amp;lt;= &#39;9&#39;){
       index++;
       hasNum = true;
     }
     if(index === n) break;
     let c = str.charAt(index);
     if(c === &#39;e&#39; || c === &#39;E&#39;){
       if(hasE || !hasNum) return false;
       hasE = true;
       hasNum = false;
       hasSign = false;
       hasDot = false;
     }else if(c === &#39;+&#39; || c === &#39;-&#39;){
        if(hasSign || hasNum || hasDot) return false;
        hasSign = true;
     }else if(c === &#39;.&#39;){
       if(hasDot || hasE) return false;
       hasDot = true;
     }else if(c === &#39; &#39;){
       break;
     }else{
       return false;
     } 
     index++;
   }
   while(index &amp;lt; n &amp;amp;&amp;amp; str.charAt(index) === &#39;&#39;) index++;
   return hasNum &amp;amp;&amp;amp; index === n;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;53_1-最长不含重复字符的子字符串&#34;&gt;53_1. 最长不含重复字符的子字符串&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-54&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-55&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;哈希表 dic 统计&lt;/strong&gt;： 指针 j 遍历字符 s ，哈希表统计字符 s[j] 最后一次出现的索引 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更新左指针 i&lt;/strong&gt; ： 根据上轮左指针 i 和 dic[s[j]] ，每轮更新左边界 i ，保证区间 [i+1,j] 内无重复字符且最大。&lt;br&gt;
i=max(dic[s[j]],i)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更新结果 res&lt;/strong&gt; ： 取上轮 res 和本轮双指针区间 [i+1,j] 的宽度（即 j - i ）中的最大值。&lt;br&gt;
res=max(res,j−i)&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626400568726.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626400572547.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626400576165.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626400579117.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-复杂度与代码-55&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt; ： 其中 N 为字符串长度，动态规划需遍历计算 dp 列表。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(1)&lt;/strong&gt; ： 字符的 ASCII 码范围为 0 ~ 127 ，哈希表 dicdic 最多使用 O(128) = O(1) 大小的额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var lengthOfLongestSubstring = function(s) {
  let dic = new Map();
  let i = -1, res = 0;
  for(let j = 0; j &amp;lt; s.length; j++) {
    if(dic.has(s[j])){
      i = Math.max(i, dic.get(s[j]));
    }
    dic.set(s[j], j);
    res = Math.max(res, j - i);
  }
  return res;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;54-字符流中第一个不重复的字符&#34;&gt;54. 字符流中第一个不重复的字符&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-55&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符&amp;quot;go&amp;quot;时，第一个只出现一次的字符是&amp;quot;g&amp;quot;。当从该字符流中读出前六个字符“google&amp;quot;时，第一个只出现一次的字符是&amp;quot;l&amp;quot;。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-56&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;对于一道题，如果没有思路，就要针对题目给自己问问题。然后针对问题，来考虑需要什么样的算法或者数据结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A1：对于“重复问题”，惯性思维应该想到哈希或者set。对于“字符串问题”，大多会用到哈希。因此一结合，应该可以想到，判断一个字符是否重复，可以选择用哈希&lt;/li&gt;
&lt;li&gt;A2：对于字符流，源源不断的往池子中添加字符，然后还要返回第一个满足什么条件的字符，显然设计到了“顺序”，也就是先来的先服务，这种先进先出的数据结构不就是队列嘛。因此，这里可以用队列。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假如你已经知道了要用hash 和 queue 这两个数据结构，你可以试着自己想一想，接下来的算法过程是怎么样的？&lt;br&gt;
这里我提供一个算法过程，如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于Insert(char ch)操作， 如果ch是第一次出现，则添加到q中，然后在mp中记录一下次数，如果不是第一次出现，也就是重复了，那么我们就没必要添加到q中，但是还是需要在mp中更新一下次数，因为之后要根据次数来判断是否重复。&lt;/li&gt;
&lt;li&gt;对于FirstAppearingOnce()操作，我们直接判断q的头部，然后在mp中检查一下，是否重复，如果没有重复，那就是我们想要的数据。否则，如果重复了，那就应该弹出头部，然后判断下一个头部是否满足要求。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-复杂度与代码-56&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度：O(N)&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;空间复杂度：O(N)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let map = {};
function Init(){
    map = {};
}
function Insert(ch){
    map[ch] = map[ch] ? map[ch] + 1 : 1;
}
function FirstAppearingOnce(){
    for(const i in map){
      if(map[i] === 1) return i;
    }
    return &#39;#&#39;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;55-链表中环的入口结点&#34;&gt;55. 链表中环的入口结点&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-56&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-57&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;双指针法&lt;/strong&gt;&lt;br&gt;
根据：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;f=2s （快指针每次2步，路程刚好2倍）&lt;/li&gt;
&lt;li&gt;f = s + nb (相遇时，刚好多走了n圈）&lt;br&gt;
推出：s = nb&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从head结点走到入环点需要走 ： a + nb， 而slow已经走了nb，那么slow再走a步就是入环点了。&lt;br&gt;
如何知道slow刚好走了a步？ 从head开始，和slow指针一起走，相遇时刚好就是a步&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626412923358.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626412926902.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626412931760.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626412935065.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-57&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt; ：第二次相遇中，慢指针须走步数 a &amp;lt; a + b；第一次相遇中，慢指针须走步数 a + b - x &amp;lt; a + b，其中 x 为双指针重合点与环入口距离；因此总体为线性复杂度；&lt;br&gt;
&lt;strong&gt;空间复杂度 O(1)&lt;/strong&gt; ：双指针使用常数大小的额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var detectCycle = function(head) {
  let fast = head, slow = head;
  while(true) {
    if(!fast || !fast.next) return null;
    fast = fast.next.next;
    slow = slow.next;
    if(fast === slow) break;
  }
  fast = head;
  while(slow != fast){
    slow = slow.next;
    fast = fast.next;
  }
  return fast;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;56-删除链表中重复的结点&#34;&gt;56. 删除链表中重复的结点&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-57&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5 处理后为 1-&amp;gt;2-&amp;gt;5&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-58&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.1 递归函数定义&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;递归最基本的是要明白递归函数的定义&lt;/strong&gt;！&lt;br&gt;
递归函数直接使用题目给出的函数 deleteDuplicates(head) ，它的含义是 删除以 head 作为开头的有序链表中，值出现重复的节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2 递归终止条件&lt;/strong&gt;&lt;br&gt;
终止条件就是能想到的基本的、不用继续递归处理的case。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 head 为空，那么肯定没有值出现重复的节点，直接返回 head；&lt;/li&gt;
&lt;li&gt;如果 head.next 为空，那么说明链表中只有一个节点，也没有值出现重复的节点，也直接返回 head。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;1.3 递归调用&lt;/strong&gt;&lt;br&gt;
什么时候需要递归呢？我们想一下这两种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 head.val != head.next.val ，说明头节点的值不等于下一个节点的值，所以当前的 head 节点必须保留；但是 head.next 节点要不要保留呢？我们还不知道，需要对 head.next 进行递归，即对 head.next 作为头节点的链表，去除值重复的节点。所以 head.next = self.deleteDuplicates(head.next).&lt;/li&gt;
&lt;li&gt;如果 head.val == head.next.val ，说明头节点的值等于下一个节点的值，所以当前的 head 节点必须删除，并且 head 之后所有与 head.val 相等的节点也都需要删除；删除到哪个节点为止呢？需要用 move 指针一直向后遍历寻找到与 head.val 不等的节点。此时 move 之前的节点都不保留了，因此返回 deleteDuplicates(move);&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;1.4 返回结果&lt;/strong&gt;&lt;br&gt;
题目让我们返回删除了值重复的节点后剩余的链表，结合上面两种递归调用的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 head.val != head.next.val ，头结点需要保留，因此返回的是 head；&lt;/li&gt;
&lt;li&gt;如果 head.val == head.next.val ，头结点需要删除，需要返回的是deleteDuplicates(move);。&lt;br&gt;
对链表 1 -&amp;gt; 2 -&amp;gt; 2 -&amp;gt; 3 递归的过程如下。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626416239662.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-复杂度与代码-58&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度：O(N)&lt;/strong&gt;，每个节点访问了一次。&lt;br&gt;
&lt;strong&gt;空间复杂度：O(N)&lt;/strong&gt;，递归调用的时候会用到了系统的栈。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function deleteDuplication(pHead) {
  if (!pHead || !pHead.next) return pHead;
  if (pHead.val !== pHead.next.val) pHead.next = deleteDuplication(pHead.next);
  else {
    let move = pHead.next;
    while (move &amp;amp;&amp;amp; pHead.val === move.val) {
      move = move.next;
    }
    return deleteDuplication(move);
  }
  return pHead;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;56_1-删除排序链表中的重复元素&#34;&gt;56_1. 删除排序链表中的重复元素&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-58&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 &lt;strong&gt;只出现一次&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-59&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;指定 cur 指针指向头部 head&lt;br&gt;
当 cur 和 cur.next 的存在为循环结束条件，当二者有一个不存在时说明链表没有去重复的必要了&lt;br&gt;
当 cur.val 和 cur.next.val 相等时说明需要去重，则将 cur 的下一个指针指向下一个的下一个，这样就能达到去重复的效果&lt;br&gt;
如果不相等则 cur 移动到下一个位置继续循环&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626416958181.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626416961385.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626416964543.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-59&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度：O(N)&lt;/strong&gt;，每个节点访问了一次。&lt;br&gt;
&lt;strong&gt;空间复杂度：O(N)&lt;/strong&gt;，递归调用的时候会用到了系统的栈。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var deleteDuplicates = function(head) {
  let cur = head;
  while(cur &amp;amp;&amp;amp; cur.next){
    if(cur.val === cur.next.val) cur.next === cur.next.next;
    else cur = cur.next;
  }
  return head;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;57-二叉树的下一个结点&#34;&gt;57. 二叉树的下一个结点&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-59&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的next指针。下图为一棵有9个节点的二叉树。树中从父节点指向子节点的指针用实线表示，从子节点指向父节点的用虚线表示&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-60&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1626510575523.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
红色数字是中序遍历的顺序。接下来，我们就假设，如果当前结点分别是1,2 ... 7，下一结点看有什么规律没？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 =&amp;gt; 2 // 显然下一结点是 1 的父亲结点&lt;/li&gt;
&lt;li&gt;2 =&amp;gt; 3 // 下一节点是当前结点右孩子的左孩子结点，其实你也应该想到了，应该是一直到左孩子为空的那个结点&lt;/li&gt;
&lt;li&gt;3 =&amp;gt; 4 // 跟 2 的情况相似，当前结点右孩子结点的左孩子为空的那个结点&lt;/li&gt;
&lt;li&gt;4 =&amp;gt; 5 // 5 是父亲结点 3 的父亲结点，发现和1有点像，因为 1，3,同样是父亲结点的左孩子&lt;/li&gt;
&lt;li&gt;5 =&amp;gt; 6 // 跟 4=&amp;gt;5 一样的道理&lt;/li&gt;
&lt;li&gt;6 =&amp;gt; 7 // 跟 3=&amp;gt;4 一样的道理&lt;/li&gt;
&lt;li&gt;7 =&amp;gt; null // 因为属于最尾结点&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;如果结点有右子树，右子树最左的结点为该节点的下一个结点；&lt;/li&gt;
&lt;li&gt;如果结点没有右子树，且该结点为它父结点的左子结点，那么该结点的下一个结点是它的父结点；&lt;/li&gt;
&lt;li&gt;如果结点没有右子树，且该结点为它父结点的右子结点，那么沿其父节点向上寻找，其中有父结点为上个父节点的左子节点，那么这上个父节点为该节点的下一个节点；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-复杂度与代码-60&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度：O(n)&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;空间复杂度：O(1)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function GetNext(pNode){
  if(!pNode) return null;
  //情况一：如果该节点有右子树,一直找到所属右子树最左的节点就是下一个节点
  if(pNode.right !== null) {
    pNode = pNode.right;
    while(pNode.left !== null) pNode = pNode.left;
    return pNode;
  }
  //情况二：没有右子树,且是该节点父节点的左子树，那么下一个节点就是其父节点
  while(pNode.next !== null){
    if(pNode === pNode.next.left) return pNode.next;
    //情况三：当前节点是右节点的情况,接着向上寻找
    pNode = pNode.next;
  }
  //如果循环完都没有找到，证明当前节点是最后一个节点了，返回 null
  return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;58-对称的二叉树&#34;&gt;58. 对称的二叉树&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-60&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-61&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1626516309660.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;isSymmetric(root)&lt;/strong&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特例处理： 若根节点 root 为空，则直接返回 truetrue 。&lt;/li&gt;
&lt;li&gt;返回值： 即 recur(root.left, root.right) ;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;recur(L, R)&lt;/strong&gt; ：&lt;br&gt;
&lt;code&gt;终止条件&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当 L 和 R 同时越过叶节点： 此树从顶至底的节点都对称，因此返回 true ；&lt;/li&gt;
&lt;li&gt;当 L 或 R 中只有一个越过叶节点： 此树不对称，因此返回 false ；&lt;/li&gt;
&lt;li&gt;当节点 L 值 不等于 节点 R 值： 此树不对称，因此返回 false ；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;递推工作&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;判断两节点 L.left 和 R.right 是否对称，即 recur(L.left, R.right) ；&lt;/li&gt;
&lt;li&gt;判断两节点 L.right 和 R.left 是否对称，即 recur(L.right, R.left) ；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;返回值&lt;/code&gt;： 两对节点都对称时，才是对称树，因此用与逻辑符 &amp;amp; 连接。&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-61&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt; ： 其中 N 为二叉树的节点数量，每次执行 recur() 可以判断一对节点是否对称，因此最多调用 N/2 次 recur() 方法。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(N)&lt;/strong&gt; ： 最差情况下 二叉树退化为链表，系统使用 O(N) 大小的栈空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function isSymmetrical(pRoot){
  return pRoot === null ? true : recur(pRoot.left, pRoot.right);
}
function recur(L,R){
  if(L === null &amp;amp;&amp;amp; R === null) return true;
  if(L === null || R === null || L.val !== R.val) return false;
  return recur(L.left, R.right) &amp;amp;&amp;amp; recur(L.right, R.left);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;59_1-从上到下打印二叉树一行&#34;&gt;59_1. 从上到下打印二叉树（一行）&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-61&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-62&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1626523551296.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;特例处理&lt;/strong&gt;： 当树的根节点为空，则直接返回空列表 [] ；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化&lt;/strong&gt;： 打印结果列表 res = [] ，包含根节点的队列 queue = [root] ；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BFS 循环&lt;/strong&gt;： 当队列 queue 为空时跳出；&lt;br&gt;
* &lt;strong&gt;出队&lt;/strong&gt;： 队首元素出队，记为 node；&lt;br&gt;
* &lt;strong&gt;打印&lt;/strong&gt;： 将 node.val 添加至列表 res 尾部；&lt;br&gt;
* &lt;strong&gt;添加子节点&lt;/strong&gt;： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;： 返回打印结果列表 res 即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-复杂度与代码-62&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt; ： N 为二叉树的节点数量，即 BFS 需循环 N 次。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(N)&lt;/strong&gt; ： 最差情况下，即当树为平衡二叉树时，最多有 N/2 个树节点同时在 queue 中，使用 O(N) 大小的额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var levelOrder = function(root) {
  if(!root) return [];
  let res = [];
  let queue = [root];
  while(queue.length){
    let node = queue.shift();
    res.push(node.val);
    node.left &amp;amp;&amp;amp; queue.push(node.left);
    node.right &amp;amp;&amp;amp; queue.push(node.right);
  }
  return res;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;59_2-从上到下打印二叉树分行&#34;&gt;59_2. 从上到下打印二叉树（分行）&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-62&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-63&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1626523891340.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;特例处理&lt;/strong&gt;： 当根节点为空，则返回空列表 [] ；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化&lt;/strong&gt;： 打印结果列表 res = [] ，包含根节点的队列 queue = [root] ；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BFS 循环&lt;/strong&gt;： 当队列 queue 为空时跳出；
&lt;ul&gt;
&lt;li&gt;新建一个临时列表 tmp ，用于存储当前层打印结果；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当前层打印循环&lt;/strong&gt;： 循环次数为当前层节点数（即队列 queue 长度）；
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;出队&lt;/strong&gt;： 队首元素出队，记为 node；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;打印&lt;/strong&gt;： 将 node.val 添加至 tmp 尾部；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;添加子节点&lt;/strong&gt;： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;将当前层结果 tmp 添加入 res 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回值&lt;/strong&gt;： 返回打印结果列表 res 即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-复杂度与代码-63&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt; ： N 为二叉树的节点数量，即 BFS 需循环 N 次。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(N)&lt;/strong&gt; ： 最差情况下，即当树为平衡二叉树时，最多有 N/2 个树节点同时在 queue 中，使用 O(N) 大小的额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var levelOrder = function(root) {
  if(!root) return [];
  const res = [];
  const queue = [root];
  while(queue.length){
    let tmp = [];
    let len = queue.length;
    while(len--){
      let node = queue.shift();
      tmp.push(node.val);
      node.left &amp;amp;&amp;amp; queue.push(node.left);
      node.right &amp;amp;&amp;amp; queue.push(node.right);
    }
    res.push(tmp);    
  }
  return res;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;59_3-之字形打印二叉树分行&#34;&gt;59_3. 之字形打印二叉树（分行）&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-63&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-64&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;偶数层倒序&lt;/strong&gt;： 若 res 的长度为 &lt;strong&gt;奇数&lt;/strong&gt; ，说明当前是偶数层，则对 tmp 执行 &lt;strong&gt;倒序&lt;/strong&gt; 操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-复杂度与代码-64&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt; ： NN 为二叉树的节点数量，即 BFS 需循环 N 次，占用 O(N) 。共完成 少于 N 个节点的倒序操作，占用 O(N) 。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(N)&lt;/strong&gt; ： 最差情况下，即当树为满二叉树时，最多有 N/2 个树节点同时在 queue 中，使用 O(N) 大小的额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var levelOrder = function(root) {
  if(!root) return [];
  const res = [];
  const queue = [root];
  while(queue.length){
    const tmp = [];
    let len = queue.length;
    while(len--){
      const node = queue.shift();
      tmp.push(node.val);
      node.left &amp;amp;&amp;amp; queue.push(node.left);
      node.right &amp;amp;&amp;amp; queue.push(node.right);
    }
    res.length % 2 === 1 ? res.push(tmp.reverse()) : res.push(tmp); // 余数为0，第一层（奇数层）正常放入，余数为1，第二层（偶数层）取反再放入
  }
  return res;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;61-序列化二叉树&#34;&gt;61. 序列化二叉树&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-64&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-65&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;h3 id=&#34;序列化&#34;&gt;序列化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;递归遍历一棵树，重点关注当前节点，它的子树的遍历交给递归完成：&lt;br&gt;
&lt;strong&gt;“serialize函数，请帮我分别序列化我的左右子树，我等你的返回结果，再拼接一下。”&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;选择前序遍历，是因为 根|左|右根∣左∣右 的打印顺序，在反序列化时更容易定位出根节点的值。&lt;/li&gt;
&lt;li&gt;遇到 null 节点也要翻译成特定符号，反序列化时才知道这里是 null。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1626529082759.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;反序列化&#34;&gt;反序列化&lt;/h3&gt;
&lt;p&gt;前序遍历的序列化字符串，就像下图右一：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626529266234.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义函数 buildTree 用于还原二叉树，传入由序列化字符串转成的 list 数组。&lt;/li&gt;
&lt;li&gt;逐个 pop 出 list 的首项，构建当前子树的根节点，顺着 list，构建顺序是根节点 &amp;gt; 左子树 &amp;gt; 右子树。&lt;br&gt;
1. 如果弹出的字符为 &amp;quot;X&amp;quot;，则返回 null 节点。&lt;br&gt;
2. 如果弹出的字符是数值，则创建root节点，并递归构建root的左右子树，最后返回root。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626529302558.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-复杂度与代码-65&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt; ： N 为二叉树的节点数，层序遍历需要访问所有节点，最差情况下需要访问 N + 1 个 null ，总体复杂度为 O(2N + 1) = O(N 。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(N)&lt;/strong&gt;： 最差情况下，队列 queue 同时存储 (N+1)/2 个节点（或 N+1 个 null ），使用 O(N) ；列表 res 使用 O(N)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var serialize = function(root) {
  if(!root) return &#39;X&#39;;
  const left = serialize(root.left);
  const right = serialize(root.right);
  return root.val + &#39;,&#39; + left + &#39;,&#39; + right; // 按  根,左,右  拼接字符串
};

var deserialize = function(data) {
  const list = data.split(&#39;,&#39;);               // split成数组
  const buildTree = list =&amp;gt; {                 // 基于list构建当前子树
    const rootVal = list.shift();             // 弹出首项，获取它的“数据”
    if(rootVal === &#39;X&#39;) return null;          // 是X，返回null节点
    const root = new TreeNode(rootVal);       // 不是X，则创建节点
    root.left = buildTree(list);              // 递归构建左子树
    root.right = buildTree(list);             // 递归构建右子树
    return root;                              // 返回当前构建好的root
  }
  return buildTree(list);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;62-二叉搜索树的第k个结点&#34;&gt;62. 二叉搜索树的第k个结点&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-65&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;给定一棵二叉搜索树，请找出其中的第k小的TreeNode结点。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-66&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1626577327421.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看到，4是按大小排序时，第3个节点。如果K=3，即4为所求的值。而对应大小排序的就是中序遍历，中序遍历结果是{2,3,4,5,6,7,8}，&lt;strong&gt;所以本题核心需要使用到中序遍历&lt;/strong&gt;。然后对中序遍历的结果中，取第K个元素即可。这里可以使用数字或者集合存储遍历结果，然后取第k个，但是会产生额外的空间复杂度，当然也可以使用一个变量记录遍历的节点数，当遍历到K个节点时即为所求。&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-66&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(N)&lt;/strong&gt;：使用数组存储，代码看起来非常的清晰。这个代码还有优化空间，因为完成了所有的遍历，事实上可以在遍历到K时，让遍历退出。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(N)&lt;/strong&gt;： 使用数组存储&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function KthNode(pRoot, k){
  if(!pRoot || !k) return null;
  const res = [];
  centerSort(pRoot, res);
  return res[k - 1];
}
const centerSort = (root, list) =&amp;gt; {
  if(!root) return null;
  centerSort(root.left, list);
  list.push(root);
  centerSort(root.right, list);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;63-数据流中的中位数&#34;&gt;63. 数据流中的中位数&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-66&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-67&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;其实不需要每次添加元素的时候，都对全部元素重新排序。如果之前一直保证元素是有序的，那么添加新元素的时候，只需要将元素插入到正确位置即可，查找正确位置可以通过「二分搜索」来完成。&lt;/p&gt;
&lt;p&gt;为了保证之前的元素有序，针对每个新添加的元素都将其放入正确位置。&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-67&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度O(N)&lt;/strong&gt; : 二分查找需要O(logN)的复杂度，移动元素需要O(N)复杂度，所以时间复杂度是O(N)。&lt;br&gt;
&lt;strong&gt;空间复杂度O(N)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [];
function Insert(num)
{
  if(!arr.length){
    arr.push(num);
    return;
  }
  let left = 0, right = arr.length - 1;
  while(left &amp;lt;= right){
    let mid = Math.floor((left + right) / 2);
    if(arr[mid] === num){
      arr.splice(mid, 0, num);
      return
    }else if(arr[mid] &amp;lt; num){
      left = mid + 1;
    }else {
      right = mid - 1;
    }
  }
  arr.splice(right + 1, 0, num);
}
function GetMedian(){
  const length = arr.length;
  if(!length) return null;
  const mid = Math.floor((length - 1) / 2);
  if(length % 2) return arr[mid];
  return (arr[mid] + arr[mid + 1]) / 2; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;64-滑动窗口的最大值&#34;&gt;64. 滑动窗口的最大值&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-67&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。&lt;/p&gt;
&lt;p&gt;例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。&lt;/p&gt;
&lt;p&gt;窗口大于数组长度的时候，返回空&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-68&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;看题中给的数据&lt;br&gt;
1  3  -1 -3  5  3  6  7&lt;br&gt;
我们给一个窗口队列，来存放进入的数据&lt;/p&gt;
&lt;p&gt;首先是1进入，队列为[1]，然后3进入，这时候3进入的时候先和它前面的数据进行比较，发现3&amp;gt;1，这时候把队列中1抛出&lt;/p&gt;
&lt;p&gt;这时候-1进入队列，发现-1小于3，所以-1进入以后不进行任何操作。这时候队列为[3,-1]这时候其实窗口的大小已经为3啦&lt;/p&gt;
&lt;p&gt;因为我们前面抛出一个1所以看着是两个数据。然后-3进入，这时候就要判断，窗口队列的长度是不是大于k，当大于k的时候&lt;/p&gt;
&lt;p&gt;就要把队列的首元素抛出。-3进入的时候，明显长度没有超出，所以不用管，然后-3和队尾元素比较，小于队尾。进入队里无操作。&lt;/p&gt;
&lt;p&gt;这时候队列是[3,-1,-3],随后5进入，这时候，队列的长度大于k，把队列头元素3抛出，然后进行判断，发现5比队尾元素大，这时候&lt;br&gt;
抛出队尾的-3，这时候队尾元素变成-1，5还是大于-1，继续抛出，这时候队列中只有[5].然后6准备进入。&lt;/p&gt;
&lt;p&gt;发现6大于队尾5,5抛出，6进入。7的操作同上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上面的操作结果为：队列的头元素永远是最大的，所以后面的(nums.length-k)次进入，只需要队列的头放入输出数组即可&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-68&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度O(n)&lt;/strong&gt; : 因为只有每次进入的时候，有时间复杂度，里面的判断和抛出都是O(1)的操作&lt;br&gt;
&lt;strong&gt;空间复杂度O(n)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function maxInWindows(num, size){
  if(!size) return [];
  const numLength = num.length;
  let window = [],       //队列用来存放下标
      res = [];
  for(let i = 0; i &amp;lt; numLength; i++){
    if(i &amp;gt;= size + window[0]) window.shift();    // 如果 i 比窗口最大范围大, 移除队头
    while(window &amp;amp;&amp;amp; num[i] &amp;gt; num[window[window.length - 1]]){
      window.pop();                   // 如果 nums[i] 比窗口中的值大，将窗口中的值删除
    }
    window.push(i);                   // 窗口中加入当前元素
    if(i &amp;gt;= size - 1) res.push(num[window[0]])   // 如果 i &amp;gt; size - 1，每次都记录最大值
  }
 return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;65-矩阵中的路径&#34;&gt;65. 矩阵中的路径&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-68&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-69&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;深度优先搜索&lt;/strong&gt;： 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;剪枝&lt;/strong&gt;： 在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 可行性剪枝 。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626588797412.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;递归参数&lt;/strong&gt;： 当前元素在矩阵 board 中的行列索引 i 和 j ，当前目标字符在 word 中的索引 k 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;终止条件&lt;/strong&gt;：&lt;br&gt;
1. 返回 falsefalse ： (1) 行或列索引越界 &lt;code&gt;或&lt;/code&gt; (2) 当前矩阵元素与目标字符不同 &lt;code&gt;或&lt;/code&gt; (3) 当前矩阵元素已访问过 （ (3) 可合并至 (2) ） 。&lt;br&gt;
2. 返回 truetrue ： k = len(word) - 1 ，即字符串 word 已全部匹配。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;递推工作&lt;/strong&gt;：&lt;br&gt;
1. 标记当前矩阵元素： 将 board[i][j] 修改为 &lt;strong&gt;空字符&lt;/strong&gt; &#39;&#39; ，代表此元素已访问过，防止之后搜索时重复访问。&lt;br&gt;
2. 搜索下一单元格： 朝当前元素的 &lt;strong&gt;上、下、左、右&lt;/strong&gt; 四个方向开启下层递归，使用 或 连接 （代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至 res 。&lt;br&gt;
3. 还原当前矩阵元素： 将 board[i][j] 元素还原至初始值，即 word[k] 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;： 返回布尔量 res ，代表是否搜索到目标字符串。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-复杂度与代码-69&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(3^K*MN)&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;空间复杂度 O(K)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function hasPath( matrix ,  word ) {
  let row = matrix.length;
  let col = matrix[0].length;
  let dfs = function(i, j, matrix, word, index){
    if(i&amp;lt;0 || i&amp;gt;=row || j&amp;lt;0 || j&amp;gt;col || matrix[i][j] !== word[index]) return false;// 判断不符合条件
    if(index === word.length - 1) return true;  // word遍历完了
    let tmp = matrix[i][j];                     // 记录到board的值
    matrix[i][j] = &#39;&#39;;                         // 锁上，因为后续的递归是4个方向上的，无法保证上一个方向的值
    let res = dfs(i-1, j, matrix, word, index+1) || dfs(i+1, j, matrix, word, index+1) || 
              dfs(i, j-1, matrix, word, index+1) || dfs(i, j+1, matrix, word, index+1)
    matrix[i][j] = tmp;                         // 恢复现场
    return res;
  }
  // 遍历整个board，找到初始位置点
  for(let i = 0; i &amp;lt; row; i++){
    for(let j = 0; j &amp;lt; col; j++){
      if(dfs(i, j, matrix, word, 0 )) return true
    }
  }
  // 没找到
  return false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;66-机器人的运动范围&#34;&gt;66. 机器人的运动范围&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-69&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;地上有一个rows行和cols列的方格。坐标从 [0,0] 到 [rows-1,cols-1]。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于threshold的格子。 例如，当threshold为18时，机器人能够进入方格[35,37]，因为3+5+3+7 = 18。但是，它不能进入方格[35,38]，因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-70&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;深度优先搜索&lt;/strong&gt;： 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;剪枝&lt;/strong&gt;： 在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 可行性剪枝 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;算法解析&lt;/code&gt;：&lt;br&gt;
&lt;strong&gt;递归参数&lt;/strong&gt;： 当前元素在矩阵中的行列索引 i 和 j ，两者的数位和 si, sj 。&lt;br&gt;
&lt;strong&gt;终止条件&lt;/strong&gt;： 当 ① 行列索引越界 &lt;code&gt;或&lt;/code&gt; ② 数位和超出目标值 k &lt;code&gt;或&lt;/code&gt; ③ 当前元素已访问过 时，返回 00 ，代表不计入可达解。&lt;br&gt;
&lt;strong&gt;递推工作&lt;/strong&gt;：&lt;br&gt;
1. &lt;strong&gt;标记当前单元格&lt;/strong&gt; ：将索引 (i, j) 存入 Set visited 中，代表此单元格已被访问过。&lt;br&gt;
2. &lt;strong&gt;搜索下一单元格&lt;/strong&gt;： 计算当前元素的 &lt;code&gt;下、右&lt;/code&gt; 两个方向元素的数位和，并开启下层递归 。&lt;br&gt;
&lt;strong&gt;回溯返回值&lt;/strong&gt;： 返回 1 + 右方搜索的可达解总数 + 下方搜索的可达解总数，代表从本单元格递归搜索的可达解总数。&lt;/p&gt;
&lt;h2 id=&#34;3-复杂度与代码-70&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度 O(MN)&lt;/strong&gt;： 最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为 O(MN) 。&lt;br&gt;
&lt;strong&gt;空间复杂度 O(MN)&lt;/strong&gt; ： 最差情况下，Set visited 内存储矩阵所有单元格的索引，使用 O(MN) 的额外空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function movingCount(threshold, rows, cols){
    let flag = new Array(rows).fill(0).map(x =&amp;gt; Array(cols).fill(false));
    return getRes(flag, rows, cols, 0, 0, threshold);
}
function getRes(flag, row, col, x, y, k){
    // i &amp;gt;= m || j &amp;gt;= n是边界条件的判断     
    // k &amp;lt; sum(i, j)判断当前格子坐标是否满足条件    
    // flag[i][j]判断这个格子是否被访问过
    if(x &amp;lt; 0 || y &amp;lt; 0 || x &amp;gt;= row || y &amp;gt;= col || flag[x][y] || sum(x, y) &amp;gt; k) return 0;
    flag[x][y] = true;     // 标注这个格子被访问过
    return 1 + getRes(flag, row, col, x+1, y, k) + getRes(flag, row, col, x, y+1, k);  // 沿着当前格子的右边和下边继续访问
}
// 按位求和
function sum(row, col){
    let str = row + &#39;&#39; + col;
    let res = 0;
    for(let i = 0; i &amp;lt; str.length; i++){
        res += parseInt(str[i]);
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;67-剪绳子&#34;&gt;67. 剪绳子&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-70&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1，m&amp;lt;=n），每段绳子的长度记为k[1],...,k[m]。请问k[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-71&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;前面提到：8 拆分为 3+3+2，此时乘积是最大的。然后就推测出来一个整数，要拆成多个 2 和 3 的和，保证乘积最大。原理很容易理解，因为 2 和 3 可以合成任何数字，例如5=2+3，但是5 &amp;lt; 2&lt;em&gt;3；例如6=3+3，但是6&amp;lt;3&lt;/em&gt;3。所以根据贪心算法，就尽量将原数拆成更多的 3，然后再拆成更多的 2，保证拆出来的整数的乘积结果最大。&lt;/p&gt;
&lt;p&gt;但上面的解法还有不足。如果整数 n 的形式是 3k+1，例如 7。按照上面规则，会拆分成“3 + 3 + 1”。但是在乘法操作中，1 是没作用的。此时，应该将 1 和 3 变成 4，也就是“3 + 3 + 1”变成“3 + 4”。此时乘积最大。&lt;/p&gt;
&lt;p&gt;综上所述，算法的整体思路是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;n 除 3 的结果为 a，余数是 b&lt;/li&gt;
&lt;li&gt;当 b 为 0，直接将 a 个 3 相乘&lt;/li&gt;
&lt;li&gt;当 b 为 1，将（a-1）个 3 相乘，再乘以 4&lt;/li&gt;
&lt;li&gt;当 b 为 2，将 a 个 3 相乘，再乘以 2&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-复杂度与代码-71&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度是 O(1)&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;空间复杂度是 O(1)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function cutRope(number)
{
  if(number === 2) return 1;
  if(number === 3) return 2;
  // a的含义：n能拆成的3的个数
  const a = Math.floor(number / 3);
  const b = number % 3;
  if(b === 0) return Math.pow(3, a);
  // n是 3k + 1，例如7。拆成3、3、1。由于有1对结果无法有贡献，所以最后的3、1换成4
  if(b === 1) return Math.pow(3, a-1) * 4;
  return Math.pow(3, a) * 2
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;68-回文链表&#34;&gt;68. 回文链表&lt;/h1&gt;
&lt;h2 id=&#34;1-题目描述-71&#34;&gt;1. 🎨题目描述&lt;/h2&gt;
&lt;p&gt;请判断一个链表是否为回文链表。&lt;/p&gt;
&lt;h2 id=&#34;2-解题思路-72&#34;&gt;2. 🧠解题思路&lt;/h2&gt;
&lt;p&gt;快慢指针，起初都指向表头，快指针一次走两步，慢指针一次走一步，遍历结束时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要么，slow 正好指向中间两个结点的后一个。&lt;/li&gt;
&lt;li&gt;要么，slow 正好指向中间结点。&lt;/li&gt;
&lt;li&gt;用 prev 保存 slow 的前一个结点，通过prev.next = null断成两个链表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将后半段链表翻转，和前半段从头比对。空间复杂度降为O(1)。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626591769578.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何翻转单链表&lt;/strong&gt;&lt;br&gt;
可以这么思考：一次迭代中，有哪些指针需要变动：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个结点的 next 指针要变动。&lt;/li&gt;
&lt;li&gt;指向表头的 slow 指针要变动。&lt;/li&gt;
&lt;li&gt;需要有指向新链表表头的 head2 指针，它也要变。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626591819088.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-复杂度与代码-72&#34;&gt;3. 🍭复杂度与代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt; : O(n)&lt;br&gt;
&lt;strong&gt;空间复杂度&lt;/strong&gt; : O(1)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var isPalindrome = function (head) {
  if(!head || !head.next) return true;
  let fast = head;
  let slow = head;
  let prev;
  while(fast &amp;amp;&amp;amp; fast.next){
    prev = slow;
    slow = slow.next;
    fast = fast.next.next;
  }
  prev = null;
  let head2 = null;
  while(slow){
    let tmp = slow.next;
    slow.next = head2;
    head2 = slow;
    slow = tmp;
  }
  while(head &amp;amp;&amp;amp; head2){
    if(head.val !== head2.val) return false;
    head = head.next;
    head2 =head2.next;
  }
  return true;
};
&lt;/code&gt;&lt;/pre&gt;
">【JS】手撕剑指offerⅡ</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/typescript-shang-kuai-su-ru-men/"" data-c="
          &lt;h1 id=&#34;1-快速入门&#34;&gt;1. 快速入门&lt;/h1&gt;
&lt;h2 id=&#34;0-typescript简介&#34;&gt;0、TypeScript简介&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;TypeScript是JavaScript的超集。&lt;/li&gt;
&lt;li&gt;它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。&lt;/li&gt;
&lt;li&gt;TS代码需要通过编译器编译为JS，然后再交由JS解析器执行。&lt;/li&gt;
&lt;li&gt;TS完全兼容JS，换言之，任何的JS代码都可以直接当成JS使用。&lt;/li&gt;
&lt;li&gt;相较于JS而言，TS拥有了静态类型，更加严格的语法，更强大的功能；TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;1-typescript-开发环境搭建&#34;&gt;1、TypeScript 开发环境搭建&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下载Node.js&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;64位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi&lt;/li&gt;
&lt;li&gt;32位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装Node.js&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用npm全局安装typescript&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进入命令行&lt;/li&gt;
&lt;li&gt;输入：npm i -g typescript&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建一个ts文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用tsc对ts文件进行编译&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;进入命令行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入ts文件所在目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行命令：tsc xxx.ts&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-基本类型&#34;&gt;2、基本类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类型声明&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类型声明是TS非常重要的一个特点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过类型声明可以指定TS中变量（参数、形参）的类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;let 变量: 类型;

let 变量: 类型 = 值;

function fn(参数: 类型, 参数: 类型): 类型{
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自动类型判断&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TS拥有自动的类型判断机制&lt;/li&gt;
&lt;li&gt;当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型&lt;/li&gt;
&lt;li&gt;所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;例子&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;number&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1, -33, 2.5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;任意数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;string&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&#39;hi&#39;, &amp;quot;hi&amp;quot;, &lt;code&gt;hi&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;任意字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;boolean&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;true、false&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;布尔值true或false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;字面量&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;其本身&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;限制变量的值就是该字面量的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;any&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;*&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;任意类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;unknown&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;*&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;类型安全的any&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;void&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;空值（undefined）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;没有值（或undefined）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;never&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;没有值&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不能是任何值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;object&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;{name:&#39;孙悟空&#39;}&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;任意的JS对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;array&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;[1,2,3]&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;任意JS数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;tuple&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;[4,5]&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;元素，TS新增类型，固定长度数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;enum&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;enum{A, B}&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;枚举，TS中新增类型&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;number&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
let big: bigint = 100n;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;boolean&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;let isDone: boolean = false;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;string&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;let color: string = &amp;quot;blue&amp;quot;;
color = &#39;red&#39;;

let fullName: string = `Bob Bobbington`;
let age: number = 37;
let sentence: string = `Hello, my name is ${fullName}.

I&#39;ll be ${age + 1} years old next month.`;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字面量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;let color: &#39;red&#39; | &#39;blue&#39; | &#39;black&#39;;
let num: 1 | 2 | 3 | 4 | 5;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;any&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;let d: any = 4;
d = &#39;hello&#39;;
d = true;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;unknown&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;let notSure: unknown = 4;
notSure = &#39;hello&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;void&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;let unusable: void = undefined;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;never&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;function error(message: string): never {
  throw new Error(message);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;object（没啥用）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;let obj: object = {};
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;array&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;let list: number[] = [1, 2, 3];
let list: Array&amp;lt;number&amp;gt; = [1, 2, 3];
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tuple&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;let x: [string, number];
x = [&amp;quot;hello&amp;quot;, 10]; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;enum&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;enum Color {
  Red,
  Green,
  Blue,
}
let c: Color = Color.Green;

enum Color {
  Red = 1,
  Green,
  Blue,
}
let c: Color = Color.Green;

enum Color {
  Red = 1,
  Green = 2,
  Blue = 4,
}
let c: Color = Color.Green;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类型断言&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;let someValue: unknown = &amp;quot;this is a string&amp;quot;;
let strLength: number = (someValue as string).length;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;let someValue: unknown = &amp;quot;this is a string&amp;quot;;
let strLength: number = (&amp;lt;string&amp;gt;someValue).length;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-编译选项&#34;&gt;3、编译选项&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;自动编译文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;tsc xxx.ts -w
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自动编译整个项目&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;include&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义希望被编译文件所在的目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认值：[&amp;quot;**/*&amp;quot;]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;include&amp;quot;:[&amp;quot;src/**/*&amp;quot;, &amp;quot;tests/**/*&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上述示例中，所有src目录和tests目录下的文件都会被编译&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;exclude&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义需要排除在外的目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认值：[&amp;quot;node_modules&amp;quot;, &amp;quot;bower_components&amp;quot;, &amp;quot;jspm_packages&amp;quot;]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;exclude&amp;quot;: [&amp;quot;./src/hello/**/*&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上述示例中，src下hello目录下的文件都不会被编译&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;extends&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义被继承的配置文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;extends&amp;quot;: &amp;quot;./configs/base&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;files&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;指定被编译文件的列表，只有需要编译的文件少时才会用到&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;files&amp;quot;: [
    &amp;quot;core.ts&amp;quot;,
    &amp;quot;sys.ts&amp;quot;,
    &amp;quot;types.ts&amp;quot;,
    &amp;quot;scanner.ts&amp;quot;,
    &amp;quot;parser.ts&amp;quot;,
    &amp;quot;utilities.ts&amp;quot;,
    &amp;quot;binder.ts&amp;quot;,
    &amp;quot;checker.ts&amp;quot;,
    &amp;quot;tsc.ts&amp;quot;
  ]
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列表中的文件都会被TS编译器所编译&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;compilerOptions&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;编译选项是配置文件中非常重要也比较复杂的配置选项&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在compilerOptions中包含多个子选项，用来完成对编译的配置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;项目选项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;target&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;设置ts代码编译的目标版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ES3（默认）、ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;target&amp;quot;: &amp;quot;ES6&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;lib&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;指定代码运行时所包含的库（宿主环境）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ......&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;target&amp;quot;: &amp;quot;ES6&amp;quot;,
    &amp;quot;lib&amp;quot;: [&amp;quot;ES6&amp;quot;, &amp;quot;DOM&amp;quot;],
    &amp;quot;outDir&amp;quot;: &amp;quot;dist&amp;quot;,
    &amp;quot;outFile&amp;quot;: &amp;quot;dist/aa.js&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;module&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;设置编译后代码使用的模块化系统&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CommonJS、UMD、AMD、System、ES2020、ESNext、None&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;&amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;module&amp;quot;: &amp;quot;CommonJS&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;outDir&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;编译后文件的所在目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;outDir&amp;quot;: &amp;quot;dist&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置后编译后的js文件将会生成到dist目录&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;outFile&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将所有的文件编译为一个js文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;outFile&amp;quot;: &amp;quot;dist/app.js&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;rootDir&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;rootDir&amp;quot;: &amp;quot;./src&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;allowJs&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否对js文件编译&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;checkJs&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;是否对js文件进行检查&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;allowJs&amp;quot;: true,
    &amp;quot;checkJs&amp;quot;: true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;removeComments&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否删除注释&lt;/li&gt;
&lt;li&gt;默认值：false&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;noEmit&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不对代码进行编译&lt;/li&gt;
&lt;li&gt;默认值：false&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sourceMap&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否生成sourceMap&lt;/li&gt;
&lt;li&gt;默认值：false&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;严格检查&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;strict
&lt;ul&gt;
&lt;li&gt;启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;alwaysStrict
&lt;ul&gt;
&lt;li&gt;总是以严格模式对代码进行编译&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;noImplicitAny
&lt;ul&gt;
&lt;li&gt;禁止隐式的any类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;noImplicitThis
&lt;ul&gt;
&lt;li&gt;禁止类型不明确的this&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;strictBindCallApply
&lt;ul&gt;
&lt;li&gt;严格检查bind、call和apply的参数列表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;strictFunctionTypes
&lt;ul&gt;
&lt;li&gt;严格检查函数的类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;strictNullChecks
&lt;ul&gt;
&lt;li&gt;严格的空值检查&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;strictPropertyInitialization
&lt;ul&gt;
&lt;li&gt;严格检查属性是否初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;额外检查&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;noFallthroughCasesInSwitch
&lt;ul&gt;
&lt;li&gt;检查switch语句包含正确的break&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;noImplicitReturns
&lt;ul&gt;
&lt;li&gt;检查函数没有隐式的返回值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;noUnusedLocals
&lt;ul&gt;
&lt;li&gt;检查未使用的局部变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;noUnusedParameters
&lt;ul&gt;
&lt;li&gt;检查未使用的参数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高级&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;allowUnreachableCode
&lt;ul&gt;
&lt;li&gt;检查不可达代码&lt;/li&gt;
&lt;li&gt;可选值：
&lt;ul&gt;
&lt;li&gt;true，忽略不可达代码&lt;/li&gt;
&lt;li&gt;false，不可达代码将引起错误&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;noEmitOnError
&lt;ul&gt;
&lt;li&gt;有错误的情况下不进行编译&lt;/li&gt;
&lt;li&gt;默认值：false&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-webpack&#34;&gt;4、webpack&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通常情况下，实际开发中我们都需要使用构建工具对代码进行打包，TS同样也可以结合构建工具一起使用，下边以webpack为例介绍一下如何结合构建工具使用TS。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;初始化项目&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进入项目根目录，执行命令 &lt;code&gt;npm init -y&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;主要作用：创建package.json文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载构建工具&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;npm i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;共安装了7个包
&lt;ul&gt;
&lt;li&gt;webpack
&lt;ul&gt;
&lt;li&gt;构建工具webpack&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;webpack-cli
&lt;ul&gt;
&lt;li&gt;webpack的命令行工具&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;webpack-dev-server
&lt;ul&gt;
&lt;li&gt;webpack的开发服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;typescript
&lt;ul&gt;
&lt;li&gt;ts编译器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ts-loader
&lt;ul&gt;
&lt;li&gt;ts加载器，用于在webpack中编译ts文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;html-webpack-plugin
&lt;ul&gt;
&lt;li&gt;webpack中html插件，用来自动创建html文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;clean-webpack-plugin
&lt;ul&gt;
&lt;li&gt;webpack中的清除插件，每次构建都会先清除目录&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根目录下创建webpack的配置文件webpack.config.js&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const path = require(&amp;quot;path&amp;quot;);
const HtmlWebpackPlugin = require(&amp;quot;html-webpack-plugin&amp;quot;);
const { CleanWebpackPlugin } = require(&amp;quot;clean-webpack-plugin&amp;quot;);

module.exports = {
    optimization:{
        minimize: false // 关闭代码压缩，可选
    },

    entry: &amp;quot;./src/index.ts&amp;quot;,
    
    devtool: &amp;quot;inline-source-map&amp;quot;,
    
    devServer: {
        contentBase: &#39;./dist&#39;
    },

    output: {
        path: path.resolve(__dirname, &amp;quot;dist&amp;quot;),
        filename: &amp;quot;bundle.js&amp;quot;,
        environment: {
            arrowFunction: false // 关闭webpack的箭头函数，可选
        }
    },

    resolve: {
        extensions: [&amp;quot;.ts&amp;quot;, &amp;quot;.js&amp;quot;]
    },
    
    module: {
        rules: [
            {
                test: /\.ts$/,
                use: {
                   loader: &amp;quot;ts-loader&amp;quot;     
                },
                exclude: /node_modules/
            }
        ]
    },

    plugins: [
        new CleanWebpackPlugin(),
        new HtmlWebpackPlugin({
            title:&#39;TS测试&#39;
        }),
    ]

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根目录下创建tsconfig.json，配置可以根据自己需要&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;compilerOptions&amp;quot;: {
        &amp;quot;target&amp;quot;: &amp;quot;ES2015&amp;quot;,
        &amp;quot;module&amp;quot;: &amp;quot;ES2015&amp;quot;,
        &amp;quot;strict&amp;quot;: true
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改package.json添加如下配置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  ...略...
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;test&amp;quot;: &amp;quot;echo \&amp;quot;Error: no test specified\&amp;quot; &amp;amp;&amp;amp; exit 1&amp;quot;,
    &amp;quot;build&amp;quot;: &amp;quot;webpack&amp;quot;,
    &amp;quot;start&amp;quot;: &amp;quot;webpack serve --open chrome.exe&amp;quot;
  },
  ...略...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在src下创建ts文件，并在并命令行执行&lt;code&gt;npm run build&lt;/code&gt;对代码进行编译，或者执行&lt;code&gt;npm start&lt;/code&gt;来启动开发服务器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-babel&#34;&gt;5、Babel&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;经过一系列的配置，使得TS和webpack已经结合到了一起，除了webpack，开发中还经常需要结合babel来对代码进行转换以使其可以兼容到更多的浏览器，在上述步骤的基础上，通过以下步骤再将babel引入到项目中。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装依赖包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;npm i -D @babel/core @babel/preset-env babel-loader core-js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;共安装了4个包，分别是：
&lt;ul&gt;
&lt;li&gt;@babel/core
&lt;ul&gt;
&lt;li&gt;babel的核心工具&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@babel/preset-env
&lt;ul&gt;
&lt;li&gt;babel的预定义环境&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@babel-loader
&lt;ul&gt;
&lt;li&gt;babel在webpack中的加载器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;core-js
&lt;ul&gt;
&lt;li&gt;core-js用来使老版本的浏览器支持新版ES语法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改webpack.config.js配置文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;...略...
module: {
    rules: [
        {
            test: /\.ts$/,
            use: [
                {
                    loader: &amp;quot;babel-loader&amp;quot;,
                    options:{
                        presets: [
                            [
                                &amp;quot;@babel/preset-env&amp;quot;,
                                {
                                    &amp;quot;targets&amp;quot;:{
                                        &amp;quot;chrome&amp;quot;: &amp;quot;58&amp;quot;,
                                        &amp;quot;ie&amp;quot;: &amp;quot;11&amp;quot;
                                    },
                                    &amp;quot;corejs&amp;quot;:&amp;quot;3&amp;quot;,
                                    &amp;quot;useBuiltIns&amp;quot;: &amp;quot;usage&amp;quot;
                                }
                            ]
                        ]
                    }
                },
                {
                    loader: &amp;quot;ts-loader&amp;quot;,

                }
            ],
            exclude: /node_modules/
        }
    ]
}
...略...
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如此一来，使用ts编译后的文件将会再次被babel处理，使得代码可以在大部分浏览器中直接使用，可以在配置选项的targets中指定要兼容的浏览器版本。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2-面向对象&#34;&gt;2. 面向对象&lt;/h1&gt;
&lt;p&gt;面向对象是程序中一个非常重要的思想，它被很多同学理解成了一个比较难，比较深奥的问题，其实不然。面向对象很简单，简而言之就是程序之中所有的操作都需要通过对象来完成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;举例来说：
&lt;ul&gt;
&lt;li&gt;操作浏览器要使用window对象&lt;/li&gt;
&lt;li&gt;操作网页要使用document对象&lt;/li&gt;
&lt;li&gt;操作控制台要使用console对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一切操作都要通过对象，也就是所谓的面向对象，那么对象到底是什么呢？这就要先说到程序是什么，计算机程序的本质就是对现实事物的抽象，抽象的反义词是具体，比如：照片是对一个具体的人的抽象，汽车模型是对具体汽车的抽象等等。程序也是对事物的抽象，在程序中我们可以表示一个人、一条狗、一把枪、一颗子弹等等所有的事物。一个事物到了程序中就变成了一个对象。&lt;/p&gt;
&lt;p&gt;在程序中所有的对象都被分成了两个部分数据和功能，以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。数据在对象中被成为属性，而功能就被称为方法。所以简而言之，在程序中一切皆是对象。&lt;/p&gt;
&lt;h2 id=&#34;1-类class&#34;&gt;1、类（class）&lt;/h2&gt;
&lt;p&gt;要想面向对象，操作对象，首先便要拥有对象，那么下一个问题就是如何创建对象。要创建对象，必须要先定义类，所谓的类可以理解为对象的模型，程序中可以根据类创建指定类型的对象，举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，通过Car类来创建汽车的对象，不同的类可以用来创建不同的对象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;class 类名 {
	属性名: 类型;
	
	constructor(参数: 类型){
		this.属性名 = 参数;
	}
	
	方法名(){
		....
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;class Person{
    name: string;
    age: number;

    constructor(name: string, age: number){
        this.name = name;
        this.age = age;
    }

    sayHello(){
        console.log(`大家好，我是${this.name}`);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const p = new Person(&#39;孙悟空&#39;, 18);
p.sayHello();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-面向对象的特点&#34;&gt;2、面向对象的特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;封装&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在TS中可以对属性的权限进行设置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只读属性（readonly）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果在声明属性时添加一个readonly，则属性便成了只读属性无法修改&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TS中属性具有三种修饰符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;public（默认值），可以在类、子类和对象中修改&lt;/li&gt;
&lt;li&gt;protected ，可以在类、子类中修改&lt;/li&gt;
&lt;li&gt;private ，可以在类中修改&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;public&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;class Person{
    public name: string; // 写或什么都不写都是public
    public age: number;

    constructor(name: string, age: number){
        this.name = name; // 可以在类中修改
        this.age = age;
    }

    sayHello(){
        console.log(`大家好，我是${this.name}`);
    }
}

class Employee extends Person{
    constructor(name: string, age: number){
        super(name, age);
        this.name = name; //子类中可以修改
    }
}

const p = new Person(&#39;孙悟空&#39;, 18);
p.name = &#39;猪八戒&#39;;// 可以通过对象修改
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;protected&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;class Person{
    protected name: string;
    protected age: number;

    constructor(name: string, age: number){
        this.name = name; // 可以修改
        this.age = age;
    }

    sayHello(){
        console.log(`大家好，我是${this.name}`);
    }
}

class Employee extends Person{

    constructor(name: string, age: number){
        super(name, age);
        this.name = name; //子类中可以修改
    }
}

const p = new Person(&#39;孙悟空&#39;, 18);
p.name = &#39;猪八戒&#39;;// 不能修改
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;private&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;class Person{
    private name: string;
    private age: number;

    constructor(name: string, age: number){
        this.name = name; // 可以修改
        this.age = age;
    }

    sayHello(){
        console.log(`大家好，我是${this.name}`);
    }
}

class Employee extends Person{

    constructor(name: string, age: number){
        super(name, age);
        this.name = name; //子类中不能修改
    }
}

const p = new Person(&#39;孙悟空&#39;, 18);
p.name = &#39;猪八戒&#39;;// 不能修改
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;属性存取器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于一些不希望被任意修改的属性，可以将其设置为private&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接将其设置为private将导致无法再通过对象修改其中的属性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读取属性的方法叫做setter方法，设置属性的方法叫做getter方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;class Person{
    private _name: string;

    constructor(name: string){
        this._name = name;
    }

    get name(){
        return this._name;
    }

    set name(name: string){
        this._name = name;
    }

}

const p1 = new Person(&#39;孙悟空&#39;);
console.log(p1.name); // 通过getter读取name属性
p1.name = &#39;猪八戒&#39;; // 通过setter修改name属性
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;静态属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;静态属性（方法）使用static开头&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;class Tools{
    static PI = 3.1415926;
    
    static sum(num1: number, num2: number){
        return num1 + num2
    }
}

console.log(Tools.PI);
console.log(Tools.sum(123, 456));
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;this&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在类中，使用this表示当前对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;继承&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;继承时面向对象中的又一个特性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过继承可以将其他类中的属性和方法引入到当前类中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;class Animal{
    name: string;
    age: number;

    constructor(name: string, age: number){
        this.name = name;
        this.age = age;
    }
}

class Dog extends Animal{

    bark(){
        console.log(`${this.name}在汪汪叫！`);
    }
}

const dog = new Dog(&#39;旺财&#39;, 4);
dog.bark();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过继承可以在不修改类的情况下完成对类的扩展&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重写&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;发生继承时，如果子类中的方法会替换掉父类中的同名方法，这就称为方法的重写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;class Animal{
    name: string;
    age: number;

    constructor(name: string, age: number){
        this.name = name;
        this.age = age;
    }

    run(){
        console.log(`父类中的run方法！`);
    }
}

class Dog extends Animal{

    bark(){
        console.log(`${this.name}在汪汪叫！`);
    }

    run(){
        console.log(`子类中的run方法，会重写父类中的run方法！`);
    }
}

const dog = new Dog(&#39;旺财&#39;, 4);
dog.bark();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在子类中可以使用super来完成对父类的引用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抽象类（abstract class）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;抽象类是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;abstract class Animal{
    abstract run(): void;
    bark(){
        console.log(&#39;动物在叫~&#39;);
    }
}

class Dog extends Animals{
    run(){
        console.log(&#39;狗在跑~&#39;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-接口interface&#34;&gt;3、接口（Interface）&lt;/h2&gt;
&lt;p&gt;接口的作用类似于抽象类，不同点在于接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法。接口主要负责定义一个类的结构，接口可以去限制一个对象的接口，对象只有包含接口中定义的所有属性和方法时才能匹配接口。同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;示例（检查对象类型）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;interface Person{
    name: string;
    sayHello():void;
}

function fn(per: Person){
    per.sayHello();
}

fn({name:&#39;孙悟空&#39;, sayHello() {console.log(`Hello, 我是 ${this.name}`)}});

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例（实现）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;interface Person{
    name: string;
    sayHello():void;
}

class Student implements Person{
    constructor(public name: string) {
    }

    sayHello() {
        console.log(&#39;大家好，我是&#39;+this.name);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-泛型generic&#34;&gt;4、泛型（Generic）&lt;/h2&gt;
&lt;p&gt;定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定），此时泛型便能够发挥作用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;function test(arg: any): any{
	return arg;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用泛型：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;function test&amp;lt;T&amp;gt;(arg: T): T{
	return arg;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这里的&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;就是泛型，T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型。所以泛型其实很好理解，就表示某个类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;那么如何使用上边的函数呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方式一（直接使用）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;test(10)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方式二（指定类型）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;test&amp;lt;number&amp;gt;(10)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;也可以在函数后手动指定泛型&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以同时指定多个泛型，泛型间使用逗号隔开：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;function test&amp;lt;T, K&amp;gt;(a: T, b: K): K{
    return b;
}

test&amp;lt;number, string&amp;gt;(10, &amp;quot;hello&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用泛型时，完全可以将泛型当成是一个普通的类去使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类中同样可以使用泛型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;class MyClass&amp;lt;T&amp;gt;{
    prop: T;

    constructor(prop: T){
        this.prop = prop;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除此之外，也可以对泛型的范围进行约束&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;interface MyInter{
    length: number;
}

function test&amp;lt;T extends MyInter&amp;gt;(arg: T): number{
    return arg.length;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">TypeScript 快速入门</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/javascript-shi-xian-dui-jie-gou/"" data-c="
          &lt;h1 id=&#34;引言&#34;&gt;引言&lt;/h1&gt;
&lt;p&gt;堆是前端进阶必不可少的知识，也是面试的重难点，例如内存堆与垃圾回收、Top K 问题等，这篇文章将从基础开始梳理整个堆体系，按以下步骤来讲：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是堆&lt;/li&gt;
&lt;li&gt;怎样建堆&lt;/li&gt;
&lt;li&gt;堆排序&lt;/li&gt;
&lt;li&gt;内存堆与垃圾回收&lt;/li&gt;
&lt;li&gt;Top K 问题&lt;/li&gt;
&lt;li&gt;中位数问题&lt;/li&gt;
&lt;li&gt;最后来一道leetcode题目，加深理解&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面开始吧👇&lt;/p&gt;
&lt;h1 id=&#34;一-堆&#34;&gt;一、堆&lt;/h1&gt;
&lt;p&gt;满足下面两个条件的就是堆：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆是一个&lt;code&gt;完全二叉树&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;堆上的任意节点值都必须大于等于（&lt;strong&gt;大顶堆&lt;/strong&gt;）或小于等于（&lt;strong&gt;小顶堆&lt;/strong&gt;）其左右子节点值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果堆上的任意节点都大于等于子节点值，则称为&lt;strong&gt;大顶堆&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果堆上的任意节点都小于等于子节点值，则称为&lt;strong&gt;小顶堆&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也就是说，在大顶堆中，根节点是堆中最大的元素；&lt;/p&gt;
&lt;p&gt;在小顶堆中，根节点是堆中最小的元素；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1620954825339.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;二-怎样创建一个大小顶堆&#34;&gt;二、怎样创建一个大（小）顶堆&lt;/h1&gt;
&lt;p&gt;我们在上一节说过，完全二叉树适用于数组存储法，而堆又是一个完全二叉树，所以它可以直接使用数组存储法存储：&lt;br&gt;
简单来说：&lt;strong&gt;堆其实可以用一个数组表示，给定一个节点的下标 i （i从1开始） ，那么它的父节点一定为 A[i/2] ，左子节点为 A[2i] ，右子节点为 A[2i+1]&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1620956038194.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Heap() {
    let items = [,]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么怎样去创建一个大顶堆（小顶堆）喃？&lt;/p&gt;
&lt;p&gt;常用的方式有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入式创建：每次插入一个节点，实现一个大顶堆（或小顶堆）&lt;/li&gt;
&lt;li&gt;原地创建：又称堆化，给定一组节点，实现一个大顶堆（或小顶堆）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;三-插入式建堆&#34;&gt;三、插入式建堆&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;插入节点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将节点插入到队尾&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自下往上堆化&lt;/strong&gt;： 将插入节点与其父节点比较，如果插入节点大于父节点（大顶堆）或插入节点小于父节点（小顶堆），则插入节点与父节点调整位置&lt;/li&gt;
&lt;li&gt;一直重复上一步，直到不需要交换或交换到根节点，此时插入完成。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1620956484623.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;function insert(key) {
    items.push(key)
    // 获取存储位置
    let i = items.length-1 
    while (i/2 &amp;gt; 0 &amp;amp;&amp;amp; items[i] &amp;gt; items[i/2]) {  
        swap(items, i, i/2); // 交换 
        i = i/2; 
    }
}  
function swap(items, i, j) {
    let temp = items[i]
    items[i] = items[j]
    items[j] = temp
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;**时间复杂度：**O(logn)，为树的高度&lt;/p&gt;
&lt;h1 id=&#34;四-原地建堆堆化&#34;&gt;四、原地建堆（堆化）&lt;/h1&gt;
&lt;p&gt;假设一组序列：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [,1, 9, 2, 8, 3, 7, 4, 6, 5]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原地建堆的方法有两种：一种是承袭上面插入的思想，即从前往后、自下而上式堆化建堆；与之对应的另一种是，从后往前、自上往下式堆化建堆。其中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;自下而上式堆化&lt;/strong&gt; ：将节点与其父节点比较，如果节点大于父节点（大顶堆）或节点小于父节点（小顶堆），则节点与父节点调整位置&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自上往下式堆化&lt;/strong&gt; ：将节点与其左右子节点比较，如果存在左右子节点大于该节点（大顶堆）或小于该节点（小顶堆），则将子节点的最大值（大顶堆）或最小值（小顶堆）与之交换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;所以，自下而上式堆是调整节点与父节点（往上走），自上往下式堆化是调整节点与其左右子节点（往下走）。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-从前往后-自下而上式堆化建堆&#34;&gt;1. 从前往后、自下而上式堆化建堆&lt;/h2&gt;
&lt;p&gt;这里以小顶堆为例，&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1620957484377.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 原地建堆
function buildHeap(items, heapSize) {
    while(heapSize &amp;lt; items.length - 1) {
        heapSize ++
        heapify(items, heapSize)
    }
}

function heapify(items, i) {
    // 自下而上式堆化
    while (Math.floor(i/2) &amp;gt; 0 &amp;amp;&amp;amp; items[i] &amp;lt; items[Math.floor(i/2)]) {  
        swap(items, i, Math.floor(i/2)); // 交换 
        i = Math.floor(i/2); 
    }
}  

function swap(items, i, j) {
    let temp = items[i]
    items[i] = items[j]
    items[j] = temp
}

// 测试
var items = [,5, 2, 3, 4, 1]
// 初始有效序列长度为 1
buildHeap(items, 1)
console.log(items)
// [empty, 1, 2, 3, 5, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试成功&lt;/p&gt;
&lt;h2 id=&#34;2-从后往前-自上而下式堆化建堆&#34;&gt;2. 从后往前、自上而下式堆化建堆&lt;/h2&gt;
&lt;p&gt;这里以小顶堆为例&lt;/p&gt;
&lt;p&gt;注意：从后往前并不是从序列的最后一个元素开始，而是从最后一个非叶子节点开始，这是因为，叶子节点没有子节点，不需要自上而下式堆化。&lt;/p&gt;
&lt;p&gt;最后一个子节点的父节点为 &lt;code&gt;n/2&lt;/code&gt; ，所以从 &lt;code&gt;n/2&lt;/code&gt; 位置节点开始堆化：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1620958120036.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 原地建堆
// items: 原始序列
// heapSize: 初始有效序列长度
function buildHeap(items, heapSize) {
    // 从最后一个非叶子节点开始，自上而下式堆化
    for (let i = Math.floor(heapSize/2); i &amp;gt;= 1; --i) {    
        heapify(items, heapSize, i);  
    }
}
function heapify(items, heapSize, i) {
    // 自上而下式堆化
    while (true) {
        var minIndex = i;
        if(2*i &amp;lt;= heapSize &amp;amp;&amp;amp; items[i] &amp;gt; items[i*2] ) {
            minIndex = i*2;
        }
        if(2*i+1 &amp;lt;= heapSize &amp;amp;&amp;amp; items[minIndex] &amp;gt; items[i*2+1] ) {
            minIndex = i*2+1;
        }
        if (minIndex === i) break;
        swap(items, i, minIndex); // 交换 
        i = minIndex; 
    }
}  
function swap(items, i, j) {
    let temp = items[i]
    items[i] = items[j]
    items[j] = temp
}

// 测试
var items = [,5, 2, 3, 4, 1]
// 因为 items[0] 不存储数据
// 所以：heapSize = items.length - 1
buildHeap(items, items.length - 1)
console.log(items)
// [empty, 1, 2, 3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试成功&lt;/p&gt;
&lt;h1 id=&#34;五-排序算法堆排序&#34;&gt;五、排序算法：堆排序&lt;/h1&gt;
&lt;h2 id=&#34;1-原理&#34;&gt;1. 原理&lt;/h2&gt;
&lt;p&gt;堆是一棵完全二叉树，它可以使用数组存储，并且大顶堆的最大值存储在根节点（i=1），所以我们可以每次取大顶堆的根结点与堆的最后一个节点交换，此时最大值放入了有效序列的最后一位，并且有效序列减1，有效堆依然保持完全二叉树的结构，然后堆化，成为新的大顶堆，重复此操作，直到有效堆的长度为 0，排序完成。&lt;/p&gt;
&lt;p&gt;完整步骤为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将原序列（n个）转化成一个大顶堆&lt;/li&gt;
&lt;li&gt;设置堆的有效序列长度为 n&lt;/li&gt;
&lt;li&gt;将堆顶元素（第一个有效序列）与最后一个子元素（最后一个有效序列）交换，并有效序列长度减1&lt;/li&gt;
&lt;li&gt;堆化有效序列，使有效序列重新称为一个大顶堆&lt;/li&gt;
&lt;li&gt;重复以上2步，直到有效序列的长度为 1，排序完成&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-动图演示&#34;&gt;2. 动图演示&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1620960371413.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;3-代码实现&#34;&gt;3. 代码实现&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;function heapSort(items) {
    // 构建大顶堆
    buildHeap(items, items.length-1)
    // 设置堆的初始有效序列长度为 items.length - 1
    let heapSize = items.length - 1
    for (var i = items.length - 1; i &amp;gt; 1; i--) {
        // 交换堆顶元素与最后一个有效子元素
        swap(items, 1, i);
        // 有效序列长度减 1
        heapSize --;
        // 堆化有效序列(有效序列长度为 currentHeapSize，抛除了最后一个元素)
        heapify(items, heapSize, 1);
    }
    return items;
}

// 原地建堆
// items: 原始序列
// heapSize: 有效序列长度
function buildHeap(items, heapSize) {
    // 从最后一个非叶子节点开始，自上而下式堆化
    for (let i = Math.floor(heapSize/2); i &amp;gt;= 1; --i) {    
        heapify(items, heapSize, i);  
    }
}
function heapify(items, heapSize, i) {
    // 自上而下式堆化
    while (true) {
        var maxIndex = i;
        if(2*i &amp;lt;= heapSize &amp;amp;&amp;amp; items[i] &amp;lt; items[i*2] ) {
            maxIndex = i*2;
        }
        if(2*i+1 &amp;lt;= heapSize &amp;amp;&amp;amp; items[maxIndex] &amp;lt; items[i*2+1] ) {
            maxIndex = i*2+1;
        }
        if (maxIndex === i) break;
        swap(items, i, maxIndex); // 交换 
        i = maxIndex; 
    }
}  
function swap(items, i, j) {
    let temp = items[i]
    items[i] = items[j]
    items[j] = temp
}

// 测试
var items = [,1, 9, 2, 8, 3, 7, 4, 6, 5]
heapSort(items)
// [empty, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试成功&lt;/p&gt;
&lt;h2 id=&#34;4-复杂度分析&#34;&gt;4. 复杂度分析&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;：建堆过程的时间复杂度是 O(n) ，排序过程的时间复杂度是 O(nlogn) ，整体时间复杂度是 O(nlogn)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;： O(1)&lt;/p&gt;
&lt;h1 id=&#34;六-堆的经典应用-top-k-问题常见于腾讯-字节等面试中&#34;&gt;六、堆的经典应用： Top K 问题（常见于腾讯、字节等面试中）&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是 Top K 问题？简单来说就是在一组数据里面找到频率出现最高的前 K 个数，或前 K 大（当然也可以是前 K 小）的数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这种问题我们该怎么处理喃？我们以从数组中取前 K 大的数据为例，可以按以下步骤来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从数组中取前 K 个数，构造一个小顶堆&lt;/li&gt;
&lt;li&gt;从 K+1 位开始遍历数组，每一个数据都和小顶堆的堆顶元素进行比较，如果小于堆顶元素，则不做任何处理，继续遍历下一元素；如果大于堆顶元素，则将这个元素替换掉堆顶元素，然后再堆化成一个小顶堆。&lt;/li&gt;
&lt;li&gt;遍历完成后，堆中的数据就是前 K 大的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;遍历数组需要 O(N) 的时间复杂度，一次堆化需要 O(logK) 时间复杂度，所以利用堆求 Top K 问题的时间复杂度为 O(NlogK)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用堆求 Top K 问题的优势&lt;/strong&gt;&lt;br&gt;
也许很多人会认为，这种求 Top K 问题可以使用排序呀，没必要使用堆呀&lt;/p&gt;
&lt;p&gt;其实是可以使用排序来做的，将数组进行排序（可以是最简单的快排），去前 K 个数就可以了，so easy&lt;/p&gt;
&lt;p&gt;但当我们需要在一个动态数组中求 Top K 元素怎么办喃，动态数组可能会插入或删除元素，难道我们每次求 Top K 问题的时候都需要对数组进行重新排序吗？那每次的时间复杂度都为 O(NlogN)&lt;/p&gt;
&lt;p&gt;这里就可以使用堆，我们可以维护一个 K 大小的小顶堆，当有数据被添加到数组中时，就将它与堆顶元素比较，如果比堆顶元素大，则将这个元素替换掉堆顶元素，然后再堆化成一个小顶堆；如果比堆顶元素小，则不做处理。这样，每次求 Top K 问题的时间复杂度仅为 O(logK)&lt;/p&gt;
">JavaScript实现堆结构</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/mian-qian-duan-zhi-shi-dian-shu-li-xiang-mu/"" data-c="
          &lt;h1 id=&#34;1-vue-中如何实现监测数组变化&#34;&gt;1. Vue 中如何实现监测数组变化&lt;/h1&gt;
&lt;p&gt;Vue 框架是通过&lt;strong&gt;遍历数组&lt;/strong&gt; 和&lt;strong&gt;递归遍历&lt;/strong&gt;对象，从⽽达到利⽤Object.defineProperty() 也能对对象和数组（部分⽅法的操作）进⾏监听。&lt;/p&gt;
&lt;p&gt;Vue 将被侦听的数组的变更⽅法进⾏了包裹，所以它们也将会触发视图更新。这些被包裹过的⽅法包&lt;br&gt;
括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;push()&lt;/li&gt;
&lt;li&gt;pop()&lt;/li&gt;
&lt;li&gt;shift()&lt;/li&gt;
&lt;li&gt;unshift()&lt;/li&gt;
&lt;li&gt;splice()&lt;/li&gt;
&lt;li&gt;sort()&lt;/li&gt;
&lt;li&gt;reverse()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使⽤函数劫持的⽅式，重写了数组的⽅法&lt;/li&gt;
&lt;li&gt;Vue 将 data 中的数组，进⾏了原型链重写。指向了⾃⼰定义的数组原型⽅法，这样当调⽤数组&lt;br&gt;
API 的时候，可以通知依赖更新。如果数组中包含着引⽤类型。会对数组中的引⽤类型再次进⾏监&lt;br&gt;
控拦截处理&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;2-vue-中的-key-有什么作用&#34;&gt;2. Vue 中的 key 有什么作用&lt;/h1&gt;
&lt;p&gt;所以 Vue 中 key 的作⽤是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;key 是为 Vue 中 vnode 的唯⼀标记，通过这个 key，我们的 diff 操作可以更准确、更快速&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;更准确&lt;/code&gt;：因为带 key 就不是就地复⽤了，在 sameNode 函数&lt;code&gt;a.key === b.key&lt;/code&gt; 对⽐中可以避免就地复⽤的情况。所以会更加准确。&lt;br&gt;
&lt;code&gt;更快速&lt;/code&gt;：利⽤ key 的唯⼀性⽣成 map 对象来获取对应节点，⽐遍历⽅式更快&lt;/p&gt;
&lt;h1 id=&#34;3-你对-vue-项目做过哪些优化&#34;&gt;3. 你对 Vue 项⽬做过哪些优化&lt;/h1&gt;
&lt;h2 id=&#34;1-代码层面的优化&#34;&gt;1. 代码层面的优化&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;v-if 和 v-show 区分使用场景&lt;/li&gt;
&lt;li&gt;computed 和 watch 区分使用场景&lt;/li&gt;
&lt;li&gt;v-for 遍历必须为 item 添加 key，且避免同时使用 v-if&lt;/li&gt;
&lt;li&gt;图片资源懒加载&lt;/li&gt;
&lt;li&gt;路由懒加载&lt;/li&gt;
&lt;li&gt;服务端渲染 SSR or 预渲染&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-webpack-层面的优化&#34;&gt;2. Webpack 层⾯的优化&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Webpack 对图片进行压缩（image-webpack-loader）&lt;/li&gt;
&lt;li&gt;减少 ES6 转为 ES5 的冗余代码（babel-plugin-transform-runtime）&lt;/li&gt;
&lt;li&gt;提取公共代码（CommonsChunkPlugin）&lt;/li&gt;
&lt;li&gt;提取组件的 CSS&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-基础的-web-技术优化&#34;&gt;3. 基础的 Web 技术优化&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;开启 gzip 压缩&lt;/li&gt;
&lt;li&gt;浏览器缓存（静态资源进行缓存）&lt;/li&gt;
&lt;li&gt;CDN 的使用&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;4-vue30特性你有什么了解的吗&#34;&gt;4.  vue3.0特性你有什么了解的吗&lt;/h1&gt;
&lt;p&gt;Vue 3.0 正⾛在发布的路上，Vue 3.0 的⽬标是让 Vue 核⼼变得更⼩、更快、更强⼤，因此 Vue 3.0 增加以下这些新特性：&lt;/p&gt;
&lt;h2 id=&#34;1-监测机制的改变&#34;&gt;1. 监测机制的改变&lt;/h2&gt;
&lt;p&gt;3.0 将带来基于代理 Proxy 的 observer 实现，提供全语⾔覆盖的反应性跟踪。这消除了 Vue 2 当中基于Object.defineProperty 的实现所存在的很多限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只能监测属性，不能监测对象&lt;/li&gt;
&lt;li&gt;检测属性的添加和删除；&lt;/li&gt;
&lt;li&gt;检测数组索引和⻓度的变更；&lt;/li&gt;
&lt;li&gt;⽀持 Map、Set、WeakMap 和 WeakSet。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;新的 observer 还提供了以下特性：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;⽤于创建 observable 的公开 API。这为中⼩规模场景提供了简单轻量级的跨组件状态管理解决⽅&lt;br&gt;
案。&lt;/li&gt;
&lt;li&gt;默认采⽤惰性观察。在 2.x 中，不管反应式数据有多⼤，都会在启动时被观察到。如果你的数据集&lt;br&gt;
很⼤，这可能会在应⽤启动时带来明显的开销。在 3.x 中，只观察⽤于渲染应⽤程序最初可⻅部分&lt;br&gt;
的数据。&lt;/li&gt;
&lt;li&gt;更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。&lt;/li&gt;
&lt;li&gt;不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除⾮系统在内部暂时&lt;br&gt;
将其“解禁”。这个机制可⽤于冻结 prop 传递或 Vuex 状态树以外的变化。&lt;/li&gt;
&lt;li&gt;更好的调试功能：我们可以使⽤新的 renderTracked 和 renderTriggered 钩⼦精确地跟踪组件在&lt;br&gt;
什么时候以及为什么重新渲染。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-模板&#34;&gt;2. 模板&lt;/h2&gt;
&lt;p&gt;模板⽅⾯没有⼤的变更，只改了作⽤域插槽，2.x 的机制导致作⽤域插槽变了，⽗组件会重新渲染，⽽&lt;br&gt;
3.0 把作⽤域插槽改成了函数的⽅式，这样只会影响⼦组件的重新渲染，提升了渲染的性能。&lt;/p&gt;
&lt;p&gt;同时，对于 render 函数的⽅⾯，vue3.0 也会进⾏⼀系列更改来⽅便习惯直接使⽤ api 来⽣成 vdom 。&lt;/p&gt;
&lt;h2 id=&#34;3-对象式的组件声明方式&#34;&gt;3. 对象式的组件声明⽅式&lt;/h2&gt;
&lt;p&gt;vue2.x 中的组件是通过声明的⽅式传⼊⼀系列 option，和 TypeScript 的结合需要通过⼀些装饰器的⽅式来做，虽然能实现功能，但是⽐较麻烦。3.0 修改了组件的声明⽅式，改成了类式的写法，这样使得和&lt;br&gt;
TypeScript 的结合变得很容易。&lt;/p&gt;
&lt;p&gt;此外，vue 的源码也改⽤了 TypeScript 来写。其实当代码的功能复杂之后，必须有⼀个静态类型系统来&lt;br&gt;
做⼀些辅助管理。现在 vue3.0 也全⾯改⽤ TypeScript 来重写了，更是使得对外暴露的 api 更容易结合TypeScript。静态类型系统对于复杂代码的维护确实很有必要。&lt;/p&gt;
&lt;h2 id=&#34;4-其它方面的更改&#34;&gt;4. 其它⽅⾯的更改&lt;/h2&gt;
&lt;p&gt;vue3.0 的改变是全⾯的，上⾯只涉及到主要的 3 个⽅⾯，还有⼀些其他的更改：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;⽀持⾃定义渲染器，从⽽使得 weex 可以通过⾃定义渲染器的⽅式来扩展，⽽不是直接 fork 源码来&lt;br&gt;
改的⽅式。&lt;/li&gt;
&lt;li&gt;⽀持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对⼀些特殊&lt;br&gt;
的场景做了处理。&lt;/li&gt;
&lt;li&gt;基于 treeshaking 优化，提供了更多的内置功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;5-滚动到底部加载更多&#34;&gt;5. 滚动到底部加载更多&lt;/h1&gt;
&lt;p&gt;需要三个高度：&lt;code&gt;scrollHeight&lt;/code&gt;（文档内容实际高度，包括超出视窗的溢出部分）、&lt;code&gt;scrollTop&lt;/code&gt;（滚动条滚动距离）、&lt;code&gt;clientHeight&lt;/code&gt;（窗口可视范围高度）。当 &lt;code&gt;clientHeight + scrollTop &amp;gt;= scrollHeight&lt;/code&gt; 时，表示已经抵达内容的底部了，可以加载更多内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scrollHeight：通过 document.documentElement.scrollHeight 、document.body.scrollHeight 可以获取;&lt;/li&gt;
&lt;li&gt;scrollTop：通过window.pageYOffset 、 document.documentElement.scrollTop 、 document.body.scrollTop 可以获取&lt;/li&gt;
&lt;li&gt;clientHeight：通过window.innerHeight 、 document.documentElement.clientHeight 、 document.body.clientHeight 可以获取;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;   window.onscroll= function(){
        //文档内容实际高度（包括超出视窗的溢出部分）
        var scrollHeight = Math.max(document.documentElement.scrollHeight, document.body.scrollHeight);
        //滚动条滚动距离
        var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
        //窗口可视范围高度
        var clientHeight = window.innerHeight || Math.min(document.documentElement.clientHeight,document.body.clientHeight);
        
        if(clientHeight + scrollTop &amp;gt;= scrollHeight){
            console.log(&amp;quot;===加载更多内容……===&amp;quot;);
        }
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;6-vue无限滚动方案&#34;&gt;6. vue无限滚动方案&lt;/h1&gt;
&lt;h2 id=&#34;1-实现无限滚动逻辑&#34;&gt;1. 实现无限滚动逻辑&lt;/h2&gt;
&lt;p&gt;在组件的方法中，您需要创建一个名为&lt;code&gt;scroll()&lt;/code&gt;的新函数，并将其加载到&lt;code&gt;mounted()&lt;/code&gt;生命周期方法中。&lt;br&gt;
这个&lt;code&gt;scroll()&lt;/code&gt;方法应该有一个简单的条件来计算页面的底部，判断它为true或false，并执行一些操作。我们将利用文档对象的&lt;code&gt;documentElement.scrollTop&lt;/code&gt;，&lt;code&gt;documentElement.offsetHeight&lt;/code&gt;属性和窗口的&lt;code&gt;innerHeight&lt;/code&gt;属性来确定是否滚动到底部：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;window.onscroll = () =&amp;gt; {
  let bottomOfWindow = document.documentElement.scrollTop + window.innerHeight === document.documentElement.offsetHeight;

  if (bottomOfWindow) {
    // Do something, anything!
  }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-性能优化方案&#34;&gt;2. 性能优化方案&lt;/h2&gt;
&lt;p&gt;对此前端业界有一个通用解决方案叫virtualize，虚拟化，就是把整个列表虚拟化，无论你列表元素有多少，我只虚拟化一定数目的元素(大于一屏幕)，然后在滚动过程中动态的更新这些元素，这样的话我们页面重新渲染时候进行的style和layout过程的对象元素就是固定的了，时间不会变长。具体的实现方法参考下图。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1615968713779.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当列表滚动到item8之前，不做任何操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;滚动到8的时候，此时可见区域的元素是4到8，这时更新DOM的8个元素为4到11，也就是说1-8批量更新成了4-11。但是用户可见区域看到的仍然是4到8，只是bench缓冲区的元素添加了9到11三个元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;元素完成了更新，但是滚动条的位置也要完成更新，因为实际上此时可见区域的item4并不是之前列表DOM中的第4个元素了，而是变成了第1个元素，所以滚动条此时位置变回到了列表的起点，这里需要给列表一个padding-top值，设成3倍元素高度size，从而维持滚动条的位置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;7-移动端返回顶部&#34;&gt;7. 移动端返回顶部&lt;/h1&gt;
&lt;p&gt;页面滚动到一定高度出现返回顶部按钮，点击返回顶部，按钮消失&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; mounted() {
	window.addEventListener(&#39;scroll&#39;,function(){
	 var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
	 if(scrollTop&amp;gt;800){
		 document.getElementById(&amp;quot;default_drag_return&amp;quot;).style.visibility=&amp;quot;visible&amp;quot;;
		 
	 }
	 if(scrollTop&amp;lt;800){
		 document.getElementById(&amp;quot;default_drag_return&amp;quot;).style.visibility=&amp;quot;hidden&amp;quot;;
	 }
	 });
  },

  methods: {
	  topreturn:function(){
		  document.documentElement.scrollTop = document.body.scrollTop =0;
		  document.getElementById(&amp;quot;default_drag_return&amp;quot;).style.visibility=&amp;quot;hidden&amp;quot;;
		  
	  }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;8-vue-jwt后台登录权限&#34;&gt;8. Vue - JWT后台登录权限&lt;/h1&gt;
&lt;p&gt;在前后端完全分离的情况下，Vue项目中实现token验证大致思路如下：&lt;/p&gt;
&lt;p&gt;1、第一次登录的时候，前端调后端的登陆接口，发送用户名和密码&lt;br&gt;
2、后端收到请求，验证用户名和密码，验证成功，就给前端返回一个token&lt;br&gt;
3、前端拿到token，将token存储到localStorage和vuex中，并跳转路由页面&lt;br&gt;
4、前端每次跳转路由，就判断 localStroage 中有无 token ，没有就跳转到登录页面，有则跳转到对应路由页面&lt;br&gt;
5、每次调后端接口，都要在请求头中加token&lt;br&gt;
6、后端判断请求头中有无token，有token，就拿到token并验证token，验证成功就返回数据，验证失败（例如：token过期）就返回401，请求头中没有token也返回401&lt;br&gt;
7、如果前端拿到状态码为401，就清除token信息并跳转到登录页面&lt;br&gt;
8、创建vue实例的时候将vue-router挂载，但这个时候vue-router挂载一些登录或者不用权限的公用的页面。&lt;br&gt;
9、当用户登录后，获取用role，将role和路由表每个页面的需要的权限作比较，生成最终用户可访问的路由表。&lt;br&gt;
10、调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由。&lt;br&gt;
11、使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619086516830.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1618468865167.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;0-用户权限信息&#34;&gt;0. 用户权限信息&lt;/h2&gt;
&lt;p&gt;用户登录成功之后，我们会在全局钩子router.beforeEach中&lt;code&gt;拦截路由&lt;/code&gt;，判断是否已获得token，在获得token之后我们就要去获取用户的基本信息了&lt;/p&gt;
&lt;p&gt;&lt;code&gt;主体思路&lt;/code&gt;：前端会有一份路由表，它表示了每一个路由可访问的权限。当用户登录之后，通过token获取用户的role，动态根据用户的role算出其对应有权限的路由，再通过router.addRoutes动态挂载路由。但这些控制都只是页面级的，说白了前端再怎么做权限控制都不是绝对安全的，后端的权限验证是逃不掉的。&lt;/p&gt;
&lt;p&gt;前端来控制页面级的权限，不同权限的用户显示不同的侧边栏和限制其所能进入的页面(也做了少许按钮级别的权限控制)，后端则会验证每一个涉及请求的操作，验证其是否有该操作的权限，每一个后台的请求不管是 get 还是 post 都会让前端在请求header里面携带用户的token，后端会根据该token来验证用户是否有权限执行该操作。若没有权限则抛出一个对应的状态码，前端检测到该状态码，做出相对应的操作。&lt;/p&gt;
&lt;h2 id=&#34;1-令牌组成&#34;&gt;1. 令牌组成&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;header.payload.signature&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;标头(Header)&lt;/li&gt;
&lt;li&gt;有效载荷(Payload)&lt;/li&gt;
&lt;li&gt;签名(Signature)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，JWT通常如下所示：xxxx.yyyy.zzzz&lt;/p&gt;
&lt;h2 id=&#34;2-header&#34;&gt;2. Header&lt;/h2&gt;
&lt;p&gt;标头通常由两部分组成：令牌的类型(JWT)和所使用的签名算法，例如HMAC SHA256或RSA。它会使用 Base64 编码组成 JWT 结构的第一部分。&lt;/p&gt;
&lt;p&gt;注意：Base64是一种编码，也就是说，它是可以被翻译回原来的样子来的。它并不是一种加密过程。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;alg&amp;quot;:&amp;quot;HS256&amp;quot;,
    &amp;quot;typ&amp;quot;:&amp;quot;JWT&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-payload&#34;&gt;3. Payload&lt;/h2&gt;
&lt;p&gt;令牌的第二部分是有效负载，其中包含声明。声明是有关实体（通常是用户）和其他数据的声明。同样的，它会使用 Base64编码组成JWT结构的第二部分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;sub&amp;quot;:&amp;quot;123456789&amp;quot;,
    &amp;quot;name&amp;quot;:&amp;quot;John Doe&amp;quot;,
    &amp;quot;admin&amp;quot;:true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-signature&#34;&gt;4. Signature&lt;/h2&gt;
&lt;p&gt;前面两部分都是使用Base64进行编码的，即前端可以解开知道里面的信息。Signature 需要使用编码后的 header 和 payload 以及我们提供的一个密钥，然后使用 header 中指定的签名算法(HS256)进行签名。签名的作用是保证JWT没有被篡改过&lt;br&gt;
如：&lt;br&gt;
HMACSHA256(base64UrlEncode(header) + &amp;quot;.&amp;quot; + base64UrlEncode(payload) , secret);&lt;/p&gt;
&lt;h2 id=&#34;5-签名目的&#34;&gt;5. 签名目的&lt;/h2&gt;
&lt;p&gt;最后一步签名的过程，实际上是对头部以及负载内容进行签名，防止内容被窜改。如果有人对头部以及负载的内容解码之后进行修改，再进行编码，最后加上之前的签名组合形成新的JWT的话，那么服务器端会判断出新的头部和负载形成的签名和JWT附带上的签名是不一样的。如果要对新的头部和负载进行签名，在不知道服务器加密时用的密钥的话，得出来的签名也是不一样的。&lt;/p&gt;
&lt;h2 id=&#34;6-信息安全问题&#34;&gt;6. 信息安全问题&lt;/h2&gt;
&lt;p&gt;在这里大家一定会问一个问题：Base64是一种编码，是可逆的，那么我的信息不就被暴露了吗?&lt;/p&gt;
&lt;p&gt;是的。所以，在JWT中，不应该在负载里面加入任何敏感的数据。在上面的例子中，我们传输的是用户的User ID。这个值实际上不是什么敏感内容，一般情况下被知道也是安全的。但是像密码这样的内容就不能被放在JWT中了。如果将用户的密码放在了JWT中，那么怀有恶意的第三方通过Base64解码就能很快地知道你的密码了。因此JWT适合用于向Web应用传递一些非敏感信息。JWT还经常用于设计用户认证和授权系统，甚至实现Web应用的单点登录。&lt;/p&gt;
&lt;h2 id=&#34;7-认证流程&#34;&gt;7. 认证流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload(负载)，将其与头部分别进行Base64编码拼接后签名，形成一个JWT(Token)。形成的JWT就是一个形同111.zzz.xxx的字符串。token head.payload.signature&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后端将JWT字符串作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在localStorage或sessionStorage上，退出登录时前端删除保存的JWT即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前端在每次请求时将JWT放入HTTP Header中的Authorization位。(解决XSS和XSRF问题）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确；检查Token是否过期；检查Token的接收方是否是自己(可选)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;8-jwt优势&#34;&gt;8. JWT优势&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;简洁(Compact)：可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快&lt;/li&gt;
&lt;li&gt;自包含(Self-contained)：负载中包含了所有用户所需要的信息，避免了多次查询数据库&lt;/li&gt;
&lt;li&gt;因为Token是以JSON加密的形式保存在客户端的，所以JWT是跨语言的，原则上任何web形式都支持。&lt;/li&gt;
&lt;li&gt;不需要在服务端保存会话信息，特别适用于分布式微服务。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619086600490.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;9-vue实现带进度条的文件拖动上传&#34;&gt;9. Vue实现带进度条的文件拖动上传&lt;/h1&gt;
&lt;h2 id=&#34;1-基本界面&#34;&gt;1. 基本界面&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot;
          content=&amp;quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&amp;quot;&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot;&amp;gt;
    &amp;lt;link href=&amp;quot;https://cdn.bootcss.com/bootstrap/4.0.0/css/bootstrap.min.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
    &amp;lt;script src=&amp;quot;https://cdn.bootcss.com/vue/2.5.13/vue.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;style&amp;gt;
        .dropbox {
            border: .25rem dashed #007bff;
            min-height: 5rem;
        }
    &amp;lt;/style&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&amp;quot;app&amp;quot; class=&amp;quot;m-5&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;dropbox p-3&amp;quot;&amp;gt;
        &amp;lt;h2 class=&amp;quot;text-center&amp;quot;&amp;gt;把要上传的文件拖动到这里&amp;lt;/h2&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
    new Vue({
        el: &#39;#app&#39;,
        data: {},
        methods: {},
        mounted: function () {}
    });
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1615980095840.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;2-检测拖动事件&#34;&gt;2. 检测拖动事件&lt;/h2&gt;
&lt;p&gt;首先让页面支持文件拖拽，在 Vue 的&lt;code&gt;mounted()&lt;/code&gt; 函数中添加代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mounted: function () {
    var dropbox = document.querySelector(&#39;.dropbox&#39;);
    dropbox.addEventListener(&#39;dragenter&#39;, this.onDrag, false);
    dropbox.addEventListener(&#39;dragover&#39;, this.onDrag, false);
    dropbox.addEventListener(&#39;drop&#39;, this.onDrop, false);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当把文件拖动到浏览器的拖动区域时，会触发三种事件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文件第一次进入拖动区时，触发 dragenter 事件&lt;/li&gt;
&lt;li&gt;文件在拖动区来回拖拽时，不断触发 dragover 事件&lt;/li&gt;
&lt;li&gt;文件已经在拖动区，并松开鼠标时，触发 drop 事件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实现拖动上传，我们只需要关心 drop 事件。不过另外两个事件也需要监听，目的是阻止浏览器默认行为。如果不阻止，那么把文件拖到浏览器时，浏览器就会自动下载这个文件（默认行为），drop 事件触发不出来。&lt;/p&gt;
&lt;p&gt;事件的监听函数添加在 Vue 的 &lt;code&gt;methods&lt;/code&gt; 对象中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;methods: {
    uploadFile: function (file) {
        console.log(file);
    },
    onDrag: function (e) {
        e.stopPropagation();
        e.preventDefault();
    },
    onDrop: function (e) {
        e.stopPropagation();
        e.preventDefault();
        var dt = e.dataTransfer;
        for (var i = 0; i !== dt.files.length; i++) {
            this.uploadFile(dt.files[i]);
        }
    }
},
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;onDrop()&lt;/code&gt; 函数中，通过&lt;code&gt;e.dataTransfer.files&lt;/code&gt; 可以拿到用户拖动到浏览器的文件的基本信息，&lt;code&gt;uploadFile()&lt;/code&gt; 函数现在只这些信息打印了出来，可以了解到，拖动到浏览器的每个文件都是一个 File 对象：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1615980412873.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-处理拖动事件&#34;&gt;3. 处理拖动事件&lt;/h2&gt;
&lt;p&gt;现在，我们要给 &lt;code&gt;uploadFile()&lt;/code&gt; 函数增加功能，实现拖动文件时，拖动区出现文件名和一个上传进度条。&lt;/p&gt;
&lt;p&gt;首先在 Vue 的 data 对象中定义 &lt;strong&gt;files&lt;/strong&gt; 属性，用来保存所有拖动到浏览器中文件的名称。然后在&lt;code&gt;uploadFile()&lt;/code&gt; 函数每当被调用时，把文件名和上传进度保存到 files 中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data: {
    files: []
},
methods: {
    uploadFile: function (file) {
        var item = {
            name: file.name,
            uploadPercentage: 67
        };
        this.files.push(item);
    },
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上传进度的功能在后面再介绍，先写一个固定值。&lt;/p&gt;
&lt;p&gt;相应地，在HTML代码中，用 &lt;code&gt;v-for&lt;/code&gt; 关键字显示 &lt;code&gt;files&lt;/code&gt; 的每一项：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;dropbox p-3&amp;quot;&amp;gt;
    &amp;lt;h2 class=&amp;quot;text-center&amp;quot;&amp;gt;把要上传的文件拖动到这里&amp;lt;/h2&amp;gt;
    &amp;lt;div class=&amp;quot;border m-2 d-inline-block p-4&amp;quot; style=&amp;quot;width:15rem&amp;quot; v-for=&amp;quot;file in files&amp;quot;&amp;gt;
        &amp;lt;h5 class=&amp;quot;mt-0&amp;quot;&amp;gt;{{ file.name }}&amp;lt;/h5&amp;gt;
        &amp;lt;div class=&amp;quot;progress&amp;quot;&amp;gt;
            &amp;lt;div class=&amp;quot;progress-bar progress-bar-striped&amp;quot;
                    :style=&amp;quot;{ width: file.uploadPercentage+&#39;%&#39; }&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而且，“把要上传的文件拖动到这里” 的提示只在拖动区没有文件的时候才显示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;h2 v-if=&amp;quot;files.length===0&amp;quot; class=&amp;quot;text-center&amp;quot;&amp;gt;把要上传的文件拖动到这里&amp;lt;/h2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样，拖动效果就有了：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1615980581346.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-文件上传&#34;&gt;4. 文件上传&lt;/h2&gt;
&lt;p&gt;接下来实现真正的文件上传，继续往 &lt;code&gt;uploadFile()&lt;/code&gt; 函数添加代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;uploadFile: function (file) {
    var item = {
        name: file.name,
        uploadPercentage: 67
    };
    this.files.push(item);
    var fd = new FormData();
    fd.append(&#39;myFile&#39;, file);

    var xhr = new XMLHttpRequest();
    xhr.open(&#39;POST&#39;, &#39;upload.php&#39;, true);
    xhr.send(fd);
},
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里用到了 FormData，把要上传的文件附在了 FormData 上，并通过AJAX方式发送给PHP端。&lt;/p&gt;
&lt;h2 id=&#34;5-进度条的展示&#34;&gt;5. 进度条的展示&lt;/h2&gt;
&lt;p&gt;基本的上传功能完成了，最后我们来完成进度条。每当AJAX请求发送了一段时间的数据时，都会生成一个 progress 事件，我们可以监听 progress 事件来知道当前的上传进度：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;uploadFile: function (file) {
    ...
    xhr.upload.addEventListener(&#39;progress&#39;, function (e) {
        item.uploadPercentage = Math.round((e.loaded * 100) / e.total);
    }, false);
    xhr.send(fd);
},
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;e.loaded&lt;/code&gt; 代表当前AJAX发送了多少字节，e.total 代表AJAX总共要发送多少字节。通过这两个属性可以计算上传进度的百分比。&lt;/p&gt;
&lt;p&gt;这样，一个带进度条的文件拖动上传功能就完成了。&lt;/p&gt;
&lt;h1 id=&#34;10-formdata传递参数&#34;&gt;10. FormData传递参数&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;FormData的主要用途有两个：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将form表单元素的name与value进行组合，实现表单数据的序列化，从而减少表单元素的拼接，提高工作效率。&lt;/li&gt;
&lt;li&gt;异步上传文件&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;1-创建formdata对象&#34;&gt;1. 创建formData对象&lt;/h2&gt;
&lt;h3 id=&#34;1-创建一个空对象&#34;&gt;1. 创建一个空对象：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;//通过FormData构造函数创建一个空对象
var formdata=new FormData();
//可以通过append()方法来追加数据
formdata.append(&amp;quot;name&amp;quot;,&amp;quot;laotie&amp;quot;);
//通过get方法对值进行读取
console.log(formdata.get(&amp;quot;name&amp;quot;));//laotie
//通过set方法对值进行设置
formdata.set(&amp;quot;name&amp;quot;,&amp;quot;laoliu&amp;quot;);
console.log(formdata.get(&amp;quot;name&amp;quot;));//laoliu
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-通过表单对formdata进行初始化&#34;&gt;2. 通过表单对formData进行初始化&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;创建表单：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form id=&amp;quot;advForm&amp;quot;&amp;gt;
    &amp;lt;p&amp;gt;广告名称：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;advName&amp;quot;  value=&amp;quot;xixi&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;广告类别：&amp;lt;select name=&amp;quot;advType&amp;quot;&amp;gt;
        &amp;lt;option value=&amp;quot;1&amp;quot;&amp;gt;轮播图&amp;lt;/option&amp;gt;
        &amp;lt;option value=&amp;quot;2&amp;quot;&amp;gt;轮播图底部广告&amp;lt;/option&amp;gt;
        &amp;lt;option value=&amp;quot;3&amp;quot;&amp;gt;热门回收广告&amp;lt;/option&amp;gt;
        &amp;lt;option value=&amp;quot;4&amp;quot;&amp;gt;优品精选广告&amp;lt;/option&amp;gt;
    &amp;lt;/select&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;&amp;lt;input type=&amp;quot;button&amp;quot; id=&amp;quot;btn&amp;quot; value=&amp;quot;添加&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;通过表单元素作为参数，实现对formData的初始化：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//获得表单按钮元素
var btn=document.querySelector(&amp;quot;#btn&amp;quot;);
//为按钮添加点击事件
btn.onclick=function(){
    //根据ID获得页面当中的form表单元素
    var form=document.querySelector(&amp;quot;#advForm&amp;quot;);
    //将获得的表单元素作为参数，对formData进行初始化
    var formdata=new FormData(form);
    //通过get方法获得name为advName元素的value值
    console.log(formdata.get(&amp;quot;advName&amp;quot;));//xixi
    //通过get方法获得name为advType元素的value值
    console.log(formdata.get(&amp;quot;advType&amp;quot;));//1 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-操作方法&#34;&gt;2. 操作方法&lt;/h2&gt;
&lt;h3 id=&#34;1-通过getkey与getallkey来获取相对应的值&#34;&gt;1. 通过get(key)与getAll(key)来获取相对应的值&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// 获取key为age的第一个值
formdata.get(&amp;quot;age&amp;quot;); 
 // 获取key为age的所有值，返回值为数组类型
formdata.getAll(&amp;quot;age&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-通过appendkeyvalue在数据末尾追加数据&#34;&gt;2. 通过append(key,value)在数据末尾追加数据&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;//通过FormData构造函数创建一个空对象
var formdata=new FormData();
//通过append()方法在末尾追加key为name值为laoliu的数据
formdata.append(&amp;quot;name&amp;quot;,&amp;quot;laoliu&amp;quot;);
//通过append()方法在末尾追加key为name值为laoli的数据
formdata.append(&amp;quot;name&amp;quot;,&amp;quot;laoli&amp;quot;);
//通过append()方法在末尾追加key为name值为laotie的数据
formdata.append(&amp;quot;name&amp;quot;,&amp;quot;laotie&amp;quot;);
//通过get方法读取key为name的第一个值
console.log(formdata.get(&amp;quot;name&amp;quot;));//laoliu
//通过getAll方法读取key为name的所有值
console.log(formdata.getAll(&amp;quot;name&amp;quot;));//[&amp;quot;laoliu&amp;quot;, &amp;quot;laoli&amp;quot;, &amp;quot;laotie&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-通过setkey-value来设置修改数据&#34;&gt;3. 通过set(key, value)来设置修改数据&lt;/h3&gt;
&lt;p&gt;key的值不存在，会添加一条数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//通过FormData构造函数创建一个空对象
var formdata=new FormData();
//如果key的值不存在会为数据添加一个key为name值为laoliu的数据
formdata.set(&amp;quot;name&amp;quot;,&amp;quot;laoli&amp;quot;);
//通过get方法读取key为name的第一个值
console.log(formdata.get(&amp;quot;name&amp;quot;));//laoli
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;key的值存在，会修改对应的value值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//通过FormData构造函数创建一个空对象
var formdata=new FormData();
//通过append()方法在末尾追加key为name值为laoliu的数据
formdata.append(&amp;quot;name&amp;quot;,&amp;quot;laoliu&amp;quot;);
//通过append()方法在末尾追加key为name值为laoliu2的数据
formdata.append(&amp;quot;name&amp;quot;,&amp;quot;laoliu2&amp;quot;);
//通过get方法读取key为name的第一个值
console.log(formdata.get(&amp;quot;name&amp;quot;));//laoliu
//通过getAll方法读取key为name的所有值
console.log(formdata.getAll(&amp;quot;name&amp;quot;));//[&amp;quot;laoliu&amp;quot;, &amp;quot;laoliu2&amp;quot;]

//将存在的key为name的值修改为laoli
formdata.set(&amp;quot;name&amp;quot;,&amp;quot;laoli&amp;quot;);
//通过get方法读取key为name的第一个值
console.log(formdata.get(&amp;quot;name&amp;quot;));//laoli
//通过getAll方法读取key为name的所有值
console.log(formdata.getAll(&amp;quot;name&amp;quot;));//[&amp;quot;laoli&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-通过haskey来判断是否存在对应的key值&#34;&gt;4. 通过has(key)来判断是否存在对应的key值&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;//通过FormData构造函数创建一个空对象
var formdata=new FormData();
//通过append()方法在末尾追加key为name值为laoliu的数据
formdata.append(&amp;quot;name&amp;quot;,&amp;quot;laoliu&amp;quot;);
//判断是否包含key为name的数据
console.log(formdata.has(&amp;quot;name&amp;quot;));//true
//判断是否包含key为age的数据
console.log(formdata.has(&amp;quot;age&amp;quot;));//false
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-通过deletekey可以删除数据&#34;&gt;5. 通过delete(key)可以删除数据&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;//通过FormData构造函数创建一个空对象
var formdata=new FormData();
//通过append()方法在末尾追加key为name值为laoliu的数据
formdata.append(&amp;quot;name&amp;quot;,&amp;quot;laoliu&amp;quot;);
console.log(formdata.get(&amp;quot;name&amp;quot;));//laoliu
//删除key为name的值
formdata.delete(&amp;quot;name&amp;quot;);
console.log(formdata.get(&amp;quot;name&amp;quot;));//null
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-通过xmlhttprequest发送数据&#34;&gt;3. 通过XMLHttpRequest发送数据&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;创建表单：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form id=&amp;quot;advForm&amp;quot;&amp;gt;
    &amp;lt;p&amp;gt;广告名称：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;advName&amp;quot; value=&amp;quot;xixi&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;广告类别：&amp;lt;select name=&amp;quot;advType&amp;quot;&amp;gt;
        &amp;lt;option value=&amp;quot;1&amp;quot;&amp;gt;轮播图&amp;lt;/option&amp;gt;
        &amp;lt;option value=&amp;quot;2&amp;quot;&amp;gt;轮播图底部广告&amp;lt;/option&amp;gt;
        &amp;lt;option value=&amp;quot;3&amp;quot;&amp;gt;热门回收广告&amp;lt;/option&amp;gt;
        &amp;lt;option value=&amp;quot;4&amp;quot;&amp;gt;优品精选广告&amp;lt;/option&amp;gt;
    &amp;lt;/select&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;广告图片：&amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;advPic&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;广告地址：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;advUrl&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;广告排序：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;orderBy&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;&amp;lt;input type=&amp;quot;button&amp;quot; id=&amp;quot;btn&amp;quot; value=&amp;quot;添加&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;发送数据：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var btn=document.querySelector(&amp;quot;#btn&amp;quot;);
btn.onclick=function(){
    var formdata=new FormData(document.getElementById(&amp;quot;advForm&amp;quot;));
    var xhr=new XMLHttpRequest();
    xhr.open(&amp;quot;post&amp;quot;,&amp;quot;http://127.0.0.1/adv&amp;quot;);
    xhr.send(formdata);
    xhr.onload=function(){
        if(xhr.status==200){
            //...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;11-vue防止用户手动修改url访问非权限页面&#34;&gt;11. Vue防止用户手动修改URL访问非权限页面&lt;/h1&gt;
&lt;p&gt;今天在写filter的时候，要做一个防止用户手动修改URL访问非权限页面的验证。在网上搜索了下，&lt;/p&gt;
&lt;p&gt;发现可以通过：&lt;code&gt;request.getHeader(&amp;quot;referer&amp;quot;);&lt;/code&gt;  &lt;br&gt;
// js的话：javascript:document.referrer来防止，&lt;/p&gt;
&lt;p&gt;如果返回值为null的话，说明是手动修改url访问的，然后进而通过后台，判断是否该登陆用户具&lt;/p&gt;
&lt;p&gt;有访问权限，如果有，放行，否则，跳转到错误页面。&lt;/p&gt;
&lt;p&gt;原理：&lt;code&gt;referer只有从别的页面点击连接来到这页的才会有内容，否则为null。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;request.getHeader(&amp;quot;referer&amp;quot;)的作用：&lt;/strong&gt;&lt;br&gt;
①防止盗连，比如我是个下载软件的网站，在下载页面我先用referer来判断上一页面是不是自己网站，如果不是，说明有人盗连了你的下载地址。&lt;/p&gt;
&lt;p&gt;②电子商务网站的安全，我在提交信用卡等重要信息的页面用referer来判断上一页是不是自己的网站，如果不是，可能是黑客用自己写的一个表单，来提交，为了能跳过你上一页里的javascript的验证等目的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void doFilter(ServletRequest request, ServletResponse response,
			FilterChain chain) throws IOException, ServletException {
		HttpServletRequest req = (HttpServletRequest) request;
		HttpServletResponse resp = (HttpServletResponse) response;
		String conString = &amp;quot;&amp;quot;;
		conString = req.getHeader(&amp;quot;REFERER&amp;quot;);//获取父url--如果不是直接输入的话就是先前的访问过来的页面，要是用户输入了，这个父url是不存在的
		if(&amp;quot;&amp;quot;.equals(conString) || null==conString){ //判断如果上一个目录为空的话，说明是用户直接输入url访问的
			String servletPath = req.getServletPath();//当前请求url，去掉几个可以直接访问的页面
			if(servletPath.contains(&amp;quot;index.jsp&amp;quot;) || servletPath.contains(&amp;quot;admin/login.jsp&amp;quot;)){ //跳过index.jsp和登陆Login.jsp
				chain.doFilter(request, response);
			} else {
				resp.sendRedirect(&amp;quot;/ejuornal/index.jsp&amp;quot;);//跳回首页
			}
		} else {
			chain.doFilter(request, response);
		}
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;12-手动一个v-model组件&#34;&gt;12. 手动一个v-model组件&lt;/h1&gt;
&lt;h2 id=&#34;1-知识储备&#34;&gt;1. 知识储备&lt;/h2&gt;
&lt;p&gt;在开始之前我们先需要知道一些知识，v-model是一个语法糖，如下：&lt;br&gt;
&lt;code&gt;&amp;lt;input type=&amp;quot;text&amp;quot; v-model=&amp;quot;name&amp;quot;&amp;gt;&lt;/code&gt;&lt;br&gt;
实则是等于下面的：&lt;br&gt;
&lt;code&gt;&amp;lt;input type=&amp;quot;text&amp;quot; :value=&amp;quot;name&amp;quot; @input=&amp;quot;name=$event.target.value&amp;quot;&amp;gt;&lt;/code&gt;&lt;br&gt;
也就是说，&lt;strong&gt;v-model就是绑定了一个名为value的props和一个事件input&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;注意：所以在子组件中可以通过props中定义value接受值，然后通过$emit触发input事件传新值并修改。
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1616570989198.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1-最简单的实现方法&#34;&gt;1. 最简单的实现方法&lt;/h2&gt;
&lt;p&gt;综合上述特性，我们可以认为我们要实现自定义组件的双向绑定，其实需要的功能其实是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组件内部可以接收并同步父组件传入的value值&lt;/li&gt;
&lt;li&gt;组件内部可以在该双向绑定值修改时emit一个input事件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们知道，直接修改父组件传入的值（prop）是不被允许的，&lt;br&gt;
而且需要在双向绑定值于组件内部修改时拦截其操作，改为向父组件emit事件&lt;/p&gt;
&lt;p&gt;首先是父组件的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;&amp;quot;&amp;gt;
      &amp;lt;p&amp;gt;{{name}}&amp;lt;/p&amp;gt;
      &amp;lt;son v-model=&amp;quot;name&amp;quot;&amp;gt;&amp;lt;/son&amp;gt;
      &amp;lt;!-- 等同于下面 --&amp;gt;
      &amp;lt;!-- &amp;lt;son type=&amp;quot;text&amp;quot; :value=&amp;quot;name&amp;quot; @input=&amp;quot;name=子组件传回来的值&amp;quot;&amp;gt; --&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
import Son from &#39;./son&#39;
export default {
  name: &amp;quot;&amp;quot;,
  data() {
    return {
        name:&#39;ydw&#39;,
    }
  },
  components: {
      Son
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后是子组件的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class&amp;gt;
      &amp;lt;input type=&amp;quot;text&amp;quot; :value=&amp;quot;value&amp;quot; @input=&amp;quot;$emit(&#39;input&#39;,$event.target.value)&amp;quot;&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
export default {
  name: &amp;quot;&amp;quot;,
  props:{
      value:{
          type: String,
          defalut () 
              return &#39;&#39;
          }
      }
  },
  data() {
    return {

    }
  },
  components: {
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;父组件中我加了一个注释的代码行，其实是帮助我自己理解的，不知道有没有小伙伴跟我一样，第一次看的时候压根不知道它在做什么的？哭唧唧。&lt;/p&gt;
&lt;h2 id=&#34;3-使用最新的语法model属性&#34;&gt;3. 使用最新的语法，model属性。&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1616555019332.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
也就是说这个属性是为了回避props定义的value这个名字的。&lt;/p&gt;
&lt;p&gt;下面看看它的用法，我们先看子组件怎么修改：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; :value=&amp;quot;val&amp;quot; @input=&amp;quot;$emit(&#39;change&#39;,$event.target.value)&amp;quot; /&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;                                                 export default {         
  name: &amp;quot;&amp;quot;,
  model:{
    prop:&#39;val&#39;,
    event:&#39;change&#39;
  },
  props: {
    val: {
      type: String,
      defalut() {
        return &amp;quot;&amp;quot;;
      }
    }
  },
  data() {                                                       
    return {                                                                  
    };
  }
};
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;model属性中prop是重新命名传值的名字，而event则是重新命名事件的名字，但是同样的，props中的传值名字必须与model属性中的prop的名字一样。其实只要对比一下第一种方法就知道，vue多出一个model属性是为了value这个名字可以使用。&lt;/p&gt;
&lt;h2 id=&#34;4-vue20封装elementui&#34;&gt;4. Vue2.0封装elementUI&lt;/h2&gt;
&lt;p&gt;首先讲我简单的封装代码上来：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;form-container&amp;quot;&amp;gt;
    &amp;lt;el-form
      :model=&amp;quot;filterObject&amp;quot;
      label-position=&amp;quot;left&amp;quot;
      :label-width=&amp;quot;labelWidth&amp;quot;
    &amp;gt;
      &amp;lt;el-row :gutter=&amp;quot;10&amp;quot;&amp;gt;
        &amp;lt;el-col
          v-for=&amp;quot;item in formData&amp;quot;
          :key=&amp;quot;item.prop&amp;quot;
          :span=&amp;quot;item.span || 8&amp;quot;
        &amp;gt;
          &amp;lt;el-form-item :label=&amp;quot;item.label&amp;quot;&amp;gt;
            &amp;lt;el-input
              v-if=&amp;quot;item.type === &#39;text&#39;&amp;quot;
              v-model=&amp;quot;filterObject[item.prop]&amp;quot;
              clearable
              :disabled=&amp;quot;item.disabled || false&amp;quot;
              :placeholder=&amp;quot;item.placeholder&amp;quot;
            &amp;gt;&amp;lt;/el-input&amp;gt;

            &amp;lt;el-select
              v-if=&amp;quot;item.type === &#39;select&#39;&amp;quot;
              v-model=&amp;quot;filterObject[item.prop]&amp;quot;
              clearable
              :placeholder=&amp;quot;item.placeholder&amp;quot;
              @change=&amp;quot;handleChange&amp;quot;
            &amp;gt;
              &amp;lt;el-option
                v-for=&amp;quot;sub in item.arr&amp;quot;
                :key=&amp;quot;sub.value&amp;quot;
                :label=&amp;quot;sub.label&amp;quot;
                :value=&amp;quot;sub.value&amp;quot;
              &amp;gt;&amp;lt;/el-option&amp;gt;
            &amp;lt;/el-select&amp;gt;
          &amp;lt;/el-form-item&amp;gt;
        &amp;lt;/el-col&amp;gt;
      &amp;lt;/el-row&amp;gt;
    &amp;lt;/el-form&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
  model: {
    prop: &#39;filterObject&#39;,
    event: &#39;change&#39;,
  },
  props: {
    filterObject: {
      type: Object,
      default() {
        return {}
      },
    },
    labelWidth: {
      type: String,
      default: &#39;80px&#39;,
    },
    formData: {
      type: Array,
      default() {
        return []
      },
    },
  },
  data() {
    return {}
  },
  methods: {
    handleChange() {
      console.log(this.filterObject)
    },
  },
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中的&lt;strong&gt;filterObject&lt;/strong&gt;就是今天的主角了，我的想法是在父组件直接传递一个对象进来，在进行相关操作的时候，父组件直接可以在外面用到这些值，而不是通过子组件暴露方法获取这些值。(ps:在封装search组件的时候可以这么做，向外暴露search，reset方法可以暴露子组件里面的值。&lt;strong&gt;其实封装search跟这个form有点相似，都是用elementUI的form表单来封装的。&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;接下来是父组件的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;home&amp;quot;&amp;gt;
    &amp;lt;HHform
      :formData=&amp;quot;searchOptions&amp;quot;
      labelWidth=&amp;quot;120px&amp;quot;
      v-model=&amp;quot;filterObject&amp;quot;
    &amp;gt;&amp;lt;/HHform&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import HHform from &#39;@/components/HH-form&#39;
export default {
  name: &#39;Home&#39;,
  components: {
    HHform,
  },
  data() {
    return {
      searchOptions: [
        {
          type: &#39;select&#39;,
          prop: &#39;status&#39;,
          label: &#39;状态：&#39;,
          span: 5,
          placeholder: &#39;请选择&#39;,
          arr: [
            {
              value: &#39;&#39;,
              label: &#39;全部招生顾问&#39;,
            },
            {
              value: 1,
              label: &#39;正常招顾&#39;,
            },
            {
              value: 2,
              label: &#39;冻结招顾&#39;,
            },
          ],
        },
        {
          type: &#39;select&#39;,
          prop: &#39;region&#39;,
          label: &#39;地区：&#39;,
          span: 5,
          placeholder: &#39;请选择&#39;,
          arr: [],
        },
        {
          type: &#39;text&#39;,
          prop: &#39;userName&#39;,
          span: 8,
          label: &#39;招生顾问名称：&#39;,
          placeholder: &#39;选择或输入搜索&#39;,
        },
        {
          type: &#39;text&#39;,
          prop: &#39;phone&#39;,
          label: &#39;手机号：&#39;,
          span: 5,
          placeholder: &#39;选择或输入搜索&#39;,
        },
      ],
      filterObject: {},
    }
  },
  methods: {},
  },
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;父组件的代码比较简单，直接通过v-model传值过去就行了。下面是演示效果。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616568833036.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;目前封装form组件的时候是使用这种方法，父组件直接传值的话，不需要子组件提供方法返回值。在封装search组件的时候则是使用子组件暴露方法的方式拿到值的，为什么这么做呢？因为在进行搜索的时候一定会暴露search跟reset方法，这时候带出去就行了。&lt;/p&gt;
&lt;h1 id=&#34;13-大数据量表格加载慢的问题解决方案&#34;&gt;13. 大数据量表格加载慢的问题解决方案&lt;/h1&gt;
&lt;p&gt;由于目前表格实现技术是通过vue+elementUI实现的，所以以上解决方法都是通过vue+js+elementUI实现的，不过思路适用于其他技术。&lt;/p&gt;
&lt;p&gt;总共有以下几种方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个页面加载所有数据&lt;/li&gt;
&lt;li&gt;假分页加载数据（滚动加载数据）&lt;/li&gt;
&lt;li&gt;无限分页加载数据&lt;/li&gt;
&lt;li&gt;真分页加载数据（滚动加载数据）&lt;/li&gt;
&lt;li&gt;模拟滚动实现加载数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-一个页面加载所有数据&#34;&gt;1. 一个页面加载所有数据&lt;/h2&gt;
&lt;p&gt;这个其实就是elementUI自带的table表格功能，一个页面加载所有数据。&lt;/p&gt;
&lt;p&gt;这种方案优点就是非常简单啊，直接调用接口获取到数据，然后传入所有数据，最后一行一行全部渲染出来。&lt;/p&gt;
&lt;p&gt;但是缺点同样明显，首先要通过后台获取数据，如果数据非常多，那么数据越多接口返回速度就越慢，你就只能看着加载圈圈一直在转啊转。数据返回后还得渲染到页面上，数据量小你可能感觉不到什么，但是数据一旦一多比如一次渲染100条、1000条以上的数据，那么页面就会卡住直到数据渲染到页面上。所以这时就要有新的解决方法了。&lt;/p&gt;
&lt;h2 id=&#34;2-假分页显示数据滚动加载数据&#34;&gt;2. 假分页显示数据（滚动加载数据）&lt;/h2&gt;
&lt;p&gt;因为后台接口返回数据并不是很慢，但是表格渲染造成页面非常卡。所以这时就需要想一种方法让数据一次不全部渲染完，而是分批渲染。一次只渲染一部分数据，前一次数据渲染完后再渲染新的数据。&lt;/p&gt;
&lt;p&gt;这里有两种方案实现。一种就是利用elementUI中的分页器和表格实现，每次只加载当前页面的数据。比如有1000条数据，每页显示100条数据，就会分为10页，第一页显示0-100区间的数据，第二页显示100-200区间的数据，以此类推。通过点击不同页实现数据的截取。另外一种就是不需要分页器，还是在一页显示，只不过首次只加载一部分数据，当鼠标滚动到列表底部的时候再加载其他部分数据，实现思路和假分页其实一样，只不过展示不同，这种情况适用于手机上列表加载上。&lt;/p&gt;
&lt;p&gt;这两种方案优点是优化了假数据的渲染速度。&lt;/p&gt;
&lt;p&gt;缺点还是没解决后台接口返回数据慢的问题。而且就算分页，一页展示的数据量还是很多、表格复杂的时候还是卡顿。你可能会说一页展示尽可能少的数据，但是如果实际情况是最少展示100条数据，这种方法就不行。&lt;/p&gt;
&lt;h2 id=&#34;3-无限分页加载数据&#34;&gt;3. 无限分页加载数据&lt;/h2&gt;
&lt;p&gt;由于数据库中数据量增加的非常快，浏览表格时就不能确定总数，否则确定总数后分页器总页数也就固定了。就会造成最后一页的数据有可能显示的不是最新的。比如日志记录统计，这个变化非常快，一会就增加几十条。由于滚动加载的方式可以不用知道总数，就可以使用滚动加载的方式。不过PC端一般都是分页的，所以分页要解决这个问题就必须不确定总数，一直有下一页，可以点击请求后台接口，直到获取没有数据为止。&lt;/p&gt;
&lt;p&gt;所以就有了无限分页。实现方式是基于假分页上的。它的思路是先显示前6页的数据，不展示总页数。当点击第6页时再次调用接口返回7-13页数据，以此类推，如果返回的数据量不足6*每页数量则表示目前所有数据已返回了。&lt;/p&gt;
&lt;p&gt;这种方案优点是可以在&lt;code&gt;不知道总条数的情况下获取实时部分数据&lt;/code&gt;。因为多次请求接口，接口数据返回速度提升。适用于数据量大、数据增加速度快的场景。&lt;/p&gt;
&lt;p&gt;缺点是不常用，不好确定数据总数，场景固定。&lt;/p&gt;
&lt;h2 id=&#34;4-真分页加载数据滚动加载数据&#34;&gt;4. 真分页加载数据（滚动加载数据）&lt;/h2&gt;
&lt;p&gt;由于接口数据返回速度慢，导致表格加载变慢。前面无限分页已经优化了这个问题，但是无限分页不适用于一般的场景。要解决这个问题就必须&lt;code&gt;多次调用&lt;/code&gt;接口返回部分数据，而不是一次返回所有数据。&lt;/p&gt;
&lt;p&gt;有两种方案解决，一种是真分页，实现方式是基于假分页上的，只不过假分页是在所有数据上截取，而真分页是调用接口实现的。而且还得改动一些勾选全选逻辑，利用缓存记录不同页的勾选情况。它的思路是每次点击分页就给后台发送带当前页参数的请求，请求当前页的数据。另一种就是不需要分页器，还是在一页显示，当鼠标滚动到列表底部的时候再请求其他部分数据，实现思路和真分页其实一样，只不过展示不同，这种情况适用于手机上列表加载上。&lt;/p&gt;
&lt;p&gt;优点是接口调用速度提升到最优了。&lt;/p&gt;
&lt;p&gt;缺点是一页渲染的数据还是很多、表格复杂的时候还是卡顿。而且代码实现批量操作不同页数据的情况比较复杂。&lt;/p&gt;
&lt;h2 id=&#34;5-模拟滚动实现加载数据&#34;&gt;5. 模拟滚动实现加载数据&lt;/h2&gt;
&lt;p&gt;这种情况和后台接口返回速度没关系，只是为了解决单页面数据量大时的渲染问题。由于某些特定情况导致表格结构复杂、浏览器版本低，导致真分页情况下单页100条数据渲染都消耗很长时间。所以必须想一种方法解决单页可以渲染大量数据而不影响性能。&lt;/p&gt;
&lt;p&gt;因为电脑显示屏就那么大，加载表格时你能直观看见的也就最多20条数据左右。所以为什么不可以只渲染20条数据左右，然后鼠标滚动就更新当前数据，DOM数量也就不会增加。就算你有百万条数据，你能直观看见的只能是20条数据左右，你只能通过总条数、滚动条来判断总数。总条数可以通过数据的数量来得到，所以只需要模拟滚动条位置就行了。滚动条一滚动就根据滚动条位置拿到能看见的数据。其实就是通过欺骗用户视觉来达到目的。&lt;/p&gt;
&lt;p&gt;你现在有100条数据需要显示在表格中，你直观只能看见20条数据左右，所以你只需要固定表格高度、每行高度就可以知道20行数据的高度，以及其余80条数据的总高度。所以现在加载100条数据的表格可以变成顶部空的只有高度的div和中部你看见的20条数据和底部空的只有高度的div的组合。滚动条向下滚动的时候增加顶部div的高度，减少底部div的高度，改变中部显示的数据。这样就实现了模拟滚动的功能。&lt;/p&gt;
&lt;p&gt;优点是优化了表格渲染的性能。可以和假分页真分页一起使用。可以摆脱复杂的分页实现方式，只用单页渲染不卡顿。&lt;/p&gt;
&lt;p&gt;缺点是实现起来比较复杂。&lt;/p&gt;
&lt;h2 id=&#34;6-总结&#34;&gt;6. 总结&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618378715611.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;14-前端性能监控你会监控哪些数据&#34;&gt;14. 前端性能监控你会监控哪些数据?&lt;/h1&gt;
&lt;h2 id=&#34;1-为什么要做性能监控&#34;&gt;1. 为什么要做性能监控&lt;/h2&gt;
&lt;p&gt;对于公司来说，性能在一定程度上与利益直接相关&lt;/p&gt;
&lt;p&gt;为什么性能会影响公司的收益呢？根本原因还是在于性能影响了用户体验。加载的延迟、操作的卡顿等都会影响用户的使用体验。尤其是移动端，用户对页面响应延迟和连接中断的容忍度很低。想象一下你拿着手机打开一个网页想看到某个信息却加载半天的心情，你很可能选择直接离开换一个网页。谷歌也将页面加载速度作为 SEO 的一个权重&lt;/p&gt;
&lt;h2 id=&#34;2-哪些点需要监控&#34;&gt;2. 哪些点需要监控&lt;/h2&gt;
&lt;p&gt;我们可以分为以下几个点来进行监控&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;白屏时间&lt;/li&gt;
&lt;li&gt;首屏时间&lt;/li&gt;
&lt;li&gt;用户可操作时间&lt;/li&gt;
&lt;li&gt;总下载时间&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-白屏时间&#34;&gt;1. 白屏时间&lt;/h3&gt;
&lt;p&gt;白屏时间是用户首次看到内容的时间，也叫做首次渲染时间，chrome 高版本有 firstPaintTime 接口来获取这个耗时，但大部分浏览器并不支持，必须想其他办法来监测。仔细观察 WebPagetest 视图分析发现，白屏时间出现在头部外链资源加载完附近，因为浏览器只有加载并解析完头部资源才会真正渲染页面。基于此我们可以通过获取头部资源加载完的时刻来近似统计白屏时间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE HTML&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;/&amp;gt;
    &amp;lt;script&amp;gt;
      var start_time = +new Date; //测试时间起点，实际统计起点为 
    &amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;  
    &amp;lt;script&amp;gt;
      var end_time = +new Date; //时间终点
      var headtime = end_time - start_time; //头部资源加载时间    
      console.log(headtime);
    &amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-首屏时间&#34;&gt;2. 首屏时间&lt;/h3&gt;
&lt;p&gt;首屏时间的统计比较复杂，因为涉及图片等多种元素及异步渲染等方式。观察加载视图可发现，影响首屏的主要因素的图片的加载。通过统计首屏内图片的加载时间便可以获取首屏渲染完成的时间。统计流程如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;首屏位置调用 API 开始统计 -&amp;gt; 
绑定首屏内所有图片的 load 事件 -&amp;gt; 页面加载完后判断图片是否在首屏内，找出加载最慢的一张 -&amp;gt;
首屏时间
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-可操作时间&#34;&gt;3. 可操作时间&lt;/h3&gt;
&lt;p&gt;用户可操作默认可以统计domready时间，因为通常会在这时候绑定事件操作。对于使用了模块化异步加载的 JS 可以在代码中去主动标记重要 JS 的加载时间，这也是产品指标的统计方式&lt;/p&gt;
&lt;h3 id=&#34;4-总下载时间&#34;&gt;4. 总下载时间&lt;/h3&gt;
&lt;p&gt;总下载时间默认可以统计onload时间，这样可以统计同步加载的资源全部加载完的耗时。如果页面中存在很多异步渲染，可以将异步渲染全部完成的时间作为总下载时间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;白屏时间指head内资源加载完成&lt;/li&gt;
&lt;li&gt;首屏时间指可视区域内最后一张图片加载完成的时间&lt;/li&gt;
&lt;li&gt;可操作时间指Document.onready时间&lt;/li&gt;
&lt;li&gt;总下载时间指Document.onload时间&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;15-谈谈对前后端分离的理解&#34;&gt;15. 谈谈对前后端分离的理解&lt;/h1&gt;
&lt;p&gt;前后端分离，应该是&lt;code&gt;分离业务&lt;/code&gt;、&lt;code&gt;分离开发&lt;/code&gt;、&lt;code&gt;分离部署&lt;/code&gt;，前后端之间只有HTTP(S)上的JSON通信，做到松耦合。后台只需以REST或GraphQL的API向前端提供服务。&lt;/p&gt;
&lt;p&gt;简单来说，前后端分离，后端主要处理业务逻辑，提供api接口，前端就是调用后端的接口，实现前端页面的交互逻辑，运用nodejs或者ajax进行交互。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优势，整个项目的开发权重向前移，实现真正的前后端解耦，静态资源和动态资源分离，提高了性能和扩展性&lt;/li&gt;
&lt;li&gt;减少后端服务器压力，不再是全局刷新，实现异步加载，局部刷新。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前后端分离的初衷是用「&lt;code&gt;单一职责&lt;/code&gt;」原则把代码质量提上去，很难想象为什么之前的开发者连这么基本的原则都不知道吧，其实是因为以前没有AJAX这项技术，而且前端代码太少了，不值得花时间分离。后来突然Web 大爆发，JS代码和CSS代码从几百行跃升到几千行甚至几万行，不分一下就说不过去了。&lt;/p&gt;
">【面】前端知识点梳理（Vue项目）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/mian-qian-duan-zhi-shi-dian-shu-li-shou-xie-ti/"" data-c="
          &lt;h1 id=&#34;1-ip地址与整数的相互转换&#34;&gt;1 ip地址与整数的相互转换&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;//IP转成整型
function _ip2int(ip) 
{
    var num = 0;
    ip = ip.split(&amp;quot;.&amp;quot;);
    num = Number(ip[0]) * 256 * 256 * 256 + Number(ip[1]) * 256 * 256 + Number(ip[2]) * 256 + Number(ip[3]);
    num = num &amp;gt;&amp;gt;&amp;gt; 0;
    return num;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;//整型解析为IP地址
function _int2iP(num) 
{
    var str;
    var tt = new Array();
    tt[0] = (num &amp;gt;&amp;gt;&amp;gt; 24) &amp;gt;&amp;gt;&amp;gt; 0;
    tt[1] = ((num &amp;lt;&amp;lt; 8) &amp;gt;&amp;gt;&amp;gt; 24) &amp;gt;&amp;gt;&amp;gt; 0;
    tt[2] = (num &amp;lt;&amp;lt; 16) &amp;gt;&amp;gt;&amp;gt; 24;
    tt[3] = (num &amp;lt;&amp;lt; 24) &amp;gt;&amp;gt;&amp;gt; 24;
    str = String(tt[0]) + &amp;quot;.&amp;quot; + String(tt[1]) + &amp;quot;.&amp;quot; + String(tt[2]) + &amp;quot;.&amp;quot; + String(tt[3]);
    return str;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2-手写原生ajax&#34;&gt;2. 手写原生Ajax&lt;/h1&gt;
&lt;h2 id=&#34;get请求&#34;&gt;Get请求&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const xhr = new XMLHttpRequest()
        xhr.open(&amp;quot;GET&amp;quot;, &amp;quot;http://localhost:3000/users?id=1&amp;quot;)
        xhr.send(null)

        xhr.onreadystatechange = function () {
            if (this.readyState === 4) {
                console.log(this.responseText);
            }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;post请求&#34;&gt;Post请求&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const xhr = new XMLHttpRequest()
        xhr.open(&amp;quot;POST&amp;quot;, &amp;quot;http://localhost:3000/users&amp;quot;)
        xhr.setRequestHeader(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)
        // 转换为json传递
        xhr.send(JSON.stringify({
            &amp;quot;name&amp;quot;: &amp;quot;luke&amp;quot;,
            &amp;quot;age&amp;quot; : 19,
            &amp;quot;class&amp;quot;: 2
        }))

        xhr.onreadystatechange = function () {
            if (this.readyState === 4) {
                console.log(this.responseText);
            }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3-手写实现-bind&#34;&gt;3. 手写实现 bind()&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;Function.prototype.MyBind = function (context, ...args) {
  let self = this;
  return function() {
    return self.apply(context, args);
  }
}

// test
let a = {name: &#39;jack&#39;} 
let test = function() {
  console.log(this.name); // jack
}
let rs = test.MyBind(a);
rs();
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;4-手写实现-apply&#34;&gt;4. 手写实现 apply()&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;Function.prototype.myApply = function (context, args) {
  context.fn = this;
  let res;
  if (!args){
    res = context.fn();
  } else  {
    res = context.fn(...args)
  }
  return res;
}

// test
let obj = {
  name: &#39;jack&#39;
}
function test(arg1, arg2, arg3) {
  console.log(this.name)   // jack
  console.log(arg1, arg2, arg3);  // 1 2 3
}
test.myApply(obj, [1,2,3]);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5-手写实现-call&#34;&gt;5. 手写实现 call()&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;Function.prototype.myCall = function (context, ...rest) {
  context.fn = this;
  var result = context.fn(...rest);
  delete context.fn;
  return result;
}

// test
let obj = {
  name: &#39;jack&#39;
}
function test(arg1, arg2, arg3) {
  console.log(this.name)   // jack
  console.log(arg1, arg2, arg3);  // 1 2 3
}
test.myCall(obj, 1,2,3);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;6-手写实现-instanceof&#34;&gt;6. 手写实现 instanceof&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function myInstanceOf(left, right) {
  let prototype = right.prototype;
  left = left.__proto__;
  while(true) {
    if (!left) return false;
    if (left == prototype) return true;
    left = left.__proto__;
  }
}

console.log(myInstanceOf([], Array));  // true
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;7-手写实现-new&#34;&gt;7. 手写实现 new&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function myNew (fun, ...args) {
  let obj = {};
  obj.__proto__ = fun.prototype;
  let res = fun.apply(obj, args);
  return res instanceof Object ? res : obj;
}

function Animal(name) {
  this.name = name;
}
let animal = myNew(Animal, &#39;dog&#39;);
console.log(animal.name)  // dog
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;8-手写实现-jsonp&#34;&gt;8. 手写实现 jsonp&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;var newscript = document.createElement(&#39;script&#39;);
newscript.src = &#39;https://www.adb.com?callback=fn&#39;
document.body.appendChild(newscript);
function fn(data) {
  console.log(data);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;9-手写实现-promise&#34;&gt;9. 手写实现 Promise&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const PENDING = Symbol();
const REJECTED = Symbol();
const FULLFILLED = Symbol();

const MyPromise = function(fn) {
  this.state = PENDING;
  this.value = &#39;&#39;;

  const resolve = (value) =&amp;gt; {
    this.state = FULLFILLED;
    this.value = value;
  }

  const reject = (error) =&amp;gt; {
    this.state = REJECTED;
    this.value = error;
  }

  this.then = (onFullFill, onReject) =&amp;gt; {
    if (this.state == FULLFILLED) {
      onFullFill(this.value);
    } else {
      onReject(this.value);
    }
  }

  try {
    fn(resolve, reject);
  } catch(error) {
    reject(error);
  }
}

// test
let p = new MyPromise((resolve, reject) =&amp;gt; {
  resolve(&#39;hello&#39;);
})
p.then(res =&amp;gt; {
  console.log(res);  // hello
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;10-手写实现promiseall&#34;&gt;10. 手写实现promise.all()&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function isPromise(obj) {
  return !!obj &amp;amp;&amp;amp; (typeof obj === &#39;function&#39; || typeof obj === &#39;object&#39;) &amp;amp;&amp;amp; typeof obj.then == &#39;function&#39;;
}

function myPromiseAll(arr) {
  let res = []
  return new Promise((resolve, reject) =&amp;gt; {
    for (let i = 0; i &amp;lt; arr.length; i++) {
      if (isPromise(arr[i])) {
        arr[i].then(data =&amp;gt; {
          res[i] = data;
          if (res.length === arr.length) {
            resolve(res)
          }
        }).catch(error =&amp;gt; {
          reject(error)
        })
      } else {
        res[i] = arr[i];
      }
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;11-手写实现promiserace&#34;&gt;11. 手写实现promise.race()&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function myPromiseRace(arr) {
  return new Promise((resolve, reject) =&amp;gt; {
    for (let i = 0; i &amp;lt; arr.length; i++) {
      return arr[i].then(resolve, reject)
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;12-手写实现eventemitter-订阅监听模式&#34;&gt;12. 手写实现EventEmitter 订阅监听模式&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;class EventEmitter {
  constructor() {
    this.events = {};
  }
  on (eventName, callback) {
    if(!this.events[eventName]) {
      this.events[eventName] = [callback];
    } else {
      this.events[eventName].push(callback);
    }
  }

  emit(eventName, ...args) {
    this.events[eventName].forEach(fn =&amp;gt; fn.apply(this, args));
  }

  once(eventName, callback) {
    const fn = () =&amp;gt; {
      callback();
      this.remove(eventName, fn);
    }
    this.on(eventName, fn)
  }

  remove(eventName, callback) {
    this.events[eventName] = this.events[eventName].filter(fn =&amp;gt; fn != callback);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;13-手写settimout-实现-setinterval&#34;&gt;13. 手写setTimout 实现 setInterval&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function myInterval(fn, time) {
  let context = this;
  setTimeout(() =&amp;gt; {
    fn.call(context);
    myInterval(fn, time);
  }, time);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;14-手写实现深拷贝&#34;&gt;14. 手写实现深拷贝&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function deepClone(obj) {
  // 先判断是对象还是数组
  let copy = obj instanceof Array ? [] : {};
  for (let key in obj) {
    // 判断是否是对象上的属性，而不是原型上的属性
    if (obj.hasOwnProperty(key)) {
      // obj[key] 是否是对象，如果是对象，递归遍历
      copy[key] = typeof obj[key] === &#39;object&#39; ? deepClone(obj[key]) : obj[key];
    }
  }
  return copy;
}

// test
console.log(deepClone({name: &#39;jack&#39;, birth: {year: &#39;1997&#39;, month: &#39;10&#39;}})) // {name: &#39;jack&#39;, birth: {…}}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;递归实现&#34;&gt;递归实现&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;function deepClone1(obj, cloneObj){
  var cloneObj = cloneObj || {};
  for(var i in obj){
    if(typeof obj[i] === &#39;object&#39; &amp;amp;&amp;amp; obj[i] !== null){
      cloneObj[i] = obj[i] instanceof Array ? [] : {};

      deepClone1(obj[i], cloneObj[i]);
    }else{
      cloneObj[i] = obj[i];
    }
  }
  return cloneObj;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解决循环调用&#34;&gt;解决循环调用&lt;/h2&gt;
&lt;p&gt;循环引用问题的产生原因可能是对象之间相互引用，也可能是对象引用了其自身，而造成死循环的原因则是我们在进行深拷贝时并没有将这种引用情况考虑进去，因此解决问题的关键也就是可以将这些引用存储起来并在发现引用时返回被引用过的对象，从而结束递归的调用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function deepClone( originObj, map = new WeakMap() ) {
  if(!originObj || typeof originObj !== &#39;object&#39;) return originObj;  //空或者非对象则返回本身

  //如果这个对象已经被记录则直接返回
  if( map.get(originObj) ) {
      return  map.get(originObj);
  }
  //这个对象还没有被记录，将其引用记录在map中，进行拷贝    
  let result = Array.isArray(originObj) ? [] : {};  //拷贝结果
  map.set(originObj, result); //记录引用关系
  let keys = Object.keys(originObj); //originObj的全部key集合
  //拷贝
  for(let i =0,len=keys.length; i&amp;lt;len; i++) {
      let key = keys[i];
      let temp = originObj[key];
      result[key] = deepClone(temp, map);
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;15-手写实现浅拷贝&#34;&gt;15. 手写实现浅拷贝(...)&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function clone(obj) {
    var cloneObj = {}
    // for in 遍历，会遍历原型链里面的属性，所以需要排除原型链
    for(var key in obj) {
        if(obj.hasOwnProperty(key)) {
            cloneObj[key] = obj[key]
        }
    }
    return cloneObj
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;16-手写实现数组拍平&#34;&gt;16. 手写实现数组拍平&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;var flatten = function(arr) {
  let res = [];
  for (let i = 0; i &amp;lt; arr.length; i++) {
    if (Array.isArray(arr[i])) {
      res = res.concat(flatten(arr[i]))
    } else {
      res.push(arr[i])
    }
  }
  return res;
}

console.log(flatten([1,[1,2,[2,4]],3,5]));  // [1, 1, 2, 2, 4, 3, 5]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;17-手写函数防抖&#34;&gt;17. 手写函数防抖&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function debounce(fn, wait) {
  let timeout = null;
  return function() {
    let context = this;
    let args = arguments;
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() =&amp;gt; {
      fn.apply(context, args);
    }, wait);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;18-手写函数节流&#34;&gt;18. 手写函数节流&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function throttle(fn, wait) {
  let  pre = new Date();
  return function() {
    let context = this;
    let args = arguments;
    let now = new  Date();
    if (now - pre &amp;gt;= wait) {
      fn.apply(context, args);
      pre = now;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;19-手写函数柯里化实现-sum123&#34;&gt;19. 手写函数柯里化（实现 sum(1,2)(3)()）&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function sum(...args1) {
  let x = args1.reduce((prev, next) =&amp;gt; {return prev+next;})
  return function(...args2) {
    if (args2.length == 0) return x;
    let y = args2.reduce((prev, next) =&amp;gt; {return prev+next;})
    return sum(x+y)
  }
}

console.log(sum(1,2,2,5)(7)()) // 17
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;20-手写快速排序&#34;&gt;20. 手写快速排序&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function quicksort(arr) {
  if (arr.length &amp;lt;= 1) return arr;
  let pivotIndex = Math.floor(arr.length/2);
  let pivot = arr.splice(pivotIndex, 1)[0];
  let left = [];
  let right = [];
  for (let i = 0; i &amp;lt; arr.length; i++) {
    if (arr[i] &amp;lt;= pivot)  {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  return quicksort(left).concat(pivot, quicksort(right));

}

console.log(quicksort([4,3,5,2,1,6]));   //  [1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;21-手写归并排序&#34;&gt;21. 手写归并排序&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function merge(left, right) {
  let res = [];
  while(left.length &amp;gt; 0 &amp;amp;&amp;amp; right.length &amp;gt; 0) {
    if (left[0] &amp;lt; right[0]) {
      res.push(left.shift());
    } else {
      res.push(right.shift());
    }
  }
  return res.concat(left).concat(right);
}

function mergeSort(arr) {
  if (arr.length == 1) return arr;
  var middle = Math.floor(arr.length / 2);
  var left = arr.slice(0, middle);
  var right = arr.slice(middle);
  return merge(mergeSort(left), mergeSort(right));
}

console.log(mergeSort([3,2,4,5,1,6]));  // [1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;22-手写数组去重&#34;&gt;22. 手写数组去重&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;let arr2 = [1, 2, 3, 2, 33, 55, 66, 3, 55];
let newArr = [...new Set(arr2)];
console.log(newArr);

// (6) [1, 2, 3, 33, 55, 66]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;23-手写数组合并&#34;&gt;23. 手写数组合并&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;let arr3 = [&#39;a&#39;, &#39;b&#39;]
let arr4 = [&#39;c&#39;, &#39;d&#39;]

let arr6 = [...arr3, ...arr4];
console.log(arr6);
// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;24-手写实现map&#34;&gt;24. 手写实现map&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;Array.prototype.myMap = function(callbackFn, thisArg) {
 if (typeof callbackFn !== &#39;function&#39;) throw (&#39;callbackFn参数必须是函数&#39;);
 let element = this,
 len = element &amp;amp;&amp;amp; element.length || 0,
 result = [];
 if (!thisArg) thisArg = element;
 for (let index = 0; index &amp;lt; len; index++) {
 result[index] = callbackFn.call(thisArg, element[index], index, element);
 }
 return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;25-手写实现new&#34;&gt;25. 手写实现new&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;new&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新生成了一个对象&lt;/li&gt;
&lt;li&gt;新对象隐式原型链接到函数原型&lt;/li&gt;
&lt;li&gt;调用函数绑定this&lt;/li&gt;
&lt;li&gt;返回新对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;核心代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function _new(fun) {
  return function() {
    let obj = {
      __proto__: fun.prototype
    }
    fun.apply(obj, arguments)
    return obj
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试用例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function person(name, age) {
  this.name = name
  this.age = age
}
let obj = _new(person)(&#39;LL&#39;, 100)
console.log(obj) //{name: &#39;LL&#39;, age: 100}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;26-手写解析url&#34;&gt;26. 手写解析url&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;var url=&amp;quot;http://www.baidu.com/we/index.html?id=898602B8261890349226&amp;amp;aaa=123&amp;amp;ccc=456&amp;quot;;
  var transform=function(str){
      // 创建目标对象
      var REQUEST = new Object, 
      // 截取数据字符串
      data=str.slice(str.indexOf(&amp;quot;?&amp;quot;),str.length),
      // 将数据字符串表现为数组
      aParams = data.substr(1).split(&amp;quot;&amp;amp;&amp;quot;);
      for (i = 0; i &amp;lt; aParams.length; i++) {
          // 数据属性与数值分离
　　          var aParam = aParams[i].split(&amp;quot;=&amp;quot;);
          // 使用属性括号进行属性赋值
              REQUEST[aParam[0]] = aParam[1]
      }
      console.log(REQUEST);
  }
  transform(url);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;27-字符串原型-输出三个hello&#34;&gt;27. 字符串原型 输出三个hello&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;String.prototype.repeatify = String.prototype.repeatify || function(times) {
  var str = &#39;&#39;;
  for (var i = 0; i &amp;lt; times; i++) {
     str += this;
  }
  return str;
};
console.log(&#39;hello&#39;.repeatify(3));
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;28-手写实现翻转链表&#34;&gt;28. 手写实现翻转链表&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function ReverseList(pHead)
{
    let prev = null;
    let cur = pHead;
    while(cur){
      let next = cur.next;
      cur.next = prev;
      prev = cur;
      cur = next;
    }
    return prev;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;29-手写实现反转数组&#34;&gt;29. 手写实现反转数组&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;for (var i=0;i&amp;lt;array.length/2;i++){
  var temp = array[i]
  array[i] = array[array.length-1-i]
  array[array.length-1-i] = temp
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;30-实现一个repeat方法会输出4次hello每次间隔3s&#34;&gt;30.  实现一个repeat方法，会输出4次hello，每次间隔3s&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function repeat(func, times, wait){
  return function(){
    let _args = arguments;
    let handle = function(i){
      setTimeout(() =&amp;gt; {
        func.apply(null, _args);
      }, wait * i);
    };
    for(let i = 0; i &amp;lt; times; i++){
      handle(i);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
">【面】前端知识点梳理（手写题）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/mian-qian-duan-zhi-shi-dian-shu-li-gong-ju-yu-zu-jian/"" data-c="
          &lt;h1 id=&#34;1-关于webpack的面试题总结&#34;&gt;1. 关于webpack的面试题总结&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Webpcak搭建vue环境&lt;/li&gt;
&lt;li&gt;webpack与grunt、gulp的不同？&lt;/li&gt;
&lt;li&gt;谈谈你为什么最终选择（或放弃）使用webpack，webpack都有那些作用？&lt;/li&gt;
&lt;li&gt;有哪些常见的Loader？他们是解决什么问题的？&lt;/li&gt;
&lt;li&gt;有哪些常见的Plugin？他们是解决什么问题的？&lt;/li&gt;
&lt;li&gt;Loader和Plugin的不同？&lt;/li&gt;
&lt;li&gt;webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全&lt;/li&gt;
&lt;li&gt;你知道sourceMap是什么吗？&lt;/li&gt;
&lt;li&gt;是否写过Loader和Plugin？描述一下编写loader或plugin的思路？&lt;/li&gt;
&lt;li&gt;webpack的热更新是如何做到的？说明其原理？&lt;/li&gt;
&lt;li&gt;如何利用webpack来优化前端性能？（提高性能和体验）&lt;/li&gt;
&lt;li&gt;如何提高webpack的构建速度？&lt;/li&gt;
&lt;li&gt;怎么配置单页应用？怎么配置多页应用？&lt;/li&gt;
&lt;li&gt;npm打包时需要注意哪些？如何利用webpack来更好的构建？&lt;/li&gt;
&lt;li&gt;如何在vue项目中实现按需加载？&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;1-webpcak搭建vue环境&#34;&gt;1. Webpcak搭建vue环境&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;vue-loader： 用于解析.vue文件&lt;/li&gt;
&lt;li&gt;vue-template-compiler：用于编译模板&lt;/li&gt;
&lt;li&gt;webpack-dev-server：用于热更新&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;区分开发环境与生产环境&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;webpack.dev.js&lt;/code&gt; 开发环境配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;开发环境主要实现的是热更新,不要压缩代码，完整的sourceMap
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;code&gt;webpack.prod.js&lt;/code&gt; 生产环境配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;生产环境主要实现的是压缩代码、提取css文件、合理的sourceMap、分割代码
需要安装以下模块:
npm i -D  webpack-merge copy-webpack-plugin optimize-css-assets-webpack-plugin uglifyjs-webpack-plugin
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-webpack与grunt-gulp的不同&#34;&gt;2. webpack与grunt、gulp的不同？&lt;/h2&gt;
&lt;p&gt;三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。&lt;/li&gt;
&lt;li&gt;webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;所以总结一下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;从构建思路来说&lt;/strong&gt;：gulp和grunt需要开发者将整个前端构建过程拆分成多个&lt;code&gt;Task&lt;/code&gt;，并合理控制所有&lt;code&gt;Task&lt;/code&gt;的调用关系；webpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对于知识背景来说&lt;/strong&gt;：gulp更像后端开发者的思路，需要对于整个流程了如指掌 webpack更倾向于前端开发者的思路&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-谈谈你为什么最终选择或放弃使用webpackwebpack都有那些作用&#34;&gt;3. 谈谈你为什么最终选择（或放弃）使用webpack，webpack都有那些作用？&lt;/h2&gt;
&lt;p&gt;从官网上的描述我们其实不难理解，webpack的作用其实有以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模块打包。可以将不同模块的文件打包整合在一起，并且保证它们之间的引用正确，执行有序。利用打包我们就可以在开发的时候根据我们自己的业务自由划分文件模块，保证项目结构的清晰和可读性。&lt;/li&gt;
&lt;li&gt;编译兼容。在前端的“上古时期”，手写一堆浏览器兼容代码一直是令前端工程师头皮发麻的事情，而在今天这个问题被大大的弱化了，通过webpack的Loader机制，不仅仅可以帮助我们对代码做polyfill，还可以编译转换诸如&lt;code&gt;.less, .vue, .jsx&lt;/code&gt;这类在浏览器无法识别的格式文件，让我们在开发的时候可以使用新特性和新语法做开发，提高开发效率。&lt;/li&gt;
&lt;li&gt;能力扩展。通过webpack的Plugin机制，我们在实现模块化打包和编译兼容的基础上，可以进一步实现诸如按需加载，代码压缩等一系列功能，帮助我们进一步提高自动化程度，工程效率以及打包输出的质量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-有哪些常见的loader他们是解决什么问题的&#34;&gt;4. 有哪些常见的Loader？他们是解决什么问题的？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件&lt;/li&gt;
&lt;li&gt;url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去&lt;/li&gt;
&lt;li&gt;image-loader：加载并且压缩图片文件&lt;/li&gt;
&lt;li&gt;babel-loader：为了使我们的js代码兼容更多的环境，ES6/7/8语法转换为ES5语法&lt;/li&gt;
&lt;li&gt;babel-polyfill：转换新api，如：promise、Generator、Set、Maps、Proxy&lt;/li&gt;
&lt;li&gt;css-loader：加载 CSS，支持模块化、压缩、文件导入等特性&lt;/li&gt;
&lt;li&gt;style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。&lt;/li&gt;
&lt;li&gt;eslint-loader：通过 ESLint 检查 JavaScript 代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-有哪些常见的plugin他们是解决什么问题的&#34;&gt;5. 有哪些常见的Plugin？他们是解决什么问题的？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;define-plugin：定义环境变量&lt;/li&gt;
&lt;li&gt;commons-chunk-plugin：提取公共代码&lt;/li&gt;
&lt;li&gt;uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码&lt;/li&gt;
&lt;li&gt;html-webpack-plugin：打包出来的js文件我们需要引入到html中，自动修改js文件名&lt;/li&gt;
&lt;li&gt;clean-webpack-plugin：dist文件夹里会残留上次打包的文件，插件自动删除上次文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6-loader和plugin的不同&#34;&gt;6. Loader和Plugin的不同？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;不同的作用&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Loader直译为&amp;quot;加载器&amp;quot;。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了&lt;code&gt;加载和解析非JavaScript文件的能力&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Plugin直译为&amp;quot;插件&amp;quot;。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;不同的用法&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Loader在&lt;code&gt;module.rules&lt;/code&gt;中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）&lt;/li&gt;
&lt;li&gt;Plugin在&lt;code&gt;plugins&lt;/code&gt;中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;7-webpack的构建流程是什么从读取配置到输出文件这个过程尽量说全&#34;&gt;7. webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全&lt;/h2&gt;
&lt;p&gt;Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；&lt;/li&gt;
&lt;li&gt;开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；&lt;/li&gt;
&lt;li&gt;确定入口：根据配置中的 entry 找出所有的入口文件；&lt;/li&gt;
&lt;li&gt;编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；&lt;/li&gt;
&lt;li&gt;完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；&lt;/li&gt;
&lt;li&gt;输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；&lt;/li&gt;
&lt;li&gt;输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。&lt;/p&gt;
&lt;p&gt;其中文件的解析与构建是一个比较复杂的过程，在webpack源码中主要依赖于&lt;code&gt;compiler&lt;/code&gt;和&lt;code&gt;compilation&lt;/code&gt;两个核心对象实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;compiler 、compilation是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;compiler&lt;/code&gt; 对象包含了 Webpack 环境所有的的配置信息。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 &lt;code&gt;options，loader 和 plugin&lt;/code&gt;。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compilation&lt;/code&gt; 对象包含了当前的模块资源、编译生成资源、变化的文件等。当运行webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 &lt;code&gt;compilation&lt;/code&gt;，从而生成一组新的编译资源。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;compiler和 compilation的区别在于&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;compiler代表了整个webpack从启动到关闭的生命周期，而compilation 只是代表了一次新的编译过程&lt;/li&gt;
&lt;li&gt;compiler和compilation暴露出许多钩子，我们可以根据实际需求的场景进行自定义处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;8-你知道sourcemap是什么吗&#34;&gt;8. 你知道sourceMap是什么吗？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;sourceMap&lt;/code&gt;是一项将&lt;strong&gt;编译、打包、压缩后的代码映射回源代码的技术&lt;/strong&gt;，由于打包压缩后的代码并没有阅读性可言，一旦在开发中报错或者遇到问题，直接在混淆代码中debug问题会带来非常糟糕的体验，&lt;code&gt;sourceMap&lt;/code&gt;可以帮助我们快速定位到源代码的位置，提高我们的开发效率。sourceMap其实并不是Webpack特有的功能，而是Webpack支持sourceMap，像JQuery也支持souceMap。&lt;/p&gt;
&lt;p&gt;既然是一种源码的映射，那必然就需要有一份映射的文件，来标记混淆代码里对应的源码的位置，通常这份映射文件以&lt;code&gt;.map&lt;/code&gt;结尾，里边的数据结构大概长这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;version&amp;quot; : 3,                          // Source Map版本
  &amp;quot;file&amp;quot;: &amp;quot;out.js&amp;quot;,                       // 输出文件（可选）
  &amp;quot;sourceRoot&amp;quot;: &amp;quot;&amp;quot;,                       // 源文件根目录（可选）
  &amp;quot;sources&amp;quot;: [&amp;quot;foo.js&amp;quot;, &amp;quot;bar.js&amp;quot;],        // 源文件列表
  &amp;quot;sourcesContent&amp;quot;: [null, null],         // 源内容列表（可选，和源文件列表顺序一致）
  &amp;quot;names&amp;quot;: [&amp;quot;src&amp;quot;, &amp;quot;maps&amp;quot;, &amp;quot;are&amp;quot;, &amp;quot;fun&amp;quot;], // mappings使用的符号名称列表
  &amp;quot;mappings&amp;quot;: &amp;quot;A,AAAB;;ABCDE;&amp;quot;            // 带有编码映射数据的字符串
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了这份映射文件，我们只需要在我们的压缩代码的最末端加上这句注释，即可让sourceMap生效：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//# sourceURL=/path/to/file.js.map
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了这段注释后，浏览器就会通过&lt;code&gt;sourceURL&lt;/code&gt;去获取这份映射文件，通过解释器解析后，实现源码和混淆代码之间的映射。因此&lt;code&gt;sourceMap&lt;/code&gt;其实也是一项需要浏览器支持的技术。&lt;/p&gt;
&lt;h2 id=&#34;9-是否写过loader和plugin描述一下编写loader或plugin的思路&#34;&gt;9. 是否写过Loader和Plugin？描述一下编写loader或plugin的思路？&lt;/h2&gt;
&lt;h3 id=&#34;1-loader&#34;&gt;1. Loader&lt;/h3&gt;
&lt;p&gt;Loader像一个&amp;quot;翻译官&amp;quot;把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;loader编写原则&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单一原则: 每个 &lt;code&gt;Loader&lt;/code&gt; 只做一件事；&lt;/li&gt;
&lt;li&gt;链式调用: Webpack 会按顺序链式调用每个 &lt;code&gt;Loader&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;统一原则: 遵循 Webpack 制定的设计规则和结构，输入与输出均为字符串，各个 &lt;code&gt;Loader&lt;/code&gt; 完全独立，即插即用；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-plugin&#34;&gt;2. Plugin&lt;/h3&gt;
&lt;p&gt;相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。那么它与loader的区别是什么呢？上面我们也提到了loader的单一原则,loader只能一件事，比如说less-loader,只能解析less文件，plugin则是针对整个流程执行广泛的任务。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class firstPlugin {
  constructor (options) {
    console.log(&#39;firstPlugin options&#39;, options)
  }
  apply (compiler) {
    compiler.plugin(&#39;done&#39;, compilation =&amp;gt; {
      console.log(&#39;firstPlugin&#39;)
    ))
  }
}

module.exports = firstPlugin
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;10-webpack的热更新是如何做到的说明其原理&#34;&gt;10. webpack的热更新是如何做到的？说明其原理？&lt;/h2&gt;
&lt;h3 id=&#34;概括&#34;&gt;概括：&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt;的热更新又称热替换（&lt;code&gt;Hot Module Replacement&lt;/code&gt;），缩写为&lt;code&gt;HMR&lt;/code&gt;。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。&lt;/p&gt;
&lt;p&gt;webpack是通过&lt;code&gt;webpack-dev-server(WDS)&lt;/code&gt;来实现自动刷新。WDS是一个运行在内存中的开发服务器。启动之后，它会检测文件是否发生改变并再自动编译一次。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HMR&lt;/code&gt;的核心就是客户端从服务端拉取更新后的文件，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，&lt;strong&gt;让客户端与上一次资源进行对比&lt;/strong&gt;。客户端对比出差异后会向 WDS 发起 &lt;code&gt;Ajax&lt;/code&gt; 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 &lt;code&gt;jsonp&lt;/code&gt; 请求获取该chunk的增量更新。&lt;/p&gt;
&lt;h3 id=&#34;具体流程&#34;&gt;具体流程：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1617701765337.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;首先要知道server端和client端都做了处理工作&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。&lt;/li&gt;
&lt;li&gt;第二步是 webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。&lt;/li&gt;
&lt;li&gt;第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。&lt;/li&gt;
&lt;li&gt;第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。&lt;/li&gt;
&lt;li&gt;webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。&lt;/li&gt;
&lt;li&gt;HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。&lt;/li&gt;
&lt;li&gt;而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。&lt;/li&gt;
&lt;li&gt;最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;11-如何利用webpack来优化前端性能提高性能和体验&#34;&gt;11. 如何利用webpack来优化前端性能？（提高性能和体验）&lt;/h2&gt;
&lt;p&gt;用webpack优化前端性能是指优化webpack的&lt;code&gt;输出结果&lt;/code&gt;，让打包的最终结果在浏览器运行快速高效。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css&lt;/li&gt;
&lt;li&gt;利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径&lt;/li&gt;
&lt;li&gt;删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数--optimize-minimize来实现&lt;/li&gt;
&lt;li&gt;提取公共代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12-如何提高webpack的构建速度&#34;&gt;12. 如何提高webpack的构建速度？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;多入口情况&lt;/strong&gt;下，使用CommonsChunkPlugin来提取公共代码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用Happypack&lt;/strong&gt;：HappyPack的基本原理是将这部分任务（css，图片，字体，文件）分解到多个子进程中去并行处理，子进程处理完成后把结果发送到主进程中，从而减少总的构建时间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缩小文件的搜索范围&lt;/strong&gt;：&lt;code&gt;alias&lt;/code&gt; 当我们代码中出现 import &#39;vue&#39;时， webpack会采用向上递归搜索的方式去node_modules 目录下找。为了减少搜索范围我们可以直接告诉webpack去哪个路径下查找。也就是别名(alias)的配置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;抽离第三方模块&lt;/strong&gt;: 类似于我们的elementUi、vue全家桶等等。因为很少会变更，所以我们不希望这些依赖要被集成到每一次的构建逻辑中去。 这样做的好处是每次更改我本地代码的文件的时候，webpack只需要打包我项目本身的文件代码，而不会再去编译第三方库。这里我们使用webpack内置的&lt;code&gt;DllPlugin DllReferencePlugin进行抽离&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;配置缓存&lt;/strong&gt;: 我们可以通过&lt;code&gt;cache-loader&lt;/code&gt; ，它所做的事情很简单，就是 babel-loader 开启 cache 后做的事情，将 loader 的编译结果写入硬盘缓存。再次构建会先比较一下，如果文件较之前的没有发生变化则会直接使用缓存。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;13-怎么配置单页应用怎么配置多页应用&#34;&gt;13. 怎么配置单页应用？怎么配置多页应用？&lt;/h2&gt;
&lt;p&gt;单页应用可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可，这里不再赘述&lt;/p&gt;
&lt;p&gt;多页应用的话，可以使用webpack的 AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。 多页应用中要注意的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套css样式表&lt;/li&gt;
&lt;li&gt;随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;14-npm打包时需要注意哪些如何利用webpack来更好的构建&#34;&gt;14. npm打包时需要注意哪些？如何利用webpack来更好的构建？&lt;/h2&gt;
&lt;p&gt;NPM模块需要注意以下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;要支持CommonJS模块化规范，所以要求打包后的最后结果也遵守该规则。&lt;/li&gt;
&lt;li&gt;Npm模块使用者的环境是不确定的，很有可能并不支持ES6，所以打包的最后结果应该是采用ES5编写的。并且如果ES5是经过转换的，请最好连同SourceMap一同上传。&lt;/li&gt;
&lt;li&gt;Npm包大小应该是尽量小（有些仓库会限制包大小）&lt;/li&gt;
&lt;li&gt;发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。&lt;/li&gt;
&lt;li&gt;UI组件类的模块应该将依赖的其它资源文件，例如.css文件也需要包含在发布的模块里。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基于以上需要注意的问题，我们可以对于webpack配置做以下扩展和优化：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CommonJS模块化规范的解决方案： 设置output.libraryTarget=&#39;commonjs2&#39;使输出的代码符合CommonJS2 模块化规范，以供给其它模块导入使用&lt;/li&gt;
&lt;li&gt;输出ES5代码的解决方案：使用babel-loader把 ES6 代码转换成 ES5 的代码。再通过开启devtool: &#39;source-map&#39;输出SourceMap以发布调试。&lt;/li&gt;
&lt;li&gt;Npm包大小尽量小的解决方案：Babel 在把 ES6 代码转换成 ES5 代码时会注入一些辅助函数，最终导致每个输出的文件中都包含这段辅助函数的代码，造成了代码的冗余。解决方法是修改.babelrc文件，为其加入transform-runtime插件&lt;/li&gt;
&lt;li&gt;不能将依赖模块打包到NPM模块中的解决方案：使用externals配置项来告诉webpack哪些模块不需要打包。&lt;/li&gt;
&lt;li&gt;对于依赖的资源文件打包的解决方案：通过css-loader和extract-text-webpack-plugin来实现，配置如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;const ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;);

module.exports = {
  module: {
    rules: [
      {
        // 增加对 CSS 文件的支持
        test: /\.css/,
        // 提取出 Chunk 中的 CSS 代码到单独的文件中
        use: ExtractTextPlugin.extract({
          use: [&#39;css-loader&#39;]
        }),
      },
    ]
  },
  plugins: [
    new ExtractTextPlugin({
      // 输出的 CSS 文件名称
      filename: &#39;index.css&#39;,
    }),
  ],
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;15-如何在vue项目中实现按需加载&#34;&gt;15. 如何在vue项目中实现按需加载？&lt;/h2&gt;
&lt;p&gt;Vue UI组件库的按需加载 为了快速开发前端项目，经常会引入现成的UI组件库如ElementUI、iView等，但是他们的体积和他们所提供的功能一样，是很庞大的。 而通常情况下，我们仅仅需要少量的几个组件就足够了，但是我们却将庞大的组件库打包到我们的源码中，造成了不必要的开销。&lt;/p&gt;
&lt;p&gt;不过很多组件库已经提供了现成的解决方案，如Element出品的babel-plugin-component和AntDesign出品的babel-plugin-import 安装以上插件后，在.babelrc配置中或babel-loader的参数中进行设置，即可实现组件按需加载了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;presets&amp;quot;: [[&amp;quot;es2015&amp;quot;, { &amp;quot;modules&amp;quot;: false }]],
  &amp;quot;plugins&amp;quot;: [
    [
      &amp;quot;component&amp;quot;,
      {
        &amp;quot;libraryName&amp;quot;: &amp;quot;element-ui&amp;quot;,
        &amp;quot;styleLibraryName&amp;quot;: &amp;quot;theme-chalk&amp;quot;
      }
    ]
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;单页应用的按需加载&lt;/strong&gt; 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;import(*)&lt;/code&gt;语句来控制加载时机，webpack内置了对于import(*)的解析，会将import(*)中引入的模块作为一个新的入口在生成一个chunk。 当代码执行到import(*)语句时，会去加载Chunk对应生成的文件。import()会返回一个Promise对象，所以为了让浏览器支持，需要事先注入Promise polyfill&lt;/p&gt;
&lt;h1 id=&#34;2-webpack5新特性&#34;&gt;2. Webpack5新特性&lt;/h1&gt;
&lt;p&gt;此版本重点关注以下内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;减小打包后的文件体积&lt;/li&gt;
&lt;li&gt;按需加载支持文件名模式&lt;/li&gt;
&lt;li&gt;使用long-term caching解决生产环境下moduleIds &amp;amp; chunkIds变化的问题&lt;/li&gt;
&lt;li&gt;使用cache: {type: &amp;quot;filesystem&amp;quot;}配置实现持久化缓存，提高构建速度&lt;/li&gt;
&lt;li&gt;优化minSize&amp;amp;maxSize的配置方式&lt;/li&gt;
&lt;li&gt;Node.js polyfills 自动加载功能被移除&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;1-模块联邦&#34;&gt;1. 模块联邦&lt;/h2&gt;
&lt;p&gt;先说结论：Webpack5 模块联邦让 Webpack 达到了线上 Runtime 的效果，让代码直接在项目间利用 CDN 直接共享，不再需要本地安装 Npm 包、构建再发布了！&lt;/p&gt;
&lt;h3 id=&#34;1-npm-方式共享模块&#34;&gt;1. NPM 方式共享模块&lt;/h3&gt;
&lt;p&gt;想象一下正常的共享模块方式，对，就是 NPM。&lt;/p&gt;
&lt;p&gt;如下图所示，正常的代码共享需要将依赖作为 Lib 安装到项目，进行 Webpack 打包构建再上线，如下图：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1628587908280.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
对于项目 Home 与 Search，需要共享一个模块时，最常见的办法就是将其抽成通用依赖并分别安装在各自项目中。&lt;/p&gt;
&lt;p&gt;虽然 Monorepo 可以一定程度解决重复安装和修改困难的问题，但依然需要走本地编译。&lt;/p&gt;
&lt;h3 id=&#34;2-umd-方式共享模块&#34;&gt;2. UMD 方式共享模块&lt;/h3&gt;
&lt;p&gt;真正 Runtime 的方式可能是 UMD 方式共享代码模块，即将模块用 Webpack UMD 模式打包，并输出到其他项目中。这是非常普遍的模块共享方式：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1628587954785.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
对于项目 Home 与 Search，直接利用 UMD 包复用一个模块。但这种技术方案问题也很明显，就是包体积无法达到本地编译时的优化效果，且库之间容易冲突。&lt;/p&gt;
&lt;h3 id=&#34;3-微前端方式共享模块&#34;&gt;3. 微前端方式共享模块&lt;/h3&gt;
&lt;p&gt;微前端：micro-frontends (MFE) 也是最近比较火的模块共享管理方式，微前端就是要解决多项目并存问题，多项目并存的最大问题就是模块共享，不能有冲突。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1628587982901.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
由于微前端还要考虑样式冲突、生命周期管理，所以本文只聚焦在资源加载方式上。微前端一般有两种打包方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子应用独立打包，模块更解耦，但无法抽取公共依赖等。&lt;/li&gt;
&lt;li&gt;整体应用一起打包，很好解决上面的问题，但打包速度实在是太慢了，不具备水平扩展能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-模块联邦方式&#34;&gt;4. 模块联邦方式&lt;/h3&gt;
&lt;p&gt;终于提到本文的主角了，作为 Webpack5 内置核心特性之一的 Federated Module：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1628588023289.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
从图中可以看到，这个方案是直接将一个应用的包应用于另一个应用，同时具备整体应用一起打包的公共依赖抽取能力。&lt;/p&gt;
&lt;p&gt;让应用具备模块化输出能力，其实开辟了一种新的应用形态，即 “中心应用”，这个中心应用用于在线动态分发 Runtime 子模块，并不直接提供给用户使用：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1628588047483.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
对微前端而言，这张图就是一个完美的主应用，因为所有子应用都可以利用 Runtime 方式复用主应用的 Npm 包和模块，更好的集成到主应用中。&lt;/p&gt;
&lt;p&gt;模块联邦的使用方式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const HtmlWebpackPlugin = require(&amp;quot;html-webpack-plugin&amp;quot;);
const ModuleFederationPlugin = require(&amp;quot;webpack/lib/container/ModuleFederationPlugin&amp;quot;);

module.exports = {
  // other webpack configs...
  plugins: [
    new ModuleFederationPlugin({
      name: &amp;quot;app_one_remote&amp;quot;,
      remotes: {
        app_two: &amp;quot;app_two_remote&amp;quot;,
        app_three: &amp;quot;app_three_remote&amp;quot;
      },
      exposes: {
        AppContainer: &amp;quot;./src/App&amp;quot;
      },
      shared: [&amp;quot;react&amp;quot;, &amp;quot;react-dom&amp;quot;, &amp;quot;react-router-dom&amp;quot;]
    }),
    new HtmlWebpackPlugin({
      template: &amp;quot;./public/index.html&amp;quot;,
      chunks: [&amp;quot;main&amp;quot;]
    })
  ]
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;模块联邦本身是一个普通的 Webpack 插件 &lt;strong&gt;ModuleFederationPlugin&lt;/strong&gt;，插件有几个重要参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;name 当前应用名称，需要全局唯一。&lt;/li&gt;
&lt;li&gt;remotes 可以将其他项目的 name 映射到当前项目中。&lt;/li&gt;
&lt;li&gt;exposes 表示导出的模块，只有在此申明的模块才可以作为远程依赖被使用。&lt;/li&gt;
&lt;li&gt;shared 是非常重要的参数，制定了这个参数，可以让远程加载的模块对应依赖改为使用本地项目的 React 或 ReactDOM。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;5-总结&#34;&gt;5. 总结&lt;/h3&gt;
&lt;p&gt;模块联邦为更大型的前端应用提供了开箱解决方案，并已经作为 Webpack5 官方模块内置，可以说是继 Externals 后最终的运行时代码复用解决方案。&lt;/p&gt;
&lt;p&gt;另外 Webpack5 还内置了大量编译时缓存功能，可以看到，无论是性能还是多项目组织，Webpack5 都在尝试给出自己的最佳思路，期待 Webpack5 正式发布，前端工程化会迈向一个新的阶段。&lt;/p&gt;
&lt;h2 id=&#34;2-自动删除-nodejs-polyfills&#34;&gt;2. 自动删除 Node.js Polyfills&lt;/h2&gt;
&lt;p&gt;早期，webpack 的目标是允许在浏览器中运行大多数 node.js 模块，但是模块格局发生了变化，许多模块用途现在主要是为前端目的而编写的。webpack &amp;lt;= 4 附带了许多 node.js 核心模块的 polyfill，一旦模块使用任何核心模块（即 crypto 模块），这些模块就会自动应用。&lt;/p&gt;
&lt;p&gt;尽管这使使用为 node.js 编写的模块变得容易，但它会将这些巨大的 polyfill 添加到包中。在许多情况下，这些 polyfill 是不必要的。&lt;/p&gt;
&lt;p&gt;webpack 5 会自动停止填充这些核心模块，并专注于与前端兼容的模块。&lt;br&gt;
&lt;strong&gt;迁移：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽可能尝试使用与前端兼容的模块。&lt;/li&gt;
&lt;li&gt;可以为 node.js 核心模块手动添加一个 polyfill。错误消息将提示如何实现该目标。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-chunk-和模块-id&#34;&gt;3. Chunk 和模块 ID&lt;/h2&gt;
&lt;p&gt;添加了用于长期缓存的新算法。在生产模式下默认情况下启用这些功能。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chunkIds: &amp;quot;deterministic&amp;quot;, moduleIds: &amp;quot;deterministic&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你可以不用使用 import(/* webpackChunkName: &amp;quot;name&amp;quot; */ &amp;quot;module&amp;quot;) 在开发环境来为 chunk 命名，生产环境还是有必要的&lt;/p&gt;
&lt;p&gt;webpack 内部有 chunk 命名规则，不再是以 id(0, 1, 2)命名了&lt;/p&gt;
&lt;h2 id=&#34;4-tree-shaking&#34;&gt;4. Tree Shaking&lt;/h2&gt;
&lt;h3 id=&#34;1-webpack-现在能够处理对嵌套模块的-tree-shaking&#34;&gt;1. webpack 现在能够处理对嵌套模块的 tree shaking&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// inner.js
export const a = 1;
export const b = 2;

// module.js
import * as inner from &#39;./inner&#39;;
export { inner };

// user.js
import * as module from &#39;./module&#39;;
console.log(module.inner.a);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在生产环境中, inner 模块暴露的 b 会被删除&lt;/p&gt;
&lt;h3 id=&#34;2-webpack-现在能够多个模块之前的关系&#34;&gt;2. webpack 现在能够多个模块之前的关系&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;import { something } from &#39;./something&#39;;

function usingSomething() {
  return something;
}

export function test() {
  return usingSomething();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当设置了&amp;quot;sideEffects&amp;quot;: false时，一旦发现test方法没有使用，不但删除test，还会删除&amp;quot;./something&amp;quot;&lt;/p&gt;
&lt;h3 id=&#34;3-webpack-现在能处理对-commonjs-的-tree-shaking&#34;&gt;3. webpack 现在能处理对 Commonjs 的 tree shaking&lt;/h3&gt;
&lt;h2 id=&#34;5-output&#34;&gt;5. Output&lt;/h2&gt;
&lt;p&gt;webpack 4 默认只能输出 ES5 代码&lt;/p&gt;
&lt;p&gt;webpack 5 开始新增一个属性 output.ecmaVersion, 可以生成 ES5 和 ES6 / ES2015 代码.&lt;/p&gt;
&lt;p&gt;如：output.ecmaVersion: 2015&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SplitChunk&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;// webpack4
minSize: 30000;
// webpack5
minSize: {
  javascript: 30000,
  style: 50000,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-caching&#34;&gt;6. Caching&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 配置缓存
cache: {
  // 磁盘存储
  type: &amp;quot;filesystem&amp;quot;,
  buildDependencies: {
    // 当配置修改时，缓存失效
    config: [__filename]
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;缓存将存储到 node_modules/.cache/webpack&lt;/p&gt;
&lt;h2 id=&#34;7-监视输出文件&#34;&gt;7. 监视输出文件&lt;/h2&gt;
&lt;p&gt;之前 webpack 总是在第一次构建时输出全部文件，但是监视重新构建时会只更新修改的文件。&lt;/p&gt;
&lt;p&gt;此次更新在第一次构建时会找到输出文件看是否有变化，从而决定要不要输出全部文件。&lt;/p&gt;
&lt;h1 id=&#34;3-git命令&#34;&gt;3. Git命令&lt;/h1&gt;
&lt;h2 id=&#34;1-什么是-rebase&#34;&gt;1. 什么是 rebase?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;git rebase&lt;/strong&gt;你其实可以把它理解成是“重新设置基线”，将你的当前分支重新设置开始点。这个时候才能知道你当前分支于你需要比较的分支之间的差异。&lt;/p&gt;
&lt;p&gt;原理很简单：rebase需要基于一个分支来设置你当前的分支的基线，这基线就是当前分支的开始时间轴向后移动到最新的跟踪分支的最后面，这样你的当前分支就是最新的跟踪分支。这里的操作是基于文件事务处理的，所以你不用怕中间失败会影响文件的一致性。在中间的过程中你可以随时取消rebase 事务。&lt;/p&gt;
&lt;h2 id=&#34;2-git-rebase-和-git-merge-有啥区别&#34;&gt;2. git rebase 和 git merge 有啥区别？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;rebase&lt;/strong&gt;会把你当前分支的 commit 放到公共分支的最后面,所以叫变基。就好像你从公共分支又重新拉出来这个分支一样。&lt;br&gt;
举例：如果你从 master 拉了个feature分支出来，然后你提交了几个 commit,这个时候刚好有人把他开发的东西合并到 master 了，这个时候 master 就比你拉分支的时候多了几个 commit,如果这个时候你 rebase master 的话，就会把你当前的几个 commit，放到那个人 commit 的后面。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1618473236809.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;merge&lt;/strong&gt;会把公共分支和你当前的commit 合并在一起，形成一个新的 commit 提交&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1618473414229.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要在公共分支使用rebase&lt;/li&gt;
&lt;li&gt;本地和远端对应同一条分支，优先使用rebase，而不是merge&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-为什么不要再公共分支使用rebase&#34;&gt;3. 为什么不要再公共分支使用rebase?&lt;/h2&gt;
&lt;p&gt;因为往后放的这些 commit 都是新的，这样其他从这个公共分支拉出去的人，都需要再 rebase，相当于你 rebase 东西进来，就都是新的 commit 了&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1618473493968.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;merge和rebase实际上只是用的场景不一样&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;更通俗的解释一波&lt;/strong&gt;&lt;br&gt;
比如rebase，你自己开发分支一直在做，然后某一天，你想把主线的修改合到你的分支上，做一次集成，这种情况就用rebase比较好。把你的提交都放在主线修改的头上&lt;/p&gt;
&lt;p&gt;同样的,如果你在主分支上用rebase, rebase其他分支的修改,是不是要是别人想看主分支上有什么历史,他看到的就不是完整的历史，这个历史已经被你篡改了&lt;/p&gt;
&lt;h2 id=&#34;4-常用指令&#34;&gt;4. 常用指令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;git rebase -i dev 可以将dev分支合并到当前分支&lt;br&gt;
这里的”-i“是指交互模式。就是说你可以干预rebase这个事务的过程，包括设置commit message，暂停commit等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git rebase –abort 放弃一次合并&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;合并多次commit操作&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1618473857337.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">【面】前端知识点梳理（打包工具）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/mian-qian-duan-zhi-shi-dian-shu-li-vue/"" data-c="
          &lt;h1 id=&#34;0-v-for中key的作用&#34;&gt;0. v-for中key的作用&lt;/h1&gt;
&lt;p&gt;所以我们需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点。&lt;/p&gt;
&lt;p&gt;vue中列表循环需加:key=&amp;quot;唯一标识&amp;quot; 唯一标识可以是item里面id index等，因为vue组件高度复用增加Key可以标识组件的唯一性，为了更好地区别各个组件 key的作用主要是为了高效的更新虚拟DOM&lt;/p&gt;
&lt;p&gt;&lt;code&gt;可以这样简单地理解，无：key属性时，状态默认绑定的是位置；有：key属性时，状态根据key的属性值绑定到了相应的数组元素。&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;1-vue组件化-与-渐进式的理解&#34;&gt;1. vue组件化 与 渐进式的理解&lt;/h1&gt;
&lt;h2 id=&#34;1vue的组件化思想&#34;&gt;1.vue的组件化思想&lt;/h2&gt;
&lt;p&gt;要回答这个问题，要先理解核心知识点：组件化&lt;/p&gt;
&lt;p&gt;组件化就是一种代码设计理念。最开始的面向过程编程使一个文件的代码特别多，难以维护，所以借鉴了后端的面向对象编程，使一个本需要几千行代码的文件可以被拆分成几个几百行的文件。&lt;/p&gt;
&lt;p&gt;一个组件就是一个类 new 出来的一个对象，是一个页面的一个部分，一个组件要负责这一部分的 CSS 展示，DOM 节点的设计，以及 JS 的逻辑。合理拆解组件可以提升代码的可读性以及可维护性，将组件间共性抽离出一个通用组件，让子组件去继承这个通用组件，可以少写很多代码，最小的组件颗粒度是一个元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组件化的演进 ：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1）Angular 提出了通过面向数据编程，不用操作 DOM，但是刚出来时，性能上有瓶颈&lt;br&gt;
2）React 引入了虚拟 DOM 机制，将 DOM 的比对换成了 JS 的比对，加了diff 算法，慢慢的性能的问题就解决了，前端开始大量使用 MVVM 和 MVC 这种框架了。&lt;br&gt;
3）&lt;code&gt;vue 是一个轻量级的 MVVM 模式的框架&lt;/code&gt;，vue 引入虚拟 DOM 的目的跟 React 不同，后者是为了解决性能问题，前者是为了让&lt;code&gt;组件高度抽象化&lt;/code&gt;（虚拟 DOM 使渲染过程抽象化了）。其主要作用是使前端开发变得简单，它的设计模式让没有组件化思维的使用者也在用组件化作开发，所以写的代码不会太差。&lt;br&gt;
PS：如果对前面两个框架不熟悉的话，最好不要在面试时提到它们，否则有被继续问的风险，只谈 vue 就好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;另外 Vue 的一个优势是&lt;code&gt;速度快&lt;/code&gt;，当我们改变数据后，会引起页面重新渲染，引起的重排和重绘的代价是高昂的，有可能会破坏用户体验，让 UI 展示迟缓，重排会引起周围的 DOM 重新排列，这个范围可能是全局也可能是局部，重排的性能花销跟有多少 DOM 节点需要重新构建有关系，因此应该尽可能减少重排的次数，以及它波及的范围。&lt;br&gt;
那么 Vue 将&lt;code&gt;数据更新引起的 watcher 回调放入到 nextTick&lt;/code&gt;中（是一个微任务，当执行栈为空时，就从微任务中一次性拿取所有任务），并且同一个 watcher 只会放入一次，也就是说在当前的事件循环中，无论一个响应式数据改变多少次，&lt;code&gt;最终都只会渲染一次&lt;/code&gt;，nextTick 在下面有讲解。&lt;br&gt;
要了解这段知识点要具备这些基础知识：浏览器渲染过程、JS 运行机制、异步任务、Vue 的双向绑定。确实所有知识都是从基础知识而来的，所以学框架最终就是对基础知识有更深入的理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-vue渐进式框架的理解&#34;&gt;2. vue渐进式框架的理解&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;主张最少&lt;/code&gt;，也就是弱主张。&lt;/p&gt;
&lt;p&gt;每个框架都不可避免会有自己的一些特点，从而会对使用者有一定的要求，这些要求就是主张，主张有强有弱，它的强势程度会影响在业务开发中的使用方式。&lt;/p&gt;
&lt;p&gt;他是在vue核心库（视图模板引擎）的基础上，去&lt;code&gt;逐步添加&lt;/code&gt;所需要功能（如，组件系统、路由、状态机等）&lt;br&gt;
vue“渐进式”：是指先使用vue核心库，在vue核心库的基础上，根据自己需要再去逐渐增加功能。&lt;br&gt;
Vue的核心的功能，是一个视图模板引擎，但这不是说Vue就不能成为一个框架。&lt;br&gt;
在声明式渲染（视图模板引擎）的基础上，我们可以通过添加组件系统、客户端路由、大规模状态管理来构建一个完整的框架。&lt;br&gt;
更重要的是，这些功能相互独立，你可以在核心功能的基础上任意选用其他的部件，不一定要全部整合在一起。&lt;br&gt;
所说的“渐进式”，其实就是Vue的使用方式，同时也体现了Vue的设计的理念。&lt;/p&gt;
&lt;h1 id=&#34;2mvvm-的理解&#34;&gt;2.MVVM 的理解&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;回答思路：先聊下 MVC，再聊下 MVVM 的定义，最后进行对比。&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1615468604645.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;View 传送指令到 Controller&lt;br&gt;
Controller 完成业务逻辑后，要求 Model 改变状态&lt;br&gt;
Model 将新的数据发送到 View，用户得到反馈&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所有通信都是单向的。MVC 接收用户指令，可以先通过 View 来接收，然后传递给 Controller，也可以直接通过 Controller 来接收指令。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1615468656209.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;ViewModel 和 View 之间是通过双向绑定来实现数据的变更&lt;br&gt;
ViewModel 和 Model 之间是浏览器通过 ajax 跟服务器相互通信的过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这两个通信是双向的，且 View 和 Model 之间没有通信。&lt;/p&gt;
&lt;p&gt;MVVM 模式的出现是因为很多后端的代码放到了前端（大前端的到来），前端的代码可维护性、可扩展性以及安全性出现了问题，随着前端框架的演变才有了 MVVM 模式，MVVM 模式和 MVC 模式主要区别在于让开发者的注意力从对 DOM 的操作上，转移到对数据的管理上，即数据是什么，视图就展示什么，使前后端分离更容易，并大大提升了开发效率和代码的可维护性。&lt;/p&gt;
&lt;h1 id=&#34;3-双向绑定的原理数据劫持&#34;&gt;3. 双向绑定的原理？数据劫持？&lt;/h1&gt;
&lt;p&gt;Vue.js是通过&lt;code&gt;数据劫持&lt;/code&gt;以及结合&lt;code&gt;发布者-订阅者&lt;/code&gt;来实现双向绑定的，数据劫持是利用ES5的Object.defineProperty(obj, key, val)来劫持各个属性的的setter以及getter，在数据变动时发布消息给订阅者，从而触发相应的回调来更新视图。&lt;/p&gt;
&lt;p&gt;双向数据绑定，简单点来说分为三个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、Observer：观察者，这里的主要工作是递归地监听对象上的所有属性，在属性值改变的时候，触发相应的watcher。&lt;/li&gt;
&lt;li&gt;2、Watcher：订阅者，当监听的数据值修改时，执行响应的回调函数（Vue里面的更新模板内容）。&lt;/li&gt;
&lt;li&gt;3、Dep：订阅管理器，连接Observer和Watcher的桥梁，每一个Observer对应一个Dep，它内部维护一个数组，保存与该Observer相关的Watcher。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1615469169345.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
反向是页面数据的变化映射到 data 中，通过 input 事件监听 input 框数据的改变，JS 得到通知再赋值给 data，只是 VM 框架使手动的过程自动化了。&lt;/p&gt;
&lt;p&gt;正向是数据驱动页面，通过 Object.defineProperty() 这个核心 API，将所有数据变成响应式数据，当访问到一个响应式数据时，就会触发它的 getter 函数，收集依赖，当一个响应式数据变化时，就会触发 setter 函数，通知依赖使视图得到更新。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1615711862629.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;4-nexttick&#34;&gt;4. nextTick&lt;/h1&gt;
&lt;p&gt;nextTick 把要执行的任务&lt;code&gt;推入&lt;/code&gt;到一个&lt;code&gt;队列&lt;/code&gt;中，在下一个 tick 同步执行队列的所有任务，它是异步任务中的微任务。（关于 JS 的运行机制，这是基础知识，篇幅有限）&lt;/p&gt;
&lt;p&gt;在 Vue 中，不是每一次数据的改变都会触发所有 wather 的回调，而是将这些回调推入到一个队列中，相同的 id 的 watcher 的回调不会被重复添加，然后在下一个 tick 中再执行这些回调，因此重新渲染是异步的。这么做的好处是：比如我们写了一个将某个响应式数据不断加 1 直到 1000 的代码块，那么视图只会重新渲染一次，即从 0 到 1000，而不是重新渲染 1000 次，这是一种有效的优化手段。&lt;/p&gt;
&lt;p&gt;如果我们在更新了一个响应式数据后，需要同步拿到这个渲染后的 DOM 结果，那么就使用 $nextTick 这个方法，异步拿到这个结果。&lt;/p&gt;
&lt;p&gt;使用方式有两个：&lt;code&gt;回调方式和 Promise 方式&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;this.$nextTick(cb)
this.$nextTick().then(cb)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请注意第一种方式的使用，虽然它们都是异步执行的，但是如果你将第一种方式放在响应式数据更新的前面，那么你拿到的将是老的 DOM 结果。&lt;/p&gt;
&lt;p&gt;因为 wather 的回调函数是在 nextTick 之后执行的，使用第一种方式 wather 的回调函数将和 this.$nextTick(cb) 中的 cb 同步执行，你将它放在响应式数据更新之前的话，会先执行这个 cb，所以拿到的是未被重新渲染的 DOM 结果，而如果是放在之后，你就能拿到被重新渲染的 DOM 结果。而第二种方式的 cb 跟 watcher 的回调函数是异步执行的，所以没有顺序问题。&lt;/p&gt;
&lt;p&gt;也就是说，当我们想要改变vue中的某个数据的值时，vue不会立即重新渲染，数据不会立即发生改变，而是会在下一次事件循环的时候更新。这&lt;code&gt;主要是因为Vue中DOM的操作是异步的&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;nextTick()的应用场景主要是：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在Vue生命周期的&lt;code&gt;created()&lt;/code&gt;钩子函数进行的DOM操作一定要放在&lt;code&gt;Vue.nextTick()&lt;/code&gt;的回调函数中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进&lt;code&gt;Vue.nextTick()&lt;/code&gt;的回调函数中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;5-生命周期&#34;&gt;5. 生命周期&lt;/h1&gt;
&lt;p&gt;Vue实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载等一系列过程，我们成为Vue 实例的生命周期，钩子就是在某个阶段给你一个做某些处理的机会。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1615470829040.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
回答技巧：有哪些生命周期以及在每个生命周期的时机中我们能做的事情。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;beforeCreate 钩子的执行时机是在&lt;code&gt;initState 函数之前&lt;/code&gt;，这个函数会初始化 props、data、methods、watch、computed 等属性，也就意味着，这个&lt;code&gt;钩子是不可以访问&lt;/code&gt;到以上这些属性中的数据的；&lt;/li&gt;
&lt;li&gt;created 钩子的执行时机是在&lt;code&gt;iniState 函数之后&lt;/code&gt;，因此&lt;code&gt;可以访问&lt;/code&gt;到以上这些属性中的数据；&lt;/li&gt;
&lt;li&gt;beforeMount 钩子的执行时机是在 DOM 挂载之前，还是JavaScript中的虚拟DOM形式存在的。执行顺序是先父后子；&lt;/li&gt;
&lt;li&gt;mounted 钩子的执行时机是在 DOM 挂载之后，执行顺序是先子后父；&lt;/li&gt;
&lt;li&gt;beforeUpdate 钩子的执行时机是在数据发生改变，还没有渲染之前；&lt;/li&gt;
&lt;li&gt;updated 钩子的执行时机是数据发生改变，并且被渲染后；&lt;/li&gt;
&lt;li&gt;beforeDestroy 钩子的执行时机是组件即将被销毁之前，也因此组件实例上属性的数据还可以被访问到；&lt;/li&gt;
&lt;li&gt;destroyed 钩子的执行时机是组件被销毁之后。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有两个钩子跟 keep-alive 抽象组件相关的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;activated 钩子的执行时机是在 mounted 钩子之后执行；&lt;/li&gt;
&lt;li&gt;deactivated 钩子的执行时机是在页面退出时，由于会缓存，所以不会销毁组件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;6-虚拟-dom-的原理&#34;&gt;6. 虚拟 DOM 的原理&lt;/h1&gt;
&lt;h2 id=&#34;1-浏览器渲染引擎工作流程都差不多大致分为5步&#34;&gt;1. 浏览器渲染引擎工作流程都差不多，大致分为5步&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;第一步，用HTML分析器，分析HTML元素，&lt;strong&gt;构建一颗DOM树&lt;/strong&gt;(标记化和树构建)。&lt;/li&gt;
&lt;li&gt;第二步，用CSS分析器，分析CSS文件和元素上的inline样式，生成页面的样式表。&lt;/li&gt;
&lt;li&gt;第三步，将DOM树和样式表，关联起来，构建一颗Render树(这一过程又称为Attachment)。&lt;/li&gt;
&lt;li&gt;第四步，有了Render树，浏览器开始布局，为每个Render树上的节点确定一个在显示屏上出现的精确坐标。&lt;/li&gt;
&lt;li&gt;第五步，Render树和节点显示坐标都有了，就调用每个节点paint方法，把它们绘制出来。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;用我们传统的开发模式，原生JS或JQ操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程&lt;/code&gt;。在一次操作中，我需要更新10个DOM节点，浏览器收到第一个DOM请求后并不知道还有9次更新操作，因此会马上执行流程，最终执行10次。&lt;/p&gt;
&lt;h2 id=&#34;2-为什么需要虚拟dom它有什么好处&#34;&gt;2. 为什么需要虚拟DOM，它有什么好处&lt;/h2&gt;
&lt;p&gt;虚拟DOM就是为了&lt;code&gt;解决浏览器性能问题&lt;/code&gt;而被设计出来的。&lt;/p&gt;
&lt;p&gt;出现了一个轻量级的对真实 DOM 描述的 JS 对象，称为虚拟 DOM，与真实 DOM 一一对应，将新旧虚拟 DOM 进行 diff，然后生成变更，将变更应用于真实 DOM，最终生成最新的真实 DOM。&lt;strong&gt;这是将大量的 DOM 层面操作，转换成 JS 层面的操作&lt;/strong&gt;，是很划算的。&lt;/p&gt;
&lt;p&gt;如前，若一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的&lt;code&gt;diff&lt;/code&gt;内容保存到本地一个JS对象中，最终将这个JS对象一次性attch到DOM树上，再进行后续操作，避免大量无谓的计算量。所以，用JS对象模拟DOM节点的好处是，页面的更新可以先全部反映在JS对象(虚拟DOM)上，操作内存中的JS对象的速度显然要更快，等更新完成后，再将最终的JS对象映射成真实的DOM，交由浏览器去绘制。&lt;/p&gt;
&lt;h2 id=&#34;3-diff算法的时间复杂度&#34;&gt;3. diff算法的时间复杂度&lt;/h2&gt;
&lt;p&gt;diff算法是通过&lt;strong&gt;同层的树节点&lt;/strong&gt;进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有&lt;code&gt;O(n)&lt;/code&gt;，是一种相当高效的算法&lt;/p&gt;
&lt;h2 id=&#34;4-diff操作&#34;&gt;4. Diff操作&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;diff算法的本质是找出两个对象之间的差异，目的是尽可能复用节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1-diff算法包括一下几个步骤&#34;&gt;1. diff算法包括一下几个步骤：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文&lt;br&gt;
档当中&lt;/li&gt;
&lt;li&gt;当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较(diff)，记录两棵树差异&lt;/li&gt;
&lt;li&gt;把2所记录的差异应用到步骤1所构建的真正的DOM树上(patch)，视图就更新了&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1616659004075.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;我们先看一下简单的diff是怎么设计的&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;逐个遍历newVdom的节点，找到它在oldVdom中的位置，如果找到了就移动对应的DOM元素，如果没找到说明是新增节点，则新建一个节点插入。遍历完成之后如果oldVdom中还有没处理过的节点，则说明这些节点在newVdom中被删除了，删除它们即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;接下来我们看一下Vue的diff实现&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-vue的diff实现&#34;&gt;2. Vue的diff实现&lt;/h3&gt;
&lt;p&gt;来看看patch是怎么打补丁的（代码只保留核心部分）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   function patch (oldVnode, vnode) {
    // some code
    if (sameVnode(oldVnode, vnode)) {
        patchVnode(oldVnode, vnode)
    } else {
        const oEl = oldVnode.el // 当前oldVnode对应的真实元素节点
        let parentEle = api.parentNode(oEl)  // 父元素
        createEle(vnode)  // 根据Vnode生成新元素
        if (parentEle !== null) {
            api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 将新元素添加进父元素
            api.removeChild(parentEle, oldVnode.el)  // 移除以前的旧元素节点
            oldVnode = null
        }
    }
    // some code
    return vnode
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;patch函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点&lt;/p&gt;
&lt;p&gt;判断两节点是否值得比较，值得比较则执行patchVnode&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  function sameVnode (a, b) {
      return (
        a.key === b.key &amp;amp;&amp;amp;  // key值
        a.tag === b.tag &amp;amp;&amp;amp;  // 标签名
        a.isComment === b.isComment &amp;amp;&amp;amp;  // 是否为注释节点
        // 是否都定义了data，data包含一些具体信息，例如onclick , style
        isDef(a.data) === isDef(b.data) &amp;amp;&amp;amp;
        sameInputType(a, b) // 当标签是&amp;lt;input&amp;gt;的时候，type必须相同
      )
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不值得比较则用Vnode替换oldVnode&lt;/p&gt;
&lt;p&gt;当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法。那么这个方法做了什么呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个函数做了以下事情：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到对应的真实dom，称为el&lt;/li&gt;
&lt;li&gt;判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return&lt;/li&gt;
&lt;li&gt;如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。&lt;/li&gt;
&lt;li&gt;如果oldVnode有子节点而Vnode没有，则删除el的子节点&lt;/li&gt;
&lt;li&gt;如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el&lt;/li&gt;
&lt;li&gt;如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要&lt;/li&gt;
&lt;li&gt;其他几个点都很好理解，我们详细来讲一下updateChildren&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;updateChildren&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;代码量很大，不方便一行一行的讲解，所以下面结合一些示例图来描述一下&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616659267875.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如上图的例子，更新前是1到10排列的Node列表，更新后是乱序排列的Node列表。罗列一下图中有以下几种类型的节点变化情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;头部相同、尾部相同的节点：如1、10&lt;/li&gt;
&lt;li&gt;头尾相同的节点：如2、9（处理完头部相同、尾部相同节点之后）&lt;/li&gt;
&lt;li&gt;新增的节点：11&lt;/li&gt;
&lt;li&gt;删除的节点：8&lt;/li&gt;
&lt;li&gt;其他节点：3、4、5、6、7&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上图例子中设置了oldStart+oldEnd，newStart+newEnd这样2对指针，分别对应oldVdom和newVdom的起点和终点。Vue不断对vnode进行处理同时移动指针直到其中任意一对起点和终点相遇。处理过的节点Vue会在oldVdom和newVdom中同时将它标记为已处理（标记方法后文中有介绍）。Vue通过以下措施来提升diff的性能&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;优先处理特殊场景&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;头部的同类型节点、尾部的同类型节点&lt;br&gt;
这类节点更新前后位置没有发生变化，所以不用移动它们对应的DOM&lt;/li&gt;
&lt;li&gt;头尾/尾头的同类型节点&lt;br&gt;
这类节点位置很明确，不需要再花心思查找，直接移动DOM就好&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;处理了这些场景之后，一方面一些不需要做移动的DOM得到快速处理，另一方面待处理节点变少，缩小了后续操作的处理范围，性能也得到提升&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;“原地复用”&lt;br&gt;
“原地复用”是指Vue会尽可能复用DOM，尽可能不发生DOM的移动。Vue在判断更新前后指针是否指向同一个节点，其实不要求它们真实引用同一个DOM节点，实际上它仅判断指向的是否是同类节点（比如2个不同的div，在DOM上它们是不一样的，但是它们属于同类节点），如果是同类节点，那么Vue会直接复用DOM，这样的好处是不需要移动DOM&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;&amp;quot;原地复用&amp;quot;应该就是设置key和不设置key的区别：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom&lt;/p&gt;
&lt;h3 id=&#34;4-按步骤解析updatechildren过程&#34;&gt;4. 按步骤解析updateChildren过程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;处理头部的同类型节点，即oldStart和newStart指向同类节点的情况，如下图中的节点1&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种情况下，将节点1的变更更新到DOM，然后对其进行标记，标记方法是oldStart和newStart后移1位即可，过程中不需要移动DOM（更新DOM或许是要的，比如属性变更了，文本内容变更了等等）&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616659749656.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;处理尾部的同类型节点，即oldEnd和newEnd指向同类节点的情况，如下图中的节点10&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;与情况（1）类似，这种情况下，将节点10的变更更新到DOM，然后oldEnd和newEnd前移1位进行标记，同样也不需要移动DOM&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616659785101.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;处理头尾/尾头的同类型节点，即oldStart和newEnd，以及oldEnd和newStart指向同类节点的情况，如下图中的节点2和节点9&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;先看节点2，其实是往后移了，移到哪里？移到oldEnd指向的节点（即节点9）后面，移动之后标记该节点，将oldStart后移1位，newEnd前移一位&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616659870038.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
操作结束之后情况如下图&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616659893331.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
同样地，节点9也是类似的处理，处理完之后成了下面这样&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616659902079.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;处理新增的节点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;newStart来到了节点11的位置，在oldVdom中找不到节点11，说明它是新增的&lt;br&gt;
那么就创建一个新的节点，插入DOM树，插到什么位置？插到oldStart指向的节点（即节点3）前面，然后将newStart后移1位标记为已处理（注意oldVdom中没有节点11，所以标记过程中它的指针不需要移动），处理之后如下图&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616659960929.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;处理更新的节点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;经过第（4）步之后，newStart来到了节点7的位置，在oldVdom中能找到它而且不在指针位置（查找oldVdom中oldStart到oldEnd区间内的节点），说明它的位置移动了&lt;/p&gt;
&lt;p&gt;那么需要在DOM树中移动它，移到哪里？移到oldStart指向的节点（即节点3）前面，与此同时将节点标记为已处理，跟前面几种情况有点不同，newVdom中该节点在指针处，可以移动newStart进行标记，而在oldVdom中该节点不在指针处，所以采用设置为undefined的方式来标记（一定要标记吗？后面会提到）&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616660042587.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
处理之后就成了下面这样&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616660067446.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;处理3、4、5、6节点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;经过第（5）步处理之后，我们看到了令人欣慰的一幕，newStart和oldStart又指向了同一个节点（即都指向节点3），很简单，按照（1）中的做法只需移动指针即可，非常高效，3、4、5、6都如此处理，处理完之后如下图&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616660118899.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;处理需删除的节点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;经过前6步处理之后（实际上前6步是循环进行的），朋友们看newStart跨过了newEnd，它们相遇啦！而这个时候，oldStart和oldEnd还没有相遇，说明这2个指针之间的节点（包括它们指向的节点，即上图中的节点7、节点8）是此次更新中被删掉的节点。&lt;/p&gt;
&lt;p&gt;OK，那我们在DOM树中将它们删除，再回到前面我们对节点7做了标记，为什么标记是必需的？标记的目的是告诉Vue它已经处理过了，是需要出现在新DOM中的节点，不要删除它，所以在这里只需删除节点8。&lt;/p&gt;
&lt;p&gt;在应用中也可能会遇到oldVdom的起止点相遇了，但是newVdom的起止点没有相遇的情况，这个时候需要对newVdom中的未处理节点进行处理，这类节点属于更新中被加入的节点，需要将他们插入到DOM树中。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616660166307.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;至此，整个diff过程结束了&lt;/p&gt;
&lt;p&gt;整个过程是逐步找到更新前后vdom的差异，然后将差异反应到DOM树上（也就是patch），特别要提一下Vue的patch是即时的，并不是打包所有修改最后一起操作DOM&lt;/p&gt;
&lt;h1 id=&#34;7-vue不同组件之间如何通信的&#34;&gt;7. Vue不同组件之间如何通信的？&lt;/h1&gt;
&lt;p&gt;组件是 vue.js最强大的功能之一，而组件实例的作用域是相互独立的，这就意味着不同组件之间的数据无法相互引用。一般来说，组件可以有以下几种关系：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616310215248.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如上图所示，A 和 B、B 和 C、B 和 D 都是父子关系，C 和 D 是兄弟关系，A 和 C 是隔代关系（可能隔多代）。&lt;/p&gt;
&lt;h2 id=&#34;0-组件注册&#34;&gt;0. 组件注册&lt;/h2&gt;
&lt;p&gt;全局注册：Vue.component(tagName, options)&lt;/p&gt;
&lt;p&gt;局部注册：在其他组件中的 components 属性中注册某个组件，就可以使用它了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import HelloWorld from &#39;./components/HelloWorld&#39;

export default {
  components: {
    HelloWorld
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1-propsemit&#34;&gt;1. props/$emit&lt;/h2&gt;
&lt;p&gt;父组件A通过props的方式向子组件B传递，B to A 通过在 B 组件中 $emit, A 组件中 v-on 的方式实现。&lt;/p&gt;
&lt;h3 id=&#34;1-父组件向子组件传值&#34;&gt;1. 父组件向子组件传值&lt;/h3&gt;
&lt;p&gt;接下来我们通过一个例子，说明父组件如何向子组件传递值：在子组件Users.vue中如何获取父组件App.vue中的数据 &lt;code&gt;users:[&amp;quot;Henry&amp;quot;,&amp;quot;Bucky&amp;quot;,&amp;quot;Emily&amp;quot;]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//App.vue父组件
&amp;lt;template&amp;gt;
  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;
    &amp;lt;users v-bind:users=&amp;quot;users&amp;quot;&amp;gt;&amp;lt;/users&amp;gt;//前者自定义名称便于子组件调用，后者要传递数据名
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
import Users from &amp;quot;./components/Users&amp;quot;
export default {
  name: &#39;App&#39;,
  data(){
    return{
      users:[&amp;quot;Henry&amp;quot;,&amp;quot;Bucky&amp;quot;,&amp;quot;Emily&amp;quot;]
    }
  },
  components:{
    &amp;quot;users&amp;quot;:Users
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;//users子组件
&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;hello&amp;quot;&amp;gt;
    &amp;lt;ul&amp;gt;
      &amp;lt;li v-for=&amp;quot;user in users&amp;quot;&amp;gt;{{user}}&amp;lt;/li&amp;gt;//遍历传递过来的值，然后呈现到页面
    &amp;lt;/ul&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
  name: &#39;HelloWorld&#39;,
  props:{
    users:{           //这个就是父组件中子标签自定义名字
      type:Array,
      required:true
    }
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结：父组件通过props向下传递数据给子组件。注：组件中的数据共有三种形式：data、props、computed&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-子组件向父组件传值通过事件形式&#34;&gt;2. 子组件向父组件传值（通过事件形式）&lt;/h3&gt;
&lt;p&gt;接下来我们通过一个例子，说明子组件如何向父组件传递值：当我们点击“Vue.js Demo”后，子组件向父组件传递值，文字由原来的“传递的是一个值”变成“子向父组件传值”，实现子组件向父组件值的传递。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616310448077.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 子组件
&amp;lt;template&amp;gt;
  &amp;lt;header&amp;gt;
    &amp;lt;h1 @click=&amp;quot;changeTitle&amp;quot;&amp;gt;{{title}}&amp;lt;/h1&amp;gt;//绑定一个点击事件
  &amp;lt;/header&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
  name: &#39;app-header&#39;,
  data() {
    return {
      title:&amp;quot;Vue.js Demo&amp;quot;
    }
  },
  methods:{
    changeTitle() {
      this.$emit(&amp;quot;titleChanged&amp;quot;,&amp;quot;子向父组件传值&amp;quot;);//自定义事件  传递值“子向父组件传值”
    }
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// 父组件
&amp;lt;template&amp;gt;
  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;
    &amp;lt;app-header v-on:titleChanged=&amp;quot;updateTitle&amp;quot; &amp;gt;&amp;lt;/app-header&amp;gt;//与子组件titleChanged自定义事件保持一致
   // updateTitle($event)接受传递过来的文字
    &amp;lt;h2&amp;gt;{{title}}&amp;lt;/h2&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
import Header from &amp;quot;./components/Header&amp;quot;
export default {
  name: &#39;App&#39;,
  data(){
    return{
      title:&amp;quot;传递的是一个值&amp;quot;
    }
  },
  methods:{
    updateTitle(e){   //声明这个函数
      this.title = e;
    }
  },
  components:{
   &amp;quot;app-header&amp;quot;:Header,
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结：子组件通过events给父组件发送消息，实际上就是子组件把自己的数据发送到父组件。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-emiton&#34;&gt;2. $emit/$on&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;这种方法通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级&lt;/strong&gt;。当我们的项目比较大时，可以选择更好的状态管理解决方案vuex。&lt;/p&gt;
&lt;h3 id=&#34;1-具体实现方式&#34;&gt;1. 具体实现方式：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;    var Event=new Vue();
    Event.$emit(事件名,数据);
    Event.$on(事件名,data =&amp;gt; {});
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-举个例子&#34;&gt;2. 举个例子&lt;/h3&gt;
&lt;p&gt;假设兄弟组件有三个，分别是A、B、C组件，C组件如何获取A或者B组件的数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;itany&amp;quot;&amp;gt;
    &amp;lt;my-a&amp;gt;&amp;lt;/my-a&amp;gt;
    &amp;lt;my-b&amp;gt;&amp;lt;/my-b&amp;gt;
    &amp;lt;my-c&amp;gt;&amp;lt;/my-c&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;template id=&amp;quot;a&amp;quot;&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h3&amp;gt;A组件：{{name}}&amp;lt;/h3&amp;gt;
    &amp;lt;button @click=&amp;quot;send&amp;quot;&amp;gt;将数据发送给C组件&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;template id=&amp;quot;b&amp;quot;&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h3&amp;gt;B组件：{{age}}&amp;lt;/h3&amp;gt;
    &amp;lt;button @click=&amp;quot;send&amp;quot;&amp;gt;将数组发送给C组件&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;template id=&amp;quot;c&amp;quot;&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h3&amp;gt;C组件：{{name}}，{{age}}&amp;lt;/h3&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
var Event = new Vue();//定义一个空的Vue实例
var A = {
    template: &#39;#a&#39;,
    data() {
      return {
        name: &#39;tom&#39;
      }
    },
    methods: {
      send() {
        Event.$emit(&#39;data-a&#39;, this.name);
      }
    }
}
var B = {
    template: &#39;#b&#39;,
    data() {
      return {
        age: 20
      }
    },
    methods: {
      send() {
        Event.$emit(&#39;data-b&#39;, this.age);
      }
    }
}
var C = {
    template: &#39;#c&#39;,
    data() {
      return {
        name: &#39;&#39;,
        age: &amp;quot;&amp;quot;
      }
    },
    mounted() {//在模板编译完成后执行
     Event.$on(&#39;data-a&#39;,name =&amp;gt; {
         this.name = name;//箭头函数内部不会产生新的this，这边如果不用=&amp;gt;,this指代Event
     })
     Event.$on(&#39;data-b&#39;,age =&amp;gt; {
         this.age = age;
     })
    }
}
var vm = new Vue({
    el: &#39;#itany&#39;,
    components: {
      &#39;my-a&#39;: A,
      &#39;my-b&#39;: B,
      &#39;my-c&#39;: C
    }
}); 
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1616310652213.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
$on 监听了自定义事件 data-a和data-b，因为有时不确定何时会触发事件，一般会在 mounted 或 created 钩子中来监听。&lt;/p&gt;
&lt;h2 id=&#34;3-vuex&#34;&gt;3. Vuex&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1616310687124.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1-vuex与localstorage&#34;&gt;1. Vuex与localStorage&lt;/h3&gt;
&lt;p&gt;vuex 是 vue 的状态管理器，存储的数据是响应式的。但是并不会保存起来，刷新之后就回到了初始状态，&lt;strong&gt;具体做法应该在vuex里数据改变的时候把数据拷贝一份保存到localStorage里面，刷新之后，如果localStorage里有保存的数据，取出来再替换store里的state&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let defaultCity = &amp;quot;上海&amp;quot;
try {   // 用户关闭了本地存储功能，此时在外层加个try...catch
  if (!defaultCity){
    defaultCity = JSON.parse(window.localStorage.getItem(&#39;defaultCity&#39;))
  }
}catch(e){}
export default new Vuex.Store({
  state: {
    city: defaultCity
  },
  mutations: {
    changeCity(state, city) {
      state.city = city
      try {
      window.localStorage.setItem(&#39;defaultCity&#39;, JSON.stringify(state.city));
      // 数据改变的时候把数据拷贝一份保存到localStorage里面
      } catch (e) {}
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里需要注意的是：由于vuex里，我们保存的状态，都是数组，而localStorage只支持字符串，所以需要用JSON转换：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;JSON.stringify(state.subscribeList);   // array -&amp;gt; string
JSON.parse(window.localStorage.getItem(&amp;quot;subscribeList&amp;quot;));    // string -&amp;gt; array 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-attrslisteners&#34;&gt;4. \&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;mspace linebreak=&#34;newline&#34;&gt;&lt;/mspace&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;attrs/\\&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace newline&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;listeners&lt;/h2&gt;
&lt;p&gt;多级组件嵌套需要传递数据时，通常使用的方法是通过vuex。但如果仅仅是传递数据，而不做中间处理，使用 vuex 处理，未免有点大材小用。为此Vue2.4 版本提供了另一种方法----$attrs/$listeners&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=&amp;quot;$attrs&amp;quot; 传入内部组件。通常配合 interitAttrs 选项一起使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&amp;quot;$listeners&amp;quot; 传入内部组件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单来说：&lt;code&gt;$attrs&lt;/code&gt;与&lt;code&gt;$listeners&lt;/code&gt;是两个对象，&lt;code&gt;$attrs&lt;/code&gt;里存放的是父组件中绑定的非 Props 属性，&lt;code&gt;$listeners&lt;/code&gt;里存放的是父组件中绑定的非原生事件。&lt;/p&gt;
&lt;h2 id=&#34;5-parent-children与-ref&#34;&gt;5. $parent / $children与 ref&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ref&lt;/code&gt;：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$parent&lt;/code&gt;/ &lt;code&gt;$children&lt;/code&gt;：访问父 / 子实例&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意的是：这两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据。我们先来看个用&lt;code&gt;ref&lt;/code&gt;来访问组件的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// component-a 子组件
export default {
  data () {
    return {
      title: &#39;Vue.js&#39;
    }
  },
  methods: {
    sayHello () {
      window.alert(&#39;Hello&#39;);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// 父组件
&amp;lt;template&amp;gt;
  &amp;lt;component-a ref=&amp;quot;comA&amp;quot;&amp;gt;&amp;lt;/component-a&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
  export default {
    mounted () {
      const comA = this.$refs.comA;
      console.log(comA.title);  // Vue.js
      comA.sayHello();  // 弹窗
    }
  }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;不过，这两种方法的弊端是，无法在跨级或兄弟间通信。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们想在 component-a 中，访问到引用它的页面中（这里就是 parent.vue）的两个 component-b 组件，那这种情况下，就得配置额外的插件或工具了，比如 Vuex 和 Bus 的解决方案。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1616312059426.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;8-vuex-的理解&#34;&gt;8. vuex 的理解&lt;/h1&gt;
&lt;h2 id=&#34;1-初识vuex&#34;&gt;1. 初识VueX&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;VueX&lt;/code&gt;是适用于在&lt;code&gt;Vue&lt;/code&gt;项目开发时使用的状态管理工具。&lt;br&gt;
&lt;code&gt;Vue&lt;/code&gt;为这些被多个组件频繁使用的值提供了一个统一管理的工具——&lt;code&gt;VueX&lt;/code&gt;。在具有VueX的Vue项目中，我们只需要把这些值定义在VueX中，即可在整个Vue项目的组件中使用。&lt;/p&gt;
&lt;h2 id=&#34;2-vuex中的核心内容&#34;&gt;2. VueX中的核心内容&lt;/h2&gt;
&lt;p&gt;在VueX对象中，其实不止有&lt;code&gt;state&lt;/code&gt;，还有用来操作&lt;code&gt;state&lt;/code&gt;中数据的方法集，以及当我们需要对state中的数据需要加工的方法集等等成员。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;成员列表：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;state 存放状态&lt;/li&gt;
&lt;li&gt;mutations state成员操作&lt;/li&gt;
&lt;li&gt;getters 加工state成员给外界&lt;/li&gt;
&lt;li&gt;actions 异步操作&lt;/li&gt;
&lt;li&gt;modules 模块化状态管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;21-vuex的工作流程&#34;&gt;2.1 VueX的工作流程&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1616207478171.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;首先，&lt;code&gt;Vue&lt;/code&gt;组件如果调用某个&lt;code&gt;VueX&lt;/code&gt;的方法过程中需要向后端请求时或者说出现异步操作时，需要&lt;code&gt;dispatch&lt;/code&gt; VueX中&lt;code&gt;actions&lt;/code&gt;的方法，以保证数据的同步。可以说，&lt;code&gt;action&lt;/code&gt;的存在就是为了让&lt;code&gt;mutations&lt;/code&gt;中的方法能在异步操作中起作用。&lt;/p&gt;
&lt;p&gt;如果没有异步操作，那么我们就可以直接在组件内提交状态中的&lt;code&gt;Mutations&lt;/code&gt;中自己编写的方法来达成对&lt;code&gt;state&lt;/code&gt;成员的操作。不建议在组件中直接对state中的成员进行操作，这是因为直接修改(例如：this.$store.state.name = &#39;hello&#39;)的话不能被&lt;code&gt;VueDevtools&lt;/code&gt;所监控到。&lt;/p&gt;
&lt;p&gt;最后被修改后的&lt;code&gt;state&lt;/code&gt;成员会被渲染到组件的原位置当中去。&lt;/p&gt;
&lt;h3 id=&#34;22-mutations&#34;&gt;2.2 Mutations&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;mutations&lt;/code&gt;是操作&lt;code&gt;state&lt;/code&gt;数据的方法的集合，比如对该数据的修改、增加、删除等等。&lt;/p&gt;
&lt;p&gt;mutations方法都有默认的形参：&lt;/p&gt;
&lt;p&gt;([state] [,payload])&lt;/p&gt;
&lt;p&gt;&lt;code&gt;state&lt;/code&gt;是当前VueX对象中的state&lt;br&gt;
&lt;code&gt;payload&lt;/code&gt;是该方法在被调用时传递参数使用的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;this.$store.commit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;增加&lt;/strong&gt;：Vue.set 为某个对象设置成员的值，若不存在则新增&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Vue.set(state,&amp;quot;age&amp;quot;,15)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;删除&lt;/strong&gt;：Vue.delete 删除成员&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Vue.delete(state,&#39;age&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;23-getters&#34;&gt;2.3 Getters&lt;/h3&gt;
&lt;p&gt;可以对state中的成员加工后传递给外界&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Getters中的方法有两个默认参数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;state 当前VueX对象中的状态对象&lt;/li&gt;
&lt;li&gt;getters 当前getters对象，用于将getters下的其他getter拿来用&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;getters:{
    nameInfo(state){
        return &amp;quot;姓名:&amp;quot;+state.name
    },
    fullInfo(state,getters){
        return getters.nameInfo+&#39;年龄:&#39;+state.age
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;组件中调用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;this.$store.getters.fullInfo
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;24-actions&#34;&gt;2.4 Actions&lt;/h3&gt;
&lt;p&gt;由于直接在&lt;code&gt;mutation&lt;/code&gt;方法中进行&lt;strong&gt;异步操作&lt;/strong&gt;，将会引起数据失效。所以提供了&lt;code&gt;Actions&lt;/code&gt;来专门进行异步操作，最终提交&lt;code&gt;mutation&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;Actions中的方法有两个默认参数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;context 上下文(相当于箭头函数中的this)对象&lt;/li&gt;
&lt;li&gt;payload 挂载参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于&lt;code&gt;setTimeout&lt;/code&gt;和&lt;code&gt;promise&lt;/code&gt;是异步操作，所以需要使用&lt;code&gt;actions&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; aEdit(context,payload){
        return new Promise((resolve,reject)=&amp;gt;{
            setTimeout(()=&amp;gt;{
                context.commit(&#39;edit&#39;,payload)
                resolve()
            },2000)
        })
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在组件中调用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;this.$store.dispatch(&#39;aEdit&#39;,{age:15})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;25-models&#34;&gt;2.5 Models&lt;/h3&gt;
&lt;p&gt;当项目庞大，状态非常多时，可以采用&lt;strong&gt;模块化管理模式&lt;/strong&gt;。Vuex 允许我们将 &lt;code&gt;store&lt;/code&gt;分割成模块（&lt;code&gt;module&lt;/code&gt;）。每个模块拥有自己的&lt;code&gt;state、mutation、action、getter&lt;/code&gt;、甚至是嵌套子模块——从上至下进行同样方式的分割。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;models:{
    a:{
        state:{},
        getters:{},
        ....
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;组件内调用模块a的状态：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;this.$store.state.a
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于模块内部的 mutation 和 getter，&lt;strong&gt;接收的第一个参数是模块的局部状态对象&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同样，对于模块内部的 action，局部状态通过 &lt;code&gt;context.state&lt;/code&gt; 暴露出来，根节点状态则为 &lt;code&gt;context.rootState&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于模块内部的&lt;code&gt;getter&lt;/code&gt;，根节点状态会作为第三个参数暴露出来&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-规范目录结构&#34;&gt;3. 规范目录结构&lt;/h2&gt;
&lt;p&gt;如果把整个&lt;code&gt;store&lt;/code&gt;都放在&lt;code&gt;index.js&lt;/code&gt;中是不合理的，所以需要拆分。比较合适的目录格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;store:.
│  actions.js
│  getters.js
│  index.js
│  mutations.js
│  mutations_type.js   ##该项为存放mutaions方法常量的文件，按需要可加入
│
└─modules
        Astore.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对应的内容存放在对应的文件中，和以前一样，在&lt;code&gt;index.js&lt;/code&gt;中存放并导出&lt;code&gt;store&lt;/code&gt;。&lt;code&gt;state&lt;/code&gt;中的数据尽量放在&lt;code&gt;index.j&lt;/code&gt;s中。而&lt;code&gt;modules&lt;/code&gt;中的&lt;code&gt;Astore&lt;/code&gt;局部模块状态如果多的话也可以进行细分。&lt;/p&gt;
&lt;h2 id=&#34;4-vuex的优缺点&#34;&gt;4. vuex的优缺点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;vuex的优点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;解决了非父子组件的消息传递（将数据存放在state中）&lt;/li&gt;
&lt;li&gt;减少了AJAX请求次数，有些情景可以直接从内存中的state获取&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;vuex的缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;刷新浏览器，vuex中的state会重新变为初始状态&lt;br&gt;
解决方案vuex-along ,vuex-persistedstate&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-命名空间&#34;&gt;5. 命名空间&lt;/h2&gt;
&lt;p&gt;getter，mutation，action 他们默认都是注册在全局命名空间的，所以我们默认是可以和使用根状态一样去使用他们，但是这样不可避免会出现命名冲突的问题，所以使模块有更高的封装性与复用性，我们可以通过添加 &lt;code&gt;namespaced: true&lt;/code&gt; 使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// moduleB 模块导出的时候加个 namespaced: true,
export default {
  namespaced: true,
  state,
  getters,
  mutations,
  actions,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;51-辅助函数的使用&#34;&gt;5.1 辅助函数的使用&lt;/h3&gt;
&lt;p&gt;除了这个之外，如果你当前组件用的 vuex 状态都是一个模块的话，我们可以使用 createNamespacedHelpers 创建基于某个命名空间辅助函数，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { createNamespacedHelpers } from &#39;vuex&#39;

const { mapState, mapActions } = createNamespacedHelpers(&#39;moduleB&#39;) // moduleName
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样创建之后，我们就可以用之前的写法来访问到模块的状态。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...mapState({
  bName: state =&amp;gt; state.bName,
}),
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;52-在带命名空间的模块内访问全局内容&#34;&gt;5.2 在带命名空间的模块内访问全局内容&lt;/h3&gt;
&lt;p&gt;如果你希望使用全局 state 和 getter，rootState 和 rootGetter 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。&lt;/p&gt;
&lt;p&gt;若需要在全局命名空间内分发 action 或提交 mutation，将 { root: true } 作为第三参数传给 dispatch 或 commit 即可&lt;/p&gt;
&lt;h1 id=&#34;9-computed-和-watch-区别&#34;&gt;9、computed 和 watch 区别&lt;/h1&gt;
&lt;h2 id=&#34;1-计算属性computed&#34;&gt;1. 计算属性computed :&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;支持缓存，只有依赖数据发生改变，才会重新进行计算&lt;/li&gt;
&lt;li&gt;不支持异步，当computed内有异步操作时无效，无法监听数据的变化&lt;/li&gt;
&lt;li&gt;computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值&lt;/li&gt;
&lt;li&gt;如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed&lt;/li&gt;
&lt;li&gt;如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-侦听属性watch&#34;&gt;2. 侦听属性watch：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;不支持缓存，数据变，直接会触发相应的操作；&lt;/li&gt;
&lt;li&gt;watch支持异步；&lt;/li&gt;
&lt;li&gt;监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；&lt;/li&gt;
&lt;li&gt;当一个属性发生变化时，需要执行对应的操作；一对多；&lt;/li&gt;
&lt;li&gt;监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，&lt;br&gt;
　　immediate：组件加载立即触发回调函数执行，&lt;br&gt;
　　deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异，只有以响应式的方式触发才会被监听到。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + &#39; &#39; + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(&#39; &#39;)
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
},
watch: {
    a: {
      handler(newVal) {
        console.log(newVal)
      },
      deep: true,
      immediate: true
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;10-vue-router-hash-html5-新增的-pushstate&#34;&gt;10. vue-router (hash， HTML5 新增的 pushState)&lt;/h1&gt;
&lt;h2 id=&#34;1-单页应用如何实现其路由功能-路由原理&#34;&gt;1. 单页应用，如何实现其路由功能---路由原理&lt;/h2&gt;
&lt;p&gt;大型单页应用最显著特点之一就是采用的&lt;code&gt;前端路由&lt;/code&gt;跳转子页面系统，通过改变页面的URL，在&lt;code&gt;不重新请求页面&lt;/code&gt;的情况下，更新页面视图。&lt;/p&gt;
&lt;p&gt;更新视图但是浏览器不重新渲染整个页面，只是重新渲染部分子页面，加载速度快，页面反应灵活，这是 SPA 的优势，这也是前端路由原理的核心，这会给人一种仿佛在操作 APP 一样的感觉，目前在浏览器环境中实现这一功能的方式主要有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用 URL 的 hash(#)&lt;/li&gt;
&lt;li&gt;利用 H5 新增方法 History interface&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-利用url的hash&#34;&gt;1. 利用URL的Hash(#)&lt;/h3&gt;
&lt;p&gt;在 H5 还没有流行开来时，一般 SPA 都采用 url 的 hash(#) 作为锚点，获取到 # 之后的值，并监听其改变，再进行渲染对应的子页面。&lt;/p&gt;
&lt;p&gt;例如，你的地址为http://localhost:8888/#/abc 那么利用 location.hash 输出的内容就为 #/abc。&lt;/p&gt;
&lt;p&gt;那么我就先从 location 这个对象说起。&lt;br&gt;
先来看看location的官方属性有哪些&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;属性&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;hash&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;设置或返回从 # 开始的 URL （锚）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;host&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;设置或返回主机名和当前 URL 的端口号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;hostname&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;设置或返回当前 URL 的主机名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;href&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;设置或返回完整的 URL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pathname&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;设置或返回当前 URL 的路径部分&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;port&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;设置或返回当前 URL 的端口号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;protocol&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;设置或返回当前 URL 的协议&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;search&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;设置或返回从 ? 开始的 URL 部分&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;由上表格可以知道，我们可以轻易的获取到 # 之后的部分，那么拿到这个部分我们怎么监听其变化以及对应的子页面进行改变呢？&lt;/p&gt;
&lt;p&gt;window 对象中有一个事件是专门监听hash的变化，那就是onhashchange，首先我们需要 监听此事件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
  &amp;lt;h1 id=&amp;quot;id&amp;quot;&amp;gt;&amp;lt;/h1&amp;gt;
  &amp;lt;a href=&amp;quot;#/id1&amp;quot;&amp;gt;id1&amp;lt;/a&amp;gt;
  &amp;lt;a href=&amp;quot;#/id2&amp;quot;&amp;gt;id2&amp;lt;/a&amp;gt;
  &amp;lt;a href=&amp;quot;#/id3&amp;quot;&amp;gt;id3&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;script&amp;gt;
  window.addEventListener(&#39;hashchange&#39;, e =&amp;gt; {
    e.preventDefault()
    document.querySelector(&#39;#id&#39;).innerHTML = location.hash
  })
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见此时我们已经完全监听到了 URL 的变化，页面上的内容也对应改变了。&lt;br&gt;
那么，该如何载入不同的页面呢，目前来说有三种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;寻找节点内容并改变（也就是上面我们演示的内容）&lt;/li&gt;
&lt;li&gt;import 一个 JS 文件，文件内部 export 模版字符串&lt;/li&gt;
&lt;li&gt;利用 AJAX 加载对应的 HTML 模版&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-利用-h5-新增方法-history-interface&#34;&gt;2. 利用 H5 新增方法 History interface&lt;/h3&gt;
&lt;p&gt;如果在微信或者其他不显示 URL 的 APP 中使用，倒也无所谓，但是如果在一般的浏览器中使用就会遇到问题了。&lt;br&gt;
由此，H5 的 History 模式，解决了这一问题。&lt;/p&gt;
&lt;p&gt;在 H5 之前， History 仅仅只有一下几个 API：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;API&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;back()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;回退到上次访问的 URL （与浏览器点击后退按钮相同）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;forward()&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;前进到回退之前的 URL （与浏览器点击向前按钮相同）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;go(n)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;n 接收一个整数，移动到该整数指定的页面，比如go(1)相当于forward()，go(-1) 相当于 back()，go(0)相当于刷新当前页面&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;如果移动的位置超出了访问历史的边界，以上三个方法并不报错，而是静默失败&lt;/strong&gt;。&lt;br&gt;
然而，到了 H5 的时代，新的 H5 则赋予了其更多的新特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;往返缓存&lt;/code&gt;&lt;br&gt;
默认情况下，浏览器会缓存当前会话页面，这样当下一个页面点击后退按钮，或前一个页面点击前进按钮，浏览器便会从缓存中提取并加载此页面，这个特性被称为“往返缓存”。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;PS: 此缓存会保留页面数据、DOM和js状态，实际上是将整个页面完好无缺地保留。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;往历史记录栈中添加记录：&lt;code&gt;pushState(state, title, url)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;state: 一个 JS 对象（不大于640kB），主要用于在 popstate 事件中作为参数被获取。如果不需要这个对象，此处可以填 null&lt;/li&gt;
&lt;li&gt;title: 新页面的标题，部分浏览器(比如 Firefox )忽略此参数，因此一般为 null&lt;/li&gt;
&lt;li&gt;url: 新历史记录的地址，可为页面地址，也可为一个锚点值，新 url 必须与当前 url 处于同一个域，否则将抛出异常，此参数若没有特别标注，会被设为当前文档 url&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;除此之外，仍有几点需要注意&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 url 设为锚点值时不会触发 hashchange&lt;/li&gt;
&lt;li&gt;根据同源策略，如果设置不同域名地址，会报错，这样做的目的是：防止用户以为它们是同一个网站，若没有此限制，将很容易进行 XSS 、 CSRF 等攻击方式&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;改变当前的历史记录：&lt;code&gt;replaceState(state, title, url)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;参数含义同 pushstate&lt;/li&gt;
&lt;li&gt;改变当前的历史记录而不是添加新的记录&lt;/li&gt;
&lt;li&gt;同样不会触发 popstate&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;code&gt;popstate&lt;/code&gt;&lt;br&gt;
定义：每当同一个文档的浏览历史（即 history 对象）出现变化时，就会触发 popstate 事件。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意：若仅仅调用 pushState 方法或 replaceState 方法 ，并不会触发该事件，只有用户点击浏览器&lt;strong&gt;倒退&lt;/strong&gt;按钮和&lt;strong&gt;前进&lt;/strong&gt;按钮，或者使用 JavaScript 调用 back 、 forward 、 go 方法时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。&lt;/p&gt;
&lt;h3 id=&#34;3-总结&#34;&gt;3. 总结&lt;/h3&gt;
&lt;p&gt;一般场景下，hash 和 history 都可以，除非你更在意颜值，# 符号夹杂在 URL 里看起来确实有些不太美丽。&lt;br&gt;
另外，调用 &lt;code&gt;history.pushState()&lt;/code&gt; 相比于直接修改 &lt;code&gt;hash&lt;/code&gt;，存在以下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL&lt;/li&gt;
&lt;li&gt;pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中&lt;/li&gt;
&lt;li&gt;pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；&lt;/li&gt;
&lt;li&gt;pushState() 可额外设置 title 属性供后续使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但其实 history 也不是样样都好，虽然在浏览器里游刃有余，但真要通过 URL 向后端发起 HTTP 请求时，两者的差异就来了。尤其在用户手动输入 URL 后回车，或者刷新（重启）浏览器的时候。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 http://www.qqq.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。&lt;/li&gt;
&lt;li&gt;history 模式下，前端的 URL &lt;strong&gt;必须&lt;/strong&gt;和实际向后端发起请求的 URL 一致，如 http://www.qqq.com/book/id。如果后端缺少对 /book/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”&lt;/li&gt;
&lt;li&gt;需在后端（Apache 或 Nginx）进行简单的路由配置，同时搭配前端路由的 404 页面支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-vue-router-如何做用户登录权限等&#34;&gt;2. vue-router 如何做用户登录权限等&lt;/h2&gt;
&lt;p&gt;使用 meta 来检测一个目标页面是否需要登陆权限，然后向服务器发送一个带有 Cookie 字段的请求，询问浏览器端的 cookie 中的 sessionID 是否已过期（因为 session 是保存在服务器端的），如果过期就需要重新登陆，跳转到登陆页面，否则表示已是登陆状态，进入目标页面。&lt;/p&gt;
&lt;h2 id=&#34;3-你在项目中怎么实现路由的嵌套&#34;&gt;3. 你在项目中怎么实现路由的嵌套&lt;/h2&gt;
&lt;p&gt;一个被渲染组件同样可以包含自己的&amp;lt;router-view&amp;gt;（一个出口）&lt;br&gt;
要在嵌套的出口中渲染组件，需要在 VueRouter 中使用 children 配置&lt;br&gt;
在 children 中的路由不需要以 / 开头，因为是嵌套的路由&lt;br&gt;
除此之外就像和 routes 配置一样的路由配置数组&lt;/p&gt;
&lt;h2 id=&#34;4-vue-router-有哪几种导航钩子&#34;&gt;4. vue-router 有哪几种导航钩子&lt;/h2&gt;
&lt;h3 id=&#34;1全局的&#34;&gt;1.全局的：&lt;/h3&gt;
&lt;p&gt;全局前置守卫 beforeEach&lt;br&gt;
全局解析守卫（在组件路由所有守卫之后） beforeResolve&lt;br&gt;
全局后置钩子（没有 next 参数，因为不在导航守卫队列中，此时导航被确认） afterEach&lt;br&gt;
router.beforeEach((to,from.next) =&amp;gt; {})&lt;br&gt;
单个路由独享（在路由配置上直接定义）：beforeEnter&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1618320145843.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-组件级在路由组件内直接调用的守卫像调用生命周期那样&#34;&gt;2. 组件级：在路由组件内直接调用的守卫，像调用生命周期那样&lt;/h3&gt;
&lt;p&gt;beforeRouteEnter&lt;br&gt;
这是唯一可以给 next() 传递回调函数作为参数的守卫（对于所有守卫而言的）&lt;br&gt;
其他两个已经可以直接使用 this，所以不需要再传入回调&lt;/p&gt;
&lt;p&gt;beforeRouteUpdate 在重复组件中调用这个守卫，所以可以访问 this&lt;br&gt;
主要是因为在重用组件中使用了这个守卫，因此在这里请求数据可以在组件复用是更新数据&lt;/p&gt;
&lt;p&gt;beforeRouteLeave 离开失活组件时执行的守卫，所以可以访问到失活组件的 this&lt;br&gt;
当导航守卫的队列都清空时，表示导航被确认，然后调用全局的 afterEach 钩子，然后触发 DOM 更新，然后再会执行 beforeRouteEnter 中的 next 方法中的回调函数。&lt;br&gt;
只要有 next 参数的，最后都要执行 next() 才能跳转到下一个守卫&lt;/p&gt;
&lt;h2 id=&#34;5-route-和-router-的区别&#34;&gt;5. $route 和 $router 的区别：&lt;/h2&gt;
&lt;p&gt;this.&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;是&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;访&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;问&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;路&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;由&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;器&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;router 是访问路由器
this.&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;是&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;访&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;问&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;路&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;由&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;器&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;route 是访问当前路由&lt;/p&gt;
&lt;p&gt;this.$router.push会往history栈中添加一个新的记录。&lt;br&gt;
this.$route相当于当前正在跳转的路由对象。可以从里面获取name,path,params,query等。&lt;/p&gt;
&lt;h2 id=&#34;6-如何使用-vue-router&#34;&gt;6. 如何使用 vue-router&lt;/h2&gt;
&lt;p&gt;1）import 进来，然后通过 Vue.use() 明确安装路由功能&lt;br&gt;
2）定义路由组件，或者引入单文件组件&lt;br&gt;
3）定义路由配置，配置是一个数组，元素是对象&lt;br&gt;
4）创建一个 vue-router 实例，new vueRouter({})&lt;br&gt;
5）创建 vue 根实例，将 router 作为配置参数传入&lt;/p&gt;
&lt;h1 id=&#34;11-vue中v-if与v-show的区别以及使用场景&#34;&gt;11. vue中v-if与v-show的区别以及使用场景&lt;/h1&gt;
&lt;h2 id=&#34;1-区别&#34;&gt;1. 区别&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;手段：v-if是通过控制dom节点的&lt;code&gt;存在&lt;/code&gt;与否来控制元素的显隐；v-show是通过设置DOM元素的&lt;code&gt;display样式&lt;/code&gt;，block为显示，none为隐藏；&lt;/li&gt;
&lt;li&gt;编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的&lt;code&gt;基于css切换&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;编译条件：v-if是&lt;code&gt;惰性&lt;/code&gt;的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；&lt;/li&gt;
&lt;li&gt;性能消耗：v-if有更高的&lt;code&gt;切换消耗&lt;/code&gt;；v-show有更高的初始&lt;code&gt;渲染消耗&lt;/code&gt;；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;换句话说，v-if 的表达式返回值，会直接触发到&lt;code&gt;当前组件 生命周期&lt;/code&gt;，并且事件监听器和子组件会被适当地被销毁和重建。 所以，可以理解为 v-if 是惰性的，他不会在页面初始化时，被无条件渲染，而是按需响应式地渲染。&lt;/p&gt;
&lt;p&gt;而 v-show ，这是无论表达式返回值是否是 true 都会在&lt;code&gt;create 生命周期&lt;/code&gt;，无条件消耗资源生成对应的 Virtual DOM，并挂载到HTML页面中，只是再根据表达式返回值，切换 display 这个 CSS 属性。&lt;/p&gt;
&lt;h2 id=&#34;2-使用场景&#34;&gt;2. 使用场景&lt;/h2&gt;
&lt;p&gt;基于以上区别，因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。&lt;/p&gt;
&lt;h2 id=&#34;3-总结-2&#34;&gt;3. 总结&lt;/h2&gt;
&lt;p&gt;v-if判断是否加载，可以减轻服务器的压力，在需要时加载,但有更高的切换开销;v-show调整DOM元素的CSS的dispaly属性，可以使客户端操作更加流畅，但有更高的初始渲染开销。如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。&lt;/p&gt;
&lt;h1 id=&#34;12-vue插槽v-slot&#34;&gt;12. Vue插槽（v-slot）&lt;/h1&gt;
&lt;h2 id=&#34;1-匿名插槽&#34;&gt;1. 匿名插槽&lt;/h2&gt;
&lt;p&gt;匿名插槽，我们也可以叫它单个插槽或者默认插槽。和具名插槽相对，它是不需要设置  name 属性的，它隐藏的name属性为default。&lt;/p&gt;
&lt;p&gt;在使用的时候还有一个问题要注意的 如果是有2个以上的匿名插槽是会child标签里面的内容全部都替换到每个slot；&lt;/p&gt;
&lt;h2 id=&#34;2-具名插槽&#34;&gt;2. 具名插槽&lt;/h2&gt;
&lt;p&gt;顾名思义就是slot 是带有name的 ，定义：&amp;lt;slot name=&amp;quot;header&amp;quot; /&amp;gt;  或者使用简单缩写的定义 #header&lt;br&gt;
使用：要用一个 template标签包裹&lt;/p&gt;
&lt;p&gt;这里说一下多个具名插槽的使用 &lt;code&gt;多个具名插槽，插槽的位置不是使用插槽的位置而定的，是在定义的时候的位置来替换的&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;13-vue的scoped属性&#34;&gt;13. Vue的Scoped属性&lt;/h1&gt;
&lt;h2 id=&#34;1-什么是scoped&#34;&gt;1. 什么是scoped&lt;/h2&gt;
&lt;p&gt;在Vue文件中的style标签上有一个特殊的属性，scoped。当一个style标签拥有scoped属性时候，它的css样式只能用于&lt;code&gt;当前&lt;/code&gt;的Vue组件，可以使组件的样式不相互污染。如果一个项目的&lt;code&gt;所有style标签&lt;/code&gt;都加上了scoped属性，相当于实现了样式的&lt;code&gt;模块化&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;2-scoped的实现原理&#34;&gt;2. Scoped的实现原理&lt;/h2&gt;
&lt;p&gt;Vue中的scoped属性的效果主要是通过&lt;code&gt;PostCss&lt;/code&gt;实现的。&lt;br&gt;
以下是转译前的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style scoped lang=&amp;quot;less&amp;quot;&amp;gt;
    .example{
        color:red;
    }
&amp;lt;/style&amp;gt;
&amp;lt;template&amp;gt;
    &amp;lt;div class=&amp;quot;example&amp;quot;&amp;gt;scoped测试案例&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;转译后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.example[data-v-5558831a] {
  color: red;
}
&amp;lt;template&amp;gt;
    &amp;lt;div class=&amp;quot;example&amp;quot; data-v-5558831a&amp;gt;scoped测试案例&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;PostCSS&lt;/code&gt;给一个组件中的所有&lt;code&gt;dom&lt;/code&gt;添加了一个独一无二的&lt;code&gt;动态属性&lt;/code&gt;，给&lt;code&gt;css选择器&lt;/code&gt;额外添加一个对应的&lt;code&gt;属性选择器&lt;/code&gt;，来选择组件中的dom，这种做法使得样式只作用于含有该属性的dom元素(组件内部的dom)。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;总结：scoped的渲染规则：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;给HTML的dom节点添加一个不重复的data属性(例如: data-v-5558831a)来唯一标识这个dom 元素&lt;/li&gt;
&lt;li&gt;在每句css选择器的末尾(编译后生成的css语句)加一个当前组件的data属性选择器(例如：[data-v-5558831a])来私有化样式&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-scoped穿透&#34;&gt;3. Scoped穿透&lt;/h2&gt;
&lt;p&gt;Scoped看起来很好用，当时在Vue项目中，当我们引入第三方组件库时(如使用vue-awesome-swiper实现移动端轮播)，需要在局部组件中修改第三方组件库的样式，而又不想去除scoped属性造成组件之间的样式覆盖。这时我们可以通过特殊的方式穿透scoped。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;stylus的样式穿透 使用&amp;gt;&amp;gt;&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;外层 &amp;gt;&amp;gt;&amp;gt; 第三方组件 
        样式
        
   .wrapper &amp;gt;&amp;gt;&amp;gt; .swiper-pagination-bullet-active
    background: #fff
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sass和less的样式穿透 使用/deep/&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  外层 /deep/ 第三方组件 {
        样式
    }
    .wrapper /deep/ .swiper-pagination-bullet-active{
      background: #fff;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-在组件中修改第三方组件库样式的其它方法&#34;&gt;4. 在组件中修改第三方组件库样式的其它方法&lt;/h2&gt;
&lt;p&gt;上面我们介绍了在使用scoped 属性时，通过scopd穿透的方式修改引入第三方组件库样式的方法，下面我们介绍其它方式来修改引入第三方组件库的样式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在vue组件中不使用scoped属性&lt;/li&gt;
&lt;li&gt;在vue组建中使用两个style标签，一个加上scoped属性，一个不加scoped属性，把需要覆盖的css样式写在不加scoped属性的style标签里&lt;/li&gt;
&lt;li&gt;建立一个reset.css(基础全局样式)文件，里面写覆盖的css样式，在入口文件main.js 中引入&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;14-defineproperty-和-proxy-对象代理的区别&#34;&gt;14. defineProperty 和 Proxy 对象代理的区别 ！！！&lt;/h1&gt;
&lt;h2 id=&#34;1defineproperty-对对象和数组的监听&#34;&gt;1.defineproperty 对对象和数组的监听&lt;/h2&gt;
&lt;h3 id=&#34;1-objectdefineproperty-对象属性监听&#34;&gt;1. Object.defineProperty 对象属性监听&lt;/h3&gt;
&lt;p&gt;现在我们有这样一个对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let obj = {
	name:&#39;码不停息&#39;,
    age:18,
    love:[&#39;吃饭&#39;,&#39;睡觉&#39;,&#39;打豆豆&#39;]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们想实现只要是对象里面的任何数据改变,都要跟新视图或者执行我们自己的逻辑,那我们需要怎么办呢?&lt;/p&gt;
&lt;p&gt;我们似乎需要解决以下几个问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;obj&lt;/code&gt;对象有多个属性,可能需要__循环__添加到&lt;code&gt;Object.defineProperty&lt;/code&gt;里面&lt;/li&gt;
&lt;li&gt;&lt;code&gt;obj&lt;/code&gt;的属性也可能是对象或者数组,可能需要__递归__&lt;/li&gt;
&lt;li&gt;用户可能给&lt;code&gt;obj&lt;/code&gt;赋值新的属性,这种情况可能需要 &lt;strong&gt;单独处理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;let a = {&#39;b&#39;: 1};
Object.defineProperty(a, &#39;b&#39;, {
    enumerable: false,
    configurable: false,
    get: function(){
        console.log(&#39;b&#39; + &#39;被访问&#39;);
    },
    set: function(newVal){
        console.log(&#39;b&#39; + &#39;被修改，新&#39; + &#39;b&#39; + &#39;=&#39; + newVal);
    }
});
a.b = 2;   // b被修改，新b=2
a.b;       // b被访问
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可能会有对象中属性的值还是对象这种嵌套情况，可以通过递归解决&lt;/p&gt;
&lt;h3 id=&#34;2-objectdefineproperty-数组属性监听&#34;&gt;2. Object.defineProperty 数组属性监听&lt;/h3&gt;
&lt;p&gt;Object.defineProperty 是对象的方法监听不到数组的变更的，&lt;strong&gt;！重写 ！&lt;/strong&gt;&lt;code&gt;Array&lt;/code&gt;的原型方法来实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面我们在&lt;code&gt;observer&lt;/code&gt;中加上关于对数组的判断&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const orginalProto = Array.prototype;
const arrayProto = Object.create(orginalProto); // 先克隆一份Array的原型出来
const methodsToPatch = [
  &#39;push&#39;,
  &#39;pop&#39;,
  &#39;shift&#39;,
  &#39;unshift&#39;,
  &#39;splice&#39;,
  &#39;sort&#39;,
  &#39;reverse&#39;
]
methodsToPatch.forEach(method =&amp;gt; {
  arrayProto[method] = function () {
    // 执行原始操作
    orginalProto[method].apply(this, arguments)
    console.log(&#39;监听赋值成功&#39;, method)
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-不存在的对象属性&#34;&gt;3. 不存在的对象属性&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  {{ obj.c }}
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
  data: {
    obj: { a: 1 },
  },
  mounted() {
    this.obj.c = 3
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个例子中，我们对obj上原本不存在的&lt;code&gt;c&lt;/code&gt;属性进行了一个赋值，但是在Vue2中，这是&lt;code&gt;不会触发视图&lt;/code&gt;的响应式更新的，&lt;br&gt;
这是因为Object.defineProperty必须对于确定的&lt;code&gt;key&lt;/code&gt;值进行响应式的定义，&lt;br&gt;
这就导致了如果data在初始化的时候没有&lt;code&gt;c&lt;/code&gt;属性，那么后续对于&lt;code&gt;c&lt;/code&gt;属性的赋值都不会触发Object.defineProperty中对于&lt;code&gt;set&lt;/code&gt;的劫持，&lt;br&gt;
在Vue2中，这里只能用一个额外的api Vue.set来解决，&lt;/p&gt;
&lt;h2 id=&#34;2-proxy-代理实现&#34;&gt;2. Proxy 代理实现&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const raw = {}
const data = new Proxy(raw, {
    get(target, key) { },
    set(target, key, value) { }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出来，Proxy在定义的时候并不用关心key值，&lt;br&gt;
只要你定义了get方法，那么后续对于data上任何属性的访问（哪怕是不存在的），&lt;br&gt;
都会触发&lt;code&gt;get&lt;/code&gt;的劫持，&lt;code&gt;set&lt;/code&gt;也是同理。&lt;br&gt;
这样Vue3中，对于需要定义响应式的值，初始化时候的要求就没那么高了，只要保证它是个可以被Proxy接受的对象或者数组类型即可。&lt;br&gt;
当然，Proxy对于数据拦截带来的便利还不止于此，往下看就知道。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Proxy只会代理对象的第一层，Vue3又是怎样处理这个问题的呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-思路&#34;&gt;1. 思路&lt;/h3&gt;
&lt;p&gt;首先响应式的思路无外乎这样一个模型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义某个数据为&lt;code&gt;响应式数据&lt;/code&gt;，它会拥有收集&lt;code&gt;访问它的函数&lt;/code&gt;的能力。&lt;/li&gt;
&lt;li&gt;定义观察函数，在这个函数内部去访问&lt;code&gt;响应式数据&lt;/code&gt;，访问到&lt;code&gt;响应式数据&lt;/code&gt;的某个key的时候，会建立一个依赖关系&lt;code&gt;key -&amp;gt; reaction观察函数&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;检测到&lt;code&gt;响应式数据&lt;/code&gt;的&lt;code&gt;key&lt;/code&gt;的值更新的时候，会去重新执行一遍它所收集的所有&lt;code&gt;reaction&lt;/code&gt;观察函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-reactive的实现定义响应式数据&#34;&gt;2. reactive的实现（定义响应式数据）&lt;/h3&gt;
&lt;p&gt;首先是定义proxy&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const reactive = new Proxy(raw, baseHandlers)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个baseHandlers里就是对于数据的&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;之类的劫持，&lt;br&gt;
这里有两个&lt;code&gt;WeakMap&lt;/code&gt;： &lt;code&gt;proxyToRaw&lt;/code&gt;和&lt;code&gt;rawToProxy&lt;/code&gt;，&lt;br&gt;
可以看到在定义响应式数据为一个Proxy的时候，会进行一个&lt;code&gt;双向的存储&lt;/code&gt;，&lt;br&gt;
这样后续无论是拿到原始对象还是拿到响应式&lt;code&gt;proxy&lt;/code&gt;，都可以很容易的拿到它们的&lt;code&gt;另一半&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;之后&lt;code&gt;storeObservable&lt;/code&gt;，是用原始对象建立一个map：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const connectionStore = new WeakMap&amp;lt;Raw, ReactionForRaw&amp;gt;()

function storeObservable(value: object) {
  // 存储对象和它内部的key -&amp;gt; reaction的映射
  connectionStore.set(value, new Map() as ReactionForRaw)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是一个&lt;code&gt;Raw -&amp;gt; ReactionForRaw&lt;/code&gt;的&lt;code&gt;map&lt;/code&gt;。&lt;br&gt;
也就是&lt;code&gt;原始数据&lt;/code&gt; -&amp;gt; &lt;code&gt;这个数据收集到的观察函数依赖&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-proxy的handler&#34;&gt;3. proxy的handler&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;get收集依赖&lt;/strong&gt;&lt;br&gt;
这里做的一系列操作，就是把用&lt;code&gt;原始数据&lt;/code&gt;从&lt;code&gt;connectionStore&lt;/code&gt;里拿到依赖收集的map，&lt;br&gt;
然后在&lt;code&gt;reaction&lt;/code&gt;观察函数把对于某个&lt;code&gt;key&lt;/code&gt;访问的时候，把&lt;code&gt;reaction&lt;/code&gt;观察函数本身增加到这个&lt;code&gt;key&lt;/code&gt;的观察函数集合里，对于&lt;code&gt;observe(() =&amp;gt; console.log(counter.num));&lt;/code&gt;这个例子来说，就会收集到 &lt;code&gt;{ num -&amp;gt; Set&amp;lt;Reaction &amp;gt;}&lt;/code&gt;。&lt;br&gt;
注意这里对于数组来说，也是一样的流程，只是数组访问的key是下标数字而已。 所以会收集类似于&lt;code&gt;{ 1 -&amp;gt; Set&amp;lt;Reaction&amp;gt;}&lt;/code&gt;这样的结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;set触发更新&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;set&lt;/code&gt;赋值操作的时候，本质上就是去检查这个&lt;code&gt;key&lt;/code&gt;收集到了哪些&lt;code&gt;reaction&lt;/code&gt;观察函数，然后依次触发。（数组也是同理）&lt;/p&gt;
&lt;h3 id=&#34;4-observe-观察函数&#34;&gt;4. observe 观察函数&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;observe&lt;/code&gt;这个api接受一个用户传入的函数，在这个函数内访问响应式数据才会去收集观察函数作为自己的依赖。&lt;/p&gt;
&lt;p&gt;简化后的核心逻辑很简单，&lt;br&gt;
把&lt;code&gt;reaction&lt;/code&gt;推入&lt;code&gt;reactionStack&lt;/code&gt;后开始执行用户传入的函数，&lt;br&gt;
在函数内访问&lt;code&gt;响应式proxy&lt;/code&gt;的属性，又会触发&lt;code&gt;get&lt;/code&gt;的拦截，&lt;br&gt;
这时候&lt;code&gt;get&lt;/code&gt;去&lt;code&gt;reactionStack&lt;/code&gt;找当前正在运行的&lt;code&gt;reaction&lt;/code&gt;，就可以成功的收集到依赖了。&lt;/p&gt;
&lt;h2 id=&#34;3-边界情况&#34;&gt;3. 边界情况&lt;/h2&gt;
&lt;p&gt;以上实现只是一个最基础的响应式模型，还没有实现的点有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;深层数据的劫持&lt;/li&gt;
&lt;li&gt;数组和对象新增、删除项的响应&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来在上面的代码的基础上来实现这两种情况：&lt;/p&gt;
&lt;h3 id=&#34;1-深层数据的劫持&#34;&gt;1. 深层数据的劫持&lt;/h3&gt;
&lt;p&gt;在刚刚的代码实现中，我们只对Proxy的第一层属性做了拦截，假设有这样的一个场景&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const counter = reactive({ data: { num: 0 } });
// 会在控制台打印出0
const counterReaction = observe(() =&amp;gt; console.log(counter.data.num));
counter.data.num = 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么思路其实也有了，就是在&lt;code&gt;深层访问的时候&lt;/code&gt;，如果访问的数据是个对象，就把这个对象也用&lt;code&gt;reactive&lt;/code&gt;包装成proxy再返回，这样在进行&lt;code&gt;counter.data.num = 1;&lt;/code&gt;赋值的时候，其实也是针对一个&lt;code&gt;响应式proxy&lt;/code&gt;赋值了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/** 劫持get访问 收集依赖 */
function get(target: Raw, key: Key, receiver: ReactiveProxy) {
  const result = Reflect.get(target, key, receiver)
  // 收集依赖
  registerRunningReaction({ target, key, receiver, type: &amp;quot;get&amp;quot; })

 // 如果访问的是对象 则返回这个对象的响应式proxy
  if (isObject(result)) {
   return reactive(result)
}
  return result
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-数组和对象新增属性的响应&#34;&gt;2. 数组和对象新增属性的响应&lt;/h3&gt;
&lt;p&gt;这里需要注意的是，如果我们在观察函数中对数据做了遍历操作，那么后续加入对数据进行了&lt;strong&gt;新增&lt;/strong&gt;或&lt;strong&gt;删除&lt;/strong&gt;操作，也需要触发它的重新执行，这是很合理的，&lt;/p&gt;
&lt;p&gt;这里又有一个知识点，对于数组遍历的操作，都会触发它对&lt;code&gt;length&lt;/code&gt;的读取，然后把观察函数收集到&lt;code&gt;length&lt;/code&gt;这个key的依赖中，比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;observe(() =&amp;gt; proxyArray.forEach(() =&amp;gt; {}))
// 会访问proxyArray的length。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以在触发更新的时候，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果目标是个数组，那就从length的依赖里收集。&lt;/li&gt;
&lt;li&gt;如果目标是对象，就从ITERATION_KEY的依赖里收集。（也就是刚刚所说的，对于对象做Object.keys读取时收集的依赖）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如此一来，就实现了对遍历和新增属性这些边界情况的支持。&lt;/p&gt;
&lt;h3 id=&#34;3-删除属性的拦截&#34;&gt;3. 删除属性的拦截&lt;/h3&gt;
&lt;p&gt;基本是同一个套路，只是&lt;code&gt;queueReactionsForOperation&lt;/code&gt;寻找收集观察函数的时候，&lt;code&gt;type&lt;/code&gt;换成了&lt;code&gt;delete&lt;/code&gt;，所以会触发内部做了循环操作的观察函数重新执行。&lt;/p&gt;
&lt;h1 id=&#34;15-vue3新特性&#34;&gt;15. Vue3新特性！！！&lt;/h1&gt;
&lt;h2 id=&#34;1-vue3-为什么要重写&#34;&gt;1. vue3 为什么要重写&lt;/h2&gt;
&lt;p&gt;两个主要原因考虑重写vue新版本主要功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主流浏览器对新的JavaScript语言特性的普遍支持。&lt;/li&gt;
&lt;li&gt;当前Vue代码库随着时间的推移而暴露出来的设计和体系架构问题。&lt;/li&gt;
&lt;li&gt;对一些方法及API进行优化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下是一些原理上的分析：&lt;/p&gt;
&lt;h3 id=&#34;1-浏览器性能提升&#34;&gt;1. 浏览器性能提升&lt;/h3&gt;
&lt;p&gt;首先，随着ES6的发展已及广泛使用，浏览器对这些新的特性逐渐增加，性能不断优化，这就给vue3优化提供了一个机会，通过重写来优化提升vue的性能。&lt;/p&gt;
&lt;h3 id=&#34;2-底层实现方法&#34;&gt;2. 底层实现方法&lt;/h3&gt;
&lt;p&gt;其次，在框架设计上，&lt;strong&gt;vue2.0 是采用Object.defineProperty来实现双向绑定原理&lt;/strong&gt;，这个属性本身就存在一些不足的地方，比如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Object.defineProperty无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。 为了解决这个问题，经过vue内部处理后可以使用以下几种方法来监听数组，push()，pop()，shift()，unshift()，splice()，sort()，reverse()；由于只针对了以上八种方法进行了hack处理,所以其他数组的属性也是检测不到的，还是具有一定的局限性。&lt;/li&gt;
&lt;li&gt;Object.defineProperty只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。Vue 2.x里，是通过 递归 + 遍历 data 对象来实现对数据的监控的，如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象是才是更好的选择，新增的属性还行通过set方法来添加监听，有一定的局限性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;vue3主要采用的Proxy特性，相比之下有以下优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以劫持整个对象，并返回一个新的对象&lt;/li&gt;
&lt;li&gt;有13种劫持操作&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但同时Proxy作为ES6的新特性，有一定的兼容问题，最主要的是这个属性无法用polyfill来兼容，这个需要在vue3中需要解决的问题。&lt;/p&gt;
&lt;h3 id=&#34;3-切换到typescript&#34;&gt;3. 切换到TypeScript&lt;/h3&gt;
&lt;p&gt;Vue 2最初是用纯ES（Javascript）写成的。在原型设计阶段之后不久，我们意识到一个类型系统（Type system）对于这样一个规模的项目非常有用。类型检查（Type check）大大减少了在重构过程中引入意外错误的机会，并帮助贡献者更有信心进行大范围的更改。我们采用了Facebook的Flow type checker，因为它可以逐渐添加到现有的纯ES项目中。Flow type checker在一定程度上起到了帮助作用，但我们并没有从中得到我们所希望的那么多好处。特别是，持续的重大改变使得升级成为一种痛苦。相比较TypeScript与Visual Studio Code集成开发工具的深度集成，Flow type checker对集成开发环境的支持也不理想。&lt;/p&gt;
&lt;p&gt;我们还注意到，用户越来越多地同时使用Vue和TypeScript。为了支持它们的用例，我们必须独立于使用不同类型系统的源代码来编写和维护TypeScript声明。切换到TypeScript将允许我们自动生成声明文件，从而减轻维护负担。&lt;/p&gt;
&lt;p&gt;性能对前端框架至关重要。尽管Vue 2号称具有良好的性能，但重写提供了一个机会，可以通过试验新的渲染策略来更提供更好的性能。&lt;/p&gt;
&lt;h3 id=&#34;4-克服虚拟dom的瓶颈&#34;&gt;4. 克服虚拟DOM的瓶颈&lt;/h3&gt;
&lt;p&gt;另一个更好的办法是去掉不必要的虚拟DOM树遍历和属性比较，这在更新期间往往会产生最大的性能开销。为了实现这一点，编译器和运行时需要协同工作：编译器分析模板并生成带有优化提示的代码，而运行时尽可能获取提示并采用快速路径。这里有&lt;code&gt;三个主要的优化&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;首先，在DOM树级别。我们注意到，在没有动态改变节点结构的模板指令（例如v-if和v-for）的情况下，节点结构保持完全静态。如果我们将一个模板分成由这些结构指令分隔的嵌套“块”，则每个块中的节点结构将再次完全静态。当我们更新块中的节点时，我们不再需要递归遍历DOM树 - 该块内的动态绑定可以在一个平面数组中跟踪。这种优化通过将需要执行的树遍历量减少一个数量级来规避虚拟DOM的大部分开销。&lt;/p&gt;
&lt;p&gt;其次，编译器积极地检测模板中的静态节点、子树甚至数据对象，并在生成的代码中将它们提升到渲染函数之外。这样可以避免在每次渲染时重新创建这些对象，从而大大提高内存使用率并减少垃圾回收的频率。&lt;/p&gt;
&lt;p&gt;第三，在元素级别。编译器还根据需要执行的更新类型，为每个具有动态绑定的元素生成一个优化标志。例如，具有动态类绑定和许多静态属性的元素将收到一个标志，提示只需要进行类检查。运行时将获取这些提示并采用专用的快速路径。&lt;/p&gt;
&lt;p&gt;综合起来，这些技术大大改进了我们的渲染更新基准，Vue 3有时占用的CPU时间不到Vue 2的十分之一。&lt;/p&gt;
&lt;h2 id=&#34;2-setup&#34;&gt;2. Setup&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;setup&lt;/code&gt;函数是一个新的组件选项。作为在组件内使用&lt;code&gt;Composition Api&lt;/code&gt;的入口点。下面我们分为4个方面来讲解它&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用时机&lt;/li&gt;
&lt;li&gt;this指向&lt;/li&gt;
&lt;li&gt;函数参数&lt;/li&gt;
&lt;li&gt;返回值&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-调用时机&#34;&gt;1. 调用时机&lt;/h3&gt;
&lt;p&gt;创建组件实例，然后初始化&lt;code&gt;props&lt;/code&gt;，紧接着就调用&lt;code&gt;setup&lt;/code&gt;函数。 从生命周期的角度来看，它会在&lt;code&gt;beforeCreate&lt;/code&gt;之前执行。也就是创建组件先执行&lt;code&gt;setup&lt;/code&gt;、&lt;code&gt;beforeCreate&lt;/code&gt;、&lt;code&gt;create&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;蛙人&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
  name: &#39;App&#39;,
  setup() {
    console.log(&amp;quot;hey 蛙人&amp;quot;)
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-this指向&#34;&gt;2. this指向&lt;/h3&gt;
&lt;p&gt;由于不能在&lt;code&gt;setup&lt;/code&gt;函数中使用&lt;code&gt;data&lt;/code&gt;、&lt;code&gt;methods&lt;/code&gt;，为了避免使用Vue出错，所以把setup函数中&lt;code&gt;this&lt;/code&gt;修改为了&lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;蛙人&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
  name: &#39;App&#39;,
  setup() {
    console.log(this); // undefined
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-函数参数&#34;&gt;3. 函数参数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;props&lt;/li&gt;
&lt;li&gt;context&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;props&lt;/code&gt;&lt;br&gt;
接收组件传递过来的所有数据，并且都是响应式的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;蛙人&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
  name: &#39;App&#39;,
  props: {
      title: {
          type: String
      }
  },
  setup(props) {
    console.log(props.title)
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意一点，props数据不能使用解构，否则响应式数据失效&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;context&lt;/code&gt;&lt;br&gt;
该参数提供一个上下文对象，从原来的2.x中选择性的暴露了一些属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;attrs&lt;/li&gt;
&lt;li&gt;slots&lt;/li&gt;
&lt;li&gt;emit&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;蛙人&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
  name: &#39;App&#39;,
  props: {
      title: {
          type: String
      }
  },
  setup(props, { attrs, slots, emit } ) {
    console.log(attrs) 
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面，&lt;code&gt;attrs&lt;/code&gt;和&lt;code&gt;slots&lt;/code&gt;都是内部组件实例上对应项的代理，可以确保在更新后仍然还是最新的值。所以这里可以使用解构语法。&lt;/p&gt;
&lt;h3 id=&#34;4-返回值&#34;&gt;4. 返回值&lt;/h3&gt;
&lt;p&gt;可以将&lt;code&gt;setup&lt;/code&gt;函数返回值渲染到页面上。但前提是，&lt;code&gt;setup&lt;/code&gt;返回值必须是一个对象，否则返回其它值则渲染无效。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;蛙人&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
  name: &#39;App&#39;,
  props: {
      title: {
          type: String
      }
  },
  setup() {
    const name = &amp;quot;蛙人&amp;quot;
    return {
       name
    }
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-reactive&#34;&gt;3. Reactive&lt;/h2&gt;
&lt;p&gt;该方法接收一个参数{}创建一个响应式对象。跟&lt;code&gt;Vue2.x&lt;/code&gt;的&lt;code&gt;Vue.observable&lt;/code&gt;一样。如果该参数不是对象的话，也可以渲染到模板上，但不是响应式的数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;test&amp;quot;&amp;gt;
    姓名:  {{ name.value }}
    {{ test() }}
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import { reactive } from &amp;quot;vue&amp;quot;
export default {
 name: &#39;test&#39;,
  data() {
    return {

    }
  },
  setup() {
    let name = reactive({value: &amp;quot;蛙人&amp;quot;})
    function test() {
        name.value = &amp;quot;abc&amp;quot;; // 该方法测试响应式数据，可以看到执行完该方法视图也会发生改变
    }
    return {
        name,
        test
    }
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
">【面】前端知识点梳理（Vue）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/mian-qian-duan-zhi-shi-dian-shu-li-fu-wu-duan-yu-wang-luo/"" data-c="
          &lt;h1 id=&#34;1-常见状态码&#34;&gt;1. 常见状态码&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;1XX 信息&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;消息:&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述:&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;100 Continue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;101 Switching Protocols&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;2XX 成功&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;消息:&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述:&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;200 OK&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;请求成功（其后是对GET和POST请求的应答文档。）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;201 Created&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;请求被创建完成，同时新的资源被创建。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;202 Accepted&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;供处理的请求已被接受，但是处理未完成。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;203 Non-authoritative Information&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;204 No Content&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;3XX 重定向&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;消息:&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述:&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;300 Multiple Choices&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;301 Moved Permanently&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;所请求的页面已经转移至新的url。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;302 Found&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;所请求的页面已经临时转移至新的url。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;303 See Other&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;所请求的页面可在别的url下被找到。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;304 Not Modified&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;4XX 客户端错误&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;消息:&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述:&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;400 Bad Request&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;服务器未能理解请求。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;401 Unauthorized&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;被请求的页面需要用户名和密码。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;403 Forbidden&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对被请求页面的访问被禁止。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;404 Not Found&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;服务器无法找到被请求的页面。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;405 Method Not Allowed&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;请求中指定的方法不被允许。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;406 Not Acceptable&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;服务器生成的响应无法被客户端所接受。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;407 Proxy Authentication Required&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用户必须首先使用代理服务器进行验证，这样请求才会被处理。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;408 Request Timeout&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;请求超出了服务器的等待时间。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;409 Conflict&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;由于冲突，请求无法被完成。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;413 Request Entity Too Large&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;由于所请求的实体的太大，服务器不会接受请求。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;414 Request-url Too Long&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;5XX 服务器错误&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;消息:&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述:&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;500 Internal Server Error&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;请求未完成。服务器遇到不可预知的情况。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;501 Not Implemented&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;请求未完成。服务器不支持所请求的功能。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;502 Bad Gateway&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;请求未完成。服务器从上游服务器收到一个无效的响应。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;503 Service Unavailable&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;请求未完成。服务器临时过载或当机。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;504 Gateway Timeout&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;网关超时。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;505 HTTP Version Not Supported&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;服务器不支持请求中指明的HTTP协议版本。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;2-浏览器缓存&#34;&gt;2. 浏览器缓存&lt;/h1&gt;
&lt;h2 id=&#34;1-200-from-cache和200-ok&#34;&gt;1. 200 From cache和200 ok&lt;/h2&gt;
&lt;p&gt;为什么有的缓存是 200 OK (from cache)，有的缓存是 304 Not Modified 呢？很简单，看运维是否移除了 Entity Tag。移除了，就总是 200 OK (from cache)。没有移除，就两者交替出现。&lt;/p&gt;
&lt;p&gt;其实， 200 OK (from cache)  是浏览器没有跟服务器确认，直接用了浏览器缓存；而 304 Not Modified 是浏览器和服务器多确认了一次缓存有效性，再用的缓存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;它们都是在设置了缓存的情况下触发的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;200 OK (from cache) 是直接点击链接访问，输入网址按回车访问也能触发；而 304 Not Modified 是刷新页面时触发，或是设置了长缓存、但 Entity Tags 没有移除时触发。&lt;/p&gt;
&lt;h2 id=&#34;2-http-304状态码-浏览器缓存&#34;&gt;2. HTTP-304状态码--浏览器缓存&lt;/h2&gt;
&lt;p&gt;304状态码是在协商缓存，缓存命中的时候服务器返回的，告诉客户端，&lt;strong&gt;服务器资源没有修改，可以使用客户端自己的缓存。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;浏览器缓存分为&lt;code&gt;强缓存&lt;/code&gt;（本地缓存）和&lt;code&gt;协商缓存&lt;/code&gt;（弱缓存）。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1617850748410.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-强缓存&#34;&gt;1. 强缓存&lt;/h3&gt;
&lt;p&gt;如上图所示，在浏览器第一次发出请求之后，需要再次发送请求的时候，浏览器首先获取该资源缓存的 header 信息，然后根据 Cache-Control 和 Expires 字段判断缓存是否过期。如果没有过期，直接使用浏览器缓存，并不会与服务器通信。该过程为判断是否使用&lt;code&gt;强缓存&lt;/code&gt;，即本地缓存。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Cache-Control&lt;/strong&gt;&lt;br&gt;
该字段是 HTTP1.1 规范，一般利用该字段的 max-age 属性来判断，这个值是一个相对时间，单位为 s，代表资源的有效期。例如：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;Cache-Control:max-age=3600
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除此之外还有几个常用的值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;no-cache：表示&lt;strong&gt;不使用强缓存&lt;/strong&gt;，需要使用协商缓存&lt;/li&gt;
&lt;li&gt;no-store：禁止&lt;strong&gt;浏览器缓存&lt;/strong&gt;数据，每次请求下载完整的资源&lt;/li&gt;
&lt;li&gt;public：可以被所有用户缓存，包括终端用户和中间代理服务器&lt;/li&gt;
&lt;li&gt;private：只能被终端用户的浏览器缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;Expires&lt;/strong&gt;&lt;br&gt;
该字段是 HTTP1.0 规范，他是一个绝对时间的 GMT 格式的时间字符串。例如：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;expires:Mar, 06 Apr 2021 10:57:09 GMT
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时间代表资源的失效时间，只要发送请求的时间在这之前，都会使用强缓存。&lt;/p&gt;
&lt;p&gt;由于失效时间是一个绝对时间，因此当&lt;strong&gt;服务器时间与客户端时间偏差较大&lt;/strong&gt;时，就会导致&lt;strong&gt;缓存混乱&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;2-协商缓存&#34;&gt;2. 协商缓存&lt;/h3&gt;
&lt;p&gt;如果缓存过期，浏览器会向服务器发送请求，即使用&lt;code&gt;协商缓存&lt;/code&gt;。本次请求会带着第一次请求返回的有关缓存的 header 字段信息，比如以下两个字段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Etag/If-None-Match&lt;/strong&gt;&lt;br&gt;
判断响应头中是否存在 Etag 字段，如果存在，浏览器则发送一个带有 If-None-Match 字段的请求头的请求，该字段的值为 Etag 值。服务器通过对比&lt;strong&gt;客户端发过来的Etag值是否与服务器相同&lt;/strong&gt;。如果相同，说明缓存命中，服务器&lt;strong&gt;返回 304&lt;/strong&gt; 状态码，并将 If-None-Match 设为 false，客户端继续使用本地缓存。如果&lt;strong&gt;不相同&lt;/strong&gt;，说明缓存未命中，服务器**返回 200 **状态码，并将 If-None-Match 设为 true，并且返回请求的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Last-Modified/If-Modified-Since&lt;br&gt;
除了 Etag 字段之外，客户端还会通过服务器返回的 Last-Modified 字段判断是否继续使用缓存，该字段为服务器返回的资源的最后修改时间，为UMT时间。浏览器发送一个带有 If-Modified-Since 字段的请求头的请求给服务器，该字段的值为 Last-Modified 值。服务器收到之后，通过这个时间判断，在该时间之后，资源有无修改，如果未修改，缓存命中，返回 304 状态码；如果未命中，返回 200 状态码，并返回最新的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-知识点细节&#34;&gt;3. 知识点细节&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Cache-Control 与 Expires 的优先级：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;两者可以在服务端配置同时使用，&lt;strong&gt;Cache-Control 的优先级高于 Expires。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;为什么有了Last-Modified还要Etag&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间&lt;/li&gt;
&lt;li&gt;如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存&lt;/li&gt;
&lt;li&gt;有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Last-Modified 和 Etag 可以一起使用，&lt;strong&gt;Etag 的优先级更高。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-刷新页面的问题&#34;&gt;4. 刷新页面的问题：&lt;/h3&gt;
&lt;p&gt;F5刷新：不使用强缓存，使用协商缓存&lt;/p&gt;
&lt;p&gt;ctrl+F5：二者都不使用&lt;/p&gt;
&lt;h2 id=&#34;3-缓存的资源去哪里了&#34;&gt;3. 缓存的资源去哪里了&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;memory cache&lt;/code&gt;JS等派生资源&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MemoryCache顾名思义，就是将资源缓存到内存中，等待下次访问时不需要重新下载资源，而直接从内存中获取。Webkit早已支持memoryCache。&lt;br&gt;
目前Webkit资源分成两类，一类是主资源，比如HTML页面，或者下载项，一类是派生资源，比如HTML页面中内嵌的图片或者脚本链接，分别对应代码中两个类：MainResourceLoader和SubresourceLoader。虽然Webkit支持memoryCache，但是也只是针对派生资源，它对应的类为CachedResource，用于保存原始数据（比如CSS，JS等），以及解码过的图片数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;disk cache&lt;/code&gt;保存CSS等不频繁读取资源&lt;br&gt;
DiskCache顾名思义，就是将资源缓存到磁盘中，等待下次访问时不需要重新下载资源，而直接从磁盘中获取，它的直接操作对象为CurlCacheManager。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;*&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;memory cache&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;disk cache&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;相同点&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只能存储一些派生类资源文件&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只能存储一些派生类资源文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不同点&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;退出进程时数据会被清除&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;退出进程时数据不会被清除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;存储资源&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一般脚本、字体、图片会存在内存当中&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一般非脚本会存在内存当中，如css等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;因为CSS文件加载一次就可渲染出来,我们不会频繁读取它,所以它不适合缓存到内存中,但是js之类的脚本却随时可能会执行,如果脚本在磁盘当中,我们在执行脚本的时候需要从磁盘取到内存中来,这样IO开销就很大了,有可能导致浏览器失去响应。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三级缓存原理 (访问缓存优先级)&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先在内存中查找,如果有,直接加载。&lt;/li&gt;
&lt;li&gt;如果内存中不存在,则在硬盘中查找,如果有直接加载。&lt;/li&gt;
&lt;li&gt;如果硬盘中也没有,那么就进行网络请求。&lt;/li&gt;
&lt;li&gt;请求获取的资源缓存到硬盘和内存。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;浏览器缓存的优点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;减少了冗余的数据传输&lt;/li&gt;
&lt;li&gt;减少了服务器的负担，大大提升了网站的性能&lt;/li&gt;
&lt;li&gt;加快了客户端加载网页的速度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;br&gt;
当浏览器再次访问一个已经访问过的资源时，它会这样做：&lt;/p&gt;
&lt;p&gt;1.看看是否命中强缓存，如果命中，就直接使用缓存了。&lt;/p&gt;
&lt;p&gt;2.如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存。&lt;/p&gt;
&lt;p&gt;3.如果命中协商缓存，服务器会返回 304 告诉浏览器使用本地缓存。&lt;/p&gt;
&lt;p&gt;4.否则，返回最新的资源。&lt;/p&gt;
&lt;h1 id=&#34;3-dns解析&#34;&gt;3. DNS解析&lt;/h1&gt;
&lt;h2 id=&#34;1-什么是dns&#34;&gt;1. 什么是DNS&lt;/h2&gt;
&lt;p&gt;全称 Domain Name System ,即域名系统。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。DNS协议运行在UDP协议之上，使用端口号53。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-dns解析&#34;&gt;2. DNS解析&lt;/h2&gt;
&lt;p&gt;通过域名,最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;www.dnscache.com (域名) - DNS解析 -&amp;gt; 11.222.33.444 (IP地址)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;DNS解析步骤（缓存）&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;1） 浏览器缓存　　&lt;br&gt;
当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）；&lt;/p&gt;
&lt;p&gt;2） 系统缓存　　&lt;br&gt;
当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP；&lt;/p&gt;
&lt;p&gt;3） 路由器缓存　　&lt;br&gt;
当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查，以上三步均为客服端的DNS缓存；&lt;/p&gt;
&lt;p&gt;4） DNS缓存　　&lt;br&gt;
当在用户客服端查找不到域名对应IP地址，则将进入DNS缓存中进行查询。比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查找；&lt;/p&gt;
&lt;p&gt;5） 根域名服务器　　&lt;br&gt;
当以上均未完成，则进入根服务器进行查询。全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器IP告诉本地DNS服务器；&lt;/p&gt;
&lt;p&gt;6） 顶级域名服务器　　&lt;br&gt;
顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的IP地址告诉本地DNS服务器；&lt;/p&gt;
&lt;p&gt;7） 主域名服务器　　&lt;br&gt;
主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录；&lt;/p&gt;
&lt;p&gt;8）保存结果至缓存　　&lt;br&gt;
本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个IP地址与web服务器建立链接。&lt;/p&gt;
&lt;h1 id=&#34;4-cdn内容分发网络&#34;&gt;4. CDN（内容分发网络）&lt;/h1&gt;
&lt;h2 id=&#34;1-什么是cdn&#34;&gt;1. 什么是CDN&lt;/h2&gt;
&lt;p&gt;简单的理解CDN就是这些缓存服务器，帮助在最近的CDN节点，用最短的请求时间拿到资源，这样排队的人也就少了。也就起到分流作用，减轻服务器负载压力。&lt;/p&gt;
&lt;h2 id=&#34;2-cdn工作原理&#34;&gt;2. CDN工作原理&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;资源上传cdn之后，当用户访问cdn的资源地址之后会经历下面的步骤：&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先经过本地的dns解析，请求cname指向的那台cdn专用的dns服务器。&lt;/li&gt;
&lt;li&gt;dns服务器返回全局负载均衡的服务器ip给用户&lt;/li&gt;
&lt;li&gt;用户请求全局负载均衡服务器，服务器根据ip返回所在区域的负载均衡服务器ip给用户&lt;/li&gt;
&lt;li&gt;用户请求区域负载均衡服务器，负载均衡服务器根据用户ip选择距离近的，并且存在用户所需内容的，负载比较合适的一台缓存服务器ip给用户。当没有对应内容的时候，会去上一级缓存服务器去找，直到找到资源所在的源站服务器，并且缓存在缓存服务器中。用户下一次在请求该资源，就可以就近拿缓存了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1626742657399.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
cdn的原理主要答出&lt;code&gt;负载均衡&lt;/code&gt;和&lt;code&gt;缓存&lt;/code&gt;再就是&lt;code&gt;dns解析&lt;/code&gt;这三部分就行了吧，通过&lt;code&gt;dns解析&lt;/code&gt;到&lt;code&gt;全局负载均衡服务器&lt;/code&gt;，然后再到&lt;code&gt;区域的负载均衡&lt;/code&gt;，之后根据一些条件来找合适的&lt;code&gt;缓存服务器&lt;/code&gt;，如果第一次访问就从源站拿过来缓存。 需要注意的是一切都是根据请求的ip来的，如果ip不合理，那么可能起不到加速效果。缓存和负载均衡的思想在减轻服务器压力方面其实是很常见的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从这个例子可以了解到：&lt;/strong&gt;&lt;br&gt;
（1）CDN的加速资源是跟域名绑定的。&lt;br&gt;
（2）通过域名访问资源，首先是通过DNS分查找离用户最近的CDN节点（边缘服务器）的IP&lt;br&gt;
（3）通过IP访问实际资源时，如果CDN上并没有缓存资源，则会到源站请求资源，并缓存到CDN节点上，这样，用户下一次访问时，该CDN节点就会有对应资源的缓存了。&lt;/p&gt;
&lt;h2 id=&#34;3-cdn缓存&#34;&gt;3. CDN缓存&lt;/h2&gt;
&lt;p&gt;关于CDN缓存,在浏览器本地缓存失效后,浏览器会向CDN边缘节点发起请求。类似浏览器缓存,CDN边缘节点也存在着一套缓存机制。CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循http标准协议，通过http响应头中的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cache-control: max-age //后面会提到
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;的字段来设置CDN边缘节点数据缓存时间。&lt;/p&gt;
&lt;h2 id=&#34;4-cdn-优势&#34;&gt;4. CDN 优势&lt;/h2&gt;
&lt;p&gt;CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低。&lt;br&gt;
大部分请求在CDN边缘节点完成，CDN起到了分流作用，减轻了源服务器的负载。&lt;/p&gt;
&lt;h1 id=&#34;5-网络结构-与-http-协议&#34;&gt;5. 网络结构 与 HTTP 协议&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1616399158170.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
有两套参考模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OSI参考模型（Open Systems Interconnection Reference Model，七层）：模型过于理想化，未能在因特网上进行广泛推广。&lt;/li&gt;
&lt;li&gt;TCP/IP参考模型(或TCP/IP协议，四层)：事实上的国际标准。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1615458129735.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-http轮询即时通讯&#34;&gt;1. HTTP轮询（即时通讯）&lt;/h2&gt;
&lt;h3 id=&#34;1-轮询&#34;&gt;1. 轮询&lt;/h3&gt;
&lt;p&gt;短轮询的基本思路就是&lt;strong&gt;浏览器每隔一段时间向浏览器发送http请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应&lt;/strong&gt;。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。&lt;/p&gt;
&lt;p&gt;这种方式的优点是比较简单，易于理解，实现起来也没有什么技术难点。缺点是显而易见的，这种方式由于需要不断的建立http连接，&lt;strong&gt;严重浪费了服务器端和客户端的资源&lt;/strong&gt;。尤其是在客户端，距离来说，如果有数量级想对比较大的人同时位于基于短轮询的应用中，那么每一个用户的客户端都会疯狂的向服务器端发送http请求，而且不会间断。人数越多，服务器端压力越大，这是很不合理的。&lt;/p&gt;
&lt;p&gt;因此短轮询不适用于那些同时在线用户数量比较大，并且很注重性能的Web应用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var xhr = new XMLHttpRequest();
    setInterval(function(){
        xhr.open(&#39;GET&#39;,&#39;/user&#39;);
        xhr.onreadystatechange = function(){

        };
        xhr.send();
    },1000)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-长轮询ajax实现&#34;&gt;2. 长轮询（ajax实现）&lt;/h3&gt;
&lt;p&gt;当服务器收到客户端发来的请求后，&lt;strong&gt;服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新&lt;/strong&gt;。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制(服务器端设置)才返回。客户端JavaScript响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。&lt;/p&gt;
&lt;p&gt;长轮询和短轮询比起来，明显减少了很多不必要的http请求次数，相比之下节约了资源。&lt;strong&gt;长轮询的缺点在于，连接挂起也会导致资源的浪费&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   function ajax(){
        var xhr = new XMLHttpRequest();
        xhr.open(&#39;GET&#39;,&#39;/user&#39;);
        xhr.onreadystatechange = function(){
              ajax();
        };
        xhr.send();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;轮询与长轮询都是基于HTTP的，两者本身存在着缺陷：轮询需要更快的处理速度；长轮询则更要求处理并发的能力；两者都是“&lt;strong&gt;被动型服务器&lt;/strong&gt;”的体现：服务器不会主动推送信息，而是在客户端发送ajax请求后进行返回的响应。而理想的模型是&amp;quot;在服务器端数据有了变化后，可以主动推送给客户端&amp;quot;，这种&amp;quot;&lt;strong&gt;主动型&lt;/strong&gt;&amp;quot;服务器是解决这类问题的很好的方案。&lt;/p&gt;
&lt;h2 id=&#34;2-http建立持久连接的意义&#34;&gt;2. HTTP建立持久连接的意义&lt;/h2&gt;
&lt;p&gt;在 HTTP1.0 中每发送一次请求都要重新建立 TCP 连接并且关闭连接。这样做是很耗费时间的。而在HTTP1.1 中默认开启长连接，一次TCP连接可以发送多个HTTP请求，避免了重复建立释放连接的开销，加速了数据的传输，节省了时间和带宽。&lt;/p&gt;
&lt;h3 id=&#34;1那么长连接什么时候会释放呢&#34;&gt;1.那么长连接什么时候会释放呢？&lt;/h3&gt;
&lt;p&gt;客户端的长连接不可能一直拿着，会有一个超时时间，服务器会告诉客户端超时时间，譬如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Access-Control-Allow-Origin: http://mall.sillywa.com
Connection: keep-alive
Content-Length: 43574
Content-Type: application/json; charset=utf-8
Date: Wed, 03 Mar 2021 07:34:49 GMT
Keep-Alive: timeout=5
Vary: Origin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Keep-Alive: timeout=5&lt;/strong&gt; &lt;strong&gt;表示这个 TCP 通道可以保持 5s&lt;/strong&gt;。另外还可能有 max=xxx，表示这个长连接&lt;strong&gt;最多接受xxx次请求就断开&lt;/strong&gt;。对于客户端来说，如果服务端没有告诉是客户端超时时间也没关系，服务端可能主动发起四次挥手断开TCP连接，客户端就能够知道该TCP连接已经无效。&lt;/p&gt;
&lt;h3 id=&#34;2-长连接数据传送完成识别&#34;&gt;2. 长连接数据传送完成识别：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;判断传输的数据是否达到了 Content-Length 指示的大小&lt;/li&gt;
&lt;li&gt;没有 Content-Length，由于数据是分块传输的，这时候就要根据块的编码来判断了，最后一个一个编码的数据是一个空块，表明本次传输结束&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-http报文结构&#34;&gt;3. HTTP报文结构&lt;/h2&gt;
&lt;p&gt;HTTP报文由&lt;strong&gt;报文首部&lt;/strong&gt;和&lt;strong&gt;报文主体&lt;/strong&gt;构成，中间由一个&lt;strong&gt;空行分隔&lt;/strong&gt;。&lt;strong&gt;报文首部包含请求行和请求头部&lt;/strong&gt;，报文主体主要包含被发送的信息。&lt;/p&gt;
&lt;p&gt;报文首部是客户端或服务端需要处理请求或响应的内容及属性，可以传递额外的信息。&lt;/p&gt;
&lt;h3 id=&#34;11-http请求报文&#34;&gt;1.1 HTTP请求报文&lt;/h3&gt;
&lt;p&gt;HTTP请求报文由3部分组成（请求行+请求头+请求体）：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1617847556323.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请求行：&lt;/strong&gt;&lt;br&gt;
①是&lt;code&gt;请求方法&lt;/code&gt;，GET和POST是最常见的HTTP方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE。&lt;br&gt;
②为请求对应的&lt;code&gt;URL地址&lt;/code&gt;，它和报文头的Host属性组成完整的请求URL。&lt;br&gt;
③是&lt;code&gt;协议名称及版本号&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请求头：&lt;/strong&gt;&lt;br&gt;
④是&lt;code&gt;HTTP的报文头&lt;/code&gt;，报文头包含若干个属性，格式为“属性名:属性值”，服务端据此获取客户端的信息。&lt;br&gt;
与缓存相关的规则信息，均包含在header中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请求体：&lt;/strong&gt;&lt;br&gt;
⑤是&lt;code&gt;报文体&lt;/code&gt;，它将一个页面表单中的组件值通过param1=value1&amp;amp;param2=value2的键值对形式编码成一个格式化串，它承载多个请求参数的数据。不但报文体可以传递请求参数，请求URL也可以通过类似于“/chapter15/user.html? param1=value1&amp;amp;param2=value2”的方式传递请求参数。&lt;/p&gt;
&lt;h3 id=&#34;12-http响应报文&#34;&gt;1.2 HTTP响应报文&lt;/h3&gt;
&lt;p&gt;HTTP的响应报文也由三部分组成（响应行+响应头+响应体）&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1617847696959.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;响应行：&lt;/strong&gt;&lt;br&gt;
①报文协议及版本；&lt;br&gt;
②状态码及状态描述；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;响应头：&lt;/strong&gt;&lt;br&gt;
③响应报文头，也是由多个属性组成；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;响应体：&lt;/strong&gt;&lt;br&gt;
④响应报文体，即我们真正要的“干货”&lt;/p&gt;
&lt;h2 id=&#34;4-http首部字段&#34;&gt;4. HTTP首部字段&lt;/h2&gt;
&lt;h3 id=&#34;1-http通用首部字段&#34;&gt;1. HTTP通用首部字段&lt;/h3&gt;
&lt;p&gt;通用首部字段是请求报文和响应报文都会使用的字段，例如：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;通用头部字段&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;HTTP1.0&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;HTTP1.1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Date&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;表示请求和响应生成的日期，GTM时间。例如 Tue, 02 Mar 2021 12:31:25 GMT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Pragma&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;表示数据是否允许被缓存的通信选项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Cache-Control&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;控制缓存的相关信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Connection&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;设置发送响应之后 TCP 连接是否继续保持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Transfer-Encoding&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;表示消息主体的编码格式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Via&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;记录途中经过的代理和网关&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;2-http请求首部字段&#34;&gt;2 HTTP请求首部字段&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;请求头部字段&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;HTTP1.0&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;HTTP1.1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Host&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;接受请求的服务器IP地址和端口号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Accept&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;客户端可支持的数据类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;User-Agent&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;客户端软件的名称和版本号等相关信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;If-Modified-Since&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;UMT时间，表示该时间之后资源是否修改&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;If-None-Match&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回服务器响应头的 Etag 值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Referer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;通过点击超链接进入下一个页面时，在这里会记录上一个页面的 URI&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Accept-Encoding&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;客户端可支持的编码格式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Accept-Language&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;客户端可支持的语言&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;If-Match&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;If-Unmodified-Since&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Range&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;当只需要回去部分数据时，可通过这个字段指定要获取的数据范围&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;3-http响应首部字段&#34;&gt;3. HTTP响应首部字段&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;响应头部字段&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;HTTP1.0&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;HTTP1.1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Location&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;表示信息的准确位置，绝对路径&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Server&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;服务器程序的名称和版本号相关信息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;4-http实体消息体首部字段&#34;&gt;4 HTTP实体（消息体）首部字段&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;实体头部字段&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;HTTP1.0&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;HTTP1.1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Allow&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;表示指定的 URI 支持的方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Content-Encoding&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;消息的编码格式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Content-Length&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;消息体的长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Content-Type&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;消息体的数据类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Expires&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;消息体的有效期，UMT 时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Last-Modified&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据最后更新的日期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Etag&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;资源的唯一标识符，控制是否使用缓存&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;5-http10与http11以及http20相关知识&#34;&gt;5. HTTP1.0与HTTP1.1以及HTTP2.0相关知识&lt;/h2&gt;
&lt;h3 id=&#34;1-http-10&#34;&gt;1. HTTP 1.0&lt;/h3&gt;
&lt;p&gt;HTTP 协议老的标准是HTTP/1.0，是一种无状态，无连接的应用层协议。 为了提高系统的效率，HTTP 1.0规定浏览器与服务器只保持&lt;strong&gt;短暂的连接&lt;/strong&gt;，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。&lt;/p&gt;
&lt;p&gt;在HTTP1.0默认是短连接；简单来说就是：每次与服务器交互，都需要新开一个连接！&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626872405629.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626872408887.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;基于此会发现，http1.0被抱怨最多的就是&lt;strong&gt;连接无法复用&lt;/strong&gt;和&lt;strong&gt;队头阻塞（head of line blocking）&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2-http-11&#34;&gt;2. HTTP 1.1&lt;/h3&gt;
&lt;p&gt;在HTTP1.1中默认就使用持久化连接来解决：&lt;strong&gt;建立一次连接，多次请求均由这个连接完成！&lt;/strong&gt;(如果阻塞了，还是会开新的TCP连接的)&lt;/p&gt;
&lt;p&gt;HTTP1.1增加Connection字段，通过设置&lt;strong&gt;Keep-Alive&lt;/strong&gt;保持HTTP连接不断。避免每次客户端与服务器请求都要重复建立释放建立TCP连接。提高了网络的利用率。&lt;/p&gt;
&lt;p&gt;如果客户端想关闭HTTP连接，可以在请求头中携带Connection:false来告知服务器关闭请求。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626872730153.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。&lt;/p&gt;
&lt;p&gt;相对于持久化连接还有另外比较重要的改动：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 1.1增加host字段&lt;/li&gt;
&lt;li&gt;HTTP 1.1中引入了Chunked transfer-coding，范围请求，实现断点续传(实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输)&lt;/li&gt;
&lt;li&gt;HTTP 1.1管线化(pipelining)理论，客户端可以同时发出多个HTTP请求，而不用一个个等待响应之后再请求&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-http-20&#34;&gt;3. HTTP 2.0&lt;/h3&gt;
&lt;p&gt;在说HTTP2之前，不如先直观比较一下HTTP2和HTTP1.1的区别：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626874953559.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
上面也已经说了，HTTP 1.1提出了&lt;strong&gt;管线化(pipelining)理论&lt;/strong&gt;，但是仅仅是限于理论的阶段上，这个功能默认还是&lt;code&gt;关闭&lt;/code&gt;了的。&lt;/p&gt;
&lt;p&gt;所以说，无论是HTTP1.0还是HTTP1.1提出了Pipelining理论，还是会出现阻塞的情况。从专业的名词上说这种情况，叫做&lt;strong&gt;线头阻塞&lt;/strong&gt;（Head of line blocking）简称：HOLB&lt;/p&gt;
&lt;h4 id=&#34;1-多路复用-与-二进制传输&#34;&gt;1. 多路复用 与 二进制传输&lt;/h4&gt;
&lt;p&gt;HTTP2与HTTP1.1最重要的区别就是解决了线头阻塞的问题！其中最重要的改动是：&lt;strong&gt;多路复用 (Multiplexing)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而HTTP2所有性能增强的&lt;code&gt;核心&lt;/code&gt;在于新的&lt;code&gt;二进制分帧&lt;/code&gt;层(不再以文本格式来传输了)，它定义了如何封装http消息并在客户端与服务器之间传输。&lt;/p&gt;
&lt;p&gt;HTTP/2 采用二进制格式传输数据，而非HTTP/1.x 里纯文本形式的报文 ，二进制协议解析起来更高效。&lt;strong&gt;HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它把TCP协议的部分特性挪到了应用层，把原来的&amp;quot;Header+Body&amp;quot;的消息&amp;quot;打散&amp;quot;为数个小片的二进制&amp;quot;帧&amp;quot;(Frame)，用&amp;quot;HEADERS&amp;quot;帧存放头数据、&amp;quot;DATA&amp;quot;帧存放实体数据。HTP/2数据分帧后&amp;quot;Header+Body&amp;quot;的报文结构就完全消失了，协议看到的只是一个个的&amp;quot;碎片&amp;quot;。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626875923219.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626875879453.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。&lt;strong&gt;多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1616381290207.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如上图所示，多路复用的技术可以只通过一个 TCP 连接就可以传输所有的请求数据。&lt;/p&gt;
&lt;h4 id=&#34;2-header-压缩&#34;&gt;2. Header 压缩&lt;/h4&gt;
&lt;p&gt;HTTP/2并没有使用传统的压缩算法，而是开发了专门的&amp;quot;HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体来说:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送；&lt;/li&gt;
&lt;li&gt;每次只发送改变的（需要更新的）数据字段即可&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616380864613.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1626876168090.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-服务器推送&#34;&gt;3. 服务器推送&lt;/h3&gt;
&lt;p&gt;服务器除了最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确的需求。&lt;/p&gt;
&lt;p&gt;可以在客户端请求index.html的时候，就主动推送后面需要用到的所有静态资源给客户端，并存储在缓存中，大大改善加载时间。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1617865820470.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;6-对称加密-非对称加密-公钥-私钥-数字签名-数字证书&#34;&gt;6. 对称加密、非对称加密、公钥、私钥、数字签名、数字证书&lt;/h2&gt;
&lt;h3 id=&#34;1-对称数据加密&#34;&gt;1. 对称数据加密&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1619659703397.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
就像上图所示， 这加密和解密算法是公开的，那个密钥是保密的， 只有两人才知道， 这样生成的加密消息（密文） 别人就无法得知了。这叫对称加密算法，因为加密和解密用的是同一个密钥。&lt;/p&gt;
&lt;p&gt;问题来了，这个密钥的双方必须得知道，但是通过网络发送又不安全，这该怎么办呢？这时候就出现了非对称数据加密。&lt;/p&gt;
&lt;h3 id=&#34;2-rsa非对称加密&#34;&gt;2. RSA：非对称加密&lt;/h3&gt;
&lt;p&gt;这个RSA算法非常有意思，它不是像之前的算法， 双方必须协商一个保密的密钥， 而是有一对儿钥匙， 一个是保密的，称为私钥，另外一个是公开的，称为公钥。&lt;/p&gt;
&lt;p&gt;更有意思的是，用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据， 只有对应的私钥才能解密。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619659810918.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当张大胖给Bill发消息的时候， 就可以先用Bill的公钥去加密（反正Bill的公钥是公开的，地球人都知道）， 等到消息被Bill 收到后， 他就可以用自己的私钥去解密（只有Bill才能解开，私钥是保密的 ）【也就是A发送消息给B时候，利用B的公钥，然后B收到后利用私钥解密接收。】&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619659898143.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
反过来也是如此， 当Bill 想给张大胖发消息的时候，就用张大胖的公钥加密， 张大胖收到后，就用自己的私钥解密。&lt;/p&gt;
&lt;h3 id=&#34;3-非对称加密对称加密&#34;&gt;3. 非对称加密+对称加密&lt;/h3&gt;
&lt;p&gt;因为RSA的加密和解密的速度比较慢，RSA的算法比之前的对称密钥算法要慢上百倍。&lt;/p&gt;
&lt;p&gt;回到咱们最初的问题，我们想用一个密钥来加密通信，那个对称加密算法是非常快的，但是苦于密钥无法安全传输， 现在有了RSA ，我想可以结合一下， 分两步走　(1) 我生成一个对称加密算法的密钥， 用RSA的方式安全发给你， (2) 我们随后就不用RSA了， 只用这个密钥，利用对称加密算法来通信，这样即可以保证安全又可以加快速度。【也就是只利用RSA传输密钥，保证密钥的安全。然后利用对称加密进行信息传输。】&lt;/p&gt;
&lt;p&gt;这样以来既解决了密钥的传递问题， 又解决了RSA速度慢的问题，不错。&lt;/p&gt;
&lt;p&gt;于是两人就安全地传递了对称加密的密钥， 用它来加密解密，果然快多了！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HTTPS就是使用上述混合加密的方法。&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-中间人攻击&#34;&gt;4. 中间人攻击&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1619660545440.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;看来问题出现在公钥的分发上&lt;/strong&gt;虽然这个东西是公开的，但是在别有用心的人看来，截取以后还可以干坏事 ！&lt;br&gt;
但是怎么安全地分发公钥呢？ 似乎又回到了最初的问题： 怎么安全的保护密钥（之前是利用非对称保护私钥的传输，现在是考虑如何保证公钥的发送方）？&lt;/p&gt;
&lt;p&gt;可是似乎和最初的问题还不一样，这一次的公钥不用保密，但是一定得有个办法声明这个公钥确实是Bill的， 而不是别人的。&lt;/p&gt;
&lt;h3 id=&#34;5-信息摘要-数字签名-数字证书&#34;&gt;5. 信息摘要、数字签名、数字证书&lt;/h3&gt;
&lt;p&gt;简单来讲是这样的， Bill可以把他的公钥和个人信息用一个Hash算法生成一个消息摘要， 这个Hash算法有个极好的特性，只要输入数据有一点点变化，那生成的消息摘要就会有巨变，这样就可以防止别人修改原始内容。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619660931513.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
我们会让有公信力的认证中心（简称CA）用它的私钥对消息摘要加密，形成签名：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619660885193.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这还不算， 还把&lt;strong&gt;原始信息&lt;/strong&gt;和&lt;strong&gt;数据签名&lt;/strong&gt;合并， 形成一个全新的东西，叫做“数字证书”&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619660980624.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
张大胖接着说：当Bill把他的证书发给我的时候， 我就用同样的Hash 算法， 再次生成消息摘要，然后用CA的公钥对数字签名解密， 得到CA创建的消息摘要， 两者一比，就知道有没有人篡改了！&lt;/p&gt;
&lt;p&gt;如果没人篡改， 我就可以安全的拿到Bill的公钥喽，有了公钥， 后序的加密工作就可以开始了。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619661151582.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
那么这个CA的公钥怎么保证他的安全性？&lt;/p&gt;
&lt;p&gt;附注：我们利用上面数字证书保证传输安全的前提就是，我们默认CA的公钥是安全的。因为CA的公钥安全，所以得出的消息摘要是安全的，这就可以与Hash算法得出的消息摘要比较是否相同，从而确保消息的安全的。&lt;/p&gt;
&lt;h2 id=&#34;7-http与https的区别及实现方式&#34;&gt;7. HTTP与HTTPS的区别及实现方式&lt;/h2&gt;
&lt;h3 id=&#34;1-基本概念&#34;&gt;1. 基本概念&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;HTTP是超文本传输协议&lt;/strong&gt;，是一个简单的&lt;code&gt;请求-响应协议&lt;/code&gt;，它默认工作在TCP的80端口。&lt;strong&gt;它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应&lt;/strong&gt;。协议以明文的方式进行发送，不提供任何方式的数据加密。因此HTTP协议不适合传输一些敏感信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTPS是超文本传输安全协议&lt;/strong&gt;，是一种&lt;code&gt;安全通信&lt;/code&gt;的传输协议。&lt;strong&gt;HTTPS经由HTTP进行通信，但利用 SSL/TSL 来进行加密数据包&lt;/strong&gt;。HTTPS开发的主要目的是提供网站服务器的身份认证，保护数据交换的隐私与完整性。&lt;/p&gt;
&lt;p&gt;HTTPS默认工作在 TCP 的443 端口，它的工作方式如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP三次同步握手&lt;/li&gt;
&lt;li&gt;客户端验证服务端数字证书&lt;/li&gt;
&lt;li&gt;DH 算法协商对称加密加密算法的密钥、hash 算法的密钥&lt;/li&gt;
&lt;li&gt;SSL 安全加密隧道协商完成&lt;/li&gt;
&lt;li&gt;网页以加密的方式进行传输，用协商的对称加密算法和密钥加密，保障数据机密性；用协商的 hash 算法进行数据完整性保护，保证数据不被篡改。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-http的无状态&#34;&gt;2. HTTP的无状态&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;就是第二次来你无法识别它曾经来过&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;http的每次请求，在事务上和前后http请求没有任何关联，对上一次请求，下一次请求没有任何影响。这个是定义，从宏观上说的，实际上把无状态说成请求独立，无关联也对&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTTP 是一个无状态协议，这意味着&lt;code&gt;每个请求都是独立&lt;/code&gt;的，Keep-Alive 没能改变这个结果。&lt;/p&gt;
&lt;p&gt;缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。&lt;/p&gt;
&lt;p&gt;HTTP 协议这种特性有优点也有缺点，优点在于解放了服务器，每一次请求“点到为止”不会造成不必要连接占用，缺点在于每次请求会传输大量重复的内容信息。&lt;/p&gt;
&lt;p&gt;HTTP 无状态的特性严重阻碍了这些应用程序的实现，于是两种用于保持 HTTP 连接状态的技术就应运而生了，一个是 &lt;code&gt;Cookie&lt;/code&gt;，而另一个则是 &lt;code&gt;Session&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1619491336853.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619491341437.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-http-与-https-的区别&#34;&gt;3. HTTP 与 HTTPS 的区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 使用明文传输，数据都是&lt;strong&gt;未加密&lt;/strong&gt;的，安全性较差；HTTPS 数据传输过程是加密的，安全性较好；&lt;/li&gt;
&lt;li&gt;使用 HTTPS 一般需要到 &lt;strong&gt;CA 申请证书&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;HTTP页面的响应比 HTTPS &lt;strong&gt;快&lt;/strong&gt;，主要是因为 HTTPS 除了 TCP 的三个包之外，还要加上 ssl 握手的 9 个包&lt;/li&gt;
&lt;li&gt;HTTP 和 HTTPS 是完全不同连接方式，用的端口也不一样， 前者是80， 后者是 443&lt;/li&gt;
&lt;li&gt;HTTPS 其实就是建构在 SSL/TSL 之上的 HTTP 协议，所以要比 HTTP &lt;strong&gt;更消耗服务器资源&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-https-的工作方式&#34;&gt;4. HTTPS 的工作方式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1617862416374.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;客户端发起 HTTPS 请求&lt;br&gt;
建立TCP连接之后，客户端发起请求&lt;/li&gt;
&lt;li&gt;服务端的配置&lt;br&gt;
服务端收到请求之后，会有一套公钥和私钥，这对公钥和私钥其实就是一套数字证书，一般都是由受信任的证书颁发机构进行签发。&lt;/li&gt;
&lt;li&gt;传送公钥&lt;br&gt;
服务端将公钥传递给客户端，里面包含很多信息，如证书的颁发机构，证书的过期时间&lt;/li&gt;
&lt;li&gt;客户端解析证书&lt;br&gt;
这部分工作由客户端的 TSL 来完成，首先验证证书是否有效。如果没有问题，就会随机生成一个 key，然后利用公钥对 key 的值进行加密。&lt;/li&gt;
&lt;li&gt;传送加密的信息（key）&lt;br&gt;
将加密过后的 key 传递给服务器&lt;/li&gt;
&lt;li&gt;使用私钥解析加密信息（key）&lt;br&gt;
服务器使用自己的私钥解密加密信息得到 key&lt;/li&gt;
&lt;li&gt;使用客户端的 key，利用对称加密加密信息，并发送给客户端&lt;br&gt;
把内容通过该 key 进行对称加密，并传输给客户端&lt;/li&gt;
&lt;li&gt;客户端使用 key 解密信息&lt;br&gt;
客户端收到信息之后利用 key 进行解密&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;重点：客户端会生成 key，key 的传输使用非对称加密，而数据的传输使用 key 进行对称加密。&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;对称加密：加密密钥和解密密钥是同一个，效率较高&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;非对称加密：加密密钥和解密密钥不是同一个，效率较低&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;非对称加密的效率比较低&lt;/code&gt;，因此我们通常不使用非对称加密对整个文件进行加密，而采用&lt;code&gt;对称加密对文件加密&lt;/code&gt;，&lt;code&gt;非对称加密对对称加密的密钥加密&lt;/code&gt;，然后将&lt;code&gt;对称加密后的文件和非对称加密后的密钥&lt;/code&gt;一起在网上传送。&lt;/p&gt;
&lt;h3 id=&#34;5-ssl-的位置&#34;&gt;5. SSL 的位置&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1617863364032.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在发送方，SSL接受应用层的数据（如HTTP或者IMAP报文），对数据进行加密，然后把加了密的数据送往TCP套接字。&lt;/p&gt;
&lt;p&gt;在接收方，SSL从TCP套接字读取数据，解密后把数据交给应用层。&lt;/p&gt;
&lt;p&gt;使用非对称加密进行文件传输。通信双方在传输时需要交换各自的公钥。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SSL提供以下三个功能：&lt;/strong&gt;&lt;br&gt;
（1）SSL服务器鉴别：允许用户证实服务器的身份。具有SSL功能的浏览器维持一个表，上面有一些可信赖的认证中心CA（Certificate Authority）和它们的公钥。&lt;br&gt;
（2）加密的SSL会话：客户和服务器交互的所有数据都在发送方加密，在接收方解密。&lt;br&gt;
（3）SSL客户鉴别：允许服务器证实客户的身份。&lt;/p&gt;
&lt;h1 id=&#34;6-tcpip-和-udp-协议&#34;&gt;6. TCP/IP 和 UDP 协议&lt;/h1&gt;
&lt;h2 id=&#34;1-tcpip-协议分层管理&#34;&gt;1. TCP/IP 协议分层管理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1617869165303.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
传输层：可靠传输（丢包重发） 、流量控制、不可靠传输（只需要发送一个数据包）&lt;/p&gt;
&lt;p&gt;网络层：负责选择最佳路径、规划 IP 地址&lt;/p&gt;
&lt;p&gt;数据链路层：帧的开始和结束、透明传输（数据中出现了帧的结束标志，需要采用转义字符）、差错校验（循环冗余检测）&lt;/p&gt;
&lt;h2 id=&#34;2-tcp三次握手四次挥手机制及原因&#34;&gt;2. TCP三次握手四次挥手机制及原因&lt;/h2&gt;
&lt;h3 id=&#34;1-连接中怎么找到对方&#34;&gt;1. 连接中怎么找到对方？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;TCP头部为20字节&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源端口号（16位）和目的端口号（16位）：&lt;code&gt;再加上Ip首部的源IP地址和目的IP地址可以唯一确定一个TCP连接&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数据序号（16位）：表示在这个报文段中的第一个数据字节序号&lt;/li&gt;
&lt;li&gt;确认序号：仅当ACK标志为1时有效，确认号表示期望收到的下一个字节的序号&lt;/li&gt;
&lt;li&gt;偏移：就是头部长度，有4位，跟IP头部一样，以4字节为单位。最大是60个字节&lt;/li&gt;
&lt;li&gt;保留位：6位，必须为0&lt;/li&gt;
&lt;li&gt;6个标志位：URG-紧急指针有效；ACK-确认序号有效；PSH-接收方应尽快将这个报文交给应用层；RST-连接重置；SYN-同步序号用来发起一个连接；FIN-终止一个连接。&lt;/li&gt;
&lt;li&gt;窗口字段：16位，代表的是窗口的字节容量，也就是TCP的标准窗口最大为2^16 - 1 = 65535个字节&lt;/li&gt;
&lt;li&gt;校验和：源机器基于数据内容计算一个数值，收信息机要与源机器数值结果完全一样，从而证明数据的有效性。检验和覆盖了整个的TCP报文段：这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-三次握手&#34;&gt;2. 三次握手&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1617869541484.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;为什么需要三次握手，两次行不行？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设是两次握手，客户端刚开始发送第一个建立连接的请求，但是由于该请求在某一个路由器中停留时间过长，客户端一段时间没收到服务器的响应消息，就会再发一个建立连接的请求，这个请求达到服务器，并成功建立连接，之后数据传输完成，关闭连接。这时候先前发送的第一个建立连接的请求，终于通过网络传到了服务器，服务器收到请求，返回一个数据包，并立即打开连接，这是客户端已经关闭了，对服务端的数据包不予理睬，这样就会导致服务端资源的浪费。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么不能四次握手？&lt;/strong&gt;&lt;br&gt;
四次握手的流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送：SYN=1,ACK=0,seq=x&lt;/li&gt;
&lt;li&gt;服务端收到客户端消息，发送：ACK = 1, 确认号=x+1,seq=y&lt;/li&gt;
&lt;li&gt;服务端发送同步建立连接，发送：SYN=1，确认号=x+1，seq = w&lt;/li&gt;
&lt;li&gt;客户端收到发送：ACK=1，确认号=w+1,seq = x+1&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这个过程中，显然第二步和第三步可以合并，不需要单独发送一个 SYN&lt;/p&gt;
&lt;h3 id=&#34;3-四次挥手&#34;&gt;3. 四次挥手&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1617870529977.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
既然握手的时候，服务端发送的两个请求可以合并，&lt;strong&gt;那么释放连接的时候，是否也能合并，只需三次握手呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们的回答是不能够，因为当服务器收到客户端关闭连接的请求的时候，服务端可能还在继续发送数据，但是他又必须先给客户端一个回应，说我收到了请求。等服务端的数据发送完毕之后，再发一个数据包说我已经可以关闭请求了。客户端收到之后再作出回应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客户端为什么要有TIME-WAIT阶段&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;防止最后一个数据包丢失而导致服务器接收不到，一段时间后服务器会重新发送第三个数据包。如果此时客户端已经关闭了，则收不到第三个数据包，服务端也就无法正常关闭了。&lt;/p&gt;
&lt;h2 id=&#34;3tcpudp-的区别&#34;&gt;3.TCP/UDP 的区别&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;TCP&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;UDP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;面向连接，是指发送数据之前必须在两端建立TCP连接，连接方式为三次握手&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不面向连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可靠传输，流量控制与拥塞控制&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不可靠传输，尽最大努力交付&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;传输方式上以字节流的形式传输&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;以报文形式传输&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只能是一对一通信&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持一对一、一对多、多对多、多对一交互通信&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;最小20字节，最多60字节&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;首部开销较小，只有 8 字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;适用于要求可靠传输的应用&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;适用于实时应用，如视频会议、直播等&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;7-getpostputdeleteoptions等请求方式&#34;&gt;7. GET,POST,PUT,DELETE,OPTIONS等请求方式&lt;/h1&gt;
&lt;h2 id=&#34;1-不同请求方式区别&#34;&gt;1. 不同请求方式区别&lt;/h2&gt;
&lt;h3 id=&#34;1-get&#34;&gt;1. GET&lt;/h3&gt;
&lt;p&gt;get请求是用来获取数据的，只是用来&lt;code&gt;查询数据&lt;/code&gt;，不对服务器的数据做任何的修改，新增，删除等操作。&lt;/p&gt;
&lt;p&gt;在这里我们认为get请求是&lt;code&gt;安全的&lt;/code&gt;，以及&lt;code&gt;幂等的&lt;/code&gt;。安全就是指不影响服务器的数据，幂等是指同一个请求发送多次返回的结果应该相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;get请求会把请求的参数附加在URL后面，这样会产生安全问题，如果是系统的登陆接口采用的get请求，需要对请求的参数做一个加密。&lt;/li&gt;
&lt;li&gt;get请求其实本身HTTP协议并没有限制它的URL大小，但是不同的浏览器对其有不同的大小长度限制&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-post&#34;&gt;2. POST&lt;/h3&gt;
&lt;p&gt;post请求一般是对服务器的数据做改变，常用来数据的提交，新增操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;post请求的请求参数都是请求体中&lt;/li&gt;
&lt;li&gt;post请求本身HTTP协议也是没有限制大小的，限制它的是服务器的处理能力&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-put&#34;&gt;3. PUT&lt;/h3&gt;
&lt;p&gt;put请求与post一样都会改变服务器的数据，但是put的侧重点在于对于数据的修改操作，但是post侧重于对于数据的增加。&lt;/p&gt;
&lt;h3 id=&#34;4-delete&#34;&gt;4. DELETE&lt;/h3&gt;
&lt;p&gt;delete请求用来删除服务器的资源。&lt;/p&gt;
&lt;h3 id=&#34;5-options&#34;&gt;5. OPTIONS&lt;/h3&gt;
&lt;p&gt;options请求属于浏览器的&lt;code&gt;预检请求&lt;/code&gt;，查看服务器是否接受请求，预检通过后，浏览器才会去发get，post，put，delete等请求。至于什么情况下浏览器会发预检请求，浏览器会会将请求分为两类，简单请求与非简单请求，&lt;code&gt;非简单请求&lt;/code&gt;会产生预检options请求。(结合CORS跨域)&lt;/p&gt;
&lt;h2 id=&#34;2-浏览器的get和post&#34;&gt;2. 浏览器的GET和POST&lt;/h2&gt;
&lt;p&gt;浏览器用GET请求来获取一个html页面/图片/css/js等资源；用POST来提交一个&lt;form&gt;表单，并得到一个结果的网页。&lt;/p&gt;
&lt;h3 id=&#34;1-get-2&#34;&gt;1. GET&lt;/h3&gt;
&lt;p&gt;“读取“一个资源。比如Get到一个html文件。反复读取不应该对访问的数据有副作用。没有副作用被称为“幂等“（Idempotent)。因为GET因为是读取，就可以对GET请求的数据做缓存。这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），或者做到server端（用Etag，至少可以减少带宽消耗）&lt;/p&gt;
&lt;h3 id=&#34;2-post-2&#34;&gt;2. POST&lt;/h3&gt;
&lt;p&gt;在页面里&amp;lt;form&amp;gt; 标签会定义一个表单。点击其中的submit元素会发出一个POST请求让服务器做一件事。这件事往往是有副作用的，&lt;code&gt;不幂等&lt;/code&gt;的。不幂等也就意味着不能随意多次执行。因此也就不能缓存。&lt;/p&gt;
&lt;p&gt;此外如果尝试重新执行POST请求，浏览器也会弹一个框提示下这个刷新可能会有副作用，询问要不要继续。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1618324396186.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-区别&#34;&gt;3. 区别&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;GET和POST携带数据的格式也有区别&lt;/code&gt;。当浏览器发出一个GET请求时，就意味着要么是用户自己在浏览器的地址栏输入，要不就是点击了html里a标签的href中的url。所以其实并不是GET只能用url，而是浏览器直接发出的GET只能由一个url触发。所以没办法，GET上要在url之外带一些参数就只能依靠url上附带querystring。但是HTTP协议本身并没有这个限制。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;浏览器的POST请求都来自表单提交&lt;/code&gt;。每次提交，表单的数据被浏览器用编码到HTTP请求的body里。浏览器发出的POST请求的body主要有有两种格式，一种是application/x-www-form-urlencoded用来传输简单的数据，大概就是&amp;quot;key1=value1&amp;amp;key2=value2&amp;quot;这样的格式。另外一种是传文件，会采用multipart/form-data格式。采用后者是因为application/x-www-form-urlencoded的编码方式对于文件这种二进制的数据非常低效。&lt;/p&gt;
&lt;p&gt;浏览器在POST一个表单时，url上也可以带参数，只要&amp;lt;form action=&amp;quot;url&amp;quot; &amp;gt;里的url带querystring就行。只不过表单里面的那些用&amp;lt;input&amp;gt; 等标签经过用户操作产生的数据都在会在body里。&lt;/p&gt;
&lt;h2 id=&#34;3-接口中的get和post&#34;&gt;3. 接口中的GET和POST&lt;/h2&gt;
&lt;p&gt;这里是指通过浏览器的Ajax api，或者iOS/Android的App的http client，java的commons-httpclient/okhttp或者是curl，postman之类的工具发出来的GET和POST请求。此时GET/POST不光能用在前端和后端的交互中，还能用在后端各个子服务的调用中（即当一种RPC协议使用）。尽管RPC有很多协议，比如thrift，grpc，但是http本身已经有大量的现成的支持工具可以使用，并且对人类很友好，容易debug。HTTP协议在微服务中的使用是相当普遍的。&lt;/p&gt;
&lt;p&gt;当用HTTP实现接口发送请求时，就&lt;code&gt;没有浏览器中那么多限制&lt;/code&gt;了，只要是符合HTTP格式的就可以发。HTTP请求的格式，大概是这样的一个字符串（为了美观，我在\r\n后都换行一下）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;METHOD&amp;gt; &amp;lt;URL&amp;gt; HTTP/1.1\r\n
&amp;lt;Header1&amp;gt;: &amp;lt;HeaderValue1&amp;gt;\r\n
&amp;lt;Header2&amp;gt;: &amp;lt;HeaderValue2&amp;gt;\r\n
...
&amp;lt;HeaderN&amp;gt;: &amp;lt;HeaderValueN&amp;gt;\r\n
\r\n
&amp;lt;Body Data....&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接口规范/风格。其中名气最大的当属REST。REST充分运用GET、POST、PUT和DELETE，约定了这4个接口分别获取、创建、替换和删除“资源”，REST最佳实践还推荐在请求体使用json格式。这样仅仅通过看HTTP的method就可以明白接口是什么意思，并且解析格式也得到了统一。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;json相对于x-www-form-urlencoded的优势在于&lt;br&gt;
1）可以有嵌套结构；&lt;br&gt;
2）可以支持更丰富的数据类型。通过一些框架，json可以直接被服务器代码映射为业务实体。用起来十分方便。但是如果是写一个接口支持上传文件，那么还是multipart/form-data格式更合适。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;REST中GET和POST不是随便用的。在REST中, 【GET】 + 【资源定位符】被专用于获取资源或者资源列表，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET http://foo.com/books          获取书籍列表
GET http://foo.com/books/:bookId  根据bookId获取一本具体的书
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;REST 【POST】+ 【资源定位符】则用于“创建一个资源”，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST http://foo.com/books
{
  &amp;quot;title&amp;quot;: &amp;quot;大宽宽的碎碎念&amp;quot;,
  &amp;quot;author&amp;quot;: &amp;quot;大宽宽&amp;quot;,
  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里你就能留意到&lt;strong&gt;浏览器中用来实现表单提交的POST&lt;/strong&gt;，和REST里实现创建资源的POST语义上的不同。&lt;/p&gt;
&lt;h2 id=&#34;4-关于安全性&#34;&gt;4. 关于安全性&lt;/h2&gt;
&lt;p&gt;我们常听到GET不如POST安全，因为POST用body传输数据，而GET用url传输，更加容易看到。但是从攻击的角度，无论是GET还是POST都不够安全，因为HTTP本身是&lt;code&gt;明文协议&lt;/code&gt;。&lt;code&gt;每个HTTP请求和返回的每个byte都会在网络上明文传播，不管是url，header还是body&lt;/code&gt;。这完全不是一个“是否容易在浏览器地址栏上看到“的问题。&lt;/p&gt;
&lt;p&gt;为了避免传输中数据被窃取，&lt;code&gt;必须做从客户端到服务器的端端加密。业界的通行做法就是https&lt;/code&gt;——即用SSL协议协商出的密钥加密明文的http数据。这个加密的协议和HTTP协议本身相互独立。如果是利用HTTP开发公网的站点/App，要保证安全，https是最最基本的要求。&lt;/p&gt;
&lt;p&gt;从客户端到服务器端，有大量的中间节点，包括网关，代理等。他们的access log通常会输出完整的url，比如nginx的默认access log就是如此。如果url上携带敏感数据，就会被记录下来。但请注意，&lt;code&gt;就算私密数据在body里，也是可以被记录下来的&lt;/code&gt;，因此如果请求要经过不信任的公网，避免泄密的&lt;code&gt;唯一手段就是https&lt;/code&gt;。这里说的“避免access log泄漏“仅仅是指避免可信区域中的http代理的默认行为带来的安全隐患。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1618325278742.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;5-关于url的长度&#34;&gt;5. 关于URL的长度&lt;/h2&gt;
&lt;p&gt;因为上面提到了不论是GET和POST都可以使用URL传递数据，所以我们常说的“GET数据有长度限制“其实是指”URL的长度限制“。&lt;/p&gt;
&lt;p&gt;HTTP协议本身对URL长度并没有做任何规定。实际的限制是由客户端/浏览器以及服务器端决定的。&lt;/p&gt;
&lt;p&gt;先说浏览器。不同浏览器不太一样。比如我们常说的2048个字符的限制，其实是IE8的限制。并且原始文档的说的其实是“URL的最大长度是2083个字符，path的部分最长是2048个字符“。Chrome的URL限制是2MB&lt;/p&gt;
&lt;p&gt;除了浏览器，服务器这边也有限制，比如apache的LimieRequestLine指令。&lt;/p&gt;
&lt;p&gt;apache实际上限制的是HTTP请求第一行“Request Line“的长度，即&amp;lt;METHOD&amp;gt;&amp;lt;URL&amp;gt; &amp;lt;VERSION&amp;gt;那一行。再比如nginx用&lt;code&gt;large_client_header_buffers&lt;/code&gt; 指令来分配请求头中的很长数据的buffer。这个buffer可以用来处理url，header value等。&lt;/p&gt;
&lt;p&gt;为啥要限制呢？如果写过解析一段字符串的代码就能明白，解析的时候要分配内存。对于一个字节流的解析，必须分配buffer来保存所有要存储的数据。而URL这种东西必须当作一个整体看待，无法一块一块处理，于是就处理一个请求时必须分配一整块足够大的内存。如果URL太长，而并发又很高，就容易挤爆服务器的内存；同时，超长URL的好处并不多，我也只有处理老系统的URL时因为不敢碰原来的逻辑，又得追加更多数据，才会使用超长URL。&lt;/p&gt;
&lt;h1 id=&#34;8-ajax-axios库&#34;&gt;8. ajax、 axios库&lt;/h1&gt;
&lt;h2 id=&#34;1-ajax&#34;&gt;1. ajax&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;创建XMLHttpRequest类型的对象&lt;/li&gt;
&lt;li&gt;准备发送，打开与网址之间的连接&lt;/li&gt;
&lt;li&gt;执行发送动作&lt;/li&gt;
&lt;li&gt;指定xhr状态变化事件处理函数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// 1.创建一个 XMLHttpRequest 类型的对象  --- 相当于打开了一个浏览器
var xhr = new XMLHttpRequest();
// 2.打开一个与网址之间的连接  --- 相当于在地址栏输入网址
xhr.open(&amp;quot;GET&amp;quot;,&amp;quot;https://jsonplaceholder.typicode.com/users&amp;quot;);
// 3.通过连接发送一次请求 --- 相当于点击回车或者超链接
xhr.send(null);
// 4.指定 xhr 状态变化事件处理函数   --- 相当于处理网页呈现后的操作
xhr.onreadystatechange = function () {
  // 通过判断 xhr 的 readyState ，确定此次请求是否完成
  if (this.readyState === 4) {
    console.log(this.responseText)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-axios-api&#34;&gt;2. Axios API&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可以通过向axios()传递相关配置来创建请求&lt;/li&gt;
&lt;li&gt;axios(config) config为对象格式的配置选项&lt;/li&gt;
&lt;li&gt;axios(url,config) config可选&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;常用配置选项&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;url 用于请求服务器的URL&lt;/li&gt;
&lt;li&gt;method 创建请求时使用的方法&lt;/li&gt;
&lt;li&gt;baseURL 传递相对URL前缀，将自动加在url前面&lt;/li&gt;
&lt;li&gt;headers 即将被发送的自定义请求头&lt;/li&gt;
&lt;li&gt;params 即将与请求一起发送的URL参数&lt;/li&gt;
&lt;li&gt;data 作为请求主体被发送的数据&lt;/li&gt;
&lt;li&gt;timeout 请求超时的毫秒数&lt;/li&gt;
&lt;li&gt;responseType 表示服务器响应的数据类型，默认json&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;axios({
  url: &amp;quot;/posts&amp;quot;,
  method: &amp;quot;get&amp;quot;,
  baseURL: &amp;quot;http://localhost:3000&amp;quot;,
  params: {
    id: 1
  }
}).then(function(res){
  console.log(res.data)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;9-前端安全xss-csrf&#34;&gt;9. 前端安全XSS、CSRF&lt;/h1&gt;
&lt;h2 id=&#34;1-xss&#34;&gt;1. XSS&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;跨网站指令码（英语：Cross-site scripting，通常简称为：XSS）XSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。有很多种方式进行 XSS 攻击，但它们的共同点为：将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。&lt;/p&gt;
&lt;p&gt;XSS 分为三种：&lt;strong&gt;反射型，存储型和 DOM-based&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-反射性&#34;&gt;1. 反射性&lt;/h3&gt;
&lt;p&gt;反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。&lt;/p&gt;
&lt;p&gt;看一个示例。我先准备一个如下的静态页：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616308450110.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当用户点击恶意链接时，页面跳转到攻击者预先准备的页面，会发现在攻击者的页面执行了 js 脚本：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616308453096.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这样就产生了反射型 XSS 攻击。攻击者可以注入任意的恶意脚本进行攻击，可能注入恶作剧脚本，或者注入能获取用户隐私数据(如cookie)的脚本，这取决于攻击者的目的。&lt;/p&gt;
&lt;h3 id=&#34;2-存储型&#34;&gt;2. 存储型&lt;/h3&gt;
&lt;p&gt;存储型 XSS 会把用户输入的数据 “存储” 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。&lt;/p&gt;
&lt;p&gt;比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。&lt;/p&gt;
&lt;p&gt;当用户点击提交按钮将输入信息提交到服务端时，服务端通过 userInput 变量保存了输入内容。当用户通过 http://localhost:8001/${id} 访问时，服务端会返回与 id 对应的内容(本示例简化了处理)。如果用户输入了恶意脚本内容，则其他用户访问该内容时，恶意脚本就会在浏览器端执行：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616308560547.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-基于dom&#34;&gt;3. 基于DOM&lt;/h3&gt;
&lt;p&gt;基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。&lt;/p&gt;
&lt;p&gt;点击 Submit 按钮后，会在当前页面插入一个链接，其地址为用户的输入内容。如果用户在输入时构造了如下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;&#39; onclick=alert(/xss/)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用户提交之后，页面代码就变成了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a href onlick=&amp;quot;alert(/xss/)&amp;quot;&amp;gt;testLink&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时，用户点击生成的链接，就会执行对应的脚本：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616308646010.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-xss攻击的防范&#34;&gt;2. XSS攻击的防范&lt;/h2&gt;
&lt;p&gt;现在主流的浏览器内置了防范 XSS 的措施，例如 CSP。但对于开发者来说，也应该寻找可靠的解决方案来防止 XSS 攻击。&lt;/p&gt;
&lt;h3 id=&#34;1-httponly-防止劫取-cookie&#34;&gt;1. HttpOnly 防止劫取 Cookie&lt;/h3&gt;
&lt;p&gt;浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。&lt;/p&gt;
&lt;p&gt;上文有说到，攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。&lt;/p&gt;
&lt;h3 id=&#34;2-输入检查&#34;&gt;2. 输入检查&lt;/h3&gt;
&lt;p&gt;不要相信用户的任何输入。 对于用户的任何输入要进行检查、过滤和转义。建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。&lt;/p&gt;
&lt;p&gt;在 XSS 防御中，输入检查一般是检查用户输入的数据中是否包含 &amp;lt;，&amp;gt; 等特殊字符，如果存在，则对特殊字符进行过滤或编码，这种方式也称为 XSS Filter。&lt;/p&gt;
&lt;p&gt;而在一些前端框架中，都会有一份 decodingMap， 用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 &amp;lt;，&amp;gt;，script，防止 XSS 攻击：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// vuejs 中的 decodingMap
// 在 vuejs 中，如果输入带 script 标签的内容，会直接过滤掉
const decodingMap = {
  &#39;&amp;amp;lt;&#39;: &#39;&amp;lt;&#39;,
  &#39;&amp;amp;gt;&#39;: &#39;&amp;gt;&#39;,
  &#39;&amp;amp;quot;&#39;: &#39;&amp;quot;&#39;,
  &#39;&amp;amp;amp;&#39;: &#39;&amp;amp;&#39;,
  &#39;
  &#39;: &#39;\n&#39;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-输出检查&#34;&gt;3. 输出检查&lt;/h3&gt;
&lt;p&gt;用户的输入会存在问题，服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。例如利用 sanitize-html 对输出内容进行有规则的过滤之后再输出到页面中。&lt;/p&gt;
&lt;h2 id=&#34;3-csrf&#34;&gt;3. CSRF&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;跨站请求伪造（英语：Cross-site request forgery），中译是跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1615455801140.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-浏览器的-cookie-策略&#34;&gt;1. 浏览器的 Cookie 策略&lt;/h3&gt;
&lt;p&gt;Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。Cookie 主要用于以下两个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）&lt;/li&gt;
&lt;li&gt;个性化设置（如用户自定义设置、主题等）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而浏览器所持有的 Cookie 分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Session Cookie(会话期 Cookie)：会话期 Cookie 是最简单的Cookie，它不需要指定过期时间（Expires）或者有效期（Max-Age），它仅在会话期内有效，浏览器关闭之后它会被自动删除。&lt;/li&gt;
&lt;li&gt;Permanent Cookie(持久性 Cookie)：与会话期 Cookie 不同的是，持久性 Cookie 可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;res.setHeader(&#39;Set-Cookie&#39;, [&#39;mycookie=222&#39;, &#39;test=3333; expires=Sat, 21 Jul 2018 00:00:00 GMT;&#39;]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码创建了两个 Cookie：mycookie 和 test，前者属于会话期 Cookie，后者则属于持久性 Cookie。当我们去查看 Cookie 相关的属性时，不同的浏览器对会话期 Cookie 的 Expires 属性值会不一样：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616309731128.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
每个 Cookie 都会有与之关联的域，这个域的范围一般通过 donmain 属性指定。如果 Cookie 的域和页面的域相同，那么我们称这个 Cookie 为第一方 Cookie（first-party cookie），如果 Cookie 的域和页面的域不同，则称之为第三方 Cookie（third-party cookie）。一个页面包含图片或存放在其他域上的资源（如图片）时，第一方的 Cookie 也只会发送给设置它们的服务器。&lt;/p&gt;
&lt;h3 id=&#34;2-通过-cookie-进行-csrf-攻击&#34;&gt;2. 通过 Cookie 进行 CSRF 攻击&lt;/h3&gt;
&lt;p&gt;假设有一个 bbs 站点：http://www.c.com，当登录后的用户发起如下 GET 请求时，会删除 ID 指定的帖子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://www.c.com:8002/content/delete/:id
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如发起 http://www.c.com:8002/content/delete/87343 请求时，会删除 id 为 87343 的帖子。当用户登录之后，会设置如下 cookie：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;res.setHeader(&#39;Set-Cookie&#39;, [&#39;user=22333; expires=Sat, 21 Jul 2018 00:00:00 GMT;&#39;]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1616309827160.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
user 对应的值是用户 ID。然后构造一个页面 A：&lt;/p&gt;
&lt;p&gt;CSRF 攻击者准备的网站：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;CSRF 攻击者准备的网站：&amp;lt;/p&amp;gt;
&amp;lt;img src=&amp;quot;http://www.c.com:8002/content/delete/87343&amp;quot;&amp;gt;
页面 A 使用了一个 img 标签，其地址指向了删除用户帖子的链接：
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1616309871152.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看到，当登录用户访问攻击者的网站时，会向 www.c.com 发起一个删除用户帖子的请求。此时若用户在切换到 www.c.com 的帖子页面刷新，会发现ID 为 87343 的帖子已经被删除。&lt;/p&gt;
&lt;p&gt;由于 Cookie 中包含了用户的认证信息，当用户访问攻击者准备的攻击环境时，攻击者就可以对服务器发起 CSRF 攻击。在这个攻击过程中，攻击者借助受害者的 Cookie 骗取服务器的信任，但并不能拿到 Cookie，也看不到 Cookie 的内容。而对于服务器返回的结果，由于浏览器同源策略的限制，攻击者也无法进行解析。因此，攻击者无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。&lt;/p&gt;
&lt;p&gt;但若 CSRF 攻击的目标并不需要使用 Cookie，则也不必顾虑浏览器的 Cookie 策略了。&lt;/p&gt;
&lt;h2 id=&#34;4-csrf-攻击的防范&#34;&gt;4. CSRF 攻击的防范&lt;/h2&gt;
&lt;p&gt;当前，对 CSRF 攻击的防范措施主要有如下几种方式。&lt;/p&gt;
&lt;h3 id=&#34;1-验证码&#34;&gt;1. 验证码&lt;/h3&gt;
&lt;p&gt;验证码被认为是对抗 CSRF 攻击最简洁而有效的防御方法。&lt;/p&gt;
&lt;p&gt;从上述示例中可以看出，CSRF 攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。因为通常情况下，验证码能够很好地遏制 CSRF 攻击。&lt;/p&gt;
&lt;p&gt;但验证码并不是万能的，因为出于用户考虑，不能给网站所有的操作都加上验证码。因此，验证码只能作为防御 CSRF 的一种辅助手段，而不能作为最主要的解决方案。&lt;/p&gt;
&lt;h3 id=&#34;2-referer-check&#34;&gt;2. Referer Check&lt;/h3&gt;
&lt;p&gt;根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的”源”。&lt;/p&gt;
&lt;p&gt;比如，如果用户要删除自己的帖子，那么先要登录 www.c.com，然后找到对应的页面，发起删除帖子的请求。此时，Referer 的值是 http://www.c.com；当请求是从 www.a.com 发起时，Referer 的值是 http://www.a.com 了。因此，要防御 CSRF 攻击，只需要对于每一个删帖请求验证其 Referer 值，如果是以 www.c.com 开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是 CSRF 攻击，可以拒绝该请求。&lt;/p&gt;
&lt;p&gt;Referer Check 不仅能防范 CSRF 攻击，另一个应用场景是 “防止图片盗链”。&lt;/p&gt;
&lt;h3 id=&#34;3-添加-token-验证token令牌&#34;&gt;3. 添加 token 验证(token==令牌)&lt;/h3&gt;
&lt;p&gt;CSRF 攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie 中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。&lt;/p&gt;
&lt;h1 id=&#34;10-websocket&#34;&gt;10. Websocket&lt;/h1&gt;
&lt;p&gt;webSocket是一项可以让服务器将数据主动推送给客户端的技术。&lt;/p&gt;
&lt;h2 id=&#34;1-websocket简介&#34;&gt;1. Websocket简介&lt;/h2&gt;
&lt;p&gt;它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1617946374224.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;其他特点包括：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立在 TCP 协议之上，服务器端的实现比较容易。&lt;/li&gt;
&lt;li&gt;与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。&lt;/li&gt;
&lt;li&gt;数据格式比较轻量，性能开销小，通信高效。&lt;/li&gt;
&lt;li&gt;可以发送文本，也可以发送二进制数据。&lt;/li&gt;
&lt;li&gt;没有同源限制，客户端可以与任意服务器通信。&lt;/li&gt;
&lt;li&gt;协议标识符是&lt;code&gt;ws&lt;/code&gt;（如果加密，则为&lt;code&gt;wss&lt;/code&gt;），服务器网址就是 URL。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;ws://example.com:80/some/path
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1617946965265.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;2-websocket客户端示例&#34;&gt;2. Websocket客户端示例&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var ws = new WebSocket(&amp;quot;wss://echo.websocket.org&amp;quot;);

ws.onopen = function(evt) { 
  console.log(&amp;quot;Connection open ...&amp;quot;); 
  ws.send(&amp;quot;Hello WebSockets!&amp;quot;);
};

ws.onmessage = function(evt) {
  console.log( &amp;quot;Received Message: &amp;quot; + evt.data);
  ws.close();
};

ws.onclose = function(evt) {
  console.log(&amp;quot;Connection closed.&amp;quot;);
};      
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-websocket应用场景&#34;&gt;3. websocket应用场景&lt;/h2&gt;
&lt;p&gt;1、社交订阅&lt;br&gt;
2、多玩家游戏&lt;br&gt;
3、协同编辑文档&lt;br&gt;
4、数据流状态&lt;br&gt;
5、多人聊天&lt;/p&gt;
&lt;h1 id=&#34;11-即时通信&#34;&gt;11. 即时通信&lt;/h1&gt;
&lt;h2 id=&#34;sse&#34;&gt;SSE&lt;/h2&gt;
&lt;p&gt;ajax和JSONP 都是 client-fetch的操作. 但是有时候, 我们更需要服务器主动给我们发信息. 比如，现在的APP应用，完全可以实现服务器发送, 然后Client再处理。而SSE就是帮助我们向webapp靠近&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SSE 全称就是 Server-Sent Events&lt;/strong&gt;，，中译为 &lt;code&gt;服务器推送&lt;/code&gt;&lt;br&gt;
他的技术并不是很难，和websocket不同，他依赖原生的HTTP，所以对于开发者来说更好理解。&lt;br&gt;
比如，在nodeJS， 只要我不执行res.end()，并且一定时间持续发送信息的话，那么该连接就会持续打开(keep-alive)&lt;br&gt;
其实通俗来说，就是一个长连接。 所以，以前我们通常使用ajax，iframe长轮询来代替他。但是这样有个缺点就是，可操控性弱， 错误率高。&lt;br&gt;
所以，正对于这点W3C, 觉得需要在客户端另外指定一个机制–能够保证服务器推送, 实现连接的keep-alive，操作简单… 在这样背景下SSE诞生了&lt;/p&gt;
&lt;h1 id=&#34;12-模块化commonjses6cmdamd&#34;&gt;12. 模块化，commonJS，es6，cmd，amd&lt;/h1&gt;
&lt;h2 id=&#34;1-es6-moudle&#34;&gt;1. ES6 Moudle&lt;/h2&gt;
&lt;p&gt;这个是目前前端小伙伴接触的最多的，是浏览器和服务端通用的模块化解决方案，主要命令为：export和import&lt;br&gt;
export用于导出本模块对外的接口，import用于导入某个模块的功能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;如果单独导出一个变量或方法则是往将要导出{}对象里面添加属性。&lt;br&gt;
2.如果导出的是{}，则和已生成的导出{}对象合并。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后说一下特例&lt;code&gt;export default&lt;/code&gt;，这个是在导出对象里面加一个&lt;code&gt;default&lt;/code&gt;属性，还有一点值得注意的是&lt;code&gt;export default&lt;/code&gt;后面不能跟变量表达式。&lt;/p&gt;
&lt;h2 id=&#34;2-commonjs&#34;&gt;2. CommonJS&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;CommonJS&lt;/code&gt;最主要的代表就是&lt;code&gt;Node.js&lt;/code&gt;，主要命令：&lt;code&gt;module、exports、require&lt;/code&gt;。其中有个令人疑惑的点是exports和module.exports，其实理解起来也很简单，就是在模块里面加了一句： &lt;code&gt;exports = module.exports = {};&lt;/code&gt; exports和module.exports指向同一个内存区域，只要在exports加了属性，则module.exports会跟着变化，但是最终导出对外的接口是以module.exports为准，所以不推荐直接使用exports。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;CommonJS&lt;/code&gt;规范来说，很重要的一点是&lt;code&gt;CommonJS&lt;/code&gt;输出的是一个值拷贝，并且是运行时加载。&lt;/p&gt;
&lt;h2 id=&#34;3-commonjs和es6-module的区别&#34;&gt;3. CommonJS和ES6 Module的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;引用方式：CommonJS模块输出是值的拷贝，ES6 Module模块输出的值是引用&lt;/li&gt;
&lt;li&gt;时机：CommonJS是运行时加载，ES6 Module是编译是输出&lt;/li&gt;
&lt;li&gt;前者支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案&lt;/li&gt;
&lt;li&gt;前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响&lt;/li&gt;
&lt;li&gt;前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化&lt;/li&gt;
&lt;li&gt;后者会编译成 require/exports 来执行的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-amd&#34;&gt;4. AMD&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;AMD&lt;/code&gt;规范是采用异步方式，依赖前置必须一开始就写好，所有的依赖加载完成后才会执行回调函数里的内容，模块的加载不影响它后面语句的运行。&lt;/p&gt;
&lt;p&gt;这里异步指的是不堵塞浏览器其他任务（dom构建，css渲染等），而加载内部是同步的（加载完模块后立即执行回调）。&lt;/p&gt;
&lt;p&gt;AMD也采用require命令加载模块，但是不同于CommonJS，它要求两个参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;require([module], callback);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cmd&#34;&gt;CMD&lt;/h2&gt;
&lt;p&gt;CMD推崇&lt;code&gt;依赖就近，延迟执行&lt;/code&gt;。可以把你的依赖写进代码的任意一行，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;define(factory)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;factory为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。factory 方法在执行时，默认会传入三个参数：require、exports 和 module.&lt;/p&gt;
&lt;h1 id=&#34;13-负载均衡&#34;&gt;13. 负载均衡&lt;/h1&gt;
&lt;h2 id=&#34;1-负载均衡概念&#34;&gt;1. 负载均衡概念&lt;/h2&gt;
&lt;p&gt;是指单台服务器性能达到极限时通过服务器集群来横向增加系统的吞吐量和性能。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1628733553835.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-服务器负载均衡&#34;&gt;2. 服务器负载均衡&lt;/h2&gt;
&lt;p&gt;服务器负载均衡就是我们平时说的负载均衡，是指在服务器上游做服务分发，常用的方式有一下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DNS域名解析负载均衡&lt;/strong&gt;：假设我们的域名指向了多个IP地址，当一个域名请求来时，DNS服务器机进行域名解析将域名转换为IP地址是，在1:N的映射转换中实现负载均衡。DNS服务器提供简单的负载均衡算法，但当其中某台服务器出现故障时，通知DNS服务器移除当前故障IP。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反向代理负载均衡&lt;/strong&gt;：反向代理只值对服务器的代理，代理服务器接受请求，通过负载均衡算法，将请求转发给后端服务器，后端服务返回给代理服务器然后代理服务器返回到客户端。反向代理服务器的优点是隔离后端服务器和客户端，使用双网卡屏蔽真实服务器网络，安全性更好，相比较于DNS域名解决负载均衡，反向代理在故障处理方面更灵活，支持负载均衡算法的横向扩展。目前使用非常广泛。当然反向代理也需要考虑很多问题，比如单点故障，集群部署等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IP负载均衡&lt;/strong&gt;：我们都知道反向代理工作到HTTP层，本身开销相对大一些，对性能有一定影响，LVS-NAT是一种卫浴传输层的负载均衡，它通过修改接受的数据包目标地址的方式实现负载均衡。Linux2.6.x以后版本内置了IPVS，专注用于实现IP负载均衡，故而在Linux上IP负载均衡使用非常广泛。LVS-DR工作在数据链路层，比LVS-NAT更霸道的时候它直接修改数据包的MAC地址。LVS-TUN——基于IP隧道的请求转发机制，将调度器收到的IP数据包进行封装，转交给服务器，然后服务器返回数据，通过调度器实现负载均衡。这种方式支持跨网段调度。总结一下，LVS-DR和LVS-TUN都适合响应和请求不对称的Web服务器，如何从它们中做出选择，取决于你的网络部署需要，因为LVS-TUN可具有跨地域性，有类似这种需求的，就应该选择LVS-TUN。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-客户端负载均衡&#34;&gt;3. 客户端负载均衡&lt;/h2&gt;
&lt;p&gt;相比较服务器负载均衡而言，客户端负载均衡是一个非常小众的概念，但是面试在问道负载均衡相关知识的时候却会刻意了解候选人的知识广度。客户端负载均衡是在spring-cloud分布式框架组件Ribbon中定义的。我们在使用spring-cloud分布式框架时，同一个service大概率同时启动多个，当一个请求奔过来时，那么这多个service，Ribbon通过策略决定本次请求使用哪个service的方式就是客户端负载均衡。在spring-cloud分布式框架中客户端负载均衡对开发者是透明的，添加@LoadBalanced注解就可以了。客户端负载均衡和服务器负载均衡的核心差异在服务列表本身，客户端负载均衡服务列表在通过客户端维护，服务器负载均衡服务列表由中间服务单独维护。&lt;/p&gt;
&lt;p&gt;通过对以上知识的理解，大家能够对负载均衡有的较为全面的认识，下来我再简单的和面试官聊一聊常见的负载均衡算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;随机，通过随机选择服务进行执行，一般这种方式使用较少;&lt;/li&gt;
&lt;li&gt;轮训，负载均衡默认实现方式，请求来之后排队处理;&lt;/li&gt;
&lt;li&gt;加权轮训，通过对服务器性能的分型，给高配置，低负载的服务器分配更高的权重，均衡各个服务器的压力;&lt;/li&gt;
&lt;li&gt;地址Hash，通过客户端请求的地址的HASH值取模映射进行服务器调度。&lt;/li&gt;
&lt;li&gt;最小链接数;即使请求均衡了，压力不一定会均衡，最小连接数法就是根据服务器的情况，比如请求积压数等参数，将请求分配到当前压力最小的服务器上。&lt;/li&gt;
&lt;/ul&gt;
">【面】前端知识点梳理（服务端与网络）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/mian-qian-duan-zhi-shi-dian-shu-li-liu-lan-qi/"" data-c="
          &lt;h1 id=&#34;1-输入url到展示页面过程发生了什么详细&#34;&gt;1. 输入url到展示页面过程发生了什么？（详细）&lt;/h1&gt;
&lt;h2 id=&#34;0-梳理主干流程&#34;&gt;0. 梳理主干流程&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;1、从浏览器接收url到开启网络请求线程（涉及到：浏览器机制，线程和进程之间的关系等）

2、开启网络线程到发出一个完整的http请求（涉及到：dns查询，tcp/ip请求，5层网络协议栈等）

3、从服务器接收到请求到对应后台接收到请求（涉及到：均衡负载，安全拦截，后台内部的处理等）

4、后台和前台的http交互（涉及到：http头，响应码，报文结构，cookie等，可以提下静态资源的cookie优化，以及编码解码如gzip压缩等）

5、缓存问题：http缓存（涉及到：涉及到http缓存头部，etag，expired，cache-control等）

6、浏览器接收到http数据包后的解析流程（涉及到：html的词法分析，然后解析成dom树，同时解析css生成css规则树，合并生成render树。然后layout布局、painting渲染、复合图层的合成、GPU绘制、外链接处理、loaded和documentloaded等）

7、css可视化格式模型（涉及到：元素渲染规则，如：包含块，控制框，BFC，IFC等概念）

8、js引擎解析过程（涉及到：js解释阶段，预处理阶段，执行阶段生成执行上下文，VO（全局对象），作用域链，回收机制等）

9、其他（扩展其他模块：跨域，web安全等）
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1-从浏览器接受url到开启网络请求线程&#34;&gt;1. 从浏览器接受URL到开启网络请求线程&lt;/h2&gt;
&lt;h3 id=&#34;1-解析url&#34;&gt;1. 解析URL&lt;/h3&gt;
&lt;p&gt;输入URL后，会进行解析（URL的意思就是统一资源定位符）&lt;br&gt;
URL一般包含以下几个部分&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616400775746.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-网络请求都是单独的线程&#34;&gt;2. 网络请求都是单独的线程&lt;/h3&gt;
&lt;p&gt;每次网络请求时，都需要开辟单独的线程去进行，比如URL解析到了http协议，就会新建一个网络线程去处理资源下载。&lt;/p&gt;
&lt;p&gt;因此浏览器会根据解析得出协议，开辟一个网络线程，前往请求资源。&lt;/p&gt;
&lt;h2 id=&#34;2-开启网络线程到发出一个完整的http请求&#34;&gt;2. 开启网络线程到发出一个完整的HTTP请求&lt;/h2&gt;
&lt;p&gt;这一部分主要包括：&lt;code&gt;dns&lt;/code&gt;查询，&lt;code&gt;tcp/ip&lt;/code&gt;请求构建，&lt;code&gt;五层因特网协议栈&lt;/code&gt;等等&lt;/p&gt;
&lt;h3 id=&#34;1-dns查询得到ip&#34;&gt;1. DNS查询得到IP&lt;/h3&gt;
&lt;p&gt;如果输入的域名，需要DNS解析成IP，流程如下：&lt;br&gt;
（1）浏览器有缓存，直接用浏览器缓存，没有就去本机缓存，没有就看是不是host。&lt;br&gt;
（2）如果还没有，就向DNS域名服务器查询（这个过程经过路由，路由也有缓存），查询到对应的IP。&lt;br&gt;
（3）本地DNS服务器将ip返回给浏览器，并将ip存入缓存，方便下次访问，加快访问速度&lt;/p&gt;
&lt;p&gt;注意：1、域名查询的时候有可能经过CDN调度器（如果CDN有存储功能）；&lt;br&gt;
2、DNS解析是很耗时的，因此如果解析域名过多，首屏加载会变慢，可以考虑使用dns-prefetch优化。&lt;/p&gt;
&lt;h3 id=&#34;2-tcpip请求构建&#34;&gt;2. tcp/ip请求构建&lt;/h3&gt;
&lt;p&gt;http的本质就是tcp/ip请求构建。需要3次握手规则简历连接，以及断开连接时候的4次挥手。&lt;/p&gt;
&lt;p&gt;tcp将http长报文划分为短报文，通过3次握手与服务端建立连接，进行可靠的传输。&lt;/p&gt;
&lt;p&gt;建立成功之后，接下来就是正式传输数据。&lt;/p&gt;
&lt;p&gt;然后，等到断开连接时，需要进行4次挥手（因为是全双工的，所以需要4次握手）。&lt;/p&gt;
&lt;h3 id=&#34;3-五层网络协议栈&#34;&gt;3. 五层网络协议栈&lt;/h3&gt;
&lt;p&gt;客户端发出http请求到服务器接收，中间会经过一系列的流程。&lt;/p&gt;
&lt;p&gt;客户端发送请求具体：&lt;strong&gt;从应用层发动http请求，到传输层通过三次握手简历tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后在物理层通过物理介质传输&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;服务端接收请求具体：反过来。&lt;/p&gt;
&lt;p&gt;五层因特网协议栈其实就是：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616402062824.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;其实也有一个完整的OSI七层框架，与之相比，多了&lt;strong&gt;会话层、表示层&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示层：主要处理两个通信系统中交互信息的表示方式，包括数据格式交换，数据加密和解密，数据压缩和终端类型转换等。&lt;/li&gt;
&lt;li&gt;会话层：具体管理不同用户和进程之间的对话，如控制登录和注销过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-从服务器接收到请求到对应后台接收到请求&#34;&gt;3. 从服务器接收到请求，到对应后台接收到请求&lt;/h2&gt;
&lt;p&gt;包括：负载均衡、后台处理、&lt;/p&gt;
&lt;h3 id=&#34;1-负载均衡&#34;&gt;1. 负载均衡&lt;/h3&gt;
&lt;p&gt;对于大型项目，并发访问很大，一台服务器吃不消，一般会有若干台服务器组成一个集群，然后配合反向代理实现均衡负载。均衡负载不止一种实现方式。&lt;/p&gt;
&lt;p&gt;概括的说：&lt;strong&gt;用户发送的请求指向调度服务器（反向代理服务器，比如nginx的均衡负载），然后调度服务器根据实际的调度算法，分配不同的请求给对应的集群中的服务器执行，然后调度服务器等待实际服务器的HTTP响应，并且反馈给用户&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;2-后台处理&#34;&gt;2. 后台处理&lt;/h3&gt;
&lt;p&gt;（1）一般有的后端有统一的验证，比如安全拦截，跨域验证；&lt;br&gt;
（2）如果不符合验证规则，就直接返回相应的http报文（拒绝请求等）；&lt;br&gt;
（3）如果验证通过了，才会进入到实际的后台代码，此时程序接收到请求，然后执行查询数据库，大量计算等等；&lt;br&gt;
（4）等程序执行完毕后，会返回一个http响应包（一般这一步会经过多层封装）；&lt;br&gt;
（5）然后将这个数据包从后端返回到前端，完成交互。&lt;/p&gt;
&lt;h2 id=&#34;4-后台和前台的http交互&#34;&gt;4. 后台和前台的http交互&lt;/h2&gt;
&lt;p&gt;前后端的交互，http报文作为信息的载体。&lt;/p&gt;
&lt;h3 id=&#34;1-http报文结构&#34;&gt;1. http报文结构&lt;/h3&gt;
&lt;p&gt;报文一般包括了：&lt;code&gt;通用头部&lt;/code&gt;，&lt;code&gt;请求/响应头部&lt;/code&gt;，&lt;code&gt;请求/相应体&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1. 通用头部&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1616402828678.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;比如，在跨域拒绝的时候，可能的method是options，状态码是404/405等（可能的组合有很多）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2. 请求头/响应头&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常用的请求头部（部分）：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Accept: 接收类型，表示浏览器支持的MIME类型 （对标服务端返回的Content-Type）&lt;br&gt;
Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收&lt;br&gt;
Content-Type：客户端发送出去实体内容的类型&lt;br&gt;
Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache&lt;br&gt;
If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中&lt;br&gt;
Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间&lt;br&gt;
Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中&lt;br&gt;
If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中&lt;br&gt;
Cookie: 有cookie并且同域访问时会自动带上&lt;br&gt;
Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive&lt;br&gt;
Host：请求的服务器URL&lt;br&gt;
Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私&lt;br&gt;
Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)&lt;br&gt;
User-Agent：用户客户端的一些必要信息，如UA头部等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;常用的响应头部（部分）：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Access-Control-Allow-Headers: 服务器端允许的请求Headers&lt;br&gt;
Access-Control-Allow-Methods: 服务器端允许的请求方法&lt;br&gt;
Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）&lt;br&gt;
Content-Type：服务端返回的实体内容的类型&lt;br&gt;
Date：数据从服务器发送的时间&lt;br&gt;
Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档&lt;br&gt;
Last-Modified：请求资源的最后修改时间&lt;br&gt;
Expires：应该在什么时候认为文档已经过期,从而不再缓存它&lt;br&gt;
Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效&lt;br&gt;
ETag：请求变量的实体标签的当前值&lt;br&gt;
Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端&lt;br&gt;
Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）&lt;br&gt;
Server：服务器的一些相关信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;一般来说，请求头部和响应头部是匹配分析的&lt;/strong&gt;。&lt;br&gt;
比如：&lt;br&gt;
（1）请求头部的Accept要和响应头部的Content-Type匹配，否则会报错；&lt;br&gt;
（2）跨域请求中，请求头部的Origin要匹配响应头的Access-Control-Allow-Origin，否则会报跨域错误；&lt;br&gt;
（3）使用缓存，请求头部的if-modified-since，if-none-match分别和响应头的Last-modified，etag对应。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;3. 请求/响应实体&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;http请求时，除了头部，还有消息实体。&lt;br&gt;
请求实体中会将一些需要的参数都放入进入（用于post请求）。&lt;/p&gt;
&lt;p&gt;比如：（1）实体中可以放参数的序列化形式（a=1&amp;amp;b=2这种），或者直接放表单（Form Data对象，上传时可以夹杂其他以及文件）等等。&lt;/p&gt;
&lt;p&gt;响应实体中，就是服务端需要传给客户端的内容。&lt;/p&gt;
&lt;p&gt;一般现在的接口请求时，实体中就是对应信息的json格式，而像&lt;strong&gt;页面请求&lt;/strong&gt;这种，里面就是直接放一个html的字符串，然后浏览器自己解析并渲染。&lt;/p&gt;
&lt;p&gt;下图是对某请求的http报文结构的简要分析：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616403142489.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;5-解析页面流程&#34;&gt;5. 解析页面流程&lt;/h2&gt;
&lt;p&gt;前面提到是http交互，接下来是浏览器获取到html，然后解析，渲染。&lt;/p&gt;
&lt;h3 id=&#34;1-流程简述&#34;&gt;1. 流程简述&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;（1）解析html，构建DOM树；同时解析CSS，生成CSS规则树。&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616405665707.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;（2）合并DOM树和CSS规则树，生成Render树。&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616405717426.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;（3）布局Render树（layout/reflow）,负责各元素的尺寸，位置计算。&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616405786916.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;（4）绘制render树（paint），绘制页面像素信息。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（5）浏览器会将各层的信息发给GPU。GPU会将各层合成（composite），显示在屏幕上。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-资源外链的下载&#34;&gt;2. 资源外链的下载&lt;/h3&gt;
&lt;p&gt;上面介绍了HTML解析，渲染流程。但是实际上，在解析HTML时，会遇到一些资源连接，此时就需要进行单独处理&lt;/p&gt;
&lt;p&gt;简单起见，这里将遇到的静态资源分为以下几大类（未列举所有）：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616405978122.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;（1）遇到外链的处理&lt;/strong&gt;&lt;br&gt;
当遇到上述的外链时，会单&lt;strong&gt;独开启一个下载线程去下载资源&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;（2）遇到CSS样式资源&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616406119704.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;（3）遇到JS脚本资源&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616406134535.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注意，defer和async是有区别的：** defer是延迟执行，而async是异步执行**。&lt;br&gt;
&lt;strong&gt;（4）遇到img图片类的资源&lt;/strong&gt;&lt;br&gt;
遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方&lt;/p&gt;
&lt;h1 id=&#34;2-重绘与回流&#34;&gt;2. 重绘与回流&lt;/h1&gt;
&lt;h2 id=&#34;0-浏览器的渲染原理&#34;&gt;0. 浏览器的渲染原理&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1616378131657.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1-重绘与回流&#34;&gt;1. 重绘与回流&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;重绘(repaint)&lt;/code&gt;:当页面元素样式改变不影响元素在文档流中的位置时（如background-color，border-color，visibility），浏览器只会将新样式赋予元素并进行重新绘制操作。此时由于只需要UI层面的重新像素绘制，因此 &lt;strong&gt;损耗较少&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;回流(reflow)&lt;/code&gt;: 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变时，网络浏览器重新渲染部分或全部文档的过程。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;会触发回流的操作:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;添加或者删除可见的DOM元素；&lt;/li&gt;
&lt;li&gt;元素位置改变；&lt;/li&gt;
&lt;li&gt;元素尺寸改变——边距、填充、边框、宽度和高度&lt;/li&gt;
&lt;li&gt;内容变化，比如用户在input框中输入文字，文本或者图片大小改变而引起的计算值宽度和高度改变&lt;/li&gt;
&lt;li&gt;页面渲染初始化&lt;/li&gt;
&lt;li&gt;浏览器窗口尺寸改变——resize事件发生时&lt;/li&gt;
&lt;li&gt;计算 offsetWidth 和 offsetHeight 属性&lt;/li&gt;
&lt;li&gt;设置 style 属性的值&lt;/li&gt;
&lt;li&gt;页面初次渲染&lt;/li&gt;
&lt;li&gt;元素字体大小变化&lt;/li&gt;
&lt;li&gt;激活 CSS 伪类（例如：:hover）&lt;/li&gt;
&lt;li&gt;clientWidth、clientHeight、clientTop、clientLeft&lt;/li&gt;
&lt;li&gt;offsetWidth、offsetHeight、offsetTop、offsetLeft&lt;/li&gt;
&lt;li&gt;scrollWidth、scrollHeight、scrollTop、scrollLeft&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-性能优化&#34;&gt;2. 性能优化&lt;/h2&gt;
&lt;p&gt;回流比重绘的代价要更高，回流的花销跟render tree有多少节点需要重新构建有关系;浏览器本身能够进行优化，尽可能减少重绘和回流。&lt;/p&gt;
&lt;p&gt;如果每行JS代码操作DOM都需要回流重绘的话，浏览器可能就会受不了。所以很多浏览器都会优化这些操作，浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。&lt;/p&gt;
&lt;h2 id=&#34;3-如何减少回流-重绘&#34;&gt;3. 如何减少回流、重绘&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var s = document.body.style; 
s.padding = &amp;quot;2px&amp;quot;; // 回流+重绘
s.border = &amp;quot;1px solid red&amp;quot;; // 再一次 回流+重绘
s.color = &amp;quot;blue&amp;quot;; // 再一次重绘
s.backgroundColor = &amp;quot;#ccc&amp;quot;; // 再一次 重绘
s.fontSize = &amp;quot;14px&amp;quot;; // 再一次 回流+重绘
// 添加node，再一次 回流+重绘
document.body.appendChild(document.createTextNode(&#39;abc!&#39;));
///可以看到每次DOM元素的样式操作都会引发重绘，如果涉及布局还会引发回流。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一. CSS中避免回流&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;尽可能在DOM树的最末端改变class&lt;/li&gt;
&lt;li&gt;避免设置多层内联样式&lt;/li&gt;
&lt;li&gt;动画效果应用到position属性为absolute或fixed的元素上&lt;/li&gt;
&lt;li&gt;牺牲平滑度换取速度&lt;/li&gt;
&lt;li&gt;避免使用table布局&lt;/li&gt;
&lt;li&gt;避免使用CSS的JavaScript表达式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;二. JS操作避免回流&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;避免逐项更改样式。最好一次性更改style属性，或者将样式列表定义为class并一次性更改class属性。&lt;/li&gt;
&lt;li&gt;避免循环操作DOM。创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document。&lt;/li&gt;
&lt;li&gt;也可以在一个display:none的元素上进行操作，最终把它显示出来。因为display:none上的DOM操作不会引发回流和重绘。&lt;/li&gt;
&lt;li&gt;避免循环读取offsetLeft等属性。在循环之前把它们存起来。&lt;/li&gt;
&lt;li&gt;绝对定位具有复杂动画的元素。绝对定位使它脱离文档刘，否则会引起父元素及后续元素大量的回流。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;3-防抖与节流&#34;&gt;3. 防抖与节流&lt;/h1&gt;
&lt;h2 id=&#34;1-防抖debounce&#34;&gt;1. 防抖(debounce)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;返回顶部。这个按钮只会在滚动到距离顶部一定位置之后才出现，那么我们现在抽象出这个功能需求-- 监听浏览器滚动事件，返回当前滚条与顶部的距离。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基于上述场景，首先提出第一种思路：&lt;strong&gt;在第一次触发事件时，不立即执行函数，而是给出一个期限值&lt;/strong&gt;比如200ms，然后：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果在200ms内没有再次触发滚动事件，那么就执行函数&lt;/li&gt;
&lt;li&gt;如果在200ms内再次触发滚动事件，那么当前的计时取消，重新开始计时&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;效果&lt;/strong&gt;：如果短时间内大量触发同一事件，只会执行一次函数。利用计时器setTimeout和clearTimeout，只要触发事件，就会销毁上一次的计时器，重新计时，计时结束后才会触发回掉函数的事件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;：既然前面都提到了计时，那实现的关键就在于&lt;code&gt;setTimeout&lt;/code&gt;这个函数，由于还需要一个变量来保存计时，考虑维护全局纯净，可以借助闭包来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function debounce(fn,delay){
    let timer = null //借助闭包
    return function() {
        if(timer){
            clearTimeout(timer) 
        }
        timer = setTimeout(fn,delay) // 简化写法
    }
}
// 然后是旧代码
function showTop  () {
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
　　console.log(&#39;滚动条位置：&#39; + scrollTop);
}
window.onscroll = debounce(showTop,1000) // 为了方便观察效果我们取个大点的间断值，实际使用根据需要来配置
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;对于短时间内连续触发的事件（上面的滚动事件），防抖的含义就是让某个时间期限（如上面的1000毫秒）内，事件处理函数只执行一次。&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-节流throttle&#34;&gt;2. 节流(throttle)&lt;/h2&gt;
&lt;p&gt;类似&lt;strong&gt;控制阀门一样定期开放的函数，也就是让函数执行一次后，在某个时间段内暂时失效，过了这段时间后再重新激活&lt;/strong&gt;（类似于技能冷却时间）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效果&lt;/strong&gt;：如果短时间内大量触发同一事件，&lt;strong&gt;那么在函数执行一次之后，该函数在指定的时间期限内不再工作&lt;/strong&gt;，直至过了这段时间才重新生效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt; 这里借助&lt;code&gt;setTimeout&lt;/code&gt;来做一个简单的实现，加上一个状态位&lt;code&gt;valid&lt;/code&gt;来表示当前函数是否处于工作状态：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function throttle(fn,delay){
    let valid = true
    return function() {
       if(!valid){
           //休息时间 暂不接客
           return false 
       }
       // 工作时间，执行函数并且在间隔期内把状态位设为无效
        valid = false
        setTimeout(() =&amp;gt; {
            fn()
            valid = true;
        }, delay)
    }
}
/* 请注意，节流函数并不止上面这种实现方案,
   例如可以完全不借助setTimeout，可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定。
   也可以直接将setTimeout的返回的标记当做判断条件-判断当前定时器是否存在，如果存在表示还在冷却，并且在执行fn之后消除定时器表示激活，原理都一样
    */
// 以下照旧
function showTop  () {
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
　　console.log(&#39;滚动条位置：&#39; + scrollTop);
}
window.onscroll = throttle(showTop,1000) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行以上代码的结果是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一直拖着滚动条进行滚动，那么会以1s的时间间隔，持续输出当前位置和顶部的距离&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以完全&lt;code&gt;不借助setTimeout&lt;/code&gt;，可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定。&lt;/p&gt;
&lt;h2 id=&#34;3-其他场景&#34;&gt;3. 其他场景&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;搜索框input事件，例如要支持输入实时搜索可以使用节流方案（间隔一段时间就必须查询相关内容），或者实现输入间隔大于某个值（如500ms），就当做用户输入完成，然后开始搜索，具体使用哪种方案要看业务需求。&lt;/li&gt;
&lt;li&gt;页面resize事件，常见于需要做页面适配的时候。需要根据最终呈现的页面情况进行dom渲染（这种情形一般是使用防抖，因为只需要判断最后一次的变化情况）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-接受传参&#34;&gt;4. 接受传参&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;防抖&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt; window.onload = function() {
      // 1、获取这个按钮，并绑定事件
      var myDebounce = document.getElementById(&amp;quot;debounce&amp;quot;);
      myDebounce.addEventListener(&amp;quot;click&amp;quot;, debounce(sayDebounce));
    }
 
    // 2、防抖功能函数，接受传参
    function debounce(fn) {
      // 4、创建一个标记用来存放定时器的返回值
      let timeout = null;
      return function() {
        // 5、每次当用户点击/输入的时候，把前一个定时器清除
        clearTimeout(timeout);
        // 6、然后创建一个新的 setTimeout，
        // 这样就能保证点击按钮后的 interval 间隔内
        // 如果用户还点击了的话，就不会执行 fn 函数
        timeout = setTimeout(() =&amp;gt; {
          fn.call(this, arguments);
        }, 1000);
      };
    }
 
    // 3、需要进行防抖的事件处理
    function sayDebounce() {
      // ... 有些需要防抖的工作，在这里执行
      console.log(&amp;quot;防抖成功！&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;节流&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;  window.onload = function() {
      // 1、获取按钮，绑定点击事件
      var myThrottle = document.getElementById(&amp;quot;throttle&amp;quot;);
      myThrottle.addEventListener(&amp;quot;click&amp;quot;, throttle(sayThrottle));
    }
 
    // 2、节流函数体
    function throttle(fn) {
      // 4、通过闭包保存一个标记
      let canRun = true;
      return function() {
        // 5、在函数开头判断标志是否为 true，不为 true 则中断函数
        if(!canRun) {
          return;
        }
        // 6、将 canRun 设置为 false，防止执行之前再被执行
        canRun = false;
        // 7、定时器
        setTimeout( () =&amp;gt; {
          fn.call(this, arguments);
          // 8、执行完事件（比如调用完接口）之后，重新将这个标志设置为 true
          canRun = true;
        }, 1000);
      };
    }
 
    // 3、需要节流的事件
    function sayThrottle() {
      console.log(&amp;quot;节流成功！&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-区别&#34;&gt;5. 区别&lt;/h2&gt;
&lt;p&gt;函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。&lt;/p&gt;
&lt;h1 id=&#34;4-前端持久化储存-cookies-session-sessionstorage-localstorage-token&#34;&gt;4. 前端持久化储存 cookies、session、sessionStorage、localStorage、token&lt;/h1&gt;
&lt;h2 id=&#34;1-cookie&#34;&gt;1. cookie&lt;/h2&gt;
&lt;p&gt;由于HTTP是一种&lt;strong&gt;无状态的协议&lt;/strong&gt;，服务器单从网络连接上是无法知道客户身份的。这时候服务器就需要给客户端颁发一个cookie，用来确认用户的身份。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1617867098815.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-cookie的构成&#34;&gt;1. cookie的构成&lt;/h3&gt;
&lt;p&gt;Cookie用于用户识别及状态管理，为Cookie提供服务的首部字段有：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1617868823315.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当服务器准备管理客户端状态的时候，会告知各种信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; path=/; domain=.hackr.jp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cookie 相关的首部字段有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;expires&lt;/strong&gt;&lt;br&gt;
指定浏览器可发送Cookie的有效期。当省略 expires 属性的时候，其有效期仅限于维持浏览器会话期间。&lt;br&gt;
另外，一旦 Cookie 从服务器发送至客户端，服务器就不存在可以显示删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;max-age&lt;br&gt;
与expires作用相同，用来告诉浏览器此cookie多久过期（单位是秒），而不是一个固定的时间点。正常情况下，max-age的&lt;code&gt;优先级高&lt;/code&gt;于expires。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;path&lt;br&gt;
默认为 /，就是根目录。&lt;strong&gt;子路径页面能够访问父路径页面的 Cookie&lt;/strong&gt;。兄弟路径页面之间的 Cookie 不能互相访问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;domain&lt;br&gt;
可以访问该 Cookie 的域名。&lt;br&gt;
而跨域访问，如域A为http://t1.test.com，域B为http://t2.test.com，那么在域A生产一个令域A和域B都能访问的cookie就要将该cookie的domain设置为.http://test.com；如果要在域A生产一个令域A不能访问而域B能访问的cookie就要将该cookie的domain设置为http://t2.test.com。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;secure&lt;br&gt;
Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。&lt;br&gt;
发送 Cookie 时，指定 secure 属性的方法如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;Set-Cookie:name=value; secure
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;HttpOnly&lt;br&gt;
Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，&lt;strong&gt;它使得 JavaScript 脚本无法获取 Cookie&lt;/strong&gt;。其主要目的是为了防止跨站脚本攻击（XSS，Cross-site scripting）对 Cookie 的信息窃取。&lt;br&gt;
指定发送 HttpOnly 属性的 Cookie 的方法如下所示：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;Set-Cookie:name=value; HttpOnly
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;cookie的不可跨域名性&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：修改、删除Cookie时，新建的Cookie除value、maxAge之外的所有属性，例如name、path、domain等，都要与原Cookie完全一样。否则，浏览器将视为两个不同的Cookie不予覆盖，导致修改、删除失败。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-session&#34;&gt;2. Session&lt;/h2&gt;
&lt;p&gt;Session是另一种记录客户状态的机制，不同的是Cookie保存在&lt;code&gt;客户端浏览器&lt;/code&gt;中，而Session保存在&lt;code&gt;服务器上&lt;/code&gt;。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。&lt;/p&gt;
&lt;p&gt;Session 之所以可以识别不同的用户，依靠的就是Cookie，所以说&lt;strong&gt;session是基于cookie的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该Cookie是服务器自动颁发给浏览器的，不用我们手工创建的。该Cookie的&lt;code&gt;maxAge值默认是-1&lt;/code&gt;，也就是说仅当前浏览器使用，不将该Cookie存在硬盘中，并且各浏览器窗口间不共享，关闭浏览器就会失效。&lt;/p&gt;
&lt;h3 id=&#34;1-工作步骤&#34;&gt;1. 工作步骤：&lt;/h3&gt;
&lt;p&gt;将客户端称为 client，服务端称为 server&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;产生 sessionID：session 是基于 cookie 的一种方案，所以，首先要产生 cookie。client 第一次访问 server，server 生成一个随机数，命名为 sessionID，并将其放在响应头里，以 cookie 的形式返回给 client，client 以处理其他 cookie 的方式处理这段 cookie。大概是这样：cookie：sessionID=135165432165&lt;/li&gt;
&lt;li&gt;保存 sessionID： server 将要保存的数据保存在相对应的 sessionID 之下，再将 sessionID 保存到服务器端的特定的保存 session 的内存中（如 一个叫 session 的哈希表）&lt;/li&gt;
&lt;li&gt;使用 session： client 再次访问 server，会带上首次访问时获得的 值为 sessionID 的cookie，server 读取 cookie 中的 sessionID，根据 sessionID 到保存 session 的内存寻找与 sessionID 匹配的数据，若寻找成功就将数据返回给 client。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;session有效期&#34;&gt;Session有效期&lt;/h3&gt;
&lt;p&gt;Session生成后，只要用户继续访问，&lt;code&gt;服务器就会更新Session的最后访问时间，并维护该Session&lt;/code&gt;。用户每访问服务器一次，无论是否读写Session，服务器都认为该用户的Session“活跃（active）”了一次。&lt;/p&gt;
&lt;p&gt;由于会有越来越多的用户访问服务器，因此Session也会越来越多。为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了。&lt;/p&gt;
&lt;h2 id=&#34;3-cookie与session的区别&#34;&gt;3. cookie与session的区别&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;使用方式&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;cookie机制：如果不在浏览器中设置过期事件，cookie被保存在内存中，生命周期随浏览器的关闭而结束，这种cookie简称为会话cookie。如果在浏览器中设置了cookie的过期事件，cookie会被保存在硬盘中，关闭浏览器后，cookie数据仍然存在，直到过期事件结束才消失。cookie是服务端发给客户端的特殊信息，cookie是以文本的方式保存在客户端，每次请求时都带上它&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;session机制：当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含sessionid。如果有sessionid，服务器将根据该id返回对应session对象。如果客户端请求中没有sessionid，服务器会创建新的session对象，并把sessionid在本次响应中返回给客户端。通常使用cookie方式存储sessionid到客户端，在交互中浏览器按照规则将sessionid发送给服务器。如果用户禁用cookie，则要使用URL重写，可以通过response.encodeURL(url)进行实现；API对encodeURL的结束为，当浏览器支持cookie时，url不做任何处理；当浏览器不支持cookie的时候，将会重写URL将sessionid拼接到访问地址后。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;保持状态&lt;br&gt;
cookie保存在浏览器端，session保存在服务器端&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储的大小&lt;br&gt;
单个cookie保存的数据不能超过4kb；session大小没有限制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储内容&lt;br&gt;
cookie只能保存字符串类型，以文本的方式。&lt;br&gt;
session通过类似与Hashtable的数据结构来保存，能支持任何类型的对象（session中可含有多个对象）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安全性&lt;br&gt;
session的安全性大于cookie。原因如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;① sessionid存储在cookie中，若要攻破session首先要攻破cookie；
② sessionid是要有人登录，或者启动session_start才会有，所以攻破cookie也不一定能得到sessionid；
③ 第二次启动session_start后，前一次的sessionid就是失效了，session过期后，sessionid也随之失效。
④ sessionid是加密的。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;应用场景&lt;br&gt;
cookie：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;（1）判断用户是否登录过网站，以便下次登录时能够实现自动登录（或者记住密码）。
（2）保存上次登录的事件等信息。
（3）保存上次查看的页面
（4）浏览计数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;session：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;（1）网上商城中的购物车
（2）保存用户登录信息
（3）将某些数据放入session中，供同一用户的不同页面使用
（4）防止用户非法登录
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果说&lt;strong&gt;Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-token&#34;&gt;4. Token&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1617867124106.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1-token定义&#34;&gt;1. Token定义&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;令牌&lt;/strong&gt;，是用户身份的验证方式。&lt;br&gt;
最简单的token组成：&lt;strong&gt;uid(用户唯一的身份标识)、time（当前时间的时间戳）、sign（签名）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对Token认证的五点认识&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个Token就是一些信息的集合；&lt;/li&gt;
&lt;li&gt;在Token中包含足够多的信息，以便在后续请求中减少查询数据库的几率；&lt;/li&gt;
&lt;li&gt;服务端需要对cookie和HTTP Authrorization Header进行Token信息的检查；&lt;/li&gt;
&lt;li&gt;基于上一点，你可以用一套token认证代码来面对浏览器类客户端和非浏览器类客户端；&lt;/li&gt;
&lt;li&gt;因为token是被签名的，所以我们可以认为一个可以解码认证通过的token是由我们系统发放的，其中带的信息是合法有效的；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-基于token的身份验证&#34;&gt;2. 基于Token的身份验证&lt;/h3&gt;
&lt;p&gt;基于token的验证是无状态的。服务器不记录哪些用户已登陆或者已经发布了哪些JWT。对服务器的每个请求都需要带上验证请求的token。该标记既可以加在header中，可以在POST请求的主体中发送，也可以作为查询参数发送。&lt;/p&gt;
&lt;p&gt;工作流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户输入登陆凭据；&lt;/li&gt;
&lt;li&gt;服务器验证凭据是否正确，然后返回一个经过签名的token；&lt;/li&gt;
&lt;li&gt;客户端负责存储token，可以存在local storage，或者cookie中；&lt;/li&gt;
&lt;li&gt;对服务器的请求带上这个token；&lt;/li&gt;
&lt;li&gt;服务器对JWT进行解码，如果token有效，则处理该请求；&lt;/li&gt;
&lt;li&gt;一旦用户登出，客户端销毁token。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-token的优势&#34;&gt;3. Token的优势&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;无状态&lt;/strong&gt;&lt;br&gt;
基于token的验证是无状态的，这也许是它相对cookie来说最大的优点。后端服务不需要记录token。每个令牌都是独立的，包括检查其有效性所需的所有数据，并通过声明传达用户信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;服务器唯一的工作就是在成功的登陆请求上签署token，并验证传入的token是否有效。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;防跨站请求伪造（CSRF）&lt;/strong&gt;&lt;br&gt;
举个CSRF攻击的例子，在网页中有这样的一个链接&lt;br&gt;
&lt;code&gt;![](http://bank.com?withdraw=1000&amp;amp;to=tom)&lt;/code&gt;，假设你已经通过银行的验证并且cookie中存在验证信息，同时银行网站没有CSRF保护。一旦用户点了这个图片，就很有可能从银行向tom这个人转1000块钱。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是如果银行网站使用了token作为验证手段，攻击者将无法通过上面的链接转走你的钱。（因为攻击者无法获取正确的token）&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;多站点使用&lt;/strong&gt;&lt;br&gt;
cookie绑定到单个域。foo.com域产生的cookie无法被bar.com域读取。使用token就没有这样的问题。这对于需要向多个服务获取授权的单页面应用程序尤其有用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;支持移动平台&lt;/strong&gt;&lt;br&gt;
好的API可以同时支持浏览器，iOS和Android等移动平台。然而，在移动平台上，cookie是不被支持的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-localstorage&#34;&gt;5. localStorage&lt;/h2&gt;
&lt;p&gt;localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。&lt;/p&gt;
&lt;p&gt;并且不会因为刷新而释放，所以，&lt;strong&gt;可以使用 localStorage 来实现变量的持久化存储&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;localStorage的特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;localStorage 与 HTTP 没有任何关系，所以在HTTP请求时不会带上 localStorage 的值&lt;/li&gt;
&lt;li&gt;只有相同域名的页面才能互相读取 localStorage，同源策略与 cookie 一致&lt;/li&gt;
&lt;li&gt;不同的浏览器，对每个域名 localStorage 的最大存储量的规定不一样，超出存储量会被拒绝。最大存5M 超过5M的数据就会丢失。而 Chrome 10MB 左右&lt;/li&gt;
&lt;li&gt;常用来记录一些不敏感的信息&lt;/li&gt;
&lt;li&gt;localStorage 理论上永久有效，除非用户清理缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6-sessionstorage&#34;&gt;6. sessionStorage&lt;/h2&gt;
&lt;p&gt;sessionStorage 的所有性质基本上与 localStorage 一致，唯一的不同区别在于：&lt;/p&gt;
&lt;p&gt;sessionStorage 的有效期是页面会话持续，如果页面&lt;code&gt;会话（session）结束&lt;/code&gt;（关闭窗口或标签页），sessionStorage 就会&lt;code&gt;消失&lt;/code&gt;。而 localStorage 则会一直存在。&lt;/p&gt;
&lt;h2 id=&#34;7-localstorage与sessionstorage的区别&#34;&gt;7. localStorage与sessionStorage的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;localStorage生命周期是永久的，除非被清除，否则永久保存，而sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;5-跨域问题详解&#34;&gt;5. 跨域问题详解&lt;/h1&gt;
&lt;h2 id=&#34;1-同源策略&#34;&gt;1. 同源策略&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。&lt;br&gt;
可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同源策略，它是由Netscape提出的一个著名的安全策略。现在所有支持JavaScript 的浏览器都会使用这个策略。所谓同源是指，&lt;code&gt;域名，协议，端口相同&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当一个浏览器的两个tab页中分别打开来，百度和谷歌的页面，当浏览器的百度tab页执行一个脚本的时候会检查这个脚本是属于哪个页面的，即检查是否同源，只有和百度同源的脚本才会被执行。&lt;/p&gt;
&lt;p&gt;如果非同源，那么在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同源策略的限制：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;存储在浏览器中的数据，如localStroage、Cooke和IndexedDB不能通过脚本跨域访问&lt;/li&gt;
&lt;li&gt;不能通过脚本操作不同域下的DOM&lt;/li&gt;
&lt;li&gt;不能通过ajax请求不同域的数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-什么是浏览器跨域&#34;&gt;2. 什么是浏览器跨域&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;一个域的页面去请求另一个域的资源&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;A域的页面去请求B域的资源。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1617932910598.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-jsonp实现跨域&#34;&gt;3. JSONP实现跨域&lt;/h2&gt;
&lt;p&gt;在同源策略下，在某个服务器下的页面是无法获取到该服务器以外的数据的，但img、iframe、script等标签是个例外，这些标签可以通过src属性请求到其他服务器上的数据。利用script标签的开放策略，我们可以实现跨域请求数据，当然，也需要服务端的配合。当我们正常地请求一个JSON数据的时候，服务端返回的是一串JSON类型的数据，而我们使用JSONP模式来请求数据的时候，服务端返回的是一段可执行的JavaScript代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JSONP包含两部分：回调函数和数据。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回调函数是当响应到来时要放在当前页面被调用的函数。&lt;/li&gt;
&lt;li&gt;数据就是传入回调函数中的json数据，也就是回调函数的参数了。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;function handleResponse(response){
 console.log(&#39;The responsed data is: &#39;+response.data);
}
var script = document.createElement(&#39;script&#39;);
script.src = &#39;http://www.baidu.com/json/?callback=handleResponse&#39;;
document.body.insertBefore(script, document.body.firstChild);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;/*handleResonse({&amp;quot;data&amp;quot;: &amp;quot;zhe&amp;quot;})*/
//原理如下：
//当我们通过script标签请求时
//后台就会根据相应的参数(json,handleResponse)
//来生成相应的json数据(handleResponse({&amp;quot;data&amp;quot;: &amp;quot;zhe&amp;quot;}))
//最后这个返回的json数据(代码)就会被放在当前js文件中被执行
//至此跨域通信完成
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只能使用Get请求&lt;/li&gt;
&lt;li&gt;不能注册success、error等事件监听函数，不能很容易的确定JSONP请求是否失败&lt;/li&gt;
&lt;li&gt;JSONP是从其他域中加载代码执行，容易受到跨站请求伪造的攻击，其安全性无法确保&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-使用windowname来进行跨域&#34;&gt;4. 使用window.name来进行跨域&lt;/h2&gt;
&lt;p&gt;window.name通过在iframe（一般动态创建i）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window.name。然后，请求者可以检索window.name值作为响应。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iframe标签的跨域能力；&lt;/li&gt;
&lt;li&gt;window.name属性值在文档刷新后依旧存在的能力（且最大允许2M左右）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://www.a.com/a.html和http://www.b.com/b.html
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;a.html&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
  var iframe = document.createElement(&#39;iframe&#39;);
  iframe.style.display = &#39;none&#39;; // 隐藏
 
  var state = 0; // 防止页面无限刷新
  iframe.onload = function() {
      if(state === 1) {
          console.log(JSON.parse(iframe.contentWindow.name));
          // 清除创建的iframe
          iframe.contentWindow.document.write(&#39;&#39;);
          iframe.contentWindow.close();
          document.body.removeChild(iframe);
      } else if(state === 0) {
          state = 1;
          // 加载完成，指向当前域，防止错误(proxy.html为空白页面)
          // Blocked a frame with origin &amp;quot;http://www.a.com/a.html&amp;quot; from accessing a cross-origin frame.
          iframe.contentWindow.location = &#39;http://www.a.com/a.html&#39;;
      }
  };
 
  iframe.src = &#39;http://www.b.com/b.html&#39;;
  document.body.appendChild(iframe);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;在b.com/b.html中包含：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
     window.name = &#39;要传送的内容&#39;;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-cors&#34;&gt;5. CORS&lt;/h2&gt;
&lt;p&gt;CORS是一个W3C标准，全称是&amp;quot;跨域资源共享&amp;quot;（Cross-origin resource sharing），以避开浏览器的同源策略，确保安全的跨域数据传输。现代浏览器使用CORS在API容器如XMLHttpRequest来减少HTTP请求的风险来源。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。&lt;/p&gt;
&lt;h3 id=&#34;1-服务器设置&#34;&gt;1. 服务器设置&lt;/h3&gt;
&lt;p&gt;服务器一般需要增加如下响应头的一种或几种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
Access-Control-Max-Age: 86400
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;跨域请求默认不会携带Cookie信息，如果需要携带，请配置下述参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;Access-Control-Allow-Credentials&amp;quot;: true
// Ajax设置打开
&amp;quot;withCredentials&amp;quot;: true
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-两种请求&#34;&gt;2. 两种请求&lt;/h3&gt;
&lt;p&gt;浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。&lt;br&gt;
&lt;strong&gt;只要同时满足以下两大条件，就属于简单请求。&lt;/strong&gt;&lt;br&gt;
（1) 请求方法是以下三种方法之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HEAD&lt;/li&gt;
&lt;li&gt;GET&lt;/li&gt;
&lt;li&gt;POST&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（2）HTTP的头信息不超出以下几种字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Accept&lt;/li&gt;
&lt;li&gt;Accept-Language&lt;/li&gt;
&lt;li&gt;Content-Language&lt;/li&gt;
&lt;li&gt;Last-Event-ID&lt;/li&gt;
&lt;li&gt;Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-简单请求&#34;&gt;3. 简单请求&lt;/h3&gt;
&lt;p&gt;对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，&lt;code&gt;增加一个Origin字段&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的头信息中，&lt;code&gt;Origin字段&lt;/code&gt;用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;Origin&lt;/code&gt;指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;字段（详见下文），就知道出错了，从而抛出一个错误，被&lt;code&gt;XMLHttpRequest&lt;/code&gt;的&lt;code&gt;onerror&lt;/code&gt;回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;Origin&lt;/code&gt;指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
Content-Type: text/html; charset=utf-8
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-非简单请求&#34;&gt;4. 非简单请求&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;预检请求&lt;/strong&gt;&lt;br&gt;
非简单请求是那种对服务器有特殊要求的请求，比如请求方法是&lt;code&gt;PUT&lt;/code&gt;或&lt;code&gt;DELETE&lt;/code&gt;，或者&lt;code&gt;Content-Type字段的类型是application/json&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&amp;quot;预检&amp;quot;请求（preflight）。&lt;/p&gt;
&lt;p&gt;浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的&lt;code&gt;XMLHttpRequest&lt;/code&gt;请求，否则就报错。&lt;/p&gt;
&lt;p&gt;下面是一段浏览器的JavaScript脚本。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var url = &#39;http://api.alice.com/cors&#39;;
var xhr = new XMLHttpRequest();
xhr.open(&#39;PUT&#39;, url, true);
xhr.setRequestHeader(&#39;X-Custom-Header&#39;, &#39;value&#39;);
xhr.send();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，HTTP请求的方法是&lt;code&gt;PUT&lt;/code&gt;，并且发送一个自定义头信息&lt;code&gt;X-Custom-Header&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;浏览器发现，这是一个非简单请求，就自动发出一个&amp;quot;预检&amp;quot;请求，要求服务器确认可以这样请求。下面是这个&amp;quot;预检&amp;quot;请求的HTTP头信息。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;quot;预检&amp;quot;请求用的请求方法是&lt;code&gt;OPTIONS&lt;/code&gt;，表示这个请求是用来询问的。头信息里面，关键字段是&lt;code&gt;Origin&lt;/code&gt;，表示请求来自哪个源。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;预检请求的回应&lt;/strong&gt;&lt;br&gt;
服务器收到&amp;quot;预检&amp;quot;请求以后，检查了&lt;code&gt;Origin&lt;/code&gt;、&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;和&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;字段以后，确认允许跨源请求，就可以做出回应。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的HTTP回应中，关键的是&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;字段，表示&lt;code&gt;http://api.bob.com&lt;/code&gt;可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。&lt;/p&gt;
&lt;p&gt;如果服务器否定了&amp;quot;预检&amp;quot;请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被&lt;code&gt;XMLHttpRequest&lt;/code&gt;对象的&lt;code&gt;onerror&lt;/code&gt;回调函数捕获。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;浏览器的正常请求和回应&lt;/strong&gt;&lt;br&gt;
一旦服务器通过了&amp;quot;预检&amp;quot;请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个&lt;code&gt;Origin&lt;/code&gt;头信息字段。服务器的回应，也都会有一个&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;头信息字段。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是&amp;quot;预检&amp;quot;请求之后，浏览器的正常CORS请求。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PUT /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
X-Custom-Header: value
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面是服务器正常的回应。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Access-Control-Allow-Origin: http://api.bob.com
Content-Type: text/html; charset=utf-8
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-反向代理&#34;&gt;3. 反向代理&lt;/h3&gt;
&lt;p&gt;想一下，如果我们请求的时候还是用前端的域名，然后有个东西帮我们把这个请求转发到真正的后端域名上，不就避免跨域了吗？这时候，Nginx出场了。&lt;/p&gt;
&lt;p&gt;Nginx配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server{
    # 监听9099端口
    listen 9099;
    # 域名是localhost
    server_name localhost;
    #凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:9871 
    location ^~ /api {
        proxy_pass http://localhost:9871;
    }    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前端就不用干什么事情了，除了写接口，也没后端什么事情了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 请求的时候直接用回前端这边的域名http://localhost:9099，这就不会跨域，然后Nginx监听到凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:9871 
fetch(&#39;http://localhost:9099/api/iframePost&#39;, {
  method: &#39;POST&#39;,
  headers: {
    &#39;Accept&#39;: &#39;application/json&#39;,
    &#39;Content-Type&#39;: &#39;application/json&#39;
  },
  body: JSON.stringify({
    msg: &#39;helloIframePost&#39;
  })
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-同源策略限制下dom查询的正确打开方式&#34;&gt;2. 同源策略限制下Dom查询的正确打开方式&lt;/h2&gt;
&lt;h3 id=&#34;1postmessage&#34;&gt;1.postMessage&lt;/h3&gt;
&lt;p&gt;window.postMessage() 是HTML5的一个接口，专注实现不同窗口不同页面的跨域通讯。&lt;/p&gt;
&lt;h3 id=&#34;2documentdomain&#34;&gt;2.document.domain&lt;/h3&gt;
&lt;p&gt;这种方式只适合主域名相同，但子域名不同的iframe跨域。&lt;br&gt;
比如主域名是http://crossdomain.com:9099，子域名是http://child.crossdomain.com:9099，这种情况下给两个页面指定一下document.domain即document.domain = crossdomain.com就可以访问各自的window对象了。&lt;/p&gt;
&lt;h3 id=&#34;3canvas操作图片的跨域问题&#34;&gt;3.canvas操作图片的跨域问题&lt;/h3&gt;
&lt;p&gt;这个应该是一个比较冷门的跨域问题&lt;/p&gt;
&lt;h1 id=&#34;6-从浏览器多进程到js单线程&#34;&gt;6. 从浏览器多进程到JS单线程&lt;/h1&gt;
&lt;h2 id=&#34;1-区分进程和线程&#34;&gt;1. 区分进程和线程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;进程是cpu资源分配的最小单位（系统会给它分配内存）&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;进程要分配一大部分的内存，而线程只需要分配一部分栈就可以了&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后，再用较为官方的术语描述一遍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）&lt;/li&gt;
&lt;li&gt;线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-进程与线程的关系&#34;&gt;2. 进程与线程的关系&lt;/h2&gt;
&lt;p&gt;做个简单的比喻：&lt;strong&gt;进程=火车，线程=车厢&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程在进程下行进（单纯的车厢无法运行）&lt;/li&gt;
&lt;li&gt;一个进程可以包含多个线程（一辆火车可以有多个车厢）&lt;/li&gt;
&lt;li&gt;不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）&lt;/li&gt;
&lt;li&gt;同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）&lt;/li&gt;
&lt;li&gt;进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）&lt;/li&gt;
&lt;li&gt;进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）&lt;/li&gt;
&lt;li&gt;进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）&lt;/li&gt;
&lt;li&gt;进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－&amp;quot;互斥锁&amp;quot;&lt;/li&gt;
&lt;li&gt;进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-深入理解&#34;&gt;3. 深入理解：&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1629348251806.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1-进程线程内存文件网络句柄&#34;&gt;1. 进程(线程+内存+文件/网络句柄)&lt;/h3&gt;
&lt;p&gt;我们通过上面的图片进行进一步理解：&lt;br&gt;
&lt;strong&gt;“内存”&lt;/strong&gt;：&lt;br&gt;
我们通常所理解的内存是我们所见到的(2G/4G/8G/16G)物理内存,它为什么会在进程之中呢？&lt;br&gt;
实际上，这里的内存是逻辑内存。指的是内存的寻址空间。每个进程的内存是相互独立的。&lt;br&gt;
否则的话会出现一个问题：我们把指针的值改一改就指向其他进程的内存了，通过这样我们岂不是就可以看到其他进程中&amp;quot;微信&amp;quot;或者是&amp;quot;网上银行&amp;quot;的信息，&lt;br&gt;
这样的话，那我们的微信聊天记录或者是银行账户的信息就都被别人找到了，这是一个很危险的信号！显然这样是不可能的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“文件/网络句柄”&lt;/strong&gt;：&lt;br&gt;
它们是所有的进程所共有的，例如打开同一个文件，去抢同一个网络的端口这样的操作是被允许的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“线程”&lt;/strong&gt;：&lt;br&gt;
接下来，我们就要介绍一下我们的“线程”有关知识&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1629348582423.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-线程栈pctls&#34;&gt;2. 线程(栈+PC+TLS)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;栈:&lt;/strong&gt;&lt;br&gt;
我们通常都是说调用堆栈，其实这里的堆是没有含义的，调用堆栈就是调用栈的意思。&lt;br&gt;
那么我们的栈里面有什么呢？&lt;br&gt;
我们从主线程的入口main函数，会不断的进行函数调用，&lt;br&gt;
每次调用的时候，会把所有的参数和返回地址压入到栈中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PC:&lt;/strong&gt;&lt;br&gt;
Program Counter 程序计数器，操作系统真正运行的是一个个的线程，&lt;br&gt;
而我们的进程只是它的一个容器。PC就是指向当前的指令，而这个指令是放在内存中。&lt;br&gt;
每个线程都有一串自己的指针，去指向自己当前所在内存的指针。&lt;br&gt;
计算机绝大部分是存储程序性的，说的就是我们的数据和程序是存储在同一片内存里的&lt;br&gt;
这个内存中既有我们的数据变量又有我们的程序。所以我们的PC指针就是指向我们的内存的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TLS:&lt;/strong&gt;&lt;br&gt;
全称：thread local storage&lt;br&gt;
之前我们看到每个进程都有自己独立的内存，这时候我们想，我们的线程有没有一块独立的内存呢?答案是有的，就是TLS。&lt;br&gt;
可以用来存储我们线程所独有的数据。&lt;br&gt;
可以看到：线程才是我们操作系统所真正去运行的，而进程呢，则是像容器一样他把需要的一些东西放在了一起，而把不需要的东西做了一层隔离，进行隔离开来。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1629349035110.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;4-浏览器是多进程的&#34;&gt;4. 浏览器是多进程的&lt;/h2&gt;
&lt;p&gt;先看下简化理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器是多进程的&lt;/li&gt;
&lt;li&gt;浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）&lt;/li&gt;
&lt;li&gt;简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于以上几点的验证，&lt;strong&gt;请再第一张图&lt;/strong&gt;：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616224931683.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
图中打开了&lt;code&gt;Chrome&lt;/code&gt;浏览器的多个标签页，然后可以在&lt;code&gt;Chrome&lt;/code&gt;的任务管理器中看到有多个进程（分别是每一个&lt;code&gt;Tab&lt;/code&gt;页面有一个独立的进程，以及一个主进程）。&lt;br&gt;
感兴趣的可以自行尝试下，如果再多打开一个Tab页，进程正常会+1以上&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了&lt;br&gt;
（所以每一个Tab标签对应一个进程并不一定是绝对的）&lt;/p&gt;
&lt;h3 id=&#34;1-浏览器都包含哪些进程&#34;&gt;1. 浏览器都包含哪些进程？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有&lt;br&gt;
负责浏览器界面显示，与用户交互。如前进，后退等&lt;br&gt;
负责各个页面的管理，创建和销毁其他进程&lt;br&gt;
将Renderer进程得到的内存中的Bitmap，绘制到用户界面上&lt;br&gt;
网络资源的管理，下载等&lt;/li&gt;
&lt;li&gt;第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建&lt;/li&gt;
&lt;li&gt;GPU进程：最多一个，用于3D绘制等&lt;/li&gt;
&lt;li&gt;浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为 &lt;strong&gt;页面渲染，脚本执行，事件处理&lt;/strong&gt;等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;强化记忆：&lt;code&gt;在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-浏览器多进程的优势&#34;&gt;2. 浏览器多进程的优势&lt;/h3&gt;
&lt;p&gt;相比于单进程浏览器，多进程有如下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免单个page crash影响整个浏览器&lt;/li&gt;
&lt;li&gt;避免第三方插件crash影响整个浏览器&lt;/li&gt;
&lt;li&gt;多进程充分利用多核优势&lt;/li&gt;
&lt;li&gt;方便使用沙盒模型隔离插件等进程，提高浏览器稳定性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单点理解：&lt;code&gt;如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-重点是浏览器内核渲染进程&#34;&gt;3. 重点是浏览器内核（渲染进程）&lt;/h3&gt;
&lt;p&gt;可以这样理解，页面的渲染，JS的执行，事件的循环，都在这个进程内进行。接下来重点分析这个进程&lt;br&gt;
请牢记，浏览器的渲染进程是&lt;strong&gt;多线程&lt;/strong&gt;的（这点如果不理解，请回头看进程和线程的区分）&lt;/p&gt;
&lt;p&gt;那么接下来看看它都包含了哪些线程（列举一些主要常驻线程）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;GUI渲染线程&lt;br&gt;
- 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。&lt;br&gt;
- 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行&lt;br&gt;
- 注意，&lt;strong&gt;GUI渲染线程与JS引擎线程是互斥的&lt;/strong&gt;，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中&lt;strong&gt;等到JS引擎空闲时&lt;/strong&gt;立即被执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JS引擎线程&lt;br&gt;
- 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）&lt;br&gt;
- JS引擎线程负责解析Javascript脚本，运行代码。&lt;br&gt;
- JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序&lt;br&gt;
- 同样注意，&lt;strong&gt;GUI渲染线程与JS引擎线程是互斥的&lt;/strong&gt;，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事件触发线程&lt;br&gt;
- 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）&lt;br&gt;
- 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程，如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中&lt;br&gt;
- 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理&lt;br&gt;
- 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定时触发器线程&lt;br&gt;
- 传说中的&lt;code&gt;setInterva&lt;/code&gt;l与&lt;code&gt;setTimeout&lt;/code&gt;所在线程&lt;br&gt;
- 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）&lt;br&gt;
- 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）&lt;br&gt;
- 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步http请求线程&lt;br&gt;
- 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求&lt;br&gt;
- 将检测到状态变更时，如果设置有回调函数，异步线程就&lt;strong&gt;产生状态变更事件&lt;/strong&gt;，将这个回调再放入事件队列中。再由JavaScript引擎执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;后续将提到的事件循环机制就是基于&lt;code&gt;事件触发线程&lt;/code&gt;的，所以如果仅仅是看某个碎片化知识，&lt;br&gt;
可能会有一种似懂非懂的感觉。要完成的梳理一遍才能快速沉淀，不易遗忘。放张图巩固下吧：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616225471604.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-browser进程和浏览器内核renderer进程的通信过程&#34;&gt;4. Browser进程和浏览器内核（Renderer进程）的通信过程&lt;/h3&gt;
&lt;p&gt;那么接下来，再谈谈浏览器的Browser进程（控制进程）是如何和内核通信的，这点也理解后，就可以将这部分的知识串联起来，从头到尾有一个完整的概念。&lt;/p&gt;
&lt;p&gt;如果自己打开任务管理器，然后打开一个浏览器，就可以看到：&lt;strong&gt;任务管理器中出现了两个进程&lt;/strong&gt;（一个是主控进程，一个则是打开Tab页的渲染进程），&lt;br&gt;
然后在这前提下，看下整个的过程：(简化了很多)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程&lt;/li&gt;
&lt;li&gt;Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染
&lt;ul&gt;
&lt;li&gt;渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染&lt;/li&gt;
&lt;li&gt;当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）&lt;/li&gt;
&lt;li&gt;最后Render进程将结果传递给Browser进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Browser进程接收到结果并将结果绘制出来&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里绘一张简单的图：（很简化）&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616226222410.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;看完这一整套流程，应该对浏览器的运作有了一定理解了，这样有了知识架构的基础后，后续就方便往上填充内容。&lt;br&gt;
这块再往深处讲的话就涉及到浏览器内核源码解析了，不属于本文范围。&lt;br&gt;
如果这一块要深挖，建议去读一些浏览器内核源码解析文章，或者可以先看看参考下来源中的第一篇文章，写的不错&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;5-梳理浏览器内核中线程之间的关系&#34;&gt;5. 梳理浏览器内核中线程之间的关系&lt;/h2&gt;
&lt;h3 id=&#34;1-gui渲染线程与js引擎线程互斥&#34;&gt;1. GUI渲染线程与JS引擎线程互斥&lt;/h3&gt;
&lt;p&gt;由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。&lt;/p&gt;
&lt;p&gt;因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。&lt;/p&gt;
&lt;h3 id=&#34;2-js阻塞页面加载&#34;&gt;2. JS阻塞页面加载&lt;/h3&gt;
&lt;p&gt;从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。&lt;/p&gt;
&lt;p&gt;譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。&lt;br&gt;
然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。&lt;/p&gt;
&lt;p&gt;所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。&lt;/p&gt;
&lt;h3 id=&#34;3-webworkerjs的多线程&#34;&gt;3. WebWorker，JS的多线程？&lt;/h3&gt;
&lt;p&gt;前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？&lt;br&gt;
所以，后来HTML5中支持了&lt;code&gt;Web Worker&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面&lt;br&gt;
一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件&lt;br&gt;
这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window&lt;br&gt;
因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样理解下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）&lt;/li&gt;
&lt;li&gt;JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，只待计算出结果后，将结果通信给主线程即可，perfect!&lt;/p&gt;
&lt;p&gt;而且注意下，&lt;strong&gt;JS引擎是单线程的&lt;/strong&gt;，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。&lt;/p&gt;
&lt;h3 id=&#34;4-webworker与sharedworker&#34;&gt;4. WebWorker与SharedWorker&lt;/h3&gt;
&lt;p&gt;既然都到了这里，就再提一下&lt;code&gt;SharedWorker&lt;/code&gt;（避免后续将这两个概念搞混）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享
&lt;ul&gt;
&lt;li&gt;所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用
&lt;ul&gt;
&lt;li&gt;所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看到这里，应该就很容易明白了，本质上就是进程和线程的区别。&lt;strong&gt;SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;6-简单梳理下浏览器渲染流程&#34;&gt;6. 简单梳理下浏览器渲染流程&lt;/h2&gt;
&lt;p&gt;为了简化理解，前期工作直接省略成：（要展开的或完全可以写另一篇超长文）&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;浏览器输入url，浏览器主进程接管，开一个下载线程，&lt;br&gt;
然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，&lt;br&gt;
随后将内容通过RendererHost接口转交给Renderer进程&lt;br&gt;
浏览器渲染流程开始&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;解析html建立dom树&lt;/li&gt;
&lt;li&gt;解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）&lt;/li&gt;
&lt;li&gt;布局render树（Layout/reflow），负责各元素尺寸、位置的计算&lt;/li&gt;
&lt;li&gt;绘制render树（paint），绘制页面像素信息&lt;/li&gt;
&lt;li&gt;浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所有详细步骤都已经略去，渲染完毕后就是&lt;code&gt;load&lt;/code&gt;事件了，之后就是自己的JS逻辑处理了&lt;/p&gt;
&lt;p&gt;既然略去了一些详细的步骤，那么就提一些可能需要注意的细节把。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616246903018.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-css加载是否会阻塞dom树渲染&#34;&gt;1. css加载是否会阻塞dom树渲染？&lt;/h3&gt;
&lt;p&gt;这里说的是头部引入css的情况&lt;/p&gt;
&lt;p&gt;首先，我们都知道：&lt;strong&gt;css是由单独的下载线程异步下载的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;然后再说下几个现象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;css加载不会阻塞DOM树解析（异步加载时DOM照常构建）&lt;/li&gt;
&lt;li&gt;但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这可能也是浏览器的一种优化机制。&lt;/p&gt;
&lt;h2 id=&#34;7-从event-loop谈js的运行机制&#34;&gt;7. 从Event Loop谈JS的运行机制&lt;/h2&gt;
&lt;p&gt;这里会用到上文中的几个概念：（如果不是很理解，可以回头温习）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JS引擎线程&lt;/li&gt;
&lt;li&gt;事件触发线程&lt;/li&gt;
&lt;li&gt;定时触发器线程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后再理解一个概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JS分为同步任务和异步任务&lt;/li&gt;
&lt;li&gt;同步任务都在主线程上执行，形成一个&lt;code&gt;执行栈&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;主线程之外，&lt;strong&gt;事件触发线程&lt;/strong&gt;管理着一个&lt;code&gt;任务队列&lt;/code&gt;，只要异步任务有了运行结果，就在&lt;code&gt;任务队列&lt;/code&gt;之中放置一个事件。&lt;/li&gt;
&lt;li&gt;一旦&lt;code&gt;执行栈&lt;/code&gt;中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取&lt;code&gt;任务队列&lt;/code&gt;，将可运行的异步任务添加到可执行栈中，开始执行。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616247319925.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
看到这里，应该就可以理解了：为什么有时候setTimeout推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其它代码，所以自然有误差。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-事件循环机制进一步补充&#34;&gt;1. 事件循环机制进一步补充&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1616247383302.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
上图大致描述就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主线程运行时会产生执行栈，&lt;br&gt;
栈中的代码调用某些api时，它们会在事件队列中添加各种事件（当满足触发条件后，如ajax请求完毕）&lt;/li&gt;
&lt;li&gt;而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调&lt;/li&gt;
&lt;li&gt;如此循环&lt;/li&gt;
&lt;li&gt;注意，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-单独说说定时器&#34;&gt;2. 单独说说定时器&lt;/h3&gt;
&lt;p&gt;上述事件循环机制的核心是：&lt;strong&gt;JS引擎线程和事件触发线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它是由&lt;strong&gt;定时器线程&lt;/strong&gt;控制（因为JS引擎自己都忙不过来，根本无暇分身）&lt;/p&gt;
&lt;p&gt;因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。&lt;/p&gt;
&lt;p&gt;当使用&lt;code&gt;setTimeout&lt;/code&gt;或&lt;code&gt;setInterval&lt;/code&gt;时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。&lt;br&gt;
譬如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setTimeout(function(){
    console.log(&#39;hello!&#39;);
}, 1000);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码的作用是当1000毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setTimeout(function(){
    console.log(&#39;hello!&#39;);
}, 0);

console.log(&#39;begin&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码的效果是最快的时间内将回调函数推入事件队列中，等待主线程执行&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行结果是：先begin后hello!&lt;/li&gt;
&lt;li&gt;虽然代码的本意是0毫秒后就推入事件队列，但是W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。&lt;br&gt;
(不过也有一说是不同浏览器有不同的最小时间设定)&lt;/li&gt;
&lt;li&gt;就算不等待4ms，就算假设0毫秒就推入事件队列，也会先执行begin（因为只有可执行栈内空了后才会主动读取事件队列）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-settimeout而不是setinterval&#34;&gt;3. setTimeout而不是setInterval&lt;/h3&gt;
&lt;p&gt;用setTimeout模拟定期计时和直接用setInterval是有区别的。&lt;/p&gt;
&lt;p&gt;因为每次&lt;code&gt;setTimeout&lt;/code&gt;计时到后就会去执行，然后执行一段时间后才会继续setTimeout，中间就多了误差（误差多少与代码执行时间有关）&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;setInterval&lt;/code&gt;则是每次都精确的隔一段时间推入一个事件（但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）&lt;/p&gt;
&lt;p&gt;而且setInterval有一些比较致命的问题就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;累计效应（上面提到的），如果setInterval代码在（setInterval）再次添加到队列之前还没有完成执行，就会导致定时器代码连续运行好几次，而之间没有间隔。就算正常间隔执行，多个setInterval的代码执行时间可能会比预期小（因为代码执行需要一定时间）&lt;/li&gt;
&lt;li&gt;而且把浏览器最小化显示等操作时，setInterval并不是不执行程序，它会把setInterval的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行时&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，鉴于这么多但问题，目前一般认为的最佳方案是：&lt;strong&gt;用setTimeout模拟setInterval，或者特殊场合直接用requestAnimationFrame&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补充：JS高程中有提到，JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加。不过，仍然是有很多问题。。。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;8-事件循环进阶macrotask与microtask&#34;&gt;8. 事件循环进阶：macrotask与microtask&lt;/h2&gt;
&lt;p&gt;上文中将JS事件循环机制梳理了一遍，在ES5的情况是够用了，但是在ES6盛行的现在，仍然会遇到一些问题，譬如下面这题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(&#39;script start&#39;);

setTimeout(function() {
    console.log(&#39;setTimeout&#39;);
}, 0);

Promise.resolve().then(function() {
    console.log(&#39;promise1&#39;);
}).then(function() {
    console.log(&#39;promise2&#39;);
});

console.log(&#39;script end&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;嗯哼，它的正确执行顺序是这样子的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;script start
script end
promise1
promise2
setTimeout
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为什么呢？因为Promise里有了一个一个新的概念：&lt;code&gt;microtask&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或者，进一步，JS中分为两种任务类型：&lt;code&gt;macrotask&lt;/code&gt;和&lt;code&gt;microtask&lt;/code&gt;，在ECMAScript中，microtask称为&lt;code&gt;jobs&lt;/code&gt;，macrotask可称为&lt;code&gt;task&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;它们的定义？区别？简单点可以按如下理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）
&lt;ul&gt;
&lt;li&gt;每一个task会从头到尾将这个任务执行完毕，不会执行其它&lt;/li&gt;
&lt;li&gt;浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;（`task-&amp;gt;渲染-&amp;gt;task-&amp;gt;...`）
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务
&lt;ul&gt;
&lt;li&gt;也就是说，在当前task任务后，下一个task之前，在&lt;code&gt;渲染之前&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;所以它的响应速度相比setTimeout（&lt;code&gt;setTimeout是task&lt;/code&gt;）会更快，因为无需等渲染&lt;/li&gt;
&lt;li&gt;也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分别很么样的场景会形成macrotask和microtask呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;macrotask：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask）&lt;/li&gt;
&lt;li&gt;microtask：Promise，process.nextTick等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再根据线程来理解下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;macrotask中的事件都是放在一个事件队列中的，而这个队列由&lt;strong&gt;事件触发线程&lt;/strong&gt;维护&lt;/li&gt;
&lt;li&gt;microtask中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前macrotask执行完毕后执行，而这个队列由&lt;strong&gt;JS引擎线程&lt;/strong&gt;维护&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，总结下运行机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行一个宏任务（栈中没有就从事件队列中获取）&lt;/li&gt;
&lt;li&gt;执行过程中如果遇到微任务，就将它添加到微任务的任务队列中&lt;/li&gt;
&lt;li&gt;宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）&lt;/li&gt;
&lt;li&gt;当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染&lt;/li&gt;
&lt;li&gt;渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1616250099288.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
另外，请注意下&lt;code&gt;Promise&lt;/code&gt;的&lt;code&gt;polyfill&lt;/code&gt;与官方版本的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Promise官方版本中，是标准的microtask形式&lt;/li&gt;
&lt;li&gt;polyfill，一般都是通过setTimeout模拟的，所以是macrotask形式&lt;/li&gt;
&lt;/ul&gt;
">【面】前端知识点梳理（浏览器）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/mian-qian-duan-zhi-shi-dian-shu-li-es6/"" data-c="
          &lt;h1 id=&#34;1-声明-let-const&#34;&gt;1. 声明 let、const&lt;/h1&gt;
&lt;h2 id=&#34;1-let声明变量的特点&#34;&gt;1. let声明变量的特点:&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;变量不能重复声明&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;每个循环每执行一次都有一个大括号{}，{}内的代码属于一个代码块，let声明的变量属于块级作用域，所以看上去能重复声明。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (let i = 0; i &amp;lt; 10; i++) {
        let s = &amp;quot;a&amp;quot;;
        console.log(s);    //这里会输出10个a
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;定义的变量可以被修改&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let c = 1;
c++;
console.log(c); //2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;定义的变量是块级作用域的变量&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;必须先声明后使用&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-const-声明常量的特点&#34;&gt;2. const 声明常量的特点：&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;常量不能重复声明，同let&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;常量不能被修改&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const p  = 1;
p=2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;上面的代码浏览器会报错&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;必须先声明后使用&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;2-解构赋值&#34;&gt;2. 解构赋值&lt;/h1&gt;
&lt;h2 id=&#34;1-解构赋值的定义&#34;&gt;1. 解构赋值的定义&lt;/h2&gt;
&lt;p&gt;ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构，本质是一种模式匹配。&lt;/p&gt;
&lt;h2 id=&#34;2-数组的解构赋值&#34;&gt;2. 数组的解构赋值&lt;/h2&gt;
&lt;p&gt;按照对应位置，对变量赋值，如果解构不成功，变量的值就等于undefined。&lt;br&gt;
同时解构赋值允许指定默认值。只有当一个数组成员严格等于undefined，默认值才会生效。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let [a, b, c] = [1, 2, 3];   //a=1,b=2,c=3
let [x, , y] = [1, 2, 3];    //x=1,y=3
let [foo] = [];              //foo=undefined
let [foo = 1] = [];      //foo=1
let [foo = 1] = [null];  //foo=null
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-对象的解构赋值&#34;&gt;3. 对象的解构赋值&lt;/h2&gt;
&lt;p&gt;对象的解构是按照属性来进行解构赋值的。如果解构不成功，变量的值就等于undefined。&lt;br&gt;
对象的解构也可以指定默认值。默认值生效的条件是，对象的属性值严格等于undefined。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let { a: foo, b: bar } = { a: &amp;quot;123&amp;quot;, b: &amp;quot;456&amp;quot; }    //foo=123  bar =456
let { a: a, b: b } = { a: &amp;quot;123&amp;quot;, b: &amp;quot;456&amp;quot; }       //a=123 b=456
let { a, b } = { a: &amp;quot;123&amp;quot;, b: &amp;quot;456&amp;quot; }      //a=123 b=456   
//第三种写法等于第二种，因为es6中可以在对象中直接写入变量
let { a, c } = { a: &amp;quot;123&amp;quot;, b: &amp;quot;456&amp;quot; }     //a=123  c=undefined
let { a, c = 3 } = { a: &amp;quot;123&amp;quot;, b: &amp;quot;456&amp;quot; }    //a=123  c=3
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-其他的解构赋值&#34;&gt;4. 其他的解构赋值&lt;/h2&gt;
&lt;p&gt;解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let  { toString: s } = 123      //s是对象的toString方法
let  { toString: s } = true;     //s是对象的toString方法
let { prop: x } = undefined;   //报错
let { prop: y } = null;      //  报错
const [a, b, c, d, e] = &amp;quot;hello&amp;quot;   // a=h b=e ...
const { 0: a, 1: b, 2: c, 3: d, 4: e } = &amp;quot;hello&amp;quot;    //a=h b=e ...
//字符串被转为类数组对象，故可以使用数组和对象解构赋值
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-解构赋值的用途&#34;&gt;5. 解构赋值的用途&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;交换变量的值&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt; let x = 1
 let y = 2
 [x, y] = [y, x]
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;方便取值&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;let obj = {
  a:1,
  b:2,
  c: function(){return 1}
}
 let {a,b} = obj  //代替以前  let a= obj.a, b=obj.b 的写法
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;输入模块的指定方法&lt;/li&gt;
&lt;li&gt;遍历 Map 结构&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;3-声明类与继承class-extend&#34;&gt;3. 声明类与继承：class、extend&lt;/h1&gt;
&lt;h2 id=&#34;1-类class&#34;&gt;1. 类（Class）&lt;/h2&gt;
&lt;p&gt;基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//定义类
class Point {
  constructor(x, y) {  //constructor 构造方法
    this.x = x;
    this.y = y;
  }
  toString() {
    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
  }
}
var p = new Point(1, 2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都还是定义在类的prototype属性上面。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constructor方法&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。&lt;/p&gt;
&lt;h2 id=&#34;2-继承extends&#34;&gt;2. 继承（Extends）&lt;/h2&gt;
&lt;p&gt;Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ColorPoint extends Point {
  constructor(x, y, color) {
    super(x, y); // 调用父类的constructor(x, y)
    this.color = color;
  }
  toString() {
    return this.color + &#39; &#39; + super.toString(); // 调用父类的toString()
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。&lt;/p&gt;
&lt;p&gt;子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。&lt;/p&gt;
&lt;h2 id=&#34;3-原生构造函数继承&#34;&gt;3. 原生构造函数继承&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boolean()&lt;/li&gt;
&lt;li&gt;Number()&lt;/li&gt;
&lt;li&gt;String()&lt;/li&gt;
&lt;li&gt;Array()&lt;/li&gt;
&lt;li&gt;Date()&lt;/li&gt;
&lt;li&gt;Function()&lt;/li&gt;
&lt;li&gt;RegExp()&lt;/li&gt;
&lt;li&gt;Error()&lt;/li&gt;
&lt;li&gt;Object()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这意味着，ES6可以自定义原生数据结构（比如Array、String等）的子类，这是ES5无法做到的。&lt;/p&gt;
&lt;h2 id=&#34;4-class的generator方法&#34;&gt;4. Class的Generator方法&lt;/h2&gt;
&lt;p&gt;如果某个方法之前加上星号（*），就表示该方法是一个Generator函数。&lt;/p&gt;
&lt;h2 id=&#34;5-class的静态方法&#34;&gt;5. Class的静态方法&lt;/h2&gt;
&lt;p&gt;类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Foo {
  static classMethod() {
    return &#39;hello&#39;;
  }
}
Foo.classMethod() // &#39;hello&#39;
var foo = new Foo();
foo.classMethod()
// TypeError: foo.classMethod is not a function
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。&lt;/p&gt;
&lt;h1 id=&#34;4-promise的使用与实现&#34;&gt;4. Promise的使用与实现&lt;/h1&gt;
&lt;p&gt;Promise 是 ES6 新增的语法，解决了回调地狱的问题。&lt;/p&gt;
&lt;h2 id=&#34;1-什么是promise&#34;&gt;1. 什么是Promise？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理，让开发者不用再关注于时序和底层的结果。Promise的状态具有不受外界影响和不可逆两个特点。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;特点：&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;对象的状态不受外界影响&lt;/code&gt;。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（以失败）。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;一旦状态改变，就不会再变&lt;/code&gt;，任何时候都是可以得到这个结果的。Promise对象的状态改变只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就会凝固，不会再变了。再对Promise对象添加回调函数也会立即得到这个结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;缺点：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;首先无法取消Promise，一旦新建他就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部跑出的错误无法反应到外部。当pending的时候，无法知道进展到了哪一步。&lt;/p&gt;
&lt;h2 id=&#34;2-promise-解决的痛点是什么&#34;&gt;2. Promise 解决的痛点是什么？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;回调地狱，代码难以维护&lt;/li&gt;
&lt;li&gt;promise可以支持多个并发的请求，获取并发请求中的数据&lt;/li&gt;
&lt;li&gt;promise可以解决可读性的问题，异步的嵌套带来的可读性的问题&lt;/li&gt;
&lt;li&gt;promise可以解决信任问题，对于回调过早、回调过晚或没有调用和回调次数太少或太多，由于promise只能决议一次，决议值只能有一个，决议之后无法改变，任何then中的回调也只会被调用一次，所以这就保证了Promise可以解决信任问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-promise-如何使用&#34;&gt;3. Promise 如何使用？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;创造一个Promise实例&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可用Promise的try和catch方法预防异常&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-promise中的异步模式有哪些有什么区别&#34;&gt;4. Promise中的异步模式有哪些？有什么区别？&lt;/h2&gt;
&lt;p&gt;回到问题本身，&lt;code&gt;Promise.all()&lt;/code&gt;和&lt;code&gt;Promise.race()&lt;/code&gt;的区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;all&lt;/code&gt;（&lt;code&gt;并行执行&lt;/code&gt;）会将传入的数组中的所有promise全部决议以后，将决议值以数组的形式传入到观察回调中，任何一个promise决议为拒绝，那么就会调用拒绝回调。&lt;strong&gt;Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;race&lt;/code&gt;会将传入的数组中的所有promise中第一个决议的决议值传递给观察回调，即使决议结果是拒绝。(超时取消)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果向Promise.all()和Promise.race()传递空数组，运行结果会有什么不同？&lt;br&gt;
all会立即决议，决议结果是fullfilled，值是undefined&lt;br&gt;
race会永远都不决议，程序卡死&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;5-promise-常用的方法有哪些&#34;&gt;5. Promise 常用的方法有哪些？&lt;/h2&gt;
&lt;h3 id=&#34;1-promiseresolve的用法&#34;&gt;1. Promise.resolve的用法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;当我们在执行函数中调用resolve方法时，Promise的状态就变成fulfilled，即操作成功状态&lt;/code&gt;，还记得上面Promise.prototype上面的then和catch方法吗？当Promise状态为fullfilled状态时执行then方法里的操作，注意了，&lt;code&gt;then方法里面有两个参数&lt;/code&gt;onfulfilled(Promise为fulfilled状态时执行) 和onrejected（Promise为rejected状态时执行），步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;实例化Promise（new Promise（function（resolve,reject）））&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;用Promise的实例调用then方法&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体来看下面的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var p = new Promise(function (resolve, reject) {
            var timer = setTimeout(function () {
                console.log(&#39;执行操作1&#39;);
                resolve(&#39;这是数据1&#39;);
            }, 1000);
        });
        p.then(function (data) {
            console.log(data);
            console.log(&#39;这是成功操作&#39;);
        });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简单的理解就是&lt;code&gt;调用resolve方法，Promise变为操作成功状态（fulfilled）&lt;/code&gt;，执行then方法里面onfulfilled里的操作。其实then里面的函数就是我们平时所说的回调函数，只不过在这里只是把它分离出来而已。我们可以看到控制台上的输出结果如下所示：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616496390953.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-promisereject的用法&#34;&gt;2. Promise.reject的用法&lt;/h3&gt;
&lt;p&gt;调用reject方法后，Promise状态变为rejected，即操作失败状态，此时执行then方法里面onrejected操作，&lt;code&gt;上面我们提到了then方法有两个参数&lt;/code&gt;，一种是Promise状态为fulfilled时执行（onfullfilled），一种是Promise状态为rejected时执行（onrejected）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var p = new Promise(function (resolve, reject) {
          var flag = false;
          if(flag){
            resolve(&#39;这是数据2&#39;);
          }else{
            reject(&#39;这是数据2&#39;);
          }
        });
        p.then(function(data){//状态为fulfilled时执行
            console.log(data);
            console.log(&#39;这是成功操作&#39;);
        },function(reason){ //状态为rejected时执行
            console.log(reason);
            console.log(&#39;这是失败的操作&#39;);
        });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以看到输出结果：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616496519288.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-promiseprototypethen方法&#34;&gt;3. Promise.prototype.then()方法&lt;/h3&gt;
&lt;p&gt;Promise实例具有then方法，也就是说then方法时定义在原型对象上的。&lt;br&gt;
它的作用是为&lt;code&gt;Promise实例添加状态改变时的回调函数&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;链式写法的本质&lt;/code&gt;其实是一直&lt;code&gt;往下传递返回一个新的Promise&lt;/code&gt;，也就是说&lt;code&gt;then在下一步接收的是上一步返回的Promise&lt;/code&gt;!!!&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）因此可以采用链式写法，即then方法后面再调用另一个then方法。&lt;/li&gt;
&lt;li&gt;采用链式的then可以指定一组按照次序调用的回调函数。这时，前一个回调函数可能返回一个还是Promise对象（即有异步操作），这时候一个回调函数就会等该Promise对象的状态发生变化，才会被调用&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;getJSON(&#39;/post/1.json&#39;).then(function(post) {
    return getJSON(post.commentURL)
}).then(function funcA() {
    console.log(&amp;quot;resolved:&amp;quot;, comments)
}, function funcB(err) {
    console.log(&amp;quot;rejected:&amp;quot;, err)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一个then方法指定的回调函数，返回的是一个Promise对象。这时，第二个方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用funcA, 如果状态变为rejected，就调用funcB.&lt;/p&gt;
&lt;h3 id=&#34;4-promiseprototypecatch方法&#34;&gt;4. Promise.prototype.catch()方法&lt;/h3&gt;
&lt;p&gt;Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;getJSON(&#39;/post/1.json&#39;).then(function(posts) {
    //...
}).catch(function() {
    console.log(&#39;发生错误&#39;, error)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，getJSON方法返回一个Promise对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数。另外，then方法指定的回调函数，如果运行抛出错误，也会被catch方法捕获。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619485896060.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Promise对象的错误具有冒泡性质，会一直向后传递，直到被捕获为止，也就是说错误总会被下一个catch语句捕获。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;6-promise-在事件循环中的执行过程是怎样的&#34;&gt;6. Promise 在事件循环中的执行过程是怎样的？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1）事件循环&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从代码执行顺序的角度来看，程序最开始是按代码顺序执行代码的，遇到同步任务，立刻执行；遇到异步任务，则只是调用异步函数发起异步请求。此时，异步任务开始执行异步操作，执行完成后到消息队列中排队。程序按照代码顺序执行完毕后，查询消息队列中是否有等待的消息。如果有，则按照次序从消息队列中把消息放到执行栈中执行。执行完毕后，再从消息队列中获取消息，再执行，不断重复。由于主线程不断的重复获得消息、执行消息、再取消息、再执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2）promise的事件循环&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Promise在初始化时，传入的函数是同步执行的，然后注册 then 回调。注册完之后，继续往下执行同步代码，在这之前，then 中回调不会执行。同步代码块执行完毕后，才会在事件循环中检测是否有可用的 promise 回调，如果有，那么执行，如果没有，继续下一个事件循环&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;7-promise的问题解决办法&#34;&gt;7. Promise的问题？解决办法？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;promise的问题为：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;promise一旦执行，无法中途取消(停止)&lt;/li&gt;
&lt;li&gt;promise的错误无法在外部被捕捉到，只能在内部进行预判处理&lt;/li&gt;
&lt;li&gt;promise的内如何执行，监测起来很难&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;停止可以通过返回新的promise进入pending状态，但是可能导致&lt;strong&gt;内存泄漏&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;正是因为这些原因，ES7引入了更加灵活多变的async，await来处理异步&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;8-手写promise与ajax的结合&#34;&gt;8. 手写Promise与ajax的结合？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;实例代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function promiseGet (url) {
  return new Promise((resolve, reject) =&amp;gt; {
    let xhr = new XMLHttpRequest()
    xhr.open(&#39;GET&#39;, url, true)
    xhr.onreadystatechange = function () {
      if (this.readyState === 4) {
        if (this.status === 200) {
          resolve(this.responseText,this)
        } else {
          let resJson = {
            code: this.status,
            response: this.response
          }
          reject(resJson, this)
        }
      }
    }
  })
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5-generator异步编程-yield-next&#34;&gt;5. Generator（异步编程、yield、next()）&lt;/h1&gt;
&lt;h2 id=&#34;1-generator&#34;&gt;1. Generator&lt;/h2&gt;
&lt;p&gt;Generator是一个函数，可以在函数内部通过&lt;code&gt;yield&lt;/code&gt;返回一个值（此时，Generator函数的执行会暂定，直到下次触发&lt;code&gt;.next()&lt;/code&gt;）&lt;br&gt;
创建一个&lt;code&gt;Generator函数&lt;/code&gt;的方法是在&lt;code&gt;function&lt;/code&gt;关键字后添加&lt;code&gt;*&lt;/code&gt;标识。&lt;/p&gt;
&lt;p&gt;在调用一个Generator函数后，并不会立即执行其中的代码，函数会返回一个&lt;code&gt;Generator&lt;/code&gt;对象，通过调用对象的&lt;code&gt;next&lt;/code&gt;函数，可以获得&lt;code&gt;yield/return&lt;/code&gt;的返回值。&lt;br&gt;
无论是触发了&lt;code&gt;yield&lt;/code&gt;还是&lt;code&gt;return&lt;/code&gt;，&lt;code&gt;next()&lt;/code&gt;函数总会返回一个带有&lt;code&gt;value&lt;/code&gt;和&lt;code&gt;done&lt;/code&gt;属性的对象。&lt;br&gt;
&lt;code&gt;value&lt;/code&gt;为返回值，&lt;code&gt;done&lt;/code&gt;则是一个Boolean对象，用来标识Generator是否还能继续提供返回值。&lt;br&gt;
P.S. Generator函数的执行时惰性的，yield后的代码只在&lt;code&gt;触发next&lt;/code&gt;时才会执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function * oddGenerator () {
  yield 1
  yield 3

  return 5
}

let iterator = oddGenerator()

let first = iterator.next()  // { value: 1, done: false }
let second = iterator.next() // { value: 3, done: false }
let third = iterator.next()  // { value: 5, done: true  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-next的参数传递&#34;&gt;2. next的参数传递&lt;/h2&gt;
&lt;p&gt;我们可以在调用&lt;code&gt;next()&lt;/code&gt;的时候传递一个参数，可以在上次&lt;code&gt;yield&lt;/code&gt;前接收到这个参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function * outputGenerator () {
  let ret1 = yield 1
  console.log(`got ret1: ${ret1}`)
  let ret2 = yield 2
  console.log(`got ret2: ${ret2}`)
}

let iterator = outputGenerator()

iterator.next(1)
iterator.next(2) // got ret1: 2
iterator.next(3) // got ret2: 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一眼看上去可能会有些诡异，为什么第一条&lt;code&gt;log&lt;/code&gt;是在第二次调用&lt;code&gt;next&lt;/code&gt;时才进行输出的&lt;br&gt;
这就又要说到上边的&lt;code&gt;Generator&lt;/code&gt;的实现了，上边说到了，&lt;code&gt;yield&lt;/code&gt;与&lt;code&gt;return&lt;/code&gt;都是用来返回值的语法。 函数在执行时遇到这两个关键字后就会暂停执行，等待下次激活。&lt;br&gt;
然后&lt;code&gt;let ret1 = yield 1&lt;/code&gt;，这是一个赋值表达式，也就是说会先执行&lt;code&gt;=右边&lt;/code&gt;的部分，在=右边执行的过程中遇到了yield关键字，函数也就在此处&lt;code&gt;暂停&lt;/code&gt;了，在下次触发&lt;code&gt;next()&lt;/code&gt;时才被激活，此时，我们继续进行上次未完成的赋值语句&lt;code&gt;let ret1 = XXX&lt;/code&gt;，并在再次遇到yield时&lt;code&gt;暂停&lt;/code&gt;。&lt;br&gt;
这也就解释了为什么&lt;strong&gt;第二次调用next()的参数会被第一次yield赋值的变量接收到&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-用作迭代器使用for-of&#34;&gt;3. 用作迭代器使用(for of)&lt;/h2&gt;
&lt;p&gt;但是要注意的是，用作迭代器中的使用，则只会作用于yield&lt;br&gt;
return的返回值不计入迭代&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function * oddGenerator () {
  yield 1
  yield 3
  yield 5

  return &#39;won\&#39;t be iterate&#39;
}

for (let value of oddGenerator()) {
  console.log(value)
}
//  1
//  3
//  5
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-generator函数内部的generator&#34;&gt;4. Generator函数内部的Generator&lt;/h2&gt;
&lt;p&gt;除了&lt;code&gt;yield&lt;/code&gt;语法以外，其实还有一个&lt;code&gt;yield*&lt;/code&gt;语法，可以粗略的理解为是&lt;code&gt;Generator&lt;/code&gt;函数版的&lt;code&gt;[...]&lt;/code&gt;&lt;br&gt;
用来展开Generator迭代器的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function * gen1 () {
  yield 1
  yield* gen2()
  yield 5
}

function * gen2 () {
  yield 2
  yield 3
  yield 4
  return &#39;won\&#39;t be iterate&#39;
}

for (let value of gen1()) {
  console.log(value)
}
//  1
//  2
//  3
//  4
//  5
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;6-async和await&#34;&gt;6. async和await&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;async函数是Generator函数的语法糖，将Generator的&lt;code&gt;星号&lt;/code&gt;换成&lt;code&gt;async&lt;/code&gt;将&lt;code&gt;yield&lt;/code&gt;换成&lt;code&gt;await&lt;/code&gt;，async函数比Generator函数更好用。&lt;code&gt;async&lt;/code&gt; 表示函数里有异步操作，&lt;code&gt;await&lt;/code&gt; 表示紧跟在后面的表达式需要等待结果。&lt;/li&gt;
&lt;li&gt;async必须&lt;strong&gt;声明的是一个function&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;await 只能出现在 async 函数中&lt;/li&gt;
&lt;li&gt;async 函数返回的&lt;strong&gt;是一个 Promise 对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。&lt;br&gt;
如果它等到的是一个 Promise 对象，await 就会阻塞后面的代码，等着 Promise 对象 resolve或者reject方法，然后得到 resolve的值，作为 await 表达式的运算结果。&lt;/li&gt;
&lt;li&gt;一般await都会用try/catch包起来&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-作用&#34;&gt;1. 作用&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt;和&lt;code&gt;await&lt;/code&gt;是用来处理异步的。即你需要异步像同步一样执行，需要异步返回结果之后，再往下依据结果继续执行。&lt;br&gt;
&lt;code&gt;async&lt;/code&gt; 是“异步”的简写，而 &lt;code&gt;await&lt;/code&gt; 可以认为是 &lt;code&gt;async wait&lt;/code&gt; 的简写。&lt;br&gt;
&lt;code&gt;async&lt;/code&gt; 用于申明一个 &lt;code&gt;function&lt;/code&gt; 是异步的，而 &lt;code&gt;await&lt;/code&gt; 用于等待一个异步方法执行完成。&lt;/p&gt;
&lt;h2 id=&#34;2-async&#34;&gt;2. async&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;async function testAsync() {
    return &amp;quot;hello async&amp;quot;;
}

const result = testAsync();
console.log(result);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打印输出的是一个&lt;code&gt;Promise&lt;/code&gt; 对象，&lt;code&gt;async&lt;/code&gt; 函数会返回一个 &lt;code&gt;Promise&lt;/code&gt; 对象。&lt;br&gt;
在最外层不能用 &lt;code&gt;await&lt;/code&gt; 获取其返回值的情况下，使用 &lt;code&gt;then()&lt;/code&gt; 链来处理这个 &lt;code&gt;Promise&lt;/code&gt; 对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;testAsync().then(v =&amp;gt; {
    console.log(v);    // 输出 hello async
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当 &lt;code&gt;async&lt;/code&gt; 函数没有返回值时，返回 &lt;code&gt;Promise.resolve(undefined)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-awit&#34;&gt;3. awit&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;await&lt;/code&gt;只能放在&lt;code&gt;async&lt;/code&gt;函数内部使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;await&lt;/code&gt; 用于一个异步操作之前，表示要“等待”这个异步操作的返回值。&lt;br&gt;
&lt;code&gt;await&lt;/code&gt; 也可以用于一个同步的值。&lt;/p&gt;
&lt;p&gt;如果它等到的不是一个 &lt;code&gt;Promise&lt;/code&gt; 对象，那 &lt;code&gt;await&lt;/code&gt; 表达式的运算结果就是它等到的东西。&lt;br&gt;
如果它等到的是一个 &lt;code&gt;Promise&lt;/code&gt; 对象，&lt;code&gt;await&lt;/code&gt; 就会阻塞后面的代码，等着 &lt;code&gt;Promise&lt;/code&gt; 对象 &lt;code&gt;resolve&lt;/code&gt;，然后得到 &lt;code&gt;resolve&lt;/code&gt; 的值，作为 &lt;code&gt;await&lt;/code&gt; 表达式的运算结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 2s 之后返回双倍的值
function doubleAfter2seconds(num) {
    return new Promise((resolve, reject) =&amp;gt; {
        setTimeout(() =&amp;gt; {
            resolve(2 * num)
        }, 2000);
    })
}

async function testResult () {
    let result = await doubleAfter2seconds(30);
    console.log(result);
}

testResult();
// 2s 之后，输出了60. 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-执行顺序&#34;&gt;4. 执行顺序&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 2s 之后返回双倍的值
function doubleAfter2seconds(num) {
    return new Promise((resolve, reject) =&amp;gt; {
        setTimeout(() =&amp;gt; {
            resolve(2 * num)
        }, 2000);
    })
}

async function testResult () {
    console.log(&#39;内部调用前&#39;) // 2
    let result = await doubleAfter2seconds(30);
    console.log(result); // 4
    console.log(&#39;内部调用后&#39;) // 5
}

console.log(&#39;外部调用前&#39;) // 1
testResult();
console.log(&#39;外部调用后&#39;) // 3
// --- 依次输出
// 外部调用前
// 内部调用前
// 外部调用后
// --- 2s 之后输出
// 60
// 内部调用后
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析一下上面的执行顺序：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先打印输出&lt;code&gt;外部调用前&lt;/code&gt;，同步代码，顺序执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后调用方法&lt;code&gt;testResult()&lt;/code&gt;，打印输出&lt;code&gt;内部调用前&lt;/code&gt;，同步代码，顺序执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再执行异步方法&lt;code&gt;doubleAfter2seconds&lt;/code&gt;，&lt;br&gt;
　1&amp;gt;如果没用&lt;code&gt;await&lt;/code&gt;关键字，此后的执行顺序应该是&lt;br&gt;
　　&lt;code&gt;内部调用后，外部调用后，2s 之后输出60&lt;/code&gt;&lt;br&gt;
　　因为异步方法不阻塞其他代码的执行，最后再输出&lt;code&gt;60&lt;/code&gt;&lt;br&gt;
　2&amp;gt;这里使用了&lt;code&gt;await&lt;/code&gt;关键字，所以到这里后会等待异步返回结果，再往下执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当&lt;code&gt;testResult&lt;/code&gt;函数内部&lt;code&gt;await&lt;/code&gt;阻塞执行后，不会影响到&lt;code&gt;testResult&lt;/code&gt;函数外面&lt;/p&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt; &lt;strong&gt;函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，在调用&lt;code&gt;testResult&lt;/code&gt;函数后，会继续向下执行，打印输出外部调用后&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当2s之后，异步函数&lt;code&gt;doubleAfter2seconds&lt;/code&gt;执行完成，返回结果，&lt;br&gt;
打印输出&lt;code&gt;60&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为&lt;code&gt;await&lt;/code&gt;将异步变成同步，所以在输出&lt;code&gt;60&lt;/code&gt;后，同步执行，再输出&lt;code&gt;内部调用后&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-错误处理&#34;&gt;5. 错误处理&lt;/h2&gt;
&lt;p&gt;因为async函数返回的是一个Promise，所以我们可以在外面catch住错误。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 2s 之后返回双倍的值
function doubleAfter2seconds(num) {
    return new Promise((resolve, reject) =&amp;gt; {
        setTimeout(() =&amp;gt; {
            resolve(2 * num)
        }, 2000);
    })
}

async function testResult () {
    let first = await doubleAfter2seconds(10);
    let second = await doubleAfter2seconds(20);    
    let res = first + second;
    return res;
}

testResult().then(res =&amp;gt; {
    console.log(res);      
}).catch(error =&amp;gt; {
    console.log(error);     
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;连写&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const [err, data] = await fetchData().then(data =&amp;gt; [null, data] ).catch(err =&amp;gt; [err, null])
 console.log(&#39;err&#39;, err)
 console.log(&#39;data&#39;, data)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-asyncawait的中断&#34;&gt;6. async/await的中断&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1619487936845.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
实质就是直接&lt;code&gt;return&lt;/code&gt;返回了一个&lt;code&gt;Promise&lt;/code&gt;，相当于&lt;code&gt;return Promise.resolve(&#39;我退出了下面不进行了&#39;)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;7-asyncawait循环获取数据串行之for循环&#34;&gt;7. async/await循环获取数据(串行)之for循环&lt;/h2&gt;
&lt;p&gt;现在就来介绍一下牛逼的async/await实战，上述的代码你是不是要看吐了，的确，我也觉得好麻烦啊，那么如果用&lt;code&gt;async/await&lt;/code&gt;能有什么改进吗？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(async ()=&amp;gt;{
    arr = [timeout(2000), timeout(1000), timeout(1000)]
    for (var i=0; i &amp;lt; arr.length; i++) {
        result = await arr[i]();
        console.log(result);
    }
})()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8在接口中使用axios&#34;&gt;8.在接口中使用(axios)&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;created () {
    this.init()
},
methods: {
    async init () {
      try {
          let first = await this.getOne();
          let second = await this.getTwo();    
          let res = first + second;
          console.log(res);
      } catch (error) {
          console.log(error);
      }        
    },
    getOne () {
        const params = {name: &#39;one&#39;}
        return new Promise((resolve, reject) =&amp;gt; {
            axios.get(&#39;/one&#39;, { params}).then((res) =&amp;gt; {
                if (res.status === 200) {
                    resolve(res)
                }
            }).catch((err) =&amp;gt; {
                reject(err)
            })
        })
    },
    getTwo () {
        const params = {name: &#39;two&#39;}
        return new Promise((resolve, reject) =&amp;gt; {
            axios.get(&#39;/two&#39;, { params}).then((res) =&amp;gt; {
                if (res.status === 200) {
                    resolve(res)
                }
            }).catch((err) =&amp;gt; {
                reject(err)
            })
        })
    },
},
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;7-箭头函数this指向问题-拓展运算符&#34;&gt;7. 箭头函数this指向问题、拓展运算符&lt;/h1&gt;
&lt;h2 id=&#34;1-箭头函数this指向&#34;&gt;1. 箭头函数this指向&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;箭头函数中的this指向的是定义时的this，而不是执行时的this。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//定义一个对象
    var obj = {
        x:100,//属性x
        show(){
            //延迟500毫秒，输出x的值
            setTimeout(
               //不同处：箭头函数
               () =&amp;gt; { console.log(this.x)},
               500
            );
        }
    };
    obj.show();//打印结果：100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当定义obj的show( )方法的时候，我们在箭头函数编写this.x，此时的this是指的obj，所以this.x指的是obj.x。而在show()被调用的时候，this依然指向的是被定义时候所指向的对象，也就是obj对象，故打印出：100。&lt;/p&gt;
&lt;h2 id=&#34;2-拓展运算符&#34;&gt;2. 拓展运算符&lt;/h2&gt;
&lt;p&gt;拓展运算符允许一个可迭代的对象（数组、类数组对象、字符串、ES6中的Set、Map等拥有默认迭代器Symbol(Symbol.iterator)属性，可以被for...of遍历的对象）去拓展函数调用的参数、数组的元素，同时也允许以Object键值对的形式去拓展另一个对象&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;化参数为数组&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;var showLambdaArgs = (...foo)=&amp;gt;{
  return foo
}
showLambdaArgs(1,2,3,4,5,6)//[1,2,3,4,5,6]

//在普通函数中也能使用，注意与arguments的区别
function showArgs(...foo){
    console.log(arguments instanceof Array)// false
    console.log(foo instanceof Array)// true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;code&gt;化数组为参数&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;function introduce(){
   console.log(arguments)//对象
   console.log(arguments.length)//参数个数
}
introduce(1,2,3,...[8,9,0])// arguments对象 和 6
introduce(4,5,...&amp;quot;abcde&amp;quot;)// arguments对象 和 7
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;code&gt;化可迭代对象为数组&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;//解构赋值也可以这么用
var [a,b,c] = [...&#39;123&#39;]//a = 1;b = 2;c = 3
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;//一行去重数组ver2:
[...new Set([1,1,2,3,3,4,4,4])] //1 , 2 , 3 ,4
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;//倒序参数
function reverseArgs(){
  return [...arguments].reverse()//现在可以调用数组方法了
}
reverseArgs(1,2,3,4,5)//[5, 4, 3, 2, 1]
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;code&gt;扩展对象&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对象的拷贝方法五花八门，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有JSON.parse(JSON.stringify(obj))的&lt;/li&gt;
&lt;li&gt;有for(var i in obj){}赋值的&lt;/li&gt;
&lt;li&gt;使用ES6的Object.assign()可能是大多数使用ES6开发者的选择：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;var o = {a:1,b:2}
var p = Object.assign({},o)
console.log(o === p) //false
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;code&gt;可变传参&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;es5中参数不确定个数的情况下&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//求参数和
function f(){
  var a = Array.prototype.slice.call(arguments);
  var sum = 0;
  a.forEach(function(item){
     sum += item*1;          
  })     
  return sum;  
};
f(1,2,3);//6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;es6中可变参数&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function f(...a){
  let sum = 0;
  a.forEach(item =&amp;gt;{
     sum += item*1;
  })    
  return sum;  
}
f(1,2,3);//6
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;8-map和set数组去重map数据结构有什么优点&#34;&gt;8. map和set数组去重，map数据结构有什么优点？&lt;/h1&gt;
&lt;h2 id=&#34;1-set数组去重&#34;&gt;1. set数组去重&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;et arr = [1, 2, 2, 3, 4]
function unique (arr) {
    return [...new Set(arr)]
}
console.log(unique(arr)) // [1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-map数组去重&#34;&gt;2. map数组去重&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;function unique(arr) {
    const res = new Map()
    return arr.filter( item =&amp;gt; !res.has(JSON.stringify(item)) &amp;amp;&amp;amp; res.set(JSON.stringify(item), 1))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-map数据结构优点&#34;&gt;3. map数据结构优点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。&lt;/li&gt;
&lt;li&gt;任何具有 Iterator接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数。&lt;/li&gt;
&lt;li&gt;Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-set数据结构优点&#34;&gt;4. set数据结构优点&lt;/h2&gt;
&lt;p&gt;Set对象允许你存储任何类型的值，无论是原始值或者是对象引用。它类似于数组，但是成员的值都是唯一的，没有重复的值。&lt;br&gt;
Set 本身是一个构造函数，用来生成Set 数据结构。Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。&lt;/p&gt;
&lt;p&gt;Set 对象存储的值总是&lt;code&gt;唯一&lt;/code&gt;的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;+0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复&lt;/li&gt;
&lt;li&gt;undefined 与 undefined 是恒等的，所以不重复&lt;/li&gt;
&lt;li&gt;NaN 与 NaN 是不恒等的，但是在 Set 中认为NaN与NaN相等，所有只能存在一个，不重复。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-set作用&#34;&gt;5. set作用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;数组去重(利用扩展运算符)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const mySet = new Set([1, 2, 3, 4, 4])
[...mySet] // [1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;合并两个set对象&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a = new Set([1, 2, 3])
let b = new Set([4, 3, 2])
let union = new Set([...a, ...b]) // {1, 2, 3, 4}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;交集&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a = new Set([1, 2, 3])
let b = new Set([4, 3, 2])
let intersect = new Set([...a].filter(x =&amp;gt; b.has(x)))  // {2, 3} 利用数组的filter方法
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;差集&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a = new Set([1, 2, 3])
let b = new Set([4, 3, 2])
let difference = new Set([...a].filter(x =&amp;gt; !b.has(x))) //  {1} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;9-es6怎么编译成es5css-loader原理-过程&#34;&gt;9. ES6怎么编译成ES5？css-loader原理、过程&lt;/h1&gt;
&lt;h2 id=&#34;1-es6怎么编译成es5&#34;&gt;1. ES6怎么编译成ES5&lt;/h2&gt;
&lt;p&gt;Babel是一个广泛使用的转码器，babel可以将ES6代码完美地转换为ES5代码&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化项目&lt;/li&gt;
&lt;li&gt;全局安装babel工具&lt;/li&gt;
&lt;li&gt;新建.babelrc&lt;br&gt;
在项目根目录新建(.babelrc)文件输入如图所示代码：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;presets&amp;quot;:[
        &amp;quot;es2015&amp;quot;
    ],
    &amp;quot;plugins&amp;quot;:[]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-css-loader&#34;&gt;2. css-loader&lt;/h2&gt;
&lt;p&gt;webpack的一个loader，用于解释@import 和 url()，并通过import后进行解析，通常和style-loader结合使用&lt;/p&gt;
&lt;h1 id=&#34;10-使用es5模拟实现es6的class&#34;&gt;10. 使用ES5模拟实现ES6的class&lt;/h1&gt;
&lt;h2 id=&#34;1new操作符检查函数&#34;&gt;1.new操作符检查函数&lt;/h2&gt;
&lt;p&gt;解决问题：&lt;br&gt;
类必须使用new调用，否则会报错。ES的构造函数是可以当成普通函数使用的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function _checkType (obj, constructor) {
    if (!(obj instanceof constructor)) {
        throw new TypeError(&#39;Cannot call a class as a function&#39;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2内部方法不可枚举&#34;&gt;2.内部方法不可枚举&lt;/h2&gt;
&lt;p&gt;解决问题：&lt;br&gt;
类的内部所有定义的方法，都是不可枚举的。（包括内部定义的静态方法）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 修改构造函数描述符
function defineProperties (target, descriptors) {
    for (let descriptor of descriptors) {
        descriptor.enumerable = descriptor.enumerable || false

        descriptor.configurable = true
        if (&#39;value&#39; in descriptor) {
            descriptor.writable = true
        }

        Object.defineProperty(target, descriptor.key, descriptor)
    }
}

// 构造class
// constructor 表示类对应的constructor对象
// protoDesc 表示class内部定义的方法
// staticDesc 表示class内部定义的静态方法
function _createClass (constructor, protoDesc, staticDesc) {
    protoDesc &amp;amp;&amp;amp; defineProperties(constructor.prototype, protoDesc)
    staticDesc &amp;amp;&amp;amp; defineProperties(constructor, staticDesc)
    return constructor
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-真正的创建class&#34;&gt;3. 真正的创建class&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const Foo = function () {
    function Foo(name) {
        _checkType(this, Foo) // 先检查是不是new调用的

        this.name = name
    }

    _createClass (Foo, [ // 表示在class内部定义的方法
        {
            key: &#39;say&#39;,
            value: function () {
                console.log(this.name)
            }
        }
    ], [ // 表示在class内部定义的静态方法
        {
            key: &#39;say&#39;,
            value: function () {
                console.log(&#39;static say&#39;)
                console.log(this.name)
            }
        }
    ])

    return Foo
}()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;11-settimeout和setinterval的区别&#34;&gt;11. setTimeout和setInterval的区别&lt;/h1&gt;
&lt;p&gt;1.setTimeout和setInterval都属于JS中的定时器，可以规定延迟时间再执行某个操作，不同的是setTimeout在规定时间后执行完某个操作就停止了，而setInterval则可以一直循环下去。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function fun(){
  alert(&#39;hello&#39;);
}
  setTimeout(fun,1000);//参数是函数名
  setTimeout(&#39;fun()&#39;,1000);//参数是字符串
  setInterval(fun,1000);
  setInterval(&#39;fun(),1000&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上述代码中，无论是setTimeout还是setInterval，在使用函数名作为调用句柄时不能带参数，使用字符串调用时可以带参数。例如：setTimeout(‘fun(name)’,1000);&lt;/p&gt;
&lt;p&gt;2.不再单独再定义一个函数，直接将函数调用放在一个函数里面，可以使用函数名作为调用调用句柄。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function fun(name){
  alert(&#39;hello&#39;+&#39; &#39;+name);
}
setTimeout (function(){
  fun(&#39;Tom&#39;);
},1000);//参数是函数名
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上述代码中，setTimeout和setInterval的区别就是setTimeout延迟一秒弹出’hello’,之后便不再运行；而setInterval则会隔一秒弹出’hello’,直至用clear来清除定时器的语法。&lt;/p&gt;
">【面】前端知识点梳理（ES6）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/js-zhong-he-qu-bie/"" data-c="
          &lt;p&gt;简单来说： == 代表相同， ===代表严格相同, 为啥这么说呢，&lt;/p&gt;
&lt;p&gt;这么理解： 当进行双等号比较时候： 先检查两个操作数数据类型，如果相同， 则进行===比较， 如果不同， 则愿意为你进行一次类型转换， 转换成相同类型后再进行比较， 而===比较时， 如果类型不同，直接就是false.&lt;/p&gt;
&lt;p&gt;操作数1 == 操作数2，  操作数1 === 操作数2&lt;/p&gt;
&lt;p&gt;比较过程：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;双等号&lt;/strong&gt;&lt;code&gt;==&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;（1）如果两个值类型相同，再进行三个等号(===)的比较&lt;/p&gt;
&lt;p&gt;（2）如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换在比较：&lt;/p&gt;
&lt;p&gt;1）如果一个是null，一个是undefined，那么相等&lt;/p&gt;
&lt;p&gt;2）如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三等号&lt;/strong&gt;&lt;code&gt;===&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;（1）如果类型不同，就一定不相等&lt;/p&gt;
&lt;p&gt;（2）如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是NaN，那么不相等。（判断一个值是否是NaN，只能使用isNaN( ) 来判断）&lt;/p&gt;
&lt;p&gt;（3）如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等。&lt;/p&gt;
&lt;p&gt;（4）如果两个值都是true，或是false，那么相等&lt;/p&gt;
&lt;p&gt;（5）如果两个值都引用同一个对象或是函数，那么相等，否则不相等&lt;/p&gt;
&lt;p&gt;（6）如果两个值都是null，或是undefined，那么相等&lt;/p&gt;
">js中==和===区别</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/mian-qian-duan-zhi-shi-dian-shu-li-js-shang/"" data-c="
          &lt;h1 id=&#34;-1-面向对象编程基础&#34;&gt;-1. 面向对象编程基础！！&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;面向对象适合的是那些业务逻辑复杂（其实用“繁杂”更恰当一些）的大型项目。所谓繁杂，繁指多，杂指乱，项目“杂乱”，可以表现为：功能多改动多，所以代码量大、开发人员多、开发/维护跨度时间长……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1-什么是面向对象&#34;&gt;1. 什么是面向对象&lt;/h2&gt;
&lt;p&gt;面向对象 ( Object Oriented ) 是将现实问题构建关系，然后抽象成 &lt;strong&gt;类 ( class )&lt;/strong&gt;，给类定义属性和方法后，再将类实例化成 &lt;strong&gt;实例 ( instance )&lt;/strong&gt; ，通过访问实例的属性和调用方法来进行使用。&lt;/p&gt;
&lt;p&gt;在不同的语言中，对象的定义范围不同。在 Java 等静态语言中，一般把类的实例称为对象。&lt;/p&gt;
&lt;h2 id=&#34;2-面向对象的六大原则&#34;&gt;2. 面向对象的六大原则&lt;/h2&gt;
&lt;h3 id=&#34;1-单一职责原则&#34;&gt;1. 单一职责原则&lt;/h3&gt;
&lt;p&gt;一个合理的类，应该仅有一个引起它变化的原因，即单一职责,就是设计的这个类功能应该只有一个;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：消除耦合，减小因需求变化引起代码僵化。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-开-闭原则&#34;&gt;2. 开-闭原则&lt;/h3&gt;
&lt;p&gt;讲的是设计要对扩展有好的支持，而对修改要严格限制。即对扩展开放，对修改封闭。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：降低了程序各部分之间的耦合性，其适应性、灵活性、稳定性都比较好。当已有软件系统需要增加新的功能时，不需要对作为系统基础的抽象层进行修改，只需要在原有基础上附加新的模块就能实现所需要添加的功能。增加的新模块对原有的模块完全没有影响或影响很小，这样就无须为原有模块进行重新测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-里氏代换原则&#34;&gt;3. 里氏代换原则&lt;/h3&gt;
&lt;p&gt;规则是“子类必须能够替换基类，否则不应当设计为其子类。”也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：可以很容易的实现同一父类下各个子类的互换，而客户端可以毫不察觉。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-依赖倒换原则&#34;&gt;4. 依赖倒换原则&lt;/h3&gt;
&lt;p&gt;“设计要依赖于抽象而不是具体化”。换句话说就是设计的时候我们要用抽象来思考，而不是一上来就开始划分我需要哪些哪些类，因为这些是具体。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619593049456.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：人的思维本身实际上就是很抽象的，我们分析问题的时候不是一下子就考虑到细节，而是很抽象的将整个问题都构思出来，所以面向抽象设计是符合人的思维的。另外这个原则会很好的支持（开闭原则）OCP，面向抽象的设计使我们能够不必太多依赖于实现，这样扩展就成为了可能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-接口隔离原则&#34;&gt;5. 接口隔离原则&lt;/h3&gt;
&lt;p&gt;“将大的接口打散成多个小接口”，让系统解耦，从而容易重构，更改和重新部署。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：会使一个软件系统功能扩展时，修改的压力不会传到别的对象那里。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;6-迪米特法则&#34;&gt;6. 迪米特法则&lt;/h3&gt;
&lt;p&gt;它讲的是“一个对象应当尽可能少的去了解其他对象”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：消除耦合。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-面向对象的三大特性&#34;&gt;3. 面向对象的三大特性&lt;/h2&gt;
&lt;p&gt;理解了理论知识后，接着通过例子，再理解面向对象的三大特征：&lt;code&gt;封装&lt;/code&gt;、&lt;code&gt;继承&lt;/code&gt;、&lt;code&gt;多态&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;1-封装&#34;&gt;1. 封装&lt;/h3&gt;
&lt;p&gt;封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;封装&lt;/code&gt;，&lt;strong&gt;也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作&lt;/strong&gt;，对不可信的进行信息隐藏。&lt;/p&gt;
&lt;h3 id=&#34;2-继承&#34;&gt;2. 继承&lt;/h3&gt;
&lt;p&gt;面向对象编程 (OOP) 语言的一个主要功能就是“&lt;code&gt;继承&lt;/code&gt;”。继承是指这样一种能力：&lt;strong&gt;它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;通过继承创建的新类称为“子类”或“派生类”。&lt;br&gt;
被继承的类称为“基类”、“父类”或“超类”。&lt;/p&gt;
&lt;p&gt;要实现继承，可以通过“&lt;strong&gt;继承&lt;/strong&gt;”（Inheritance）和“&lt;strong&gt;组合&lt;/strong&gt;”（Composition）来实现。&lt;/p&gt;
&lt;p&gt;继承概念的实现方式有三类：&lt;code&gt;实现继承&lt;/code&gt;、&lt;code&gt;接口继承&lt;/code&gt;和&lt;code&gt;可视继承&lt;/code&gt;。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619592096963.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-多态&#34;&gt;3. 多态&lt;/h3&gt;
&lt;p&gt;多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，&lt;br&gt;
简单的说，就是一句话：&lt;code&gt;允许将子类类型的指针赋值给父类类型的指针&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;实现多态，有二种方式，覆盖，重载。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;覆盖，是指子类重新定义父类的虚函数的做法。&lt;/li&gt;
&lt;li&gt;重载，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么，多态的作用是什么呢？我们知道，&lt;code&gt;封装&lt;/code&gt;可以隐藏实现细节，使得代码模块化；&lt;code&gt;继承&lt;/code&gt;可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而&lt;code&gt;多态&lt;/code&gt;则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。&lt;/p&gt;
&lt;h1 id=&#34;0-new-与-objectcreate-区别&#34;&gt;0. new 与 Object.create() 区别&lt;/h1&gt;
&lt;h2 id=&#34;1-new的原理&#34;&gt;1. new的原理&lt;/h2&gt;
&lt;p&gt;new 大概会执行以下四个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个空对象&lt;/li&gt;
&lt;li&gt;将空对象的原型链连接到另一个对象&lt;/li&gt;
&lt;li&gt;执行构造函数中的代码并绑定 this 到这个对象&lt;/li&gt;
&lt;li&gt;如函数没有返回值，则返回该对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自己实现一个 _new(Constructor,...args):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function _new() {
     // 参数为 对象A，属性
      // 1.创建一个空对象
     let obj = {}
 
     // 2.将该空对象的原型链连接到传入的对象
     let [Con, ...args] = arguments
     obj.__proto__ = Con.prototype
 
     // 3.执行函数并绑定 this
     let res = Con.apply(obj, args)
 
     // 4.如果函数有返回值并且为object，则返回函数的返回值，否则返回obj
     return res instanceof Object ? res : obj
   }
 
   function Person(name, age) {
     this.name = name
     this.age = age
   }
   Person.prototype.getName = function() {
     return this.name
   }
 
   let p = _new(Person, &amp;quot;sillywa&amp;quot;, 23)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-objectcreate介绍&#34;&gt;2. Object.create()介绍&lt;/h2&gt;
&lt;p&gt;Object.create(null) 创建的对象是一个空对象，在该对象上没有继承 Object.prototype 原型链上的属性或者方法,例如：toString(), hasOwnProperty()等方法&lt;/p&gt;
&lt;p&gt;**Object.create()**方法接受两个参数:Object.create(&lt;code&gt;obj&lt;/code&gt;,&lt;code&gt;propertiesObject&lt;/code&gt;) ;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;obj:一个对象，应该是新创建的对象的原型。&lt;/li&gt;
&lt;li&gt;propertiesObject：可选。该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符（这些属性描述符的结构与Object.defineProperties()的第二个参数一样）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;1-原型原型链构造函数实例继承&#34;&gt;1. 原型/原型链/构造函数/实例/继承&lt;/h1&gt;
&lt;h2 id=&#34;11-创建对象的几种方法&#34;&gt;1.1 创建对象的几种方法&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot; charset=&amp;quot;utf-8&amp;quot;&amp;gt;
		//创建对象的几种方式
		//1.字面量
		var obj1 = {name: &#39;solo obj1&#39;};
		//2.new Object
		var obj2 = new Object({name: &#39;solo obj2&#39;})
		//3.构造函数创建
		var M = function(name){
			this.name = name;
		}
		var obj3 = new M(&#39;solo obj3&#39;);
		//4.Object.create
		var p = {name: &#39;p&#39;};
		var obj4 = Object.create(p);
	&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;12-原型-构造函数-实例-原型链&#34;&gt;1.2 原型、构造函数、实例、原型链&lt;/h2&gt;
&lt;p&gt;构造函数、原型对象、实例的关系可以参照下图：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614923904668.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;构造函数.prototype.constructor === 构造函数&lt;br&gt;
M.prototype.constructor === M 的结果为 true&lt;/p&gt;
&lt;p&gt;构造函数.prototype === 实例对象. proto&lt;br&gt;
M.prototype === obj3._ proto _ 的结果为 true&lt;/p&gt;
&lt;h2 id=&#34;13-instanceof-的原理&#34;&gt;1.3 instanceof 的原理&lt;/h2&gt;
&lt;p&gt;instanceof 的原理是判断&lt;strong&gt;实例对象的&lt;/strong&gt; &lt;strong&gt;proto&lt;/strong&gt; 是否与&lt;strong&gt;构造函数的prototype&lt;/strong&gt;指向同一个引用。&lt;/p&gt;
&lt;h2 id=&#34;14-instanceof-和-typeof-的区别&#34;&gt;1.4 instanceof 和 typeof 的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;typeof 对于基本数据类型（&lt;code&gt;null, undefined, string, number, boolean, symbol&lt;/code&gt;），除了 null 都会返回正确的类型。null 会返回 object。&lt;/li&gt;
&lt;li&gt;typeof 对于对象类型，除了函数会返回 function，其他的都返回 object。&lt;/li&gt;
&lt;li&gt;typeof会返回一个变量的基本类型, instanceof返回的是一个布尔值&lt;/li&gt;
&lt;li&gt;需要注意的是，instanceof只能用来判断对象和函数，不能用来判断字符串和数字等&lt;/li&gt;
&lt;li&gt;typeof不能用于判断是否为数组，因为都会返回object&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;15-原型链&#34;&gt;1.5 原型链&lt;/h2&gt;
&lt;p&gt;JS中每个函数都存在有一个原型对象属性prototype。并且所有函数的默认原型都是Object的实例。每个继承父函数的子函数的对象都包含一个内部属性proto。该属性包含一个指针，指向父函数的prototype。若父函数的原型对象的_proto_属性为再上一层函数。在此过程中就形成了原型链。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;原型链的作用是用来实现继承,比如我们新建一个数组,数组的方法就是从数组的原型上继承而来的&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当访问对象a.b的时候，首先会查找当前对象的b属性，如果没有，然后依次按照prototype往上找直到找到Object.prototype为止，没有则返回undefined，所以说无处不在。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1619259847019.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;js的想要调用公共类的方式就是继承原型。&lt;/p&gt;
&lt;p&gt;比如原生的[].forEach()方法，之所以任意数组都能使用，是应为forEach()被定义在了数组的构造函数function Array(){}上，也就是数组的原型上；&lt;/p&gt;
&lt;h2 id=&#34;例子&#34;&gt;例子&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;function F(){} var f = new F(); // 构造器 
F.prototype.constructor === F; // true 
F.__proto__ === Function.prototype; // true 
Function.prototype.__proto__ === Object.prototype; // true Object.prototype.__proto__ === null; // true // 实例
f.__proto__ === F.prototype; // true 
F.prototype.__proto__ === Object.prototype; // true Object.prototype.__proto__ === null;// true
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1614925004509.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;2-有几种方式可以实现继承&#34;&gt;2. 有几种方式可以实现继承&lt;/h1&gt;
&lt;p&gt;ES5实现继承有6种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原型链继承&lt;/li&gt;
&lt;li&gt;借用构造函数继承&lt;/li&gt;
&lt;li&gt;组合继承&lt;/li&gt;
&lt;li&gt;原型式继承&lt;/li&gt;
&lt;li&gt;寄生式继承&lt;/li&gt;
&lt;li&gt;寄生组合式继承&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;寄生组合式&lt;/strong&gt;继承是大家公认的最好的实现引用类型继承的方法。&lt;/p&gt;
&lt;h2 id=&#34;1-原型链继承&#34;&gt;1.  原型链继承&lt;/h2&gt;
&lt;p&gt;原型链继承的基本思想是&lt;strong&gt;利用原型让一个引用类型继承另一个引用类型的属性和方法&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
function SuperType() {
    this.name = &#39;Yvette&#39;;
    this.colors = [&#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;];
}
SuperType.prototype.getName = function () {
    return this.name;
}
function SubType() {
    this.age = 22;
}
SubType.prototype = new SuperType();
SubType.prototype.getAge = function() {
    return this.age;
}
SubType.prototype.constructor = SubType;
let instance1 = new SubType();
instance1.colors.push(&#39;yellow&#39;);
console.log(instance1.getName()); //&#39;Yvette&#39;
console.log(instance1.colors);//[ &#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;, &#39;yellow&#39; ]
 
let instance2 = new SubType();
console.log(instance2.colors);//[ &#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;, &#39;yellow&#39; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过原型来实现继承时，原型会变成另一个类型的实例，原先的实例属性变成了现在的原型属性，该原型的引用类型属性会被所有的实例共享。&lt;/li&gt;
&lt;li&gt;在创建子类型的实例时，没有办法在不影响所有对象实例的情况下给超类型的构造函数中传递参数。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-借用构造函数&#34;&gt;2. 借用构造函数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;借用构造函数&lt;/strong&gt;的技术，其基本思想为: 在子类型的构造函数中调用超类型构造函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function SuperType(name) {
    this.name = name;
    this.colors = [&#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;];
}
function SubType(name) {
    SuperType.call(this, name);
}
let instance1 = new SubType(&#39;Yvette&#39;);
instance1.colors.push(&#39;yellow&#39;);
console.log(instance1.colors);//[&#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;, yellow]
 
let instance2 = new SubType(&#39;Jack&#39;);
console.log(instance2.colors); //[&#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;优点:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以向超类传递参数&lt;/li&gt;
&lt;li&gt;解决了原型中包含引用类型值被所有实例共享的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;缺点:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;方法都在构造函数中定义，函数复用无从谈起，另外超类型原型中定义的方法对于子类型而言都是不可见的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-组合继承原型链-借用构造函数&#34;&gt;3. 组合继承(原型链 + 借用构造函数)&lt;/h2&gt;
&lt;p&gt;基本思路：使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承，既通过在原型上定义方法来实现了函数复用，又保证了每个实例都有自己的属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function SuperType(name) {
    this.name = name;
    this.colors = [&#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;];
}
SuperType.prototype.sayName = function () {
    console.log(this.name);
}
function SuberType(name, age) {
    SuperType.call(this, name);
    this.age = age;
}
SuberType.prototype = new SuperType();
SuberType.prototype.constructor = SuberType;
SuberType.prototype.sayAge = function () {
    console.log(this.age);
}
let instance1 = new SuberType(&#39;Yvette&#39;, 20);
instance1.colors.push(&#39;yellow&#39;);
console.log(instance1.colors); //[ &#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;, &#39;yellow&#39; ]
instance1.sayName(); //Yvette
 
let instance2 = new SuberType(&#39;Jack&#39;, 22);
console.log(instance2.colors); //[ &#39;pink&#39;, &#39;blue&#39;, &#39;green&#39; ]
instance2.sayName();//Jack
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;优点:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以向超类传递参数&lt;/li&gt;
&lt;li&gt;每个实例都有自己的属性&lt;/li&gt;
&lt;li&gt;实现了函数复用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;缺点:&lt;/strong&gt;&lt;br&gt;
无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。&lt;/p&gt;
&lt;h2 id=&#34;4-原型式继承&#34;&gt;4. 原型式继承&lt;/h2&gt;
&lt;p&gt;原型继承的基本思想：&lt;br&gt;
借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
function object(o) {
    function F() { }
    F.prototype = o;
    return new F();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 object() 函数内部，先创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例，从本质上讲，object() 对传入的对象执行了一次浅拷贝。&lt;/p&gt;
&lt;p&gt;在没有必要创建构造函数，仅让一个对象与另一个对象保持相似的情况下，原型式继承是可以胜任的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-寄生式继承&#34;&gt;5. 寄生式继承&lt;/h2&gt;
&lt;p&gt;寄生式继承是与原型式继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部已某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
function createAnother(original) {
    var clone = object(original);//通过调用函数创建一个新对象
    clone.sayHi = function () {//以某种方式增强这个对象
        console.log(&#39;hi&#39;);
    };
    return clone;//返回这个对象
}
var person = {
    name: &#39;Yvette&#39;,
    hobbies: [&#39;reading&#39;, &#39;photography&#39;]
};
 
var person2 = createAnother(person);
person2.sayHi(); //hi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;基于 person 返回了一个新对象 -—— person2，新对象不仅具有 person 的所有属性和方法，而且还有自己的 sayHi() 方法。在考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用寄生式继承来为对象添加函数，会由于不能做到函数复用而效率低下。&lt;/li&gt;
&lt;li&gt;同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;6-寄生组合式继承&#34;&gt;6. 寄生组合式继承&lt;/h2&gt;
&lt;p&gt;所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法，&lt;br&gt;
&lt;strong&gt;基本思路：&lt;/strong&gt;&lt;br&gt;
不必为了指定子类型的原型而调用超类型的构造函数，我们需要的仅是超类型原型的一个副本，本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function inheritPrototype(subType, superType) {
    var prototype = object(superType.prototype); //创建对象
    prototype.constructor = subType;//增强对象
    subType.prototype = prototype;//指定对象
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;第一步：创建超类型原型的一个副本&lt;/li&gt;
&lt;li&gt;第二步：为创建的副本添加 constructor 属性&lt;/li&gt;
&lt;li&gt;第三步：将新创建的对象赋值给子类型的原型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至此，我们就可以通过调用 inheritPrototype 来替换为子类型原型赋值的语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
function SuperType(name) {
    this.name = name;
    this.colors = [&#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;];
}
//...code
function SuberType(name, age) {
    SuperType.call(this, name);
    this.age = age;
}
SuberType.prototype = new SuperType();
inheritPrototype(SuberType, SuperType);
//...code
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;优点:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只调用了一次超类构造函数，效率更高。避免在SuberType.prototype上面创建不必要的、多余的属性，与其同时，原型链还能保持不变。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此寄生组合继承是引用类型最理性的继承范式。&lt;/p&gt;
&lt;h2 id=&#34;7-es6继承&#34;&gt;7 es6继承&lt;/h2&gt;
&lt;p&gt;ES6新增class和extends语法，用来定义类和实现继承，底层也是采用了寄生组合式继承。&lt;/p&gt;
&lt;h1 id=&#34;3-用原型实现继承有什么缺点怎么解决&#34;&gt;3. 用原型实现继承有什么缺点，怎么解决&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;原型继承&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Human(){
this.name=&amp;quot;teacher&amp;quot;;
this,age=39;
}
function Man(){
}
Man.prototype=new Human();
var m=new Man();
/*此时Man.name=teacher;Man.age=39；*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;br&gt;
可以继承构造函数属性，也可继承原型属性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;br&gt;
1，在创建子类实例化时，不能向超类型的构造函数中传参&lt;br&gt;
2，子类型继承了父类型原型中的所有属性和方法，但对于引用类型属性值所有实例共享，故不能在不改变其他实例情况下改变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方式&lt;/strong&gt;&lt;br&gt;
使用混合继承。&lt;/p&gt;
&lt;h1 id=&#34;4-arguments&#34;&gt;4. arguments&lt;/h1&gt;
&lt;p&gt;arguments 是一个&lt;strong&gt;类似数组&lt;/strong&gt;的对象, 对应于传递给函数的&lt;strong&gt;参数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;arguments对象是所有函数中可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;arguments[0]
arguments[1]
arguments[2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;arguments对象不是一个 Array 。它类似于数组，但除了 长度之外没有任何数组属性。&lt;/p&gt;
&lt;p&gt;可以使用 Array.from()方法或 spread 运算符将 arguments 转换为真正的数组：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let args = Array.from(arguments);
let args = [...arguments];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你调用一个函数，当这个函数的参数数量比它显式声明的参数数量更多的时候，你就可以使用 arguments 对象。你可以用 arguments.length 来得到参数的数量，然后可以用 arguments object 来对每个参数进行处理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;arguments.callee：指向当前执行的函数。&lt;/li&gt;
&lt;li&gt;arguments.caller **：指向调用当前函数的函数。&lt;/li&gt;
&lt;li&gt;arguments.length：指向传递给当前函数的参数数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;模拟函数重载&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function add(num1, num2, num3) {
if (arguments.length === 2) {
    console.log(&amp;quot;Result is &amp;quot; + (num1 + num2));
     }
else if (arguments.length === 3) {
    console.log(&amp;quot;Result is &amp;quot; + (num1 + num2 + num3));
     }
｝
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;add(1, 2);&lt;br&gt;
add(1, 2, 3)&lt;/p&gt;
&lt;p&gt;执行结果如下：&lt;br&gt;
Result is 3&lt;br&gt;
Result is 6&lt;/p&gt;
&lt;h1 id=&#34;5-数据类型判断&#34;&gt;5. 数据类型判断&lt;/h1&gt;
&lt;h2 id=&#34;50-null和undefined的区别&#34;&gt;5.0 null和undefined的区别&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1619269681622.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;51-javascript-数据类型&#34;&gt;5.1 JavaScript 数据类型&lt;/h2&gt;
&lt;p&gt;JavaScript 数据类型有两种，分别是基本数据类型和引用数据类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基本数据类型&lt;br&gt;
Number&lt;br&gt;
String&lt;br&gt;
Boolean&lt;br&gt;
Undefined&lt;br&gt;
Null&lt;br&gt;
Symbol (ES6 新增，表示独一无二的值)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引用数据类型&lt;br&gt;
Object&lt;br&gt;
Function&lt;br&gt;
Array&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;52-检验数据类型&#34;&gt;5.2 检验数据类型&lt;/h2&gt;
&lt;h3 id=&#34;521-typeof&#34;&gt;5.2.1 typeof&lt;/h3&gt;
&lt;p&gt;它返回一个表示数据类型的字符串，返回结果包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;number&lt;/li&gt;
&lt;li&gt;boolean&lt;/li&gt;
&lt;li&gt;string&lt;/li&gt;
&lt;li&gt;symbol&lt;/li&gt;
&lt;li&gt;object&lt;/li&gt;
&lt;li&gt;undefined&lt;/li&gt;
&lt;li&gt;function&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;br&gt;
除 function 以外的对象都会被识别成 object ，这样显然是不合理的，这时就需要 instanceof 来进行判断。&lt;/p&gt;
&lt;h3 id=&#34;522-instanceof&#34;&gt;5.2.2 instanceof&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上&lt;/strong&gt;&lt;br&gt;
简单来说就是 instanceof 是用来判断 A 是否为 B 的实例，表达式为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A  (object)  instanceof  B  (constructor)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果A是B的实例，则返回true,否则返回 false。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;br&gt;
1.&lt;strong&gt;是否处于原型链上的判断方法不严谨&lt;/strong&gt;&lt;br&gt;
instanceof 方法判断的是是否处于原型链上，而不是是不是处于原型链最后一位&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;无法判断字面量方式创建的基本数据类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;无法检测 null 和 undefined&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;523-objectprototypetostringcall&#34;&gt;5.2.3 Object.prototype.toString.call()&lt;/h3&gt;
&lt;p&gt;在 Number、String，Boolean，Array，RegExp、Date、Function 等对象上 toString() 方法都是被重写过了的，会按照一定的规则返回字符串。但是在 object 对象上，这个方式是返回当前方法执行的主体（方法中的this）所属类的详细信息即&amp;quot;[object Object]&amp;quot;,其中第一个object代表当前实例是对象数据类型的(这个是固定的 onject)，第二个Object代表的是this所属的类型。&lt;/p&gt;
&lt;p&gt;为了每个对象都能通过 Object.prototype.toString() 来检测，需要以 Function.prototype.call() 或者 Function.prototype.apply() 的形式来调用，传递要检查的对象作为第一个参数，称为 thisArg。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object.prototype.toString.call(&#39;&#39;) ;   // [object String]
Object.prototype.toString.call(1) ;    // [object Number]
Object.prototype.toString.call(true) ; // [object Boolean]
Object.prototype.toString.call(undefined) ; // [object Undefined]
Object.prototype.toString.call(null) ; // [object Null]
Object.prototype.toString.call(new Function()) ; // [object Function]
Object.prototype.toString.call(new Date()) ; // [object Date]
Object.prototype.toString.call([]) ; // [object Array]
Object.prototype.toString.call(new RegExp()) ; // [object RegExp]
Object.prototype.toString.call(new Error()) ; // [object Error]
Object.prototype.toString.call(document) ; // [object HTMLDocument]
Object.prototype.toString.call(window) ; //[object global] window是全局对象global的引用
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;6-作用域-作用域链和闭包的理解&#34;&gt;6. 作用域、作用域链和闭包的理解&lt;/h1&gt;
&lt;h2 id=&#34;61-作用域&#34;&gt;6.1 作用域&lt;/h2&gt;
&lt;p&gt;变量的作用域无非就是两种：&lt;strong&gt;全局变量&lt;/strong&gt;和&lt;strong&gt;局部变量&lt;/strong&gt;。&lt;br&gt;
&lt;code&gt;全局作用域&lt;/code&gt;：&lt;br&gt;
最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是可以访问的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
      var outerVar = &amp;quot;outer&amp;quot;;
      function fn(){
         console.log(outerVar);
      }
      fn();//result:outer
   &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;局部作用域&lt;/code&gt;：&lt;br&gt;
和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无法访问的，最常见的例如函数内部&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
      function fn(){
         var innerVar = &amp;quot;inner&amp;quot;;
      }
      fn();
      console.log(innerVar);// ReferenceError: innerVar is not defined
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;只要函数内定义了一个局部变量，函数在解析的时候都会将这个变量“提前声明”：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
      var scope = &amp;quot;global&amp;quot;;
      function fn(){
         var scope;//提前声明了局部变量
         console.log(scope);//result:undefined
         scope = &amp;quot;local&amp;quot;;
         console.log(scope);//result:local;
      }
      fn();
   &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;62-作用域链scope-chain&#34;&gt;6.2 作用域链（Scope Chain）&lt;/h2&gt;
&lt;p&gt;作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。&lt;/p&gt;
&lt;h3 id=&#34;621-执行环境execution-context&#34;&gt;6.2.1 执行环境（execution context）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;js为每一个执行环境关联了一个变量对象。环境中定义的所有变量和函数都保存在这个对象中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;全局执行环境是最外围的执行环境，全局执行环境被认为是window对象，因此所有的全局变量和函数都作为window对象的属性和方法创建的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;script&amp;gt;
      var scope = &amp;quot;global&amp;quot;; 
      function fn1(){
         return scope; 
      }
      function fn2(){
         return scope;
      }
      fn1();
      fn2();
   &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码执行情况演示：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614938134873.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;622-作用域链&#34;&gt;6.2.2 作用域链&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
name=&amp;quot;lwy&amp;quot;;
function t(){
    var name=&amp;quot;tlwy&amp;quot;;
    function s(){
        var name=&amp;quot;slwy&amp;quot;;
        console.log(name);
    }
    function ss(){
        console.log(name);
    }
    s();
    ss();
}
t();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当执行s时，将创建函数s的执行环境(调用对象),并将该对象置于链表开头，然后将函数t的调用对象链接在之后，最后是全局对象。然后从链表开头寻找变量name,很明显name是&amp;quot;slwy&amp;quot;。&lt;/p&gt;
&lt;p&gt;但执行ss()时，作用域链是： ss()-&amp;gt;t()-&amp;gt;window,所以name是”tlwy&amp;quot;&lt;/p&gt;
&lt;h2 id=&#34;63-闭包&#34;&gt;6.3 闭包&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1614941970240.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1-闭包的定义&#34;&gt;1. 闭包的定义&lt;/h3&gt;
&lt;p&gt;一个函数对其周围状态(变量)的&lt;strong&gt;引用&lt;/strong&gt;并&lt;strong&gt;保存&lt;/strong&gt;周围变量，乃至函数执行完成后仍然可以访问的现象称之为闭包。&lt;/p&gt;
&lt;h3 id=&#34;2-闭包的原理&#34;&gt;2. 闭包的原理&lt;/h3&gt;
&lt;p&gt;闭包的实现原理，其实是利用了作用域链的特性，我们都知道作用域链就是在当前执行环境下访问某个变量时，如果不存在就一直向外层寻找，最终寻找到最外层也就是全局作用域，这样就形成了一个链条。&lt;/p&gt;
&lt;h3 id=&#34;3-闭包的特点&#34;&gt;3. 闭包的特点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;函数嵌套函数。&lt;/li&gt;
&lt;li&gt;函数内部可以引用外部的参数和变量。&lt;/li&gt;
&lt;li&gt;参数和变量不会被垃圾回收机制回收。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-闭包的优缺点&#34;&gt;4. 闭包的优缺点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;希望一个变量长期存储在内存中。&lt;/li&gt;
&lt;li&gt;避免全局变量的污染。&lt;/li&gt;
&lt;li&gt;私有成员的存在。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;导致变量不会被垃圾回收机制回收，造成内存消耗&lt;/li&gt;
&lt;li&gt;不恰当的使用闭包可能会造成内存泄漏的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-闭包的作用&#34;&gt;5. 闭包的作用&lt;/h3&gt;
&lt;p&gt;闭包有两个&lt;code&gt;作用&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个就是读取及操作外部函数的私有变量（沿着作用域链寻找）&lt;/li&gt;
&lt;li&gt;第二个就是让这些外部变量始终保存在内存中&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
      function outer(){
         var result = new Array();
         for(var i = 0; i &amp;lt; 2; i++){//注：i是outer()的局部变量
            result[i] = function(){
               return i;
            }
         }
         return result;//返回一个函数对象数组
         //这个时候会初始化result.length个关于内部函数的作用域链
      }
      var fn = outer();
      console.log(fn[0]());//result：2
      console.log(fn[1]());//result：2
   &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;js函数内的变量值不是在编译的时候就确定的，而是等在运行时期再去寻找的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;闭包让外部访问函数内部的变量成为可能（私有属性），因为被引用的数据常驻内存，可能会造成内存泄露（一块内存长期被变量占据而不进行释放），闭包可以让你在一个内层函数中访问到其外层函数的作用域的状态并保存，在js中每当创建一个函数，闭包环境就在函数创建时产生，闭包环境相互独立，如果闭包环境引用外部函数作用域的一个变量a，即使当外部函数作用域的变量被销毁释放内存，但变量a不会被删除。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; function outer(){
         var result = new Array();
         for(var i = 0; i &amp;lt; 2; i++){
            //定义一个带参函数
            result[i] = function(num){
               function innerarg(){
                  return num;
               }
               return innerarg;
            }(i);//预先执行函数写法
            //把i当成参数传进去
         }
         return result;
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6-闭包变量回收&#34;&gt;6. 闭包变量回收&lt;/h3&gt;
&lt;p&gt;当闭包函数无外链引用时，闭包函数被垃圾回收机制标记，&lt;code&gt;闭包自身呗回收，里边的变量自然就一起被回收了&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;7-ajax的原生写法&#34;&gt;7. Ajax的原生写法&lt;/h1&gt;
&lt;h2 id=&#34;71-ajax-是什么&#34;&gt;7.1 Ajax 是什么？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;全称Asynchronous JavaScript and XML；&lt;/li&gt;
&lt;li&gt;异步的 JavaScript 和 XML；&lt;/li&gt;
&lt;li&gt;可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页内容；&lt;/li&gt;
&lt;li&gt;能够实现局部刷新，大大降低了资源的浪费；&lt;/li&gt;
&lt;li&gt;不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;72-ajax的使用&#34;&gt;7.2 Ajax的使用&lt;/h2&gt;
&lt;p&gt;Ajax的使用分为四部分：&lt;br&gt;
1.） 创建一个XMLHttpRequest对象；&lt;/p&gt;
&lt;p&gt;2.） 配置请求信息；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求的方式；&lt;/li&gt;
&lt;li&gt;请求文件的路径；&lt;/li&gt;
&lt;li&gt;是否异步，默认为true；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.）发送请求；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;get与post的区别；&lt;/li&gt;
&lt;li&gt;get与post的使用场景；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4.） 监听状态变化，执行相应回调函数；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;http状态码都有哪些？&lt;/li&gt;
&lt;li&gt;不同状态码代表的含义？&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;721-创建xmlhttprequest对象&#34;&gt;7.2.1 创建XMLHttpRequest对象&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;var xhr = new XMLHttpRequest()&lt;/code&gt;;&lt;/p&gt;
&lt;h3 id=&#34;722-连接服务器&#34;&gt;7.2.2 连接服务器&lt;/h3&gt;
&lt;p&gt;使用 XMLHttpRequest 对象的open() 方法：&lt;/p&gt;
&lt;h3 id=&#34;723-向服务器发送请求&#34;&gt;7.2.3 向服务器发送请求&lt;/h3&gt;
&lt;p&gt;使用 XMLHttpRequest 对象的send() 方法：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614951772130.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;724-监听事件变化&#34;&gt;7.2.4 监听事件变化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如果是同步请求的话，不需要写监听事件变化函数；&lt;/li&gt;
&lt;li&gt;一般默认都是异步请求，才写监听函数；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0: 请求未初始化&lt;/li&gt;
&lt;li&gt;1: 服务器连接已建立&lt;/li&gt;
&lt;li&gt;2: 请求已接收&lt;/li&gt;
&lt;li&gt;3: 请求处理中&lt;/li&gt;
&lt;li&gt;4: 请求已完成，且响应已就绪&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;73-ajax原生写法&#34;&gt;7.3 Ajax原生写法&lt;/h2&gt;
&lt;h3 id=&#34;731-get请求&#34;&gt;7.3.1 Get请求&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;const xhr = new XMLHttpRequest()
        xhr.open(&amp;quot;GET&amp;quot;, &amp;quot;http://localhost:3000/users?id=1&amp;quot;)
        xhr.send(null)

        xhr.onreadystatechange = function () {
            if (this.readyState === 4) {
                console.log(this.responseText);
            }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;732-post请求&#34;&gt;7.3.2 Post请求&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;const xhr = new XMLHttpRequest()
        xhr.open(&amp;quot;POST&amp;quot;, &amp;quot;http://localhost:3000/users&amp;quot;)
        xhr.setRequestHeader(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)
        // 转换为json传递
        xhr.send(JSON.stringify({
            &amp;quot;name&amp;quot;: &amp;quot;luke&amp;quot;,
            &amp;quot;age&amp;quot; : 19,
            &amp;quot;class&amp;quot;: 2
        }))

        xhr.onreadystatechange = function () {
            if (this.readyState === 4) {
                console.log(this.responseText);
            }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;8-对象深拷贝-浅拷贝&#34;&gt;8. 对象深拷贝、浅拷贝&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;let a = {
    age: 1
}
let b = a
a.age = 2
console.log(b.age) // 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上述例子中我们可以发现，如果给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;如果是基本数据类型，名字和值都会储存在栈内存中&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;如果是引用数据类型，名字存在栈内存中，值存在堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;81-浅拷贝&#34;&gt;8.1 浅拷贝&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1617331269019.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先可以通过 &lt;code&gt;Object.assign&lt;/code&gt; 来解决这个问题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a = {
    age: 1
}
let b = Object.assign({}, a)
a.age = 2
console.log(b.age) // 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然我们也可以通过展开运算符&lt;code&gt;（…）&lt;/code&gt;来解决&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a = {
    age: 1
}
let b = {...a}
a.age = 2
console.log(b.age) // 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就需要使用到深拷贝了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a = {
    age: 1,
    jobs: {
        first: &#39;FE&#39;
    }
}
let b = {...a}
a.jobs.first = &#39;native&#39;
console.log(b.jobs.first) // native
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到刚开始的话题了，两者享有相同的引用。要解决这个问题，我们需要引入深拷贝。&lt;/p&gt;
&lt;h2 id=&#34;82-深拷贝&#34;&gt;8.2 深拷贝&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1617331301932.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这个问题通常可以通过 &lt;code&gt;JSON.parse(JSON.stringify(object))&lt;/code&gt; 来解决。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a = {
    age: 1,
    jobs: {
        first: &#39;FE&#39;
    }
}
let b = JSON.parse(JSON.stringify(a))
a.jobs.first = &#39;native&#39;
console.log(b.jobs.first) // FE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是该方法也是有局限性的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会忽略 undefined&lt;/li&gt;
&lt;li&gt;会忽略 symbol&lt;/li&gt;
&lt;li&gt;不能序列化函数&lt;/li&gt;
&lt;li&gt;不能解决循环引用的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;9-图片懒加载-预加载&#34;&gt;9. 图片懒加载、预加载&lt;/h1&gt;
&lt;h2 id=&#34;91-懒加载&#34;&gt;9.1 懒加载&lt;/h2&gt;
&lt;h3 id=&#34;911-什么是懒加载&#34;&gt;9.1.1 什么是懒加载&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;懒加载又称延迟加载&lt;/strong&gt;。当访问一个页面的时候，需要先把img元素或者其他元素的背景图先用一张默认的图片代替（占位图），这样浏览器渲染页面的时候就只需请求一次。当图片出现在浏览器可视区域的时候，才设置图片的真实路径，把图片显示出来。&lt;/p&gt;
&lt;h3 id=&#34;912-为什么要使用图片懒加载&#34;&gt;9.1.2 为什么要使用图片懒加载？&lt;/h3&gt;
&lt;p&gt;当页面中图片的数量多到一定数量的时候，并且图片大小比较大，比如各种商场网站，图片素材网等等。如果在页面一加载的时候就加载全部图片，显然会影响网站加载速度和加大服务器负担，而且用户体验也必然不好，那么这时候可以采用懒加载。&lt;/p&gt;
&lt;h3 id=&#34;913-懒加载具体实现原理&#34;&gt;9.1.3 懒加载具体实现原理&lt;/h3&gt;
&lt;p&gt;页面中的img元素之所以会发送http请求的原因是设置了src属性，否则浏览器就不会发送请求去下载这个图片。&lt;br&gt;
首先在页面中把所有的图片用一张占位图进行占位，并且在元素下设置data-src自定义属性，存放图片的真实路径，当需要用到的时候取出该真实路径动态添加给src。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;懒加载具体实现方式&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离便开始加载，这样能保证用户拉下时正好能看到图片。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;92-预加载&#34;&gt;9.2 预加载&lt;/h2&gt;
&lt;h3 id=&#34;921-什么是预加载&#34;&gt;9.2.1 什么是预加载&lt;/h3&gt;
&lt;p&gt;预加载就是提前加载图片，当用户需要查看时可直接从本地缓存中渲染。&lt;/p&gt;
&lt;h3 id=&#34;922-为什么要使用图片预加载&#34;&gt;9.2.2 为什么要使用图片预加载？&lt;/h3&gt;
&lt;p&gt;当页面中图片比较大的时候，页面加载的时候会出现该区域空白的效果或者看到图片正在慢慢地加载出来，为了提高用户体验，需要把这些图片提前加载到缓存中，当用户一打开页面的时候，这些图片就会快速的呈现出来，获得更好的用户体验效果。&lt;/p&gt;
&lt;h3 id=&#34;923-实现方式有哪些&#34;&gt;9.2.3 实现方式有哪些？&lt;/h3&gt;
&lt;p&gt;方法1：使用css和JavaScript实现预加载&lt;br&gt;
方法2：只使用JavaScript实现预加载&lt;br&gt;
方法3：使用ajax实现预加载&lt;/p&gt;
&lt;p&gt;常用的是&lt;code&gt;new Image()&lt;/code&gt;;设置其src来实现预载，再使用onload方法回调预载完成事件。只要浏览器把图片下载到本地，同样的src就会使用缓存，这是最基本也是最实用的预载方法。当Image下载完图片头后，会得到宽和高，因此可以在预载前得到图片的大小(方法是用记时器轮循宽高变化。)&lt;/p&gt;
&lt;h1 id=&#34;10-实现页面加载进度条&#34;&gt;10. 实现页面加载进度条&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1615011309891.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;101-html结构&#34;&gt;10.1 html结构：&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;div id=&amp;quot;progressBox&amp;quot;&amp;gt;
        &amp;lt;div id=&amp;quot;progressBar&amp;quot;&amp;gt;0%&amp;lt;/div&amp;gt;
        &amp;lt;!-- 设定第二个层以便当进度超过文字的时候，修改文字的颜色 --&amp;gt;
        &amp;lt;div id=&amp;quot;progressText&amp;quot;&amp;gt;0%&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;102-css结构&#34;&gt;10.2 CSS结构：&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
        #progressBox {
            width: 300px;
            height: 40px;
            border: 1px solid #C8C8C8;
            background: white;
            position: relative;
            margin: 0 auto;
            margin-top: 100px;
        }
 
        #progressBar {
            position: absolute;
            left: 0;
            top: 0;
            z-index: 2;
            height: 40px;
            width: 100%;
            line-height: 40px;
            color: white;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            font-family: Georgia;
            clip: rect(0px, 0, 40px, 0px);
            background: #00A1F5;
        }
 
        #progressText {
            position: absolute;
            left: 0;
            top: 0;
            z-index: 1;
            width: 100%;
            height: 40px;
            line-height: 40px;
            color: black;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            font-family: Georgia;
        }
    &amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;103-javascript-部分&#34;&gt;10.3 JavaScript 部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
        window.onload = function () {
            // 设定当前起始状态值,
            // 真实情况中用html5的onprogress和onload来完成
            // 还可以跟后台配合，通过ajax实时的返回数据
            var iNow = 0;
            // 设定定时器
            var timer = setInterval(function () {
                // 如果当前的值为100
                if (iNow == 100) {
                    // 清除定时器
                    clearInterval(timer);
                }else {
                    // 将当前状态值累加1
                    iNow += 1;
                    // 调用执行状态的函数,传入状态值
                    progressFn(iNow);
                }
 
            }, 30);
 
 
            function progressFn(cent) {
                // 获取最外层的div
                var oDiv1 = document.getElementById(&#39;progressBox&#39;);
                // 获取内层进度条的div
                var oDiv2 = document.getElementById(&#39;progressBar&#39;);
                // 获取内层文字发生变化时的div
                var oDiv3 = document.getElementById(&#39;progressText&#39;);
 
                // 获取总进度条的宽度
                var allWidth = parseInt(getStyle(oDiv1, &#39;width&#39;));
 
                // 设定内层两个div的文字内容一样
                oDiv2.innerHTML = cent + &#39;%&#39;;
                oDiv3.innerHTML = cent + &#39;%&#39;;
 
                // 修改clip的的宽度值
                oDiv2.style.clip = &#39;rect(0px, &#39; + cent / 100 * allWidth + &#39;px, 40px, 0px)&#39;;
 
                // 获取当前元素的属性值
                function getStyle(obj, attr) {
                    // 兼容IE
                    if (obj.currentStyle) {
                        return obj.currentStyle[attr];
                    }else {
                        // 第二个参数为false是通用的写法，目的是为了兼容老版本
                        return getComputedStyle(obj, false)[attr];
                    }
                }
            }
        };
    &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;11-this关键字&#34;&gt;11. this关键字&lt;/h1&gt;
&lt;p&gt;首先我们需要得出一个非常重要一定要牢记于心的结论，&lt;code&gt;this的指向，是在函数被调用的时候确定的&lt;/code&gt;。也就是执行上下文被创建时确定的。因此，一个函数中的this指向，可以是非常灵活的。比如下面的例子中，同一个函数由于调用方式的不同，this指向了不一样的对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = 10;
var obj = {
    a: 20
}
function fn () {
    console.log(this.a);
}
fn(); // 10
fn.call(obj); // 20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除此之外，&lt;code&gt;在函数执行过程中，this一旦被确定，就不可更改了。&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;情况1：如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window，这里需要说明的是在js的严格版中this指向的不是window，但是我们这里不探讨严格版的问题，你想了解可以自行上网查找。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;情况2：如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;情况3：如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象，&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;111-全局对象中的this&#34;&gt;11.1 全局对象中的this&lt;/h2&gt;
&lt;p&gt;关于全局对象的this，我之前在总结变量对象的时候提到过，它是一个比较特殊的存在。全局环境中的this，指向它本身。&lt;/p&gt;
&lt;h2 id=&#34;112-函数中的this&#34;&gt;11.2 函数中的this&lt;/h2&gt;
&lt;p&gt;在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。&lt;strong&gt;如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined&lt;/strong&gt;。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = 20;
var foo = {
    a: 10,
    getA: function () {
        return this.a;
    }
}
console.log(foo.getA()); // 10

var test = foo.getA;
console.log(test());  // 20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;foo.getA()&lt;/code&gt;中，getA是调用者，他不是独立调用，被对象foo所拥有，因此它的this指向了foo。而&lt;code&gt;test()&lt;/code&gt;作为调用者，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined，在非严格模式，自动转向全局window。&lt;/p&gt;
&lt;h2 id=&#34;113-使用callapply显示指定this&#34;&gt;11.3 使用call，apply显示指定this&lt;/h2&gt;
&lt;p&gt;JavaScript内部提供了一种机制，让我们可以自行手动设置this的指向。它们就是call与apply。所有的函数都具有着两个方法。它们除了参数略有不同，其功能完全一样。它们的第一个参数都为this将要指向的对象。&lt;/p&gt;
&lt;p&gt;而call与applay后面的参数，都是向将要执行的函数传递参数。其中call以一个一个的形式传递，apply以数组的形式传递。这是他们唯一的不同。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function fn(num1, num2) {
    console.log(this.a + num1 + num2);
}
var obj = {
    a: 20
}

fn.call(obj, 100, 10); // 130
fn.apply(obj, [20, 10]); // 50
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;114-构造函数与原型方法上的this&#34;&gt;11.4 构造函数与原型方法上的this&lt;/h2&gt;
&lt;p&gt;通过new操作符调用构造函数，会经历以下4个阶段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个新的对象；&lt;/li&gt;
&lt;li&gt;将构造函数的this指向这个新对象；&lt;/li&gt;
&lt;li&gt;指向构造函数的代码，为这个对象添加属性，方法等；&lt;/li&gt;
&lt;li&gt;返回新对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;function Person(name, age) {

    // 这里的this指向了谁?
    this.name = name;
    this.age = age;   
}

Person.prototype.getName = function() {

    // 这里的this又指向了谁？
    return this.name;
}

// 上面的2个this，是同一个吗，他们是否指向了原型对象？

var p1 = new Person(&#39;Nick&#39;, 20);
p1.getName();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因此，当new操作符调用构造函数时，this其实指向的是这个新创建的对象，最后又将新的对象返回出来，被实例对象p1接收。因此，我们可以说，这个时候，构造函数的this，指向了新的实例对象，p1。&lt;/p&gt;
&lt;h1 id=&#34;12-函数式编程&#34;&gt;12. 函数式编程&lt;/h1&gt;
&lt;p&gt;函数式编程是一种编程范式，是一种构建计算机程序结构和元素的风格，它把计算看作是对数学函数的评估，&lt;strong&gt;避免了状态的变化和数据的可变&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;纯函数&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果给定相同的参数，则返回相同的结果(也称为确定性)。&lt;/li&gt;
&lt;li&gt;它不会引起任何副作用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;函数是一等公民&lt;/li&gt;
&lt;li&gt;只用表达式不用语句&lt;/li&gt;
&lt;li&gt;没有副作用(side effect)&lt;/li&gt;
&lt;li&gt;不修改状态&lt;/li&gt;
&lt;li&gt;引用透明&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;优势&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代码简洁，开发快速&lt;/li&gt;
&lt;li&gt;接近自然语言，易于理解&lt;/li&gt;
&lt;li&gt;更方便的代码管理&lt;/li&gt;
&lt;li&gt;易于&amp;quot;并发编程&amp;quot;&lt;/li&gt;
&lt;li&gt;代码的热升级&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;13-手动实现parseint&#34;&gt;13. 手动实现parseInt&lt;/h1&gt;
&lt;p&gt;主要用到的ES5中的&lt;code&gt;map&lt;/code&gt;函数和&lt;code&gt;reduce&lt;/code&gt;函数，还有利用了javascript是弱类型转换的特点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function str2num(str) {
  var strArr = str.split(&#39;&#39;)
  var strArrNum = strArr.map(function (str) {
    return +str
  })
  var num = strArrNum.reduce(function (x, y) {
    return x * 10 + y
  })
  return num
}
str2num(&#39;123&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;14-为什么会有同源策略&#34;&gt;14. 为什么会有同源策略&lt;/h1&gt;
&lt;h2 id=&#34;141-什么是同源策略&#34;&gt;14.1 什么是同源策略&lt;/h2&gt;
&lt;p&gt;两个页面地址中的协议，域名，端口号一致，则表示同源&lt;/p&gt;
&lt;h2 id=&#34;142-为什么浏览器要使用同源策略&#34;&gt;14.2 为什么浏览器要使用同源策略&lt;/h2&gt;
&lt;p&gt;设置同源策略的主要目的是为了安全，如果没有同源限制，在浏览器中的cookie等其他数据可以任意读取，不同域下的DOM任意操作，ajax任意请求其他网站的数据，包括隐私数据。&lt;/p&gt;
&lt;h1 id=&#34;15-怎么判断两个对象是否相等&#34;&gt;15. 怎么判断两个对象是否相等&lt;/h1&gt;
&lt;p&gt;方法一：通过&lt;code&gt;JSON.stringify(obj)&lt;/code&gt;来判断两个对象转后的字符串是否相等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：用法简单，对于顺序相同的两个对象可以快速进行比较得到结果&lt;/li&gt;
&lt;li&gt;缺点：这种方法有限制就是当两个对比的对象中key的顺序不是完全相同时会比较出错&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方法二：&lt;code&gt;getOwnPropertyNames&lt;/code&gt;该方法可以将Object对象的第一层key获取到并返回一个由第一层key组成的数组。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：相对方法一进行了优化，可以应对不同顺序的Object进行比较，不用担心顺序不同而对比出错&lt;/li&gt;
&lt;li&gt;缺点：从方法中可以看到只能获取到第一层的key组成的数组，当对象是复合对象时无法进行多层对象的比较&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// 对Object扩展一个方法chargeObjectEqual
Object.prototype.chargeObjectEqual = function(obj){
    // 当前Object对象
    var propsCurr = Object.getOwnPropertyNames(this);
    // 要比较的另外一个Object对象
    var propsCompare = Object.getOwnPropertyNames(obj);
    if (propsCurr.length != propsCompare.length) {
        return false;
    }
    for (var i = 0,max = propsCurr.length; i &amp;lt; max; i++) {
        var propName = propsCurr[i];
        if (this[propName] !== obj[propName]) {
            return false;
        }
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;16-事件模型&#34;&gt;16. 事件模型&lt;/h1&gt;
&lt;h2 id=&#34;1基本概念&#34;&gt;1.基本概念&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;事件代理&lt;/strong&gt;（Event Delegation），又称之为事件委托。是JavaScript中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定在子元素的响应事件（click、keydown......）委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。&lt;/p&gt;
&lt;h2 id=&#34;2-事件传播&#34;&gt;2. 事件传播&lt;/h2&gt;
&lt;p&gt;一个事件触发后，会在子元素和父元素之间&lt;strong&gt;传播&lt;/strong&gt;（propagation）。这种传播分成三个阶段&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1615169023216.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如上图所示，事件传播分成三个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;捕获阶段：从window对象传导到目标节点（上层传到底层）称为“捕获阶段”（capture phase），捕获阶段不会响应任何事件；&lt;/li&gt;
&lt;li&gt;目标阶段：在目标节点上触发，称为“目标阶段”&lt;/li&gt;
&lt;li&gt;冒泡阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。&lt;strong&gt;事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-事件冒泡和捕获&#34;&gt;3. 事件冒泡和捕获&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;冒泡&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;就是从事件 目标 的事件处理函数开始，依次向外，直到 window 的事件处理函数触发（先执行目标元素事件，再依次执行父元素事件）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;捕获&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;就是从 window 的事件处理函数开始，依次向内，直到事件 目标 的事件处理函数执行（最后才执行目标元素）&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619616013812.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;阻止事件传播&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果想只触发当前点击对象的事件，不想让外层的事件触发 ，可以使用不冒泡&lt;strong&gt;e.cancelBubble=true&lt;/strong&gt;或不传播 &lt;strong&gt;e.stopPropagation()&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;var box = document.querySelector(&#39;.box&#39;)
    var atr = document.querySelector(&#39;.atr&#39;)
    box.onclick = function (e) {
        e.stopPropagation() // 不传播
        console.log(&#39;我被点击了box&#39;)
    }
    atr.onclick = function (e) {
        e.cancelBubble=true //不冒泡
        console.log(&#39;我被点击了atr&#39;)
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-事件委托&#34;&gt;4. 事件委托&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;因为我们的冒泡机制，点击子元素的时候，也会同步触发父元素的相同事件 ，所以我们就可以把子元素的事件委托给父元素来做&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;点击子元素的时候，不管子元素有没有点击事件，只要父元素有点击事件，那么就可以触发父元素的点击事件&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt; atr.onclick = function (e) {
        // e.stopPropagation()
        var e = e || window.event //event兼容写法
        var target = e.target || e.srcElement //target兼容写法
        console.log(target,&#39;执行子盒子的点击事件&#39;)
    }
box.onclick = function (e) {
        var e = e || window.event //event兼容写法
        var target = e.target || e.srcElement //target兼容写法
        console.log(target,&#39;执行父盒子的点击事件&#39;)
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;target&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;target 这个属性是事件对象里面的属性，表示你点击的目标&lt;/li&gt;
&lt;li&gt;当你触发点击事件的时候，你点击在哪个元素上，target 就是哪个元素&lt;/li&gt;
&lt;li&gt;这个 target 也不兼容，在 IE 下要使用 srcElement&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;委托&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个时候，当我们点击 box里面的元素的时候，也可以触发 box 的点事件&lt;/li&gt;
&lt;li&gt;并且在事件内部，我们也可以拿到你点击的到底是哪个对象&lt;/li&gt;
&lt;li&gt;这个时候，我们就可以把 li 的事件委托给 box 父级来做&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;var box = document.querySelector(&#39;.box&#39;)
    var atr = document.querySelector(&#39;.atr&#39;)
    
    atr.onclick = function (e) {
        var e = e || window.event //event兼容写法
        var target = e.target || e.srcElement //target兼容写法
        if(target.className==&#39;atr&#39;){
            //这里面就找到需要操作的元素
            console.log(111)
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-事件委托的优点&#34;&gt;5. 事件委托的优点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;【1】可以大量节省内存占用，减少事件注册，比如在ul上代理所有li的click事件就非常棒&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【2】可以实现当新增子对象时无需再次对其绑定（动态绑定事件）&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;6-事件的默认行为&#34;&gt;6. 事件的默认行为&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;默认行为，就是不用我们注册，它自己就存在的事情&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比如我们点击鼠标右键的时候，会自动弹出一个菜单&lt;/li&gt;
&lt;li&gt;比如我们点击 a 标签的时候，我们不需要注册点击事件，他自己就会跳转页面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;这些不需要我们注册就能实现的事情，我们叫做默认事件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;阻止默认行为&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619617595767.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var oA = document.querySelector(&#39;a&#39;)
    a.addEventListener(&#39;click&#39;, function (e) {
        e = e || window.event
        console.log(this.href)
        //下面这个是兼容写法
        e.preventDefault ? e.preventDefault() : e.returnValue = false
    })
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7-如何让事件先冒泡后捕获&#34;&gt;7. 如何让事件先冒泡后捕获&lt;/h2&gt;
&lt;p&gt;若要实现先冒泡后捕获，给一个元素绑定两个addEventListener，其中一个第三个参数设置为false（即冒泡），另一个第三个参数设置为true（即捕获），调整它们的代码顺序，将设置为false的监听事件放在设置为true的监听事件前面即可。&lt;/p&gt;
&lt;h1 id=&#34;17-dom基本操作获取元素-节点的创建和添加-节点的替换和删除&#34;&gt;17. DOM基本操作（获取元素、节点的创建和添加、节点的替换和删除）&lt;/h1&gt;
&lt;h2 id=&#34;1-获取元素&#34;&gt;1. 获取元素&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;document.getElementById&lt;/code&gt;通过id名字获取节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
        &amp;lt;ul&amp;gt;
            &amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;document.getElementsByClassName&lt;/code&gt;通过class名字获取节点 获取的是一个数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;
        &amp;lt;ul&amp;gt;
            &amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementsByClassName(&amp;quot;box&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在HTML与CSS里.class类名是&lt;code&gt;可以重复&lt;/code&gt;使用的，在页面上可能出现多个重复的.class类名，他是获取到多个把获取到多个放在数组里&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementsByClassName(&amp;quot;box&amp;quot;)[0]
 //通过下标来换取索引0的值也可以获取别的索引值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;document.getElementsByTagName&lt;/code&gt; 通过标签名字获取节点 获取的是一个数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;
        &amp;lt;ul&amp;gt;
            &amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var aBox = document.getElementsByTagName(&amp;quot;div&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618115504124.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;那么如何获取数组里面的值呢？？？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;var aBox = document.getElementsByTagName(&amp;quot;div&amp;quot;)[2];//通过下标来换取索引2的值
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618115545753.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;document.querySelectorAll&lt;/code&gt; 通过复合（层级）选择器获取节点 获取的是一个数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;
        &amp;lt;ul&amp;gt;
            &amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; var  aLi = document.querySelectorAll(&amp;quot;.box ul li&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618115797303.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;那么如何获取数组里面的值呢？？？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;var aLi  = document.querySelectorAll(&amp;quot;.box ul li&amp;quot;)[1];
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618115827067.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;document.querySelector&lt;/code&gt; 通过复合（层级）选择器获取符合条件的第一个节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var oLi = document.querySelector(&amp;quot;.box ul li&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618115873612.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;document.getElementsByName&lt;/code&gt; 通过name属性获取节点 获取的是一个数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;sex&amp;quot; value=&amp;quot;男&amp;quot;&amp;gt;男
&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;sex&amp;quot; value=&amp;quot;女&amp;quot;&amp;gt;女
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var aInput = document.getElementsByName(&amp;quot;sex&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618116016375.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;获取特殊元素的方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;document.head&lt;/code&gt; 获取&lt;code&gt;head&lt;/code&gt;标签&lt;/li&gt;
&lt;li&gt;&lt;code&gt;document.body&lt;/code&gt; 获取&lt;code&gt;body&lt;/code&gt;标签&lt;/li&gt;
&lt;li&gt;&lt;code&gt;document.documentElement&lt;/code&gt; 获取&lt;code&gt;html&lt;/code&gt;标签&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1618116077529.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-节点的创建和添加创建完一定要添加&#34;&gt;2. 节点的创建和添加（创建完一定要添加）&lt;/h2&gt;
&lt;h3 id=&#34;1-节点的创建&#34;&gt;1. 节点的创建&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;document.createElement&lt;/code&gt; 创建元素节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; var oDiv = document.createElement(&amp;quot;div&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如何把这个属性节点添加到DOM树中?&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
        &amp;lt;span&amp;gt;我是haven&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
var oDiv = document.createElement(&amp;quot;div&amp;quot;);
oBox.appendChild(oDiv); 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618116529080.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;document.createTextNode&lt;/code&gt;创建文本节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var oText = document.createTextNode(&amp;quot;heaven&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如何把这个文本节点添加到DOM树中?&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
    &amp;lt;span&amp;gt;我是haven&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
var oText = document.createTextNode(&amp;quot;heaven&amp;quot;);
oBox.appendChild(oText);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618116715791.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;document.createComment&lt;/code&gt; 创建注释节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var oComment = document.createComment(&amp;quot;我是注释节点&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如何把这个注释节点添加到DOM树中?&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
    &amp;lt;span&amp;gt;我是haven&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var obox = document.getElementById(&amp;quot;box&amp;quot;);
var oComment = document.createComment(&amp;quot;我是注释节点&amp;quot;);
obox.appendChild(oComment);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618117356273.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-节点的添加-剪切操作&#34;&gt;2. 节点的添加、剪切操作&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;parentNode.appendChild(子节点)&lt;/code&gt; 把子节点插入到父节点的最后面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
   &amp;lt;span&amp;gt;我是haven&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
var oDiv = document.createElement(&amp;quot;div&amp;quot;);
oBox.appendChild(oDiv);//把oDiv插入到oBox的最后面是以字符串形式添加的
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618117728592.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;parentNode.insertBefore(A,B)&lt;/code&gt; 把节点A添加到节点B之前&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
        &amp;lt;h2&amp;gt;我是标题&amp;lt;/h2&amp;gt;
        &amp;lt;span&amp;gt;我是haven&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; var oBox = document.getElementById(&amp;quot;box&amp;quot;);
 var oSpan = document.getElementsByTagName(&amp;quot;span&amp;quot;)[0];
 var oDiv = document.createElement(&amp;quot;div&amp;quot;);
 oBox.insertBefore(oDiv,oSpan);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618117898677.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;结论：无论是appendChild方法还是insertBefore方法都可以对节点的 添加、剪切操作，都可以操作一次不能操作多次&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-节点的替换和删除&#34;&gt;3. 节点的替换和删除&lt;/h2&gt;
&lt;h3 id=&#34;1节点的替换&#34;&gt;1.节点的替换&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;parentNode.replaceChild(A,B)&lt;/code&gt; 用节点A替换节点B&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
    &amp;lt;h2&amp;gt;我是标题2&amp;lt;/h2&amp;gt;
    &amp;lt;span&amp;gt;我是heaven&amp;lt;/span&amp;gt;
    &amp;lt;h3&amp;gt;我是标题3&amp;lt;/h3&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
var oH3 = document.getElementsByTagName(&amp;quot;h3&amp;quot;)[0]
var oDiv = document.createElement(&amp;quot;div&amp;quot;);
oBox.replaceChild(oDiv,oH3);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618119399959.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-节点的删除-删除子节点&#34;&gt;2. 节点的删除 、删除子节点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;parentNode.removeChild(子节点)&lt;/code&gt; 删除子节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
    &amp;lt;h2&amp;gt;我是标题2&amp;lt;/h2&amp;gt;
    &amp;lt;span&amp;gt;我是heaven&amp;lt;/span&amp;gt;
    &amp;lt;h3&amp;gt;我是标题3&amp;lt;/h3&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
var oH3 = document.getElementsByTagName(&amp;quot;h3&amp;quot;);
oBox.removeChild(oH3[0]);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618119515957.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;4-动态获取与静态获取&#34;&gt;4. 动态获取与静态获取&lt;/h2&gt;
&lt;h3 id=&#34;1-get系列获取元素的方式是动态获取&#34;&gt;1. get系列获取元素的方式是动态获取&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;动态获取指的是：在获取节点之后还可以检测出符合条件的节点、并放置到集合中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;  &amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
        &amp;lt;h3&amp;gt;1&amp;lt;/h3&amp;gt;
        &amp;lt;h3&amp;gt;2&amp;lt;/h3&amp;gt;
        &amp;lt;h3&amp;gt;3&amp;lt;/h3&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
var oH3 = document.getElementsByTagName(&amp;quot;h3&amp;quot;);
var h3 = document.createElement(&amp;quot;h3&amp;quot;);
oBox.appendChild(h3);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618119951624.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;动态获取的方式是能再次感知到用js的方法添加新的标签的&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-query系列获取元素的方式是静态态获取&#34;&gt;2. query系列获取元素的方式是静态态获取&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;静态获取指的是：在获取节点之后无法检测出符合条件的节点、不能放置到集合中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
var oH3 = document.querySelectorAll(&amp;quot;h3&amp;quot;);
var h3 = document.createElement(&amp;quot;h3&amp;quot;);
oBox.appendChild(h3);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618120005689.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
静态获取的方式是不能能再次感知到用js的方法添加新的标签的&lt;/p&gt;
&lt;h2 id=&#34;5-如何在创建空节点的时候添加内容&#34;&gt;5. 如何在创建空节点的时候添加内容&lt;/h2&gt;
&lt;h3 id=&#34;1-元素节点&#34;&gt;1. 元素节点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;innerText&lt;/code&gt; 可以设置节点的文本内容、也可以读取节点的内容、&lt;code&gt;不可以解析&lt;/code&gt;标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
    &amp;lt;h3&amp;gt;1&amp;lt;/h3&amp;gt;
    &amp;lt;h3&amp;gt;2&amp;lt;/h3&amp;gt;
    &amp;lt;h3&amp;gt;3&amp;lt;/h3&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
var oH3 = document.createElement(&amp;quot;h3&amp;quot;);
oBox.appendChild(oH3);
oH3.innerText = &amp;quot;我是h3节点&amp;quot;;//创建h3标签添加文本内容
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618120681297.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;那么如何读取元素节点的内容呢？？&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
var oH3 = document.querySelectorAll(&amp;quot;h3&amp;quot;);
console.log(oH3[2].innerText);//读取节点的文本内容
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618121295691.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;修改并赋值&lt;/strong&gt;&lt;code&gt;innerText&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
var oH3 = document.querySelectorAll(&amp;quot;h3&amp;quot;);
oH3[0].innerText = &amp;quot;我是修改并赋值的节点&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618121299074.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-元素节点&#34;&gt;2. 元素节点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;innerHTML&lt;/code&gt;可以设置节点的文本内容、也可以读取节点的内容、可以&lt;code&gt;解析&lt;/code&gt;标签&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;怎么样innerHTML方法解析字符串中的标签&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
var oH3 = document.querySelectorAll(&amp;quot;h3&amp;quot;);
oH3[0].innerHTML = &amp;quot;&amp;lt;a&amp;gt;我是修改后的文本节点的内容&amp;lt;/a&amp;gt;&amp;quot;;
console.log(oH3[0].innerHTML);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打印的结果是用&lt;code&gt;innerHTML&lt;/code&gt;替换的结果&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1618121585550.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;6-元素节点的常用方法&#34;&gt;6. 元素节点的常用方法&lt;/h2&gt;
&lt;h3 id=&#34;1-属性集合&#34;&gt;1. 属性集合&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
    &amp;lt;h3 class=&amp;quot;no&amp;quot;&amp;gt;测试标题&amp;lt;/h3&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如何拿到&lt;code&gt;h3&lt;/code&gt;标签的属性集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
        console.log(oBox.children[0].attributes);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618123899949.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-设置属性节点&#34;&gt;2. 设置属性节点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;setAttribute&lt;/code&gt;(属性节点名,属性节点值)、设置指定的属性节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
    &amp;lt;h3 class=&amp;quot;no&amp;quot;&amp;gt;测试标题&amp;lt;/h3&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
oBox.children[0].setAttribute(&amp;quot;id&amp;quot;, &amp;quot;title&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618124020361.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;3-获取属性节点&#34;&gt;3. 获取属性节点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;getAttribute&lt;/code&gt;(属性节点名)、获取指定属性节点名称的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
console.log(oBox.children[0].getAttribute(&amp;quot;class&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618124061317.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;4-删除属性节点&#34;&gt;4. 删除属性节点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;removeAttribute&lt;/code&gt;(属性节点名)、删除指定属性节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
    &amp;lt;h3 class=&amp;quot;no&amp;quot;&amp;gt;测试标题&amp;lt;/h3&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
oBox.children[0].removeAttribute(&amp;quot;class&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618124130227.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;5-判断有没有子节点&#34;&gt;5. 判断有没有子节点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;hasChildNodes&lt;/code&gt; 判断元素节点有没有子节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
console.log(oBox.children[0].hasChildNodes());
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618124186614.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;如果有则返回返回结果是true&lt;/li&gt;
&lt;li&gt;如果没有则返回结果是是false&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;18-js遍历dom树&#34;&gt;18. js遍历dom树&lt;/h1&gt;
&lt;h2 id=&#34;1-遍历dom树&#34;&gt;1. 遍历dom树&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
  &amp;lt;title&amp;gt;遍历DOM树&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;遍历 DOM 树&amp;lt;/h1&amp;gt;
&amp;lt;p style=&amp;quot;color: green;&amp;quot;&amp;gt;Tip: 可以在遍历的回调函数中任意定制需求&amp;lt;/p&amp;gt;
&amp;lt;div&amp;gt;
  &amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;123&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;456&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;789&amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;div&amp;gt;
      &amp;lt;span&amp;gt;haha&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;demo_node&amp;quot;&amp;gt;
  &amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;123&amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
  &amp;lt;p&amp;gt;hello&amp;lt;/p&amp;gt;
  &amp;lt;h2&amp;gt;world&amp;lt;/h2&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;dsa&amp;lt;/p&amp;gt;
    &amp;lt;h3&amp;gt;
      &amp;lt;span&amp;gt;dsads&amp;lt;/span&amp;gt;
    &amp;lt;/h3&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;

  //获取页面中的根节点--根标签
  var root=document.documentElement;//html
  //函数遍历DOM树
  //根据根节点,调用fn的函数,显示的是根节点的名字
  function forDOM(root1) {
    //调用f1,显示的是节点的名字
   // f1(root1);
    //获取根节点中所有的子节点
    var children=root1.children;
    //调用遍历所有子节点的函数
    forChildren(children);
  }
  //给我所有的子节点,我把这个子节点中的所有的子节点显示出来
  function forChildren(children) {
    //遍历所有的子节点
    for(var i=0;i&amp;lt;children.length;i++){
      //每个子节点
      var child=children[i];
      //显示每个子节点的名字
      f1(child);
      //判断child下面有没有子节点,如果还有子节点,那么就继续的遍历
      child.children&amp;amp;&amp;amp;forDOM(child);
    }
  }
  //函数调用,传入根节点
  forDOM(root);
  function f1(node) {
    console.log(&amp;quot;节点的名字:&amp;quot;+node.nodeName);
  }
  //节点:nodeName,nodeType,nodeValue

&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-多叉-dom-树的遍历&#34;&gt;2. 多叉 DOM 树的遍历&lt;/h2&gt;
&lt;h3 id=&#34;1-广度优先遍历&#34;&gt;1. 广度优先遍历&lt;/h3&gt;
&lt;p&gt;首先遍历根节点，然后访问第一层节点，第二层节点，....,直到访问到最后一层。&lt;br&gt;
借助于队列，用非递归的方式对多叉树进行遍历&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Tree.prototype.BFSearch =  function(node,callback){  
    var queue=[];  
    while(node!=null){          
           callback(node);  
       if(node.children.length!=0){  
        for (var i=0;i&amp;lt;node.children.length;i++){  
            queue.push(node.children[i]);//借助于队列,暂存当前节点的所有子节点  
        }   
        }  
            node=queue.shift();//先入先出，借助于数据结构：队列  
    }         
};  
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-深度优先遍历&#34;&gt;2. 深度优先遍历&lt;/h3&gt;
&lt;p&gt;首先遍历根节点，然后沿着一条路径遍历到最深的一层，最后在逐层返回。&lt;br&gt;
借助于栈,实现多叉 DOM树 的深度优先遍历。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Tree.prototype.DFSearch =  function(node,callback){  
        var stack=[];         
        while(node!=null){  
        callback(node);  
        if(node.children.length!=0){  
        for (var i=node.children.length-1;i&amp;gt;=0;i--){//按照相反的子节点顺序压入栈  
            stack.push(node.children[i]);//将该节点的所有子节点压入栈  
        }  
        }  
            node = stack.pop();//弹出栈的子节点顺序就是原来的正确顺序(因为栈是先入后出的)        
    }     
};  
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;19-面试查缺补漏&#34;&gt;19. 面试查缺补漏&lt;/h1&gt;
&lt;h2 id=&#34;1-js页面跳转方式&#34;&gt;1. JS页面跳转方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;window.location.href= &#39;url&#39;: 比较常用的方法，直接跟指定要跳转的地方。&lt;/li&gt;
&lt;li&gt;window.history.back(-1);: 参见的浏览器返回上一个已访问的页面，直到访问最初访问的页面。&lt;/li&gt;
&lt;li&gt;window.navigate(&amp;quot;url&amp;quot;);: navigate对象包含有关浏览器的信息，也可以作为页面跳转，后面直接加要跳转的地方。&lt;/li&gt;
&lt;li&gt;top.location= &#39;url&#39;;: 当页面中有内嵌框架时，指定最顶层的窗口跳转，及包含框架的最外层浏览器&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618478544386.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;2-js弹出框有哪些&#34;&gt;2. JS弹出框有哪些&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;第一种：alert()方法&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1618479050149.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;第二种：confirm()方法&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1618479053584.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;第三种： prompt()方法&lt;/strong&gt;&lt;br&gt;
不但可以显示信息，而且还提供了一个文本框要求用户使用键盘输入自己的信息，同时她还包含“确认”或“取消”两个按钮，如果用户“确认”按钮，则prompt()方法返回用户在文本框中输入的内容（是字符串类型)或者初始值(如果用户没有输入信息);如果用户单击“取消”按钮，则prompt()方法返回null&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1618479103065.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1618479124548.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-url编码和解码的方式&#34;&gt;3. url编码和解码的方式&lt;/h2&gt;
&lt;h3 id=&#34;1-为什么要url编码&#34;&gt;1. 为什么要URL编码？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在因特网上传送URL，只能采用ASCII字符集&lt;/strong&gt;&lt;br&gt;
只有字母和数字[0-9a-zA-Z]、一些特殊符号$-_.+!*&#39;()[不包括双引号]、以及某些保留字（空格转换为+），才可以不经过编码直接用于URL&lt;/p&gt;
&lt;p&gt;这意味着 如果URL中有汉字，就必须编码后使用。&lt;/p&gt;
&lt;h3 id=&#34;2-js编码函数&#34;&gt;2. JS编码函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;encodeURI函数(推荐使用)&lt;/strong&gt;&lt;br&gt;
这个函数才是javascript中真正用来对URL编码的函数&lt;/p&gt;
&lt;p&gt;它着眼于对整个URL进行编码，因此除了常见的符号以外，对其他一些在网址中有特殊含义的符号&amp;quot;; / ? : @ &amp;amp; = + $ , #&amp;quot;，也不进行编码。编码后，它输出符号的utf-8形式，并且在每个字节前加上%。&lt;br&gt;
需要注意的是，它不对单引号’编码&lt;/p&gt;
&lt;p&gt;它对应的解码函数是decodeURI()。&lt;/p&gt;
&lt;h3 id=&#34;3-为什么两次编码&#34;&gt;3. 为什么两次编码&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618481823390.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;4-meta常用属性&#34;&gt;4. meta常用属性&lt;/h2&gt;
&lt;h3 id=&#34;1-charset属性&#34;&gt;1. charset属性&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 定义网页文档的字符集 --&amp;gt;
&amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-name-content属性&#34;&gt;2. name + content属性&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 网页作者 --&amp;gt;
&amp;lt;meta name=&amp;quot;author&amp;quot; content=&amp;quot;开源技术团队&amp;quot;/&amp;gt;
&amp;lt;!-- 网页地址 --&amp;gt;
&amp;lt;meta name=&amp;quot;website&amp;quot; content=&amp;quot;https://sanyuan0704.github.io/frontend_daily_question/&amp;quot;/&amp;gt;
&amp;lt;!-- 网页版权信息 --&amp;gt;
 &amp;lt;meta name=&amp;quot;copyright&amp;quot; content=&amp;quot;2018-2019 demo.com&amp;quot;/&amp;gt;
&amp;lt;!-- 网页关键字, 用于SEO --&amp;gt;
&amp;lt;meta name=&amp;quot;keywords&amp;quot; content=&amp;quot;meta,html&amp;quot;/&amp;gt;
&amp;lt;!-- 网页描述 --&amp;gt;
&amp;lt;meta name=&amp;quot;description&amp;quot; content=&amp;quot;网页描述&amp;quot;/&amp;gt;
&amp;lt;!-- 搜索引擎索引方式，一般为all，不用深究 --&amp;gt;
&amp;lt;meta name=&amp;quot;robots&amp;quot; content=&amp;quot;all&amp;quot; /&amp;gt;
&amp;lt;!-- 移动端常用视口设置 --&amp;gt;
&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1.0,maximum-scale=1.0, user-scalable=no&amp;quot;/&amp;gt;
&amp;lt;!-- 
  viewport参数详解：
  width：宽度（数值 / device-width）（默认为980 像素）
  height：高度（数值 / device-height）
  initial-scale：初始的缩放比例 （范围从&amp;gt;0 到10）
  minimum-scale：允许用户缩放到的最小比例
  maximum-scale：允许用户缩放到的最大比例
  user-scalable：用户是否可以手动缩 (no,yes)
 --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-http-equiv属性&#34;&gt;3. http-equiv属性&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- expires指定网页的过期时间。一旦网页过期，必须从服务器上下载。 --&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;expires&amp;quot; content=&amp;quot;Fri, 12 Jan 2020 18:18:18 GMT&amp;quot;/&amp;gt;
&amp;lt;!-- 等待一定的时间刷新或跳转到其他url。下面1表示1秒 --&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;refresh&amp;quot; content=&amp;quot;1; url=https://www.baidu.com&amp;quot;/&amp;gt;
&amp;lt;!-- 禁止浏览器从本地缓存中读取网页，即浏览器一旦离开网页在无法连接网络的情况下就无法访问到页面。 --&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;pragma&amp;quot; content=&amp;quot;no-cache&amp;quot;/&amp;gt;
&amp;lt;!-- 也是设置cookie的一种方式，并且可以指定过期时间 --&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;set-cookie&amp;quot; content=&amp;quot;name=value expires=Fri, 12 Jan 2001 18:18:18 GMT,path=/&amp;quot;/&amp;gt;
&amp;lt;!-- 使用浏览器版本 --&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=edge,chrome=1&amp;quot; /&amp;gt;
&amp;lt;!-- 针对WebApp全屏模式，隐藏状态栏/设置状态栏颜色，content的值为default | black | black-translucent --&amp;gt;
&amp;lt;meta name=&amp;quot;apple-mobile-web-app-status-bar-style&amp;quot; content=&amp;quot;black-translucent&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-a标签实现打电话&#34;&gt;5. a标签实现打电话&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;最常用WEB页面JS实现一键拨号的电话拨打功能：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;tel:13764567708&amp;quot;&amp;gt;移动WEB页面JS一键拨打号码咨询功能&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在拨号界面，显示号码，并提示拨打。支持大部分的浏览器，但是在QQ浏览器上支持不好。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;最常用WEB页面JS实现一键发送短信功能：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;sms:13764567708&amp;quot;&amp;gt;移动WEB页面JS一键发送短信咨询功能&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在信息录入界面，显示发送号码，并提示录入信息。&lt;/p&gt;
&lt;p&gt;支持大部分的浏览器，但是在QQ浏览器上支持不好。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;最常用WEB页面发邮件：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;mailto:youemail@mail.com?subject=邮件标题&amp;amp;body=邮件内容&amp;quot;&amp;gt;告诉我们&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-css哪些属性可以继承&#34;&gt;6. CSS哪些属性可以继承？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;css继承特性主要是指文本方面的继承，盒模型相关的属性基本没有继承特性&lt;/strong&gt;。&lt;br&gt;
&lt;code&gt;不可继承的&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、top、bottom、left、right、z-index、float、clear、 table-layout、vertical-align、page-break-after&lt;/p&gt;
&lt;p&gt;&lt;code&gt;所有元素可继承的&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;visibility和cursor&lt;/p&gt;
&lt;p&gt;&lt;code&gt;终极块级元素可继承的&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;text-indent和text-align&lt;/p&gt;
&lt;p&gt;&lt;code&gt;内联元素可继承的&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction&lt;/p&gt;
&lt;p&gt;&lt;code&gt;列表元素可继承的&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;list-style、list-style-type、list-style-position、list-style-image&lt;/p&gt;
&lt;h2 id=&#34;7-windowscroll方法&#34;&gt;7. window.scroll方法&lt;/h2&gt;
&lt;h3 id=&#34;1-windowscroll到&#34;&gt;1. window.scroll（到）&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618490087718.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2windowscrollto&#34;&gt;2.window.scrollTo&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618490106662.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;与scroll一样&lt;/p&gt;
&lt;h3 id=&#34;3-windowscrollby距离&#34;&gt;3. window.scrollBy（距离）&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1618490176094.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;8-head头包含哪些标签&#34;&gt;8. head头包含哪些标签？&lt;/h2&gt;
&lt;p&gt;head标签是所有头部元素的容器。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;head&amp;gt;内的元素可包含脚本，指示浏览器在何处可以找到样式表，提供元信息等。
可添加到head部分的标签：&amp;lt;title&amp;gt;、&amp;lt;base&amp;gt;、&amp;lt;meta&amp;gt;、&amp;lt;link&amp;gt;、&amp;lt;script&amp;gt;、&amp;lt;style&amp;gt;:
&amp;lt;title&amp;gt;：指定整个网页的标题，在浏览器最上方显示。
&amp;lt;base&amp;gt;:为页面上的所有链接规定默认地址或默认目标(target)。
&amp;lt;meta&amp;gt;：提供有关页面的基本信息。
&amp;lt;link&amp;gt;：定义文档与外部资源的关系。
&amp;lt;script&amp;gt;:定义客户端脚本，如JavaScript。
&amp;lt;style&amp;gt;:定义内部样式表与网页的关系。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;17-window的onload事件和domcontentloaded&#34;&gt;17. window的onload事件和domcontentloaded&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;DOMContentLoaded方法是当DOM加载完成，不包括样式表，图片，flash触发的事件&lt;/li&gt;
&lt;li&gt;onload事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了，用于检测一个加载完全的页面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开发中我们经常需要给一些元素的事件绑定处理函数。但问题是，如果那个元素还没有加载到页面上，但是绑定事件已经执行完了，是没有效果的。这两个事件大致就是用来避免这样一种情况，将绑定的函数放在这两个事件的回调中，保证能在页面的某些元素加载完毕之后再绑定事件的函数。&lt;/p&gt;
&lt;p&gt;当然DOMContentLoaded机制更加合理，因为我们可以容忍图片，flash延迟加载，却不可以容忍看见内容后页面不可交互。&lt;/p&gt;
&lt;h1 id=&#34;18-forin迭代和forof有什么区别&#34;&gt;18. for...in迭代和for...of有什么区别&lt;/h1&gt;
&lt;h2 id=&#34;1-forin&#34;&gt;1. for…in&lt;/h2&gt;
&lt;p&gt;for…in 循环返回的值是数据的结构的&lt;strong&gt;key&lt;/strong&gt;(类比键值名)&lt;br&gt;
&lt;code&gt;遍历对象&lt;/code&gt;返回的对象&lt;code&gt;key&lt;/code&gt;值，&lt;code&gt;遍历数组&lt;/code&gt;返回的数组的&lt;code&gt;下标&lt;/code&gt;（key）&lt;br&gt;
for…in 不仅可以遍历数字 键名，还会遍历原型上的值和手动添加其他的键&lt;br&gt;
for…in 循环出的是（key）&lt;br&gt;
总结：&lt;br&gt;
for…in 循环特别适合遍历对象&lt;/p&gt;
&lt;h2 id=&#34;2-forof&#34;&gt;2. for…of&lt;/h2&gt;
&lt;p&gt;for…of 是ES6新引入的特性。修复了ES5引入的for…in的不足支持set().map()&lt;br&gt;
for…of不能循环普通的对象，需要通过和OBject.Keys()搭配使用&lt;br&gt;
for…of不同与forEach&lt;br&gt;
它可以与break.continue和return 配合使用&lt;br&gt;
for…of 循环可以随时推出循环&lt;br&gt;
for…of 循环出的是（&lt;strong&gt;value&lt;/strong&gt;）&lt;br&gt;
总结：&lt;br&gt;
for…of 循环特别适合&lt;code&gt;遍历数组&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;19-函数柯里化-和-高阶函数&#34;&gt;19. 函数柯里化 和 高阶函数&lt;/h1&gt;
&lt;h2 id=&#34;1-函数柯里化&#34;&gt;1. 函数柯里化&lt;/h2&gt;
&lt;p&gt;柯里化，是函数式编程的一个重要概念。它既能减少代码冗余，也能增加可读性。&lt;br&gt;
&lt;strong&gt;定义&lt;/strong&gt;：在数学和计算机科学中，柯里化是一种将使用&lt;strong&gt;多个参数&lt;/strong&gt;的一个函数转换成一系列使用&lt;strong&gt;一个参数&lt;/strong&gt;的函数的技术。&lt;br&gt;
&lt;code&gt;简单版：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function add(a) {
  function sum(b) { // 使用闭包
      a = a + b; // 累加
      return sum;
   }
   sum.toString = function() { // 重写toString()方法
      return a;
  }
   return sum; // 返回一个函数
}

add(1); // 1
add(1)(2);  // 3
add(1)(2)(3) // 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;完整版：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function add() {
  // 第一次执行时，定义一个数组专门用来存储所有的参数
  var _args = [].slice.call(arguments);

  // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值
  var adder = function () {
      var _adder = function() {
          _args.push(...arguments);
          return _adder;
      };

      // 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回
      _adder.toString = function () {
          return _args.reduce(function (a, b) {
              return a + b;
          });
      }

      return _adder;
  }
  return adder(..._args);
}

var a = add(1)(2)(3)(4);   // f 10
var b = add(1, 2, 3, 4);   // f 10
var c = add(1, 2)(3, 4);   // f 10
var d = add(1, 2, 3)(4);   // f 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数的柯里化，是 Javascript 中函数式编程的一个重要概念。&lt;code&gt;它返回的，是一个函数的函数&lt;/code&gt;。其实现方式，需要依赖&lt;code&gt;参数以及递归&lt;/code&gt;，通过&lt;code&gt;拆分参数&lt;/code&gt;的方式，来调用一个多参数的函数方法，以达到减少代码冗余，增加可读性的目的。&lt;/p&gt;
&lt;h2 id=&#34;2-高阶函数&#34;&gt;2. 高阶函数&lt;/h2&gt;
&lt;h3 id=&#34;1-arrayprototypemap&#34;&gt;1. Array.prototype.map&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;map()&lt;/code&gt;(映射)方法最后生成一个新数组，不改变原始数组的值。其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array.map(callback,[ thisObject]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;callback(回调函数)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[].map(function(currentValue, index, array) {
    // ...
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传递给&lt;code&gt;map&lt;/code&gt;的回调函数（&lt;code&gt;callback&lt;/code&gt;）接受三个参数，分别是&lt;code&gt;currentValue&lt;/code&gt;——正在遍历的元素；&lt;code&gt;index&lt;/code&gt;（可选）——元素索引；&lt;code&gt;array&lt;/code&gt;（可选）——原数组本身，除了 callback 之外还可以接受 this 值（可选），用于执行 callback 函数时使用的this 值。&lt;/p&gt;
&lt;p&gt;来个简单的例子方便理解，现在有一个数组[1,2,3,4]，我们想要生成一个新数组，其每个元素皆是之前数组的两倍&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const arr1 = [1, 2, 3, 4];
const arr2 = arr1.map(item =&amp;gt; item * 2);

console.log( arr2 );
// [2, 4, 6, 8]
console.log( arr1 );
// [1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;map高阶函数注意点&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;callback需要有return值，否则会出现所有项映射为undefind；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;].map(parseInt);
//输出结果为  [1,NaN,NaN]

[&amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;3&amp;quot;].map(x=&amp;gt;parseInt(x));
//输出结果为  [1,2,3]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-arrayprototypereduce&#34;&gt;2. Array.prototype.reduce&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;reduce()&lt;/code&gt;方法对数组中的每个元素执行一个提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值。传递给 reduce 的回调函数（callback）接受四个参数，分别是累加器 &lt;code&gt;accumulator&lt;/code&gt;；&lt;code&gt;currentValue&lt;/code&gt;——正在操作的元素；&lt;code&gt;currentIndex&lt;/code&gt;（可选）——元素索引，但是它的开始会有特殊说明；&lt;code&gt;array&lt;/code&gt;（可选）——原始数组本身，除了 callback 之外还可以接受初始值 initialValue 值（可选）。&lt;/p&gt;
&lt;p&gt;例子，现在有一个数组 [0, 1, 2, 3, 4]，需要计算数组元素的和，需求比较简单，来看下代码实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const arr = [0, 1, 2, 3, 4];
let sum = arr.reduce((accumulator, currentValue, currentIndex, array) =&amp;gt; {
  return accumulator + currentValue;
});

console.log( sum );
// 10
console.log( arr );
// [0, 1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;31&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1615256323803.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;3-arrayprototypefilter&#34;&gt;3. Array.prototype.filter&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;filter&lt;/code&gt;(过滤，筛选) 方法创建一个新数组,原始数组不发生改变。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array.filter(callback,[ thisObject]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接收的参数和 map 是一样的，filter的&lt;code&gt;callback&lt;/code&gt;函数需要返回布尔值true或false. 如果为true则表示通过啦！如果为false则失败，其返回值是一个新数组，由通过测试为true的所有元素组成，如果没有任何数组元素通过测试，则返回空数组。&lt;/p&gt;
&lt;p&gt;来个例子介绍下，现在有一个数组 [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]，我们想要生成一个新数组，这个数组要求没有重复的内容，即为去重。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const arr1 = [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4];
const arr2 = arr1.filter( (element, index, self) =&amp;gt; {
    return self.indexOf( element ) === index;
});

console.log( arr2 );
// [1, 2, 3, 5, 4]
console.log( arr1 );
// [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;20-call-与-apply区别原生实现bind&#34;&gt;20.  call 与 apply区别，原生实现bind&lt;/h1&gt;
&lt;h2 id=&#34;1-call-和-apply-的共同点&#34;&gt;1. call 和 apply 的共同点&lt;/h2&gt;
&lt;p&gt;它们的共同点是，都能够&lt;strong&gt;改变函数执行时的上下文&lt;/strong&gt;，将一个对象的方法交给另一个对象来执行，并且是立即执行的。&lt;/p&gt;
&lt;p&gt;为何要改变执行上下文？举一个生活中的小例子：平时没时间做饭的我，周末想给孩子炖个腌笃鲜尝尝。但是没有适合的锅，而我又不想出去买。所以就问邻居借了一个锅来用，这样既达到了目的，又节省了开支，一举两得。&lt;/p&gt;
&lt;p&gt;改变执行上下文也是一样的，A 对象有一个方法，而 B 对象因为某种原因，也需要用到同样的方法，那么这时候我们是单独为 B 对象扩展一个方法呢，还是借用一下 A 对象的方法呢？当然是借用 A 对象的啦，既完成了需求，又减少了内存的占用。&lt;/p&gt;
&lt;p&gt;另外，它们的写法也很类似，&lt;strong&gt;调用 call 和 apply 的对象，必须是一个函数 Function&lt;/strong&gt;。接下来，就会说到具体的写法，那也是它们区别的主要体现。&lt;/p&gt;
&lt;h2 id=&#34;2-call-和-apply-的区别&#34;&gt;2. call 和 apply 的区别&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;call 的写法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Function.call(obj,[param1[,param2[,…[,paramN]]]])
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;调用 call 的对象，必须是个函数 Function。&lt;/li&gt;
&lt;li&gt;call 的第一个参数，是一个对象。 Function 的调用者，将会指向这个对象。如果不传，则默认为全局对象 window。&lt;/li&gt;
&lt;li&gt;第二个参数开始，可以接收任意个参数。每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;function func (a,b,c) {}

func.call(obj, 1,2,3)
// func 接收到的参数实际上是 1,2,3

func.call(obj, [1,2,3])
// func 接收到的参数实际上是 [1,2,3],undefined,undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;apply 的写法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Function.apply(obj[,argArray])
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;它的调用者必须是函数 Function，并且只接收两个参数，第一个参数的规则与 call 一致。&lt;/li&gt;
&lt;li&gt;第二个参数，必须是数组或者类数组，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。这也是 call 和 apply 之间，很重要的一个区别。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;func.apply(obj, [1,2,3])
// func 接收到的参数实际上是 1,2,3

func.apply(obj, {
    0: 1,
    1: 2,
    2: 3,
    length: 3
})
// func 接收到的参数实际上是 1,2,3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;类数组无法使用 forEach、splice、push 等数组原型链上的方法&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-call-和-apply-的用途&#34;&gt;3 call 和 apply 的用途&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;call 的使用场景&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;对象的继承&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;function superClass () {
    this.a = 1;
    this.print = function () {
        console.log(this.a);
    }
}

function subClass () {
    superClass.call(this);
    this.print();
}

subClass();
// 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;subClass 通过 call 方法，继承了 superClass 的 print 方法和 a 变量。此外，subClass 还可以扩展自己的其他方法。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;借用方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;let domNodes = Array.prototype.slice.call(document.getElementsByTagName(&amp;quot;*&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;apply 的一些妙用&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Math.max&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;let max = Math.max.apply(null, array);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同理，要获取数组中最小的一项，可以这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let min = Math.min.apply(null, array);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;实现两个数组合并&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];

Array.prototype.push.apply(arr1, arr2);
console.log(arr1); // [1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-bind-的使用&#34;&gt;4. bind 的使用&lt;/h2&gt;
&lt;p&gt;bind() 方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。&lt;/p&gt;
&lt;p&gt;它的语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Function.bind(thisArg[, arg1[, arg2[, ...]]])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bind 方法 与 apply 和 call 比较类似，也能改变函数体内的 this 指向。不同的是，&lt;code&gt;bind 方法的返回值是函数，并且需要稍后调用，才会执行&lt;/code&gt;。而 apply 和 call 则是&lt;code&gt;立即调用&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;来看下面这个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function add (a, b) {
    return a + b;
}

function sub (a, b) {
    return a - b;
}

add.bind(sub, 5, 3); // 这时，并不会返回 8
add.bind(sub, 5, 3)(); // 调用后，返回 8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果 bind 的第一个参数是 null 或者 undefined，this 就指向全局对象 window。&lt;/p&gt;
&lt;h2 id=&#34;5-总结&#34;&gt;5. 总结&lt;/h2&gt;
&lt;p&gt;call 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。&lt;/p&gt;
&lt;p&gt;bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;原生实现bind函数&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 原生js实现bind函数
// 所有的函数都要有bind方法，所以要定义在Function的原型对象上
Function.prototype.myBind = function(objThis,...params){
    // objThis是要绑定的this对象，...params是因为参数数量不确定才用解构语法
    const thisFn = this;//当前调用的函数，例如fn.myBind()就把fn保存到thisFn
    let funcForBind = function(...secondParams){ // 要返回的函数
        // 判断函数是否是用new function生成的
        const isNew = this instanceof funcForBind
        const thisArg = isNew?this:objThis //this的指向
        // 绑定好this和参数返回到外层，暂时用call绑定，call也可以原生实现
        return thisFn.call(thisArg,...params,...secondParams)
    }
    // 绑定原型
    funcForBind.prototype = Object.create(thisFn)
    return funcForBind //返回绑定好的函数
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;21-立即执行函数和使用场景与闭包结合&#34;&gt;21. 立即执行函数和使用场景（与闭包结合）&lt;/h1&gt;
&lt;h2 id=&#34;1-什么是立即执行函数&#34;&gt;1. 什么是立即执行函数？&lt;/h2&gt;
&lt;p&gt;声明一个函数，并马上调用这个匿名函数就叫做立即执行函数；也可以说立即执行函数是一种语法，让你的函数在定义以后立即执行；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1615271995138.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-立即执行函数的写法&#34;&gt;2. 立即执行函数的写法：&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;(function(){
//code
}())

(function (){
//code
})()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上边的两种写法，都是以圆括号开头，引擎会意味后面跟的是表达式，而不是一个函数定义语句，所以就避免了错误，这就叫做&amp;quot;立即调用的函数表达式&amp;quot;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(function () {alert(&amp;quot;我是匿名函数&amp;quot;)}())   //用括号把整个表达式包起来
(function () {alert(&amp;quot;我是匿名函数&amp;quot;)})()  //用括号把函数包起来
!function () {alert(&amp;quot;我是匿名函数&amp;quot;)}()  //求反，我们不在意值是多少，只想通过语法检查
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-立即执行函数的作用&#34;&gt;3. 立即执行函数的作用：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不必为函数命名，避免了污染全局变量&lt;/li&gt;
&lt;li&gt;立即执行函数内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量&lt;/li&gt;
&lt;li&gt;封装变量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总而言之：&lt;strong&gt;立即执行函数会形成一个单独的作用域，我们可以封装一些临时变量或者局部变量，避免污染全局变量&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-使用场景&#34;&gt;4. 使用场景&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;怎样使以下alert的结果为0,1,2：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;ul id=&amp;quot;list&amp;quot;&amp;gt;
        &amp;lt;li&amp;gt;公司简介&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;联系我们&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;营销网络&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
    &amp;lt;script&amp;gt;
       var list = document.getElementById(&amp;quot;list&amp;quot;);
      var li = list.children;
      for(var i = 0 ;i&amp;lt;li.length;i++){
       ( function(j){
            li[j].onclick = function(){
              alert(j);
          })(i); //把实参i赋值给形参j
        }
      }
     &amp;lt;/script&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结合闭包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (var i = 1; i &amp;lt;= 5; i++) {
  (function(j) {
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })(i);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;如何避免了污染全局变量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;某些代码只需要执行一次，比如只需要显示一个时间，但是这些代码也需要一些临时的变量，但是初始化过程结束之后，就再也不会被用到，如果将这些变量作为全局变量，不是一个好的主意，我们可以用立即执行函数——去将我们所有的代码包裹在它的局部作用域中，不会让任何变量泄露成全局变量，看如下代码：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1615273235393.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
比如上面的代码，如果没有被包裹在立即执行函数中，而是直接以非函数的形式直接写在&amp;lt;script&amp;gt;&lt;/script&gt;标签里面，虽然也会立即执行，但是临时变量todaydom,days,today,year,month,date,day,msg都将成为全局变量（初始化代码遗留的产物）。&lt;br&gt;
而用立即执行函数之后，这些变量都不会在全局变量中存在，以后也不会其他地方使用，有效的避免了污染全局变量。&lt;/p&gt;
&lt;h1 id=&#34;22-设计模式要求说出如何实现应用优缺点单例模式实现&#34;&gt;22. 设计模式(要求说出如何实现,应用,优缺点)/单例模式实现&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;32&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1615273736555.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;0-为什么要用设计模式&#34;&gt;0. 为什么要用设计模式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;高内聚低耦合!!&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计模式是一种代码设计思路，其最最本质的目的是为了解耦，延伸一点的话，还有为了可扩展性和健壮性，但是这都是建立在解耦的基础之上。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-高内聚&#34;&gt;1. 高内聚&lt;/h3&gt;
&lt;p&gt;系统中A、B两个模块进行交互，如果修改了A模块，不影响模块B的工作，那么认为A是高度内聚的。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619618717519.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-低耦合&#34;&gt;2. 低耦合&lt;/h3&gt;
&lt;p&gt;那么当B发生改变时，A模块仍然可以正常工作，那么就认为A与B是低耦合的。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619620950653.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;所以解耦，本质上就是让不同的代码块各司其职，互不干扰&lt;/strong&gt;！&lt;/p&gt;
&lt;h2 id=&#34;1-创建型模式&#34;&gt;1. 创建型模式&lt;/h2&gt;
&lt;h3 id=&#34;1-工厂模式&#34;&gt;1. 工厂模式&lt;/h3&gt;
&lt;p&gt;工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象，用工厂方法代替new操作的一种模式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Animal(opts){
    var obj = new Object();
    obj.color = opts.color;
    obj.name= opts.name;
    obj.getInfo = function(){
        return &#39;名称：&#39;+ onj.name+&#39;， 颜色：&#39;+ obj.color;
    }
    return obj;
}
var cat = Animal({name: &#39;波斯猫&#39;, color: &#39;白色&#39;});
cat.getInfo();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;小结:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造函数和创建者分离，对new操作进行封装&lt;/li&gt;
&lt;li&gt;符合开放封闭原则&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-单例模式&#34;&gt;2. 单例模式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1615274155679.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var Single = (function(){
    var instance;
    function init() {
        // 定义私有方法和属性
        // 操作逻辑
        return {
           // 定义公共方法和属性
        };
    }
    return {
        // 获取实例
        getInstance:function(){
            if(!instance){
                instance = init();
            }
            return instance;
        }
    }
})();

var obj1 = Single.getInstance();
var obj2 = Single.getInstance();
console.log(obj1 === obj2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;小结:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单例模式的主要思想就是，实例如果已经创建，则直接返回&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;function creatSingleton() {
    var obj = null
    // 实例如已经创建过，直接返回
    if (!obj) {
        obj = xxx
    }
    return obj
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;符合开放封闭原则&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-原型模式&#34;&gt;3. 原型模式&lt;/h3&gt;
&lt;p&gt;用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。&lt;/p&gt;
&lt;p&gt;在JavaScript中，实现原型模式是在ECMAScript5中，提出的Object.create方法，使用现有的对象来提供新创建的对象的__proto__。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var prototype = {
    name: &#39;Jack&#39;,
    getName: function() {
        return this.name
    }
}

var obj = Object.create(prototype, {
    job: {
        value: &#39;IT&#39;
    }
})

console.log(obj.getName())  // Jack
console.log(obj.job)  // IT
console.log(obj.__proto__ === prototype)  //true
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-结构型模式&#34;&gt;2. 结构型模式&lt;/h2&gt;
&lt;h3 id=&#34;1-适配器模式&#34;&gt;1. 适配器模式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;33&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1615274391311.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;class GooleMap {
    show() {
        console.log(&#39;渲染谷歌地图&#39;)
    }
}

class BaiduMap {
    display() {
        console.log(&#39;渲染百度地图&#39;)
    }
}


// 定义适配器类, 对BaiduMap类进行封装
class BaiduMapAdapter {
    show() {
        var baiduMap = new BaiduMap()
        return baiduMap.display() 
    }
}

function render(map) {
    if (map.show instanceof Function) {
        map.show()
    }
}

render(new GooleMap())         // 渲染谷歌地图
render(new BaiduMapAdapter())  // 渲染百度地图
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;小结:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;适配器模式主要解决两个接口之间不匹配的问题，不会改变原有的接口，而是由一个对象对另一个对象的包装。&lt;/li&gt;
&lt;li&gt;适配器模式符合开放封闭原则&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-行为型模式&#34;&gt;3. 行为型模式&lt;/h2&gt;
&lt;h3 id=&#34;1-观察者模式订阅-发布模式&#34;&gt;1. 观察者模式(订阅-发布模式)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1615274507790.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;发布者发出通知 =&amp;gt;主题对象收到通知并推送给订阅者 =&amp;gt; 订阅者执行相应的操作。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; // 一个发布者 publisher，功能就是负责发布消息 - publish
        var pub = {
            publish: function () {
                dep.notify();
            }
        }
        // 多个订阅者 subscribers， 在发布者发布消息之后执行函数
        var sub1 = { 
            update: function () {
                console.log(1);
            }
        }
        var sub2 = { 
            update: function () {
                console.log(2);
            }
        }
        var sub3 = { 
            update: function () {
                console.log(3);
            }
        }
        // 一个主题对象
        function Dep() {
            this.subs = [sub1, sub2, sub3];
        }
        Dep.prototype.notify = function () {
            this.subs.forEach(function (sub) {
                sub.update();
            });
        }

        // 发布者发布消息， 主题对象执行notify方法，进而触发订阅者执行Update方法
        var dep = new Dep();
        pub.publish();
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;23-iframe的缺点有哪些&#34;&gt;23. iframe的缺点有哪些&lt;/h1&gt;
&lt;h2 id=&#34;1-iframe的优点&#34;&gt;1. iframe的优点：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;iframe能够原封不动的把嵌入的网页展现出来。&lt;/li&gt;
&lt;li&gt;如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。&lt;/li&gt;
&lt;li&gt;网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。&lt;/li&gt;
&lt;li&gt;如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-iframe的缺点&#34;&gt;2. iframe的缺点：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;会产生很多页面，&lt;code&gt;不容易管理&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，&lt;code&gt;用户体验度差&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会&lt;code&gt;不利于搜索引擎优化&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;很多的移动设备（PDA手机）无法完全显示框架，&lt;code&gt;设备兼容性差&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;iframe框架页面会&lt;code&gt;增加服务器的http请求&lt;/code&gt;，对于大型网站是不可取的。&lt;br&gt;
分析了这么多，现在基本上都是用&lt;code&gt;Ajax来代替iframe&lt;/code&gt;，所以iframe已经渐渐的退出了前端开发。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;24-数组问题&#34;&gt;24. 数组问题&lt;/h1&gt;
&lt;h2 id=&#34;1-数组去重&#34;&gt;1. 数组去重&lt;/h2&gt;
&lt;h3 id=&#34;1-利用es6-set去重es6中最常用&#34;&gt;1. 利用ES6 Set去重（ES6中最常用）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function unique (arr) {
  return Array.from(new Set(arr))
}
var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,{},{}];
console.log(unique(arr))
 //[1, &amp;quot;true&amp;quot;, true, 15, false, undefined, null, NaN, &amp;quot;NaN&amp;quot;, 0, &amp;quot;a&amp;quot;, {}, {}]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不考虑兼容性，这种去重的方法代码最少。这种方法还无法去掉“{}”空对象，后面的高阶方法会添加去掉重复“{}”的方法。&lt;/p&gt;
&lt;h3 id=&#34;2-利用for嵌套for然后splice去重es5中最常用&#34;&gt;2. 利用for嵌套for，然后splice去重（ES5中最常用）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function unique(arr){            
  for(var i=0; i&amp;lt;arr.length; i++){
      for(var j=i+1; j&amp;lt;arr.length; j++){
          if(arr[i]===arr[j]){         //第一个等同于第二个，splice方法删除第二个
              arr.splice(j,1);
              j--;
          }
      }
  }
return arr;
}
var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,{},{}];
console.log(unique(arr))
//  [1, &#39;true&#39;,true, 15,false,undefined,null, NaN,NaN, &#39;NaN&#39;,0, &#39;a&#39;,{}, {}]  //NaN和{}没有去重
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。&lt;/p&gt;
&lt;h3 id=&#34;3-利用indexof去重&#34;&gt;3. 利用indexOf去重&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function unique(arr) {
  if (!Array.isArray(arr)) {
      console.log(&#39;type error!&#39;)
      return
  }
  var array = [];
  for (var i = 0; i &amp;lt; arr.length; i++) {
      if (array .indexOf(arr[i]) === -1) {
          array .push(arr[i])
      }
  }
  return array;
}
var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,{},{}];
console.log(unique(arr))
 // [1, &amp;quot;true&amp;quot;, true, 15, false, undefined, null, NaN, NaN, &amp;quot;NaN&amp;quot;, 0, &amp;quot;a&amp;quot;, {…}, {…}]  //NaN、{}没有去重
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组。&lt;/p&gt;
&lt;h3 id=&#34;4-利用sort&#34;&gt;4. 利用sort()&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function unique(arr) {
  if (!Array.isArray(arr)) {
      console.log(&#39;type error!&#39;)
      return;
  }
  arr = arr.sort()
  var arrry= [arr[0]];
  for (var i = 1; i &amp;lt; arr.length; i++) {
      if (arr[i] !== arr[i-1]) {
          arrry.push(arr[i]);
      }
  }
  return arrry;
}
   var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,{},{}];
      console.log(unique(arr))
// [0, 1, 15, &amp;quot;NaN&amp;quot;, NaN, NaN, {…}, {…}, &amp;quot;a&amp;quot;, false, null, true, &amp;quot;true&amp;quot;, undefined]      //NaN、{}没有去重
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对。&lt;/p&gt;
&lt;h3 id=&#34;5-利用includes&#34;&gt;5. 利用includes&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log(&#39;type error!&#39;)
        return
    }
    var array =[];
    for(var i = 0; i &amp;lt; arr.length; i++) {
            if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值
                    array.push(arr[i]);
              }
    }
    return array
}
var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,{},{}];
    console.log(unique(arr))
    //[1, &amp;quot;true&amp;quot;, true, 15, false, undefined, null, NaN, &amp;quot;NaN&amp;quot;, 0, &amp;quot;a&amp;quot;, {…}, {…}]     //{}没有去重
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6-利用filter&#34;&gt;6. 利用filter&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function unique(arr) {
  return arr.filter(function(item, index, arr) {
    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素
    return arr.indexOf(item, 0) === index;
  });
}
    var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,{},{}];
        console.log(unique(arr))
//[1, &amp;quot;true&amp;quot;, true, 15, false, undefined, null, &amp;quot;NaN&amp;quot;, 0, &amp;quot;a&amp;quot;, {…}, {…}]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;7-利用map数据结构去重&#34;&gt;7. 利用Map数据结构去重&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function arrayNonRepeatfy(arr) {
  let map = new Map();
  let array = new Array();  // 数组用于返回结果
  for (let i = 0; i &amp;lt; arr.length; i++) {
    if(map.has(arr[i])) {  // 如果有该key值
      map.set(arr[i], true); 
    } else { 
      map.set(arr[i], false);   // 如果没有该key值
      array.push(arr[i]);
    }
  } 
  return array ;
}
 var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,{},{}];
    console.log(arrayNonRepeatfy(arr))
//[1, &amp;quot;a&amp;quot;, &amp;quot;true&amp;quot;, true, 15, false, 1, {…}, null, NaN, NaN, &amp;quot;NaN&amp;quot;, 0, &amp;quot;a&amp;quot;, {…}, undefined]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-数组常用方法&#34;&gt;2. 数组常用方法&lt;/h2&gt;
&lt;h3 id=&#34;1-arraymap&#34;&gt;1. Array.map()&lt;/h3&gt;
&lt;p&gt;此方法是将数组中的每个元素调用一个提供的函数，结果作为一个新的数组返回，并&lt;code&gt;没有改变原来的数组&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5]
    let newArr = arr.map(x =&amp;gt; x*2)
    //arr= [1, 2, 3, 4, 5]   原数组保持不变
    //newArr = [2, 4, 6, 8, 10] 返回新数组
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-arrayforeach&#34;&gt;2. Array.forEach()&lt;/h3&gt;
&lt;p&gt;此方法是将数组中的每个元素执行传进提供的函数，没有返回值，&lt;code&gt;改变原数组&lt;/code&gt;，注意和map方法区分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5]
   num.forEach(x =&amp;gt; x*2)
   // arr = [1, 2, 3, 4, 5]  数组改变,注意和map区分
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-arrayfilter&#34;&gt;3. Array.filter()&lt;/h3&gt;
&lt;p&gt;此方法是将所有元素进行判断，将满足条件的元素作为一个新的数组返回&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5]
    const isBigEnough = value =&amp;gt; value &amp;gt;= 3
    let newArr = arr.filter(isBigEnough )
    //newNum = [3, 4, 5] 满足条件的元素返回为一个新的数组
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-arrayevery&#34;&gt;4. Array.every()&lt;/h3&gt;
&lt;p&gt;此方法是将所有元素进行判断返回一个布尔值，如果&lt;code&gt;所有元素&lt;/code&gt;都满足判断条件，则返回true，否则为false：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5]
    const isLessThan4 = value =&amp;gt; value &amp;lt; 4
    const isLessThan6 =&amp;gt; value =&amp;gt; value &amp;lt; 6
    arr.every(isLessThan4 ) //false
    arr.every(isLessThan6 ) //true
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-arraysome&#34;&gt;5. Array.some()&lt;/h3&gt;
&lt;p&gt;此方法是将所有元素进行判断返回一个布尔值，如果&lt;code&gt;存在&lt;/code&gt;元素都满足判断条件，则返回true，若所有元素都不满足判断条件，则返回false：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr= [1, 2, 3, 4, 5]
    const isLessThan4 = value =&amp;gt; value &amp;lt; 4
    const isLessThan6 = value =&amp;gt; value &amp;gt; 6
    arr.some(isLessThan4 ) //true
    arr.some(isLessThan6 ) //false
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6-arrayreduce&#34;&gt;6. Array.reduce()&lt;/h3&gt;
&lt;p&gt;此方法是所有元素调用返回函数，返回值为最后结果,传入的值必须是函数类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5]
   const add = (a, b) =&amp;gt; a + b
   let sum = arr.reduce(add)
   //sum = 15  相当于累加的效果
   与之相对应的还有一个 Array.reduceRight() 方法，区别是这个是从右向左操作的
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;7-arraypush&#34;&gt;7. Array.push()&lt;/h3&gt;
&lt;p&gt;此方法是在数组的后面添加新加元素，此方法改变了数组的长度：&lt;/p&gt;
&lt;h3 id=&#34;8-arraypop&#34;&gt;8. Array.pop()&lt;/h3&gt;
&lt;p&gt;此方法在数组后面删除&lt;code&gt;最后一个元素&lt;/code&gt;，并返回数组，此方法改变了数组的长度：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5]
    arr.pop()
    console.log(arr) //[1, 2, 3, 4]
    console.log(arr.length) //4
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;9-arrayshift&#34;&gt;9. Array.shift()&lt;/h3&gt;
&lt;p&gt;此方法在数组后面删除&lt;code&gt;第一个元素&lt;/code&gt;，并返回数组，此方法改变了数组的长度：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5]
    arr.shift()
    console.log(arr) //[2, 3, 4, 5]
    console.log(arr.length) //4 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;10-arrayunshift&#34;&gt;10. Array.unshift()&lt;/h3&gt;
&lt;p&gt;此方法是将一个或多个元素添加到数组的开头，并返回新数组的长度：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5]
    arr.unshift(6, 7)
    console.log(arr) //[6, 7, 1, 2, 3, 4, 5]
    console.log(arr.length) //7 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;11-arrayisarray&#34;&gt;11. Array.isArray()&lt;/h3&gt;
&lt;p&gt;判断一个对象是不是数组，返回的是布尔值&lt;/p&gt;
&lt;h3 id=&#34;12-arrayconcat&#34;&gt;12. Array.concat()&lt;/h3&gt;
&lt;p&gt;此方法是一个可以将多个数组拼接成一个数组：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr1 = [1, 2, 3]
      arr2 = [4, 5]
  let arr = arr1.concat(arr2)
  console.log(arr)//[1, 2, 3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;13-arraytostring&#34;&gt;13. Array.toString()&lt;/h3&gt;
&lt;p&gt;此方法将数组转化为字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5];
   let str = arr.toString()
   console.log(str)// 1,2,3,4,5
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;14-arrayjoin&#34;&gt;14. Array.join()&lt;/h3&gt;
&lt;p&gt;此方法也是将数组转化为字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5];
  let str1 = arr.join()
  let str2 = arr.join(&#39;,&#39;)
  let str3 = arr.join(&#39;##&#39;)
  console.log(str1)// 1,2,3,4,5
  console.log(str2)// 1,2,3,4,5
  console.log(str3)// 1##2##3##4##5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;可以设置元素之间的间隔&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;15-arraysplice开始位置-删除的个数元素&#34;&gt;15. Array.splice(开始位置， 删除的个数，元素)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;万能方法，可以实现增删改：&lt;/strong&gt;&lt;code&gt;0增，3删，1改&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5];
     let arr1 = arr.splice(2, 0 &#39;haha&#39;)
     let arr2 = arr.splice(2, 3)
     let arr1 = arr.splice(2, 1 &#39;haha&#39;)
     console.log(arr1) //[1, 2, &#39;haha&#39;, 3, 4, 5]新增一个元素
     console.log(arr2) //[1, 2] 删除三个元素
     console.log(arr3) //[1, 2, &#39;haha&#39;, 4, 5] 替换一个元素
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-查找数组重复项&#34;&gt;3. 查找数组重复项&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;let arr= [1,2,3,4,5,1,2];
let rep = [];
arr.forEach((item,index)=&amp;gt;{
	if(arr.indexOf(item)!=index){ // 匹配数组元素第一个item位置和当前循环的index
        let obj = {};
        obj.key = (arr.indexOf(item) + 1) + &#39;|&#39; + (index + 1); // 用&#39;|&#39;分隔两个重复项的下标   
		obj.value = item;
        rep.push(obj);
	}
});
console.log(rep)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-扁平化数组flatten&#34;&gt;4. 扁平化数组（flatten）&lt;/h2&gt;
&lt;p&gt;扁平化就是将嵌套的数组变成一维数组的过程。&lt;/p&gt;
&lt;p&gt;通常有几种方法可以实现扁平化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;迭代递归法&lt;/li&gt;
&lt;li&gt;曲线救国法&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-迭代递归&#34;&gt;1. 迭代递归&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;var array = [[1,2,3],4,5,6,[[7]],[]]
var result = flatten(array)

console.log(result)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;for...of 实现&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function flatten(arr, result = []) {
    for (let item of arr) {
        if (Array.isArray(item))
            flatten(item, result)
        else
            result.push(item)
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们使用 result 变量存储结果，然后迭代当前数组，如果值也是数组则继续扁平化，否则将值放入 result 里。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;生成器实现&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;迭代器的升级版就是生成器（Generator），其实这种扁平化最适合用生成器来做了，因为我们的目的就是生成一个个的值，然后把它们组织成一维数组：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function* flat(arr) {
    for (let item of arr) {
        if (Array.isArray(item))
            yield* flat(item)
        else
            yield item
    }
}

function flatten(arr) {
    let result = []
    for (let val of flat(arr)) {
        result.push(val)
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里有两点需要注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;嵌套 yield 需要再加一个星号，这被称为生成器委托。&lt;/li&gt;
&lt;li&gt;不能使用 forEach 代替 for...of 但可以用 for 循环，因为 for 循环和for...of 可以中断迭代去执行 yield，forEach 不行&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;reduce 三句实现法&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function flatten(arr) {
  return arr.reduce((flat, toFlatten) =&amp;gt; {
    return flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten);
  }, []);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-曲线救国法&#34;&gt;2. 曲线救国法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;降维打击法&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function flatten(arr){
    let str = arr.toString()
    return str.split(&#39;,&#39;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;转成字符串，之后再复原成数组，不过这个方法有个缺点，就是原来的空数组转的空字符串也会被放入新生成的数组里去。&lt;/p&gt;
&lt;h1 id=&#34;25-dom和bom相关&#34;&gt;25. DOM和BOM相关&lt;/h1&gt;
&lt;h2 id=&#34;1dom&#34;&gt;1.DOM&lt;/h2&gt;
&lt;h3 id=&#34;1-dom是什么&#34;&gt;1. DOM是什么：&lt;/h3&gt;
&lt;p&gt;DOM（Document Object Model）&lt;code&gt;文档对象模型&lt;/code&gt;，是&lt;strong&gt;处理可扩展标志语言&lt;/strong&gt;的标准编程接口。&lt;/p&gt;
&lt;p&gt;DOM 是 &lt;strong&gt;W3C&lt;/strong&gt; 的标准&lt;/p&gt;
&lt;h3 id=&#34;2-dom0级和dom2级有什么区别&#34;&gt;2. DOM0级和DOM2级有什么区别：&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;DOM0&lt;/code&gt;级中为某个dom元素绑定多个事件时，只有最后一个事件有效。&lt;code&gt;onclick&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DOM2&lt;/code&gt;级中可以为单个元素绑定多个事件，每个事件都可以被触发。&lt;code&gt;addEventListener&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-textcontent-innertext-innnerhtml-value的区别&#34;&gt;3. textContent、innerText、innnerHTML、value的区别：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;textContent用来获取和设置文本内容，与innerText的差别是:&lt;code&gt;textContent&lt;/code&gt;获取到的内容包括了元素中的&lt;code&gt;style标签&lt;/code&gt;和&lt;code&gt;script标签&lt;/code&gt;的内容。&lt;/li&gt;
&lt;li&gt;innerText只能获取和设置&lt;code&gt;文本&lt;/code&gt;内容，不能获取和设置html代码&lt;/li&gt;
&lt;li&gt;innerHTML可以获取和设置&lt;code&gt;html&lt;/code&gt;代码&lt;/li&gt;
&lt;li&gt;value获取的是&lt;code&gt;表单元素&lt;/code&gt;的值&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-关于dom的api有什么&#34;&gt;4. 关于dom的api有什么：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;节点创建型api：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;document.createElement()&lt;/li&gt;
&lt;li&gt;document.createTextNode()&lt;/li&gt;
&lt;li&gt;parent.cloneNode(true)&lt;/li&gt;
&lt;li&gt;document.createDocumentFragment() &lt;code&gt;创建文档片段,解决大量添加节点造成的回流问题&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;页面修改型API：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;parent.appendChild(child)&lt;/li&gt;
&lt;li&gt;parent.insertBefore(newNode,referenceNode) &lt;code&gt;将新元素添加到父元素中指定的子元素前面&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;parent.removeChild(child)&lt;/li&gt;
&lt;li&gt;parent.replcaeChild(newChild,oldChild)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;节点查询型API：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;document.getElementById()&lt;/li&gt;
&lt;li&gt;document.getElementsByTagName() 返回的是一个即时的HTMLCollection类型&lt;/li&gt;
&lt;li&gt;document.getElementsByName() 根据指定的name属性获取元素,返回的是一个即时的NodeList&lt;/li&gt;
&lt;li&gt;document.getElementsByClassName() 返回的是一个即时的HTMLCollection&lt;/li&gt;
&lt;li&gt;document.querySelector() 获取匹配到的第一个元素，采用的是深度优先搜索。&lt;/li&gt;
&lt;li&gt;docuemnt.querySelectorAll()&lt;br&gt;
返回的是一个非即时的NodeList，也就是说结果不会随着文档树的变化而变化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;节点关系型api：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;父关系型：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;node.parentNode()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;兄弟关系型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;node.previouSibling() 返回节点的前一个节点（包括元素节点，文本节点，注释节点）&lt;/li&gt;
&lt;li&gt;node.previousElementSibling() 返回前一个元素节点&lt;/li&gt;
&lt;li&gt;node.nextSibling() 返回下一个节点&lt;/li&gt;
&lt;li&gt;node.nextElementSibling() 返回下一个元素节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;子关系型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;parent.childNodes() 返回一个即时的NodeList，包括了文本节点和注释节点&lt;/li&gt;
&lt;li&gt;parent.children() 一个即时的HTMLCollection，子节点都是Element&lt;/li&gt;
&lt;li&gt;parent.firsrtNode()&lt;/li&gt;
&lt;li&gt;parent.lastNode()&lt;/li&gt;
&lt;li&gt;hasChildNodes()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;元素属性型api：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;element.setAttribute(“name”,“value”) 为元素添加属性&lt;/li&gt;
&lt;li&gt;element.getAtrribute(“name”) 获取元素的属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;元素样式型api：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;window.getComputedStyle(element) 返回一个CSSStyleDeclaration,可以从中访问元素的任意样式属性。&lt;/li&gt;
&lt;li&gt;element.getBoundingClientRect() 返回一个DOMRect对象，里面&lt;strong&gt;包括了元素相对于可视区的位置top,left&lt;/strong&gt;,以及元素的大小,单位为纯数字。可用于判断某元素是否出现在了可视区域。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5什么是事件监听&#34;&gt;5.什么是事件监听:&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;addEventListener()方法&lt;/code&gt;，用于向指定元素添加事件句柄，它可以更简单的控制事件，语法为&lt;/p&gt;
&lt;p&gt;element.addEventListener(event, function, useCapture);&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个参数是事件的类型(如 “click” 或 “mousedown”).&lt;/li&gt;
&lt;li&gt;第二个参数是事件触发后调用的函数。&lt;/li&gt;
&lt;li&gt;第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事件传递有两种方式，&lt;code&gt;冒泡&lt;/code&gt;和&lt;code&gt;捕获&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;事件传递定义了元素事件触发的顺序，如果你将P元素插入到div元素中，用户点击P元素，&lt;/p&gt;
&lt;p&gt;在冒泡中，内部元素先被触发，然后再触发外部元素，&lt;br&gt;
捕获中，外部元素先被触发，在触发内部元素，&lt;/p&gt;
&lt;h3 id=&#34;6-说说前端中的事件流&#34;&gt;6. 说说前端中的事件流&lt;/h3&gt;
&lt;p&gt;事件发生时会在元素节点之间按照特定的顺序传播，整个过程分为&lt;code&gt;捕获阶段，目标阶段和冒泡阶段&lt;/code&gt;，这个&lt;code&gt;传播过程&lt;/code&gt;叫做Dom事件流。&lt;/p&gt;
&lt;p&gt;事件冒泡：从事件源逐级向上传播到DOM最顶层节点的过程。&lt;/p&gt;
&lt;p&gt;事件捕获：从DOM最顶层节点逐级向下传播到事件源的过程。&lt;/p&gt;
&lt;p&gt;addEventListener用于指定事件处理程序，共接收三个参数。分别是触发事件，事件处理程序函数以及一个布尔值。第三个参数默认为false，表示在该事件的处理函数会在冒泡阶段被调用。若改为true，则表示事件处理函数会在捕获阶段被调用。&lt;/p&gt;
&lt;h3 id=&#34;7-如何让事件先冒泡后捕获-2&#34;&gt;7. 如何让事件先冒泡后捕获&lt;/h3&gt;
&lt;p&gt;对于&lt;code&gt;目标元素&lt;/code&gt;来说，如果DOM节点通过addEventListener同时绑定了两个事件监听函数，一个用于捕获，一个用于冒泡，那么两个事件的执行顺序是按照代码添加的顺序执行的。所以，先绑定冒泡的函数，再绑定捕获的函数，即可实现。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;非目标元素&lt;/code&gt;来说，可以给捕获事件的处理程序添加一个定时器，将处理程序推入下一个宏任务执行。&lt;/p&gt;
&lt;h3 id=&#34;8-说一下事件代理&#34;&gt;8. 说一下事件代理：&lt;/h3&gt;
&lt;p&gt;事件委托是指 不在子节点单独设置事件监听器，而将事件&lt;code&gt;监听器设置在父节点上&lt;/code&gt;，再利用&lt;code&gt;冒泡原理&lt;/code&gt;使每一个子节点都能触发该事件。&lt;/p&gt;
&lt;p&gt;事件委托的优点：只操作一次Dom，提高了程序的性能。&lt;/p&gt;
&lt;p&gt;常用于&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ul和li标签的事件监听，一般采用事件委托机制将事件监听器绑定在ul上。&lt;/li&gt;
&lt;li&gt;还适合动态元素的绑定，新添加的子元素不需单独添加事件处理程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;（1）了解事件代理吗，这样做有什么好处&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事件代理就是说我们将事件添加到本来要添加的事件的父节点，将事件委托给父节点来触发处理函数，这通常会使用在大量的同级元素需要添加同一类事件的时候，比如一个动态的非常多的列表，需要为每个列表项都添加点击事件，这时就可以使用事件代理，通过判断e.target.nodeName来判断发生的具体元素，这样做的好处是减少事件绑定，同事动态的DOM结构任然可以监听，事件代理发生在冒泡阶段&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）事件代理在捕获阶段的实际应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以在父元素层面阻止事件向子元素传播，也可代替子元素执行某些操作。&lt;/p&gt;
&lt;h3 id=&#34;9-事件类型相关&#34;&gt;9. 事件类型相关：&lt;/h3&gt;
&lt;p&gt;（1）&lt;code&gt;mouseover和mouseenter的区别&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移出事件是mouseout。&lt;/li&gt;
&lt;li&gt;mouseenter：鼠标移入子元素时不会再次触发mouseenter事件，对应的移出事件是mouseleave。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（2）&lt;code&gt;三种键盘事件的区别：&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;keyup: 松开键盘触发&lt;/li&gt;
&lt;li&gt;keydown:按下键盘触发&lt;/li&gt;
&lt;li&gt;keypress:不能识别功能键，比如ctrl,alt,shift,左右箭头。可以区分大小写。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在输入框中按下一个键的全过程：触发keydown/keypress事件-&amp;gt;文字键入输入框中-&amp;gt;触发keyup事件&lt;/p&gt;
&lt;p&gt;按下按键后&lt;code&gt;自动对焦&lt;/code&gt;输入框，应该使用&lt;code&gt;keyup&lt;/code&gt;，不应该使用keydown/keypress,因为后者会使按键落入输入框中,对于回车键的话还不能使用keypress。&lt;/p&gt;
&lt;h3 id=&#34;10-静态绑定事件与动态绑定事件的区别&#34;&gt;10. 静态绑定事件与动态绑定事件的区别：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;静态绑定&lt;/strong&gt;事件是指直接在Html标签上通过οnclick=&amp;quot;hide()&amp;quot;来绑定事件。&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;html和js文件存在耦合，不符合结构和行为分离的原则。&lt;/li&gt;
&lt;li&gt;可能存在引发错误，如果js代码还没加载就触发该事件则会抛出错误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;动态绑定&lt;/strong&gt;事件是指通过js动态绑定事件，element.onclick() element.addEventListener()。&lt;/p&gt;
&lt;h3 id=&#34;11-元素的位置和大小&#34;&gt;11. 元素的位置和大小&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;① offset系列：&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;offsetTop（获取元素位置）: 相对于带有‘定位’的父元素的偏移量&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;offsetHeight: content+padding+border&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;② cilent系列：&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;clientHeight(获取元素宽高): content+padding,不包含border&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;③ scroll系列：&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;scrollTop（获取滚动的距离）&lt;/strong&gt;: 向下滚动后，上面被卷去的距离，即隐藏的高度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;④ document.clientWidth与document.style.width的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;区别1：前者可以获取任意样式表中的width样式值，包括行内样式的，内嵌样式的，外部样式的；后者只能获取行内的样式。&lt;/li&gt;
&lt;li&gt;区别2：clientWidth获取的是数字型的，style获取的带有px后缀&lt;/li&gt;
&lt;li&gt;区别3：clientWidth包含了padding,而style.width只包含content。&lt;/li&gt;
&lt;li&gt;区别4：clientWidth是只读属性，所以一般用于获取元素的大小；而style.width是可读可写的，可用于获取，也可用于修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;⑤ 判断一个元素是否已经出现在了可视区域：(此问题可应用在懒加载中)&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;使用element.getBoundingClientRect().top获取在可视区的位置。&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;window.addEventListener(&amp;quot;scroll&amp;quot;, function () {
    let viewPortHeight = window.pageYOffset;
    let offset = box2.getBoundingClientRect().top;
    if (offset &amp;lt; viewPortHeight) {
        if (offset + box2.offsetHeight &amp;lt; 0) {
            console.log(&amp;quot;他走了&amp;quot;);
        } else {
            console.log(&amp;quot;他来啦他来啦&amp;quot;);
        }
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;12-js拖动及拖拽功能的实现&#34;&gt;12. js拖动及拖拽功能的实现&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;（1）拖动功能的实现：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;前置条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;拖动事件的三个过程：鼠标按下mousedown,鼠标移动mousemove,鼠标松开mouseup&lt;br&gt;
鼠标按下后执行mousemove事件。&lt;/li&gt;
&lt;li&gt;盒子采用绝对定位，通过left和top属性来修改位置。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;方法一：（直接根据鼠标移动的距离确定元素移动的距离）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;鼠标的坐标通过clientX,clientY获取：&lt;/li&gt;
&lt;li&gt;盒子的定位信息：鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的offetLeft.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;（2）拖拽功能的实现：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用html5提供的拖拽API（Drag 和 drop）&lt;/p&gt;
&lt;h2 id=&#34;2-bom浏览器对象模型&#34;&gt;2. (BOM)浏览器对象模型：&lt;/h2&gt;
&lt;h3 id=&#34;1-实用的bom属性对象方法&#34;&gt;1. 实用的BOM属性对象方法：&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;location对象&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;location.href– 返回或设置当前文档的URL&lt;/li&gt;
&lt;li&gt;location.search – 返回URL中的查询字符串部分。例如 http://www.dreamdu.com/dreamdu.php?id=5&amp;amp;name=dreamdu 返回包括(?)后面的内容?id=5&amp;amp;name=dreamdu&lt;/li&gt;
&lt;li&gt;location.hash – 返回URL#后面的内容，如果没有#，返回空&lt;/li&gt;
&lt;li&gt;location. – 返回URL中的域名部分，例如www.dreamdu.com&lt;/li&gt;
&lt;li&gt;location.hostname – 返回URL中的主域名部分，例如dreamdu.com&lt;/li&gt;
&lt;li&gt;location.pathname – 返回URL的域名后的部分。例如 http://www.dreamdu.com/xhtml/ 返回/xhtml/&lt;/li&gt;
&lt;li&gt;location.port – 返回URL中的端口部分。例如 http://www.dreamdu.com:8080/xhtml/ 返回8080&lt;/li&gt;
&lt;li&gt;location.protocol – 返回URL中的协议部分。例如 http://www.dreamdu.com:8080/xhtml/ 返回(//)前面的内容http:&lt;/li&gt;
&lt;li&gt;location.assign() – 重定向页面，与location.href一样，会记录历史，能后退页面&lt;/li&gt;
&lt;li&gt;location.replace() – 设置当前文档的URL，不记录历史，不能后退页面&lt;/li&gt;
&lt;li&gt;location.reload() – 重载当前页面,相当于F5。添加参数true则表示强制刷新，直接从服务器获取数据，不从浏览器缓存中取数据，相当于Ctrl+F5&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;history对象&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;history.go(n) – 前进或后退指定的页面数;&lt;/li&gt;
&lt;li&gt;history.back() – 后退一页&lt;/li&gt;
&lt;li&gt;history.forward() – 前进一页&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;navigator对象&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;navigator包含了用户浏览器的信息&lt;/li&gt;
&lt;li&gt;navigator.userAgent – 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)&lt;/li&gt;
&lt;li&gt;navigator.cookieEnabled – 返回浏览器是否支持(启用)cookie&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-settimeoutfn100100毫秒是如何权衡的&#34;&gt;2. setTimeout(fn,100);100毫秒是如何权衡的：&lt;/h3&gt;
&lt;p&gt;100ms指的是将回调函数加入到任务队列所花的时间。至于具体什么时候执行，需要看主线程的执行栈中是否还有任务在执行。&lt;/p&gt;
&lt;h3 id=&#34;3-requestanimationframe&#34;&gt;3. requestAnimationFrame&lt;/h3&gt;
&lt;p&gt;特点：requestAnimationFrame采用系统时间间隔，保证了最佳的绘制效率。&lt;/p&gt;
&lt;p&gt;使用方法：requestAnimationFrame接收一个回调函数，这个回调函数会在下一次浏览器重绘之前调用。&lt;/p&gt;
&lt;h3 id=&#34;4-分别用setintervalsettimeoutrequestanimationframe制作有个简单的进度条效果&#34;&gt;4. 分别用setInterval,setTimeout,requestAnimationFrame制作有个简单的进度条效果：&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;setInterval:&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div
     style=&amp;quot;width: 0; height: 20px; background-color: orange&amp;quot;
     id=&amp;quot;div&amp;quot;
     &amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
    let timer = setInterval(() =&amp;gt; {
        if (parseInt(div.style.width) &amp;gt;= 500) {
            return clearInterval(timer);
        }
        console.log(div.style.width);
        div.style.width = parseInt(div.style.width) + 5 + &amp;quot;px&amp;quot;;
        div.innerHTML = parseInt(div.style.width) / 5 + &amp;quot;%&amp;quot;;
    }, 16);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;setTimeout:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div
     style=&amp;quot;width: 0; height: 20px; background-color: orange&amp;quot;
     id=&amp;quot;div&amp;quot;
     &amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
    let timer = setTimeout(function fn() {
        if (parseInt(div.style.width) &amp;lt; 500) {
            div.style.width = parseInt(div.style.width) + 5 + &amp;quot;px&amp;quot;;
            div.innerHTML = parseInt(div.style.width) / 5 + &amp;quot;%&amp;quot;;
            timer = setTimeout(fn, 16);
        } else {
            clearTimeout(timer);
        }
    }, 16);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;requestAnimationFrame:类似于setTimeout,需要一次次的调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div
     style=&amp;quot;width: 0; height: 20px; background-color: orange&amp;quot;
     id=&amp;quot;div&amp;quot;
     &amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
    let timer = requestAnimationFrame(function fn() {
        if (parseInt(div.style.width) &amp;lt; 500) {
            div.style.width = parseInt(div.style.width) + 5 + &amp;quot;px&amp;quot;;
            div.innerHTML = parseInt(div.style.width) / 5 + &amp;quot;%&amp;quot;;
            requestAnimationFrame(fn);
        } else {
            cancelAnimationFrame(timer);
        }
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-js中的轮播实现原理假如一个页面上有两个轮播你会怎么实现&#34;&gt;5. js中的轮播实现原理？假如一个页面上有两个轮播，你会怎么实现？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;让图片存在一个数组中，然后将最后一张图片重复添加在数组的头部，将第一张图片重复添加在数组的最后。&lt;/li&gt;
&lt;li&gt;然后准备一个只能显示一张图片的盒子，对盒子做溢出隐藏处理。&lt;/li&gt;
&lt;li&gt;通过定时器增减索引，显示对应的图片，实现轮播功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果有两个轮播，可封装一个轮播组件，将需要轮播的图片作为参数传递。&lt;/p&gt;
&lt;h1 id=&#34;26-服务端渲染server-side-render&#34;&gt;26. 服务端渲染（server side render）&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;服务端渲染(SSR)&lt;/code&gt;：页面上的内容是由服务器上的代码决定的。即，页面上的内容在服务器上已经生成好了，服务器把这个内容给到浏览器，浏览器拿到这个内容直接显示在页面上即可。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;客户端渲染(CSR)&lt;/code&gt; ：一个网页是由JS文件渲染出来的，而不是服务器直接返回回来的。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1615364099956.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-ssr的优势&#34;&gt;1. SSR的优势&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;更利于SEO&lt;br&gt;
服务端渲染返回给客户端的是已经获取了异步数据并执行JavaScript脚本的最终HTML，网络爬中就可以抓取到完整页面的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更利于首屏渲染&lt;br&gt;
首屏的渲染是node发送过来的html字符串，并不依赖于js文件了，这就会使用户更快的看到页面的内容。尤其是针对大型单页应用，打包后文件体积比较大，普通客户端渲染加载所有所需文件时间较长，首页就会有一个很长的白屏等待时间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-ssr的劣势&#34;&gt;2. SSR的劣势&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;服务端压力较大&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开发条件受限&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;学习成本相对较高&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;27-js-垃圾回收机制&#34;&gt;27.  JS 垃圾回收机制&lt;/h1&gt;
&lt;h2 id=&#34;1-垃圾回收&#34;&gt;1. 垃圾回收&lt;/h2&gt;
&lt;p&gt;JavaScript 中的内存管理是自动执行的，而且是不可见的。我们创建基本类型、对象、函数……所有这些都需要内存。&lt;/p&gt;
&lt;h2 id=&#34;2-可达性&#34;&gt;2. 可达性&lt;/h2&gt;
&lt;p&gt;JavaScript 中内存管理的主要概念是可达性。&lt;/p&gt;
&lt;p&gt;简单地说，“可达性” 值就是那些以某种方式&lt;code&gt;可访问&lt;/code&gt;或&lt;code&gt;可用&lt;/code&gt;的值，它们被保证存储在内存中。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有一组基本的固有可达值，由于显而易见的原因无法删除。例如:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;本地函数的局部变量和参数&lt;/li&gt;
&lt;li&gt;当前嵌套调用链上的其他函数的变量和参数&lt;/li&gt;
&lt;li&gt;全局变量&lt;/li&gt;
&lt;li&gt;还有一些其他的，内部的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;这些值称为根。&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;如果局部变量中有对象，并且该对象具有引用另一个对象的属性，则该对象被视为&lt;strong&gt;可达性&lt;/strong&gt;， 它引用的那些也是可以访问的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;下面是最简单的例子:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// user 具有对象的引用
let user = {
  name: &amp;quot;John&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1615366337580.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里箭头表示一个对象引用。全局变量&lt;code&gt;“user”&lt;/code&gt;引用对象 &lt;code&gt;{name:“John”}&lt;/code&gt;(为了简洁起见，我们将其命名为John)。John 的 &lt;code&gt;“name”&lt;/code&gt;属性存储一个基本类型，因此它被绘制在对象中。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;user&lt;/code&gt; 的值被覆盖，则引用丢失:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user = null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1615366388527.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
现在 John 变成不可达的状态，没有办法访问它，没有对它的引用。垃圾回收器将丢弃 John 数据并释放内存。&lt;/p&gt;
&lt;h2 id=&#34;3两个引用&#34;&gt;3.两个引用&lt;/h2&gt;
&lt;p&gt;现在让我们假设我们将引用从 &lt;code&gt;user&lt;/code&gt;复制到 &lt;code&gt;admin&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// user具有对象的引用
let user = {
  name: &amp;quot;John&amp;quot;
};
let admin = user;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1615366454334.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
现在如果我们做同样的事情:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user = null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该对象仍然可以通过 &lt;code&gt;admin&lt;/code&gt; 全局变量访问，所以它在内存中。如果我们也覆盖&lt;code&gt;admin&lt;/code&gt;，那么它可以被释放。&lt;/p&gt;
&lt;h2 id=&#34;4-相互关联的对象&#34;&gt;4. 相互关联的对象&lt;/h2&gt;
&lt;p&gt;现在来看一个更复杂的例子， family 对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function marry (man, woman) {
  woman.husban = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman
  }
}

let family = marry({
  name: &amp;quot;John&amp;quot;
}, {
  name: &amp;quot;Ann&amp;quot;
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;产生的内存结构:&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1615366611256.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
现在让我们删除两个引用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;delete family.father;
delete family.mother.husband;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1615366634406.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
仅仅删除这两个引用中的一个是不够的，因为所有对象仍然是可访问的。&lt;/p&gt;
&lt;p&gt;但是如果我们把这两个都删除，那么我们可以看到 John 不再有传入的引用:&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1615366651083.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
输出引用无关紧要。只有传入的对象才能使对象可访问，因此，John 现在是不可访问的，并将从内存中删除所有不可访问的数据。&lt;/p&gt;
&lt;p&gt;垃圾回收之后：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1615366668995.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;5-内部算法&#34;&gt;5. 内部算法&lt;/h2&gt;
&lt;p&gt;基本的垃圾回收算法称为“&lt;strong&gt;标记-清除&lt;/strong&gt;”，定期执行以下“垃圾回收”步骤:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;垃圾回收器获取根并“&lt;strong&gt;标记&lt;/strong&gt;”(记住)它们。&lt;/li&gt;
&lt;li&gt;然后它访问并“标记”所有来自它们的引用。&lt;/li&gt;
&lt;li&gt;然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。&lt;/li&gt;
&lt;li&gt;以此类推，直到有未访问的引用(可以从根访问)为止。&lt;/li&gt;
&lt;li&gt;除标记的对象外，所有对象都被删除。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如，对象结构如下:&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1615366772644.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
我们可以清楚地看到右边有一个“不可到达的块”。现在让我们看看“&lt;strong&gt;标记并清除&lt;/strong&gt;”垃圾回收器如何处理它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步标记根&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1615367324843.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;然后标记他们的引用&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1615367344647.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;以及子孙代的引用:&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1615367365917.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
现在进程中不能访问的对象被认为是不可访问的，将被删除:&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1615367388777.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;这就是垃圾收集的工作原理。JavaScript引擎应用了许多优化，使其运行得更快，并且不影响执行。&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;6面试怎么回答&#34;&gt;6.面试怎么回答&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1）问什么是垃圾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般来说没有被引用的对象就是垃圾，就是要被清除， 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）如何检垃圾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一种算法是标记 标记-清除 算法&lt;/p&gt;
&lt;h1 id=&#34;28-eventloop&#34;&gt;28. eventloop&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Event Loop&lt;/code&gt;即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用&lt;strong&gt;异步&lt;/strong&gt;的原理。&lt;/p&gt;
&lt;h2 id=&#34;1-进程和线程&#34;&gt;1. 进程和线程&lt;/h2&gt;
&lt;p&gt;线程，是程序执行流的最小单位。线程可与同属一个进程的其他线程共享所拥有的全部资源，同一进程中的多个线程之间可以并发执行。线程有&lt;code&gt;就绪&lt;/code&gt;，&lt;code&gt;阻塞&lt;/code&gt;，&lt;code&gt;运行&lt;/code&gt;三种基本状态。&lt;/p&gt;
&lt;p&gt;阮一峰大神针对进程和线程的类比，很是形象：&lt;code&gt;计算机的核心CPU&lt;/code&gt;，是个工厂，时刻运转着，工厂里有很多个车间（进程），一个车间开工其他车间不能开工，就是说：&lt;code&gt;单核CPU一次只能运行一个进程。任何时候，CPU总是运行一个进程&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;而一个车间里面有很多工人（线程），协同完成一个任务。所以：&lt;code&gt;一个进程可以包括多个线程&lt;/code&gt;。车间空间是工人共享的，&lt;code&gt;一个进程中的内存空间是所有线程共享的&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是房间大小不同个，容纳量不同，有些线程进去了，其他线程就不能再进去使用了。这就是：&lt;code&gt;一个线程使用某些共享内存时，其他线程得等它结束后才能使用共享内存&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;内存可以上锁，防止其他线程进来，【互斥锁】也就是防止多个线程读写同一块内存区域。&lt;/p&gt;
&lt;p&gt;还有些共享内存比较大，可以容纳多个线程，但是也是有限的，只能容纳固定数目的线程使用。如何保证多个线程不冲突呢？内存门口有个钥匙架，如果发现钥匙架空了，那就不能再进去了【信号量】。&lt;/p&gt;
&lt;h2 id=&#34;2-函数调用栈与任务队列&#34;&gt;2. 函数调用栈与任务队列&lt;/h2&gt;
&lt;p&gt;Javascript有一个main thread 主进程和call-stack（一个调用堆栈），在对一个调用堆栈中的task处理的时候，其他的都要等着。当在执行过程中遇到一些类似于setTimeout等异步操作的时候，会交给浏览器的其他模块(以webkit为例，是webcore模块)进行处理，当到达setTimeout指定的延时执行的时间之后，task(回调函数)会放入到任务队列之中。一般不同的异步任务的回调函数会放入不同的任务队列之中。等到调用栈中所有task执行完毕之后，接着去执行任务队列之中的task(回调函数)。&lt;/p&gt;
&lt;p&gt;任务队列是“先进先出”的数据结构，先来的优先被主线程读取。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1615368924655.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上图中，调用栈中遇到DOM操作、ajax请求以及setTimeout等WebAPIs的时候就会交给浏览器内核的其他模块进行处理，webkit内核在Javasctipt执行引擎之外，有一个重要的模块是webcore模块。对于图中WebAPIs提到的三种API，webcore分别提供了DOM Binding、network、timer模块来处理底层实现。等到这些模块处理完这些操作的时候将回调函数放入任务队列中，之后等栈中的task执行完之后再去执行任务队列之中的回调函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小结：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有的代码都要通过函数调用栈中调用执行。&lt;/li&gt;
&lt;li&gt;当遇到前文中提到的APIs的时候，会交给浏览器内核的其他模块进行处理。&lt;/li&gt;
&lt;li&gt;任务队列中存放的是回调函数。&lt;/li&gt;
&lt;li&gt;等到调用栈中的task执行完之后再回去执行任务队列之中的task。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-宏任务与微任务&#34;&gt;3. 宏任务与微任务&lt;/h2&gt;
&lt;p&gt;其中setTimeout叫做macro-task(宏任务)，当然如我们所想，还有如promise的micro-task(微任务)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;micro-task包括：process.nextTick, Promise, Object.observe, MutationObserver&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;事件循环的顺序是从script开始第一次循环，随后全局上下文进入函数调用栈，碰到macro-task就将其交给处理它的模块处理完之后将回调函数放进macro-task的队列之中，碰到micro-task也是将其回调函数放进micro-task的队列之中。直到函数调用栈清空只剩全局执行上下文，然后开始执行所有的micro-task。当所有可执行的micro-task执行完毕之后。循环再次执行macro-task中的一个任务队列，执行完之后再执行所有的micro-task，就这样一直循环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不同的任务会放进不同的任务队列之中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;先执行macro-task，等到函数调用栈清空之后再执行所有在队列之中的micro-task。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等到所有micro-task执行完之后再从macro-task中的一个任务队列开始执行，就这样一直循环。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当有多个macro-task(micro-task)队列时，事件循环的顺序是按上文macro-task(micro-task)的分类中书写的顺序执行的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4事件循环event-loop&#34;&gt;4.事件循环（Event Loop）&lt;/h2&gt;
&lt;p&gt;JavaScript是单线程的，单线程意味着需要一个任务队列来管理任务事件，任务分为两种：&lt;code&gt;同步任务&lt;/code&gt;和&lt;code&gt;异步任务&lt;/code&gt;。同步任务是在主线程上面排队执行的任务，只有前面任务完成，下一个任务才能执行。异步任务是不进入主线程，而是进入任务队列中，只有通知主线程某个异步任务可以执行了，该任务方可执行。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1615368575238.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们的同步任务在主线程上运行会形成一个执行栈&lt;/li&gt;
&lt;li&gt;如果碰到异步任务，比如setTimeout、onClick等等的一些操作，我们会将他的执行结果放入队列，此期间主线程不阻塞&lt;/li&gt;
&lt;li&gt;等到主线程中的所有同步任务执行完毕，就会通过event loop在队列里面从头开始取，在执行栈中执行&lt;/li&gt;
&lt;li&gt;event loop永远不会断&lt;/li&gt;
&lt;li&gt;以上的这一整个流程就是Event Loop（事件循环机制）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;29-如何快速让字符串变成以千为精度的数字&#34;&gt;29. 如何快速让字符串变成以千为精度的数字&lt;/h1&gt;
&lt;h2 id=&#34;1-字符串转换成数字的三种方法&#34;&gt;1. 字符串转换成数字的三种方法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;转换函数、强制类型转换、利用js变量弱类型转换&lt;/code&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;转换函数：&lt;br&gt;
js提供了parseInt()和parseFloat()两个转换函数。前者把值转换成整数，后者把值转换成浮点数。只有对String类型调用这些方法，这两个函数才能正确运行；对其他类型返回的都是NaN(Not a Number)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;parseInt()方法还有基模式，可以把二进制、八进制、十六进制或其他任何进制的字符串转换成整数。基是由parseInt()方法的第二个参数指定的，示例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;parseInt(&amp;quot;AF&amp;quot;,   16);   //returns   175
parseInt(&amp;quot;10&amp;quot;,   2);   //returns   2
parseInt(&amp;quot;10&amp;quot;,   8);   //returns   8
parseInt(&amp;quot;10&amp;quot;,   10);   //returns   10
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;强制类型转换&lt;br&gt;
ECMAScript中可用的3种强制类型转换如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Boolean(value)——把给定的值转换成Boolean型；&lt;/li&gt;
&lt;li&gt;Number(value)——把给定的值转换成数字（可以是整数或浮点数）；&lt;/li&gt;
&lt;li&gt;String(value)——把给定的值转换成字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;利用js变量弱类型转换&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-数字千位符格式化&#34;&gt;2. 数字千位符格式化&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;function toThousands(num) {
    var result = &#39;&#39;, counter = 0;
    num = (num || 0).toString();
    for (var i = num.length - 1; i &amp;gt;= 0; i--) {
        counter++;
        result = num.charAt(i) + result;
        if (!(counter % 3) &amp;amp;&amp;amp; i != 0) { result = &#39;,&#39; + result; }
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;30-js中v8引擎的详解&#34;&gt;30. js中v8引擎的详解&lt;/h1&gt;
&lt;h2 id=&#34;1-v8引擎出现的原因&#34;&gt;1. v8引擎出现的原因&lt;/h2&gt;
&lt;p&gt;这里先说一下什么是&lt;code&gt;编译型语言&lt;/code&gt;和&lt;code&gt;解释性语言&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;编译型&lt;/code&gt;语言： 在程序执行之前必须进行专门的编译过程，有如下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;只须编译一次&lt;/code&gt;就可以把源代码&lt;code&gt;编译成机器语言&lt;/code&gt;，后面的执行&lt;code&gt;无须重新编译&lt;/code&gt;，直接使用之前的编译结果就可以；因此其执行的&lt;code&gt;效率比较高&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;编译性语言代表：C、C++、Java、Pascal/Object Pascal（Delphi）&lt;/li&gt;
&lt;li&gt;程序执行效率比较高，但比较依赖编译器，因此跨平台性差一些&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;解释型&lt;/code&gt;语言 - 解释型语言，支持动态类型，弱类型，在&lt;code&gt;程序运行&lt;/code&gt;的时候&lt;code&gt;才进行编译&lt;/code&gt;，而编译前需要确定变量的类型，效率比较低，对不同系统平台有较大的兼容性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源代码&lt;code&gt;不能直接&lt;/code&gt;翻译成机器语言，而是先翻译成&lt;code&gt;中间代码&lt;/code&gt;，再由&lt;code&gt;解释器&lt;/code&gt;对中间代码进行&lt;code&gt;解释运行&lt;/code&gt; 源代码—&amp;gt;中间代码—&amp;gt;机器语言&lt;/li&gt;
&lt;li&gt;程序&lt;code&gt;不需要编译&lt;/code&gt;，程序在运行时才翻译成机器语言，&lt;code&gt;每执行一次都要翻译一次&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;解释型语言代表：Python、JavaScript、Shell、Ruby、MATLAB等&lt;/li&gt;
&lt;li&gt;运行效率一般相对&lt;code&gt;比较低&lt;/code&gt;，&lt;code&gt;依赖解释器&lt;/code&gt;，跨平台性好&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;比较：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一般，&lt;code&gt;编译型语言的运行效率比解释型语言更高&lt;/code&gt;；但是不能一概而论，部分解释性语言的解释器通过在运行时动态优化代码，甚至能使解释性语言的性能超过编译性语言；&lt;/li&gt;
&lt;li&gt;编译性语言的跨平台特性比解释性语言差一些；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进过以上说明，解释型语言，&lt;code&gt;运行效率低&lt;/code&gt;，随着Web相关技术的发展，JavaScript所要承担的工作也越来越多，早就超越了“表单验证”的范畴，&lt;code&gt;这就更需要快速的解析和执行JavaScript脚本&lt;/code&gt;。&lt;code&gt;V8引擎&lt;/code&gt;就是为解决这一问题而生，在node中也是采用该引擎来解析JavaScript&lt;/p&gt;
&lt;h2 id=&#34;2-渲染引擎及网页渲染&#34;&gt;2. 渲染引擎及网页渲染&lt;/h2&gt;
&lt;p&gt;为用户提供网页浏览服务无疑是最重要的功能，如下介绍：&lt;/p&gt;
&lt;h3 id=&#34;1-渲染引擎&#34;&gt;1. 渲染引擎&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;渲染引擎&lt;/code&gt; - 能够能够将HTML/CSS/JavaScript文本及相应的&lt;code&gt;资源文件&lt;/code&gt;转换成&lt;code&gt;图像&lt;/code&gt;结果.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;作用&lt;/code&gt; - 将&lt;code&gt;资源文件&lt;/code&gt;转化为&lt;code&gt;用户可见&lt;/code&gt;的结果。&lt;/li&gt;
&lt;li&gt;渲染引擎的种类 - Tridend(IE)、Gecko(FF),WebKit(Safari,Chrome,Andriod浏览器)等.&lt;/li&gt;
&lt;li&gt;介绍 - WebKit是由苹果2005年发起的一个开源项目，引起了众多公司的重视，几年间被很多公司所采用，在移动端更占据了垄断地位。更有甚者，开发出了基于WebKit的支持HTML5的web操作系统(如：Chrome OS、Web OS)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;WebKit的大致结构&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616375134643.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616375172770.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-网页渲染流程&#34;&gt;2. 网页渲染流程&lt;/h3&gt;
&lt;p&gt;上面介绍了渲染引擎的各个模块，那么一张网页，要经历怎样的过程，才能展示给用户。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616375416528.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;过程&lt;/code&gt; - 首先是网页内容，输入到HTML解析器，HTML解析器解析，然后构建DOM树，在这期间如果遇到JavaScript代码则交给JavaScript引擎处理；如果来自CSS解析器的样式信息，构建一个内部绘图模型。该模型由布局模块计算模型内部各个元素的位置和大小信息，最后由绘图模块完成从该模型到图像的绘制。在网页渲染的过程中，大致可分为下面3个阶段：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616375499789.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;上述是一个完整的渲染过程，现代网页很多都是动态的，随着网页与用户的交互，浏览器需要不断的重复渲染过程。&lt;/p&gt;
&lt;h3 id=&#34;3-javascript引擎&#34;&gt;3. JavaScript引擎&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1616376387769.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
JavaScript本质上是一种&lt;code&gt;解释型语言&lt;/code&gt;，与编译型语言不同的是它需要&lt;code&gt;一边执行一边解析&lt;/code&gt;，而编译型语言在执行时已经完成编译，可直接执行，有更快的执行速度(如上图所示)。JavaScript代码是在浏览器端解析和执行的，如果需要时间太长，会影响用户体验。那么&lt;code&gt;提高JavaScript的解析速度&lt;/code&gt;就是当务之急。JavaScript引擎和渲染引擎的关系如下图所示：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616376459980.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
avaScript语言是解释型语言，为了&lt;code&gt;提高性能&lt;/code&gt;，引入了J&lt;code&gt;ava虚拟机&lt;/code&gt;和&lt;code&gt;C++编译器&lt;/code&gt;中的众多&lt;code&gt;技术&lt;/code&gt;。现在JavaScript引擎的执行过程大致是:&lt;br&gt;
&lt;code&gt;源代码&lt;/code&gt;-→&lt;code&gt;抽象语法树&lt;/code&gt;-→&lt;code&gt;字节码&lt;/code&gt;-→&lt;code&gt;JIT&lt;/code&gt;-→&lt;code&gt;本地代码&lt;/code&gt;(V8引擎没有中间字节码)。&lt;/p&gt;
&lt;p&gt;V8更加直接的将&lt;code&gt;抽象语法树&lt;/code&gt;通过&lt;code&gt;JIT技术&lt;/code&gt;转换成&lt;code&gt;本地代码&lt;/code&gt;，&lt;code&gt;放弃了&lt;/code&gt;在&lt;code&gt;字节码&lt;/code&gt;阶段可以进行的一些性能优化，但保证了执行速度。在V8生成本地代码后，也会通过Profiler采集一些信息，来优化本地代码。虽然，少了生成字节码这一阶段的性能优化，但极大减少了转换时间。&lt;/p&gt;
&lt;h2 id=&#34;3-v8引擎&#34;&gt;3. V8引擎&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;V8引擎是一个&lt;code&gt;JavaScript引擎&lt;/code&gt;实现，最初由一些语言方面专家设计，后被谷歌收购，随后谷歌对其进行了&lt;code&gt;开源&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;V8使用&lt;code&gt;C++开发&lt;/code&gt;，在运行JavaScript之前，相比其它的JavaScript的引擎转换成字节码或解释执行，&lt;code&gt;V8将其编译成原生机器码&lt;/code&gt;（IA-32, x86-64, ARM, or MIPS CPUs），并且使用了如&lt;code&gt;内联缓存&lt;/code&gt;（inline caching）等方法来&lt;code&gt;提高性能&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;有了这些功能，JavaScript程序在V8引擎下的运行速度媲美二进制程序。&lt;/li&gt;
&lt;li&gt;V8支持&lt;code&gt;众多操作系统&lt;/code&gt;，如windows、linux、android等，也支持其他硬件架构，如IA32,X64,ARM等，具有很好的&lt;code&gt;可移植&lt;/code&gt;和&lt;code&gt;跨平台特性&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-数据表示&#34;&gt;4. 数据表示&lt;/h2&gt;
&lt;p&gt;JavaScript是一种动态类型语言，&lt;code&gt;在编译时并不能准确知道变量的类型&lt;/code&gt;，&lt;code&gt;只可以在运行时确定&lt;/code&gt;，这就不像c++或者java等静态类型语言，在编译时候就可以确切知道变量的类型。然而，&lt;code&gt;在运行时计算和决定类型，会严重影响语言性能&lt;/code&gt;，这也就是JavaScript运行效率比C++或者JAVA低很多的原因之一。&lt;/p&gt;
&lt;p&gt;在C++中，源代码需要经过编译才能执行，在生成本地代码的过程中，变量的地址和类型已经确定，运行本地代码时利用数组和位移就可以存取变量和方法的地址，不需要再进行额外的查找，几个机器指令即可完成，节省了确定类型和地址的时间。由于JavaScript是无类型语言，那就不能像c++那样在执行时已经知道变量的类型和地址，需要临时确定。JavaScript 和C++有以下几个区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;编译确定位置&lt;/code&gt; -&lt;code&gt;C++&lt;/code&gt;编译阶段确定位置偏移信息，在&lt;code&gt;执行时直接存取&lt;/code&gt;，&lt;code&gt;JavaScript&lt;/code&gt;在&lt;code&gt;执行阶段确定&lt;/code&gt;，而且执行期间可以修改对象属性；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;偏移信息共享&lt;/code&gt; - &lt;code&gt;C++&lt;/code&gt;有类型定义，执行时&lt;code&gt;不能动态改变&lt;/code&gt;，可共享偏移信息，&lt;code&gt;JavaScript&lt;/code&gt;每个对象都是&lt;code&gt;自描述&lt;/code&gt;，属性和位置偏移信息都包含在自身的结构中；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;偏移信息查找&lt;/code&gt; - &lt;code&gt;C++&lt;/code&gt;查找偏移地址很简单，在编译代码阶段，对使用的某类型成员变量&lt;code&gt;直接设置偏移位置&lt;/code&gt;，&lt;code&gt;JavaScript&lt;/code&gt;中使用一个对象，需要通过&lt;code&gt;属性名匹配&lt;/code&gt;才能找到相应的值，需要更多的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;34&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1616377366139.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;5-工作过程&#34;&gt;5. 工作过程&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;35&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1616377457407.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;编译阶段&#34;&gt;编译阶段&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;36&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1616377563413.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;运行阶段&#34;&gt;运行阶段&lt;/h3&gt;
&lt;p&gt;由于&lt;code&gt;V8缺少了生成中间代码这一环节&lt;/code&gt;，缺少了必要的优化，为了提升性能，V8会在&lt;code&gt;生成本地代码后&lt;/code&gt;，使用&lt;code&gt;数据分析器&lt;/code&gt;(profiler)&lt;code&gt;采集一些信息&lt;/code&gt;，然后根据这些数据将本地代码进行优化，生成更高效的本地代码，这是一个逐步改进的过程。同时，当发现优化后代码的性能还不如未优化的代码，V8将退回原来的代码，也就是优化回滚。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1616377618319.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;优化回滚&#34;&gt;优化回滚&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;37&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1616377669446.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">【面】前端知识点梳理（JS）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/mian-23-tiao-qian-duan-xing-neng-you-hua/"" data-c="
          &lt;h1 id=&#34;1-前端性能优化&#34;&gt;1. 前端性能优化&lt;/h1&gt;
&lt;h2 id=&#34;1-减少http请求次数&#34;&gt;1. 减少HTTP请求次数&lt;/h2&gt;
&lt;p&gt;尽量合并图片、CSS、JS。比如加载一个页面，如果有5个css文件的话，那么会发出5次http请求，这样会让用户第一次访问你的页面的时候会长时间等待。而如果把这个5个文件合成一个的话，就只需要发出一次http请求，节省网络请求时间，加快页面的加载。&lt;/p&gt;
&lt;h2 id=&#34;2-使用cdn&#34;&gt;2. 使用CDN&lt;/h2&gt;
&lt;p&gt;网站上静态资源即css、js全都使用cdn分发，图片亦然。&lt;/p&gt;
&lt;h2 id=&#34;3-避免空的src和href&#34;&gt;3. 避免空的src和href&lt;/h2&gt;
&lt;p&gt;当link标签的href属性为空、script标签的src属性为空的时候，浏览器渲染的时候会把当前页面的URL作为它们的属性值，从而把页面的内容加载进来作为它们的值。所以要避免犯这样的疏忽。&lt;/p&gt;
&lt;h2 id=&#34;4-为文件头指定expires&#34;&gt;4. 为文件头指定Expires&lt;/h2&gt;
&lt;p&gt;Expires是用来设置文件的过期时间的，一般对css、js、图片资源有效。 他可以使内容具有缓存性，这样下回再访问同样的资源时就通过浏览器缓存区读取，不需要再发出http请求。如下例子：&lt;/p&gt;
&lt;p&gt;新浪微博的这个css文件的Expires时间是2016-5-04 09:14:14.&lt;/p&gt;
&lt;h2 id=&#34;5-使用gzip压缩内容&#34;&gt;5. 使用gzip压缩内容&lt;/h2&gt;
&lt;p&gt;gzip能够压缩任何一个文本类型的响应，包括html，xml，json。大大缩小请求返回的数据量。&lt;/p&gt;
&lt;h2 id=&#34;6-把css放到顶部&#34;&gt;6. 把CSS放到顶部&lt;/h2&gt;
&lt;p&gt;网页上的资源加载时从上网下顺序加载的，所以css放在页面的顶部能够优先渲染页面，让用户感觉页面加载很快。&lt;/p&gt;
&lt;h2 id=&#34;7-把js放到底部&#34;&gt;7. 把JS放到底部&lt;/h2&gt;
&lt;p&gt;加载js时会对后续的资源造成阻塞，必须得等js加载完才去加载后续的文件 ，所以就把js放在页面底部最后加载。&lt;/p&gt;
&lt;h2 id=&#34;8-避免使用css表达式&#34;&gt;8. 避免使用CSS表达式&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;font-color: expression( (new Date()).getHours()%3 ? “#FFFFFF&amp;quot; : “#AAAAAA&amp;quot; );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个表达式会持续的在页面上计算样式，影响页面的性能。并且css表达式只被IE支持。&lt;/p&gt;
&lt;h2 id=&#34;9-将css和js放到外部文件中&#34;&gt;9. 将CSS和JS放到外部文件中&lt;/h2&gt;
&lt;p&gt;目的是缓存文件，可以参考原则4。 但有时候为了减少请求，也会直接写到页面里，需根据PV和IP的比例权衡。&lt;/p&gt;
&lt;h2 id=&#34;10-权衡dns查找次数&#34;&gt;10. 权衡DNS查找次数&lt;/h2&gt;
&lt;p&gt;减少主机名可以节省响应时间。但同时，需要注意，减少主机会减少页面中并行下载的数量。&lt;/p&gt;
&lt;p&gt;IE浏览器在同一时刻只能从同一域名下载两个文件。当在一个页面显示多张图片时，IE 用户的图片下载速度就会受到影响。所以新浪会搞N个二级域名来放图片。&lt;/p&gt;
&lt;p&gt;下面是新浪微博的图片域名，我们可以看到他有多个域名，这样可以保证这些不同域名能够同时去下载图片，而不用排队。不过如果当使用的域名过多时，响应时间就会慢，因为不用响应域名时间不一致。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1614914780547.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;11-精简css和js&#34;&gt;11.  精简CSS和JS&lt;/h2&gt;
&lt;p&gt;这里就涉及到css和js的压缩了。比如下面的新浪的一个css文件，把空格回车全部去掉，减少文件的大小。现在的压缩工具有很多，基本主流的前端构建工具都能进行css和js文件的压缩，如grunt，glup等。&lt;/p&gt;
&lt;h2 id=&#34;12-避免跳转&#34;&gt;12. 避免跳转&lt;/h2&gt;
&lt;p&gt;有种现象会比较坑爹，看起来没什么差别，其实多次了一次页面跳转。比如当URL本该有斜杠（/）却被忽略掉时。例如，当我们要访问 http://baidu.com 时，实际上返回的是一个包含301代码的跳转，它指向的是 http://baidu.com/（注意末尾的斜杠）。在&lt;code&gt;nginx服务器&lt;/code&gt;可以使用rewrite；&lt;code&gt;Apache服务器&lt;/code&gt;中可以使用Alias 或者 mod_rewrite或者the DirectorySlash来避免。&lt;/p&gt;
&lt;p&gt;另一种是不用域名之间的跳转， 比如访问 http://baidu.com/bbs 跳转到http://bbs.baidu.com/。那么可以通过使用Alias或者mod_rewirte建立CNAME（保存一个域名和另外一个域名之间关系的DNS记录）来替代。&lt;/p&gt;
&lt;h2 id=&#34;13-删除重复的js和css&#34;&gt;13. 删除重复的JS和CSS&lt;/h2&gt;
&lt;p&gt;重复调用脚本，除了增加额外的HTTP请求外，多次运算也会浪费时间。在IE和Firefox中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。&lt;/p&gt;
&lt;h2 id=&#34;14-配置etags&#34;&gt;14. 配置ETags&lt;/h2&gt;
&lt;p&gt;它用来判断浏览器缓存里的元素是否和原来服务器上的一致。比last-modified date更具有弹性，例如某个文件在1秒内修改了10次，Etag可以综合Inode(文件的索引节点(inode)数)，MTime(修改时间)和Size来精准的进行判断，避开UNIX记录MTime只能精确到秒的问题。 服务器集群使用，可取后两个参数。使用ETags减少Web应用带宽和负载&lt;/p&gt;
&lt;h2 id=&#34;15-可缓存的ajax&#34;&gt;15. 可缓存的AJAX&lt;/h2&gt;
&lt;p&gt;异步请求同样的造成用户等待，所以使用ajax请求时，要主动告诉浏览器如果该请求有缓存就去请求缓存内容。如下代码片段, cache:true就是显式的要求如果当前请求有缓存的话，直接使用缓存&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614914923304.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;16-使用get来完成ajax请求&#34;&gt;16. 使用GET来完成AJAX请求&lt;/h2&gt;
&lt;p&gt;当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数据。因此使用GET获取数据时更加有意义。&lt;/p&gt;
&lt;h2 id=&#34;17-减少dom元素数量&#34;&gt;17. 减少DOM元素数量&lt;/h2&gt;
&lt;p&gt;这是一门大学问，这里可以引申出一堆优化的细节。想要具体研究的可以看后面推荐书籍。总之大原则减少DOM数量，就会减少浏览器的解析负担。&lt;/p&gt;
&lt;h2 id=&#34;18-避免404&#34;&gt;18. 避免404&lt;/h2&gt;
&lt;p&gt;比如外链的css、js文件出现问题返回404时，会破坏浏览器的并行加载。&lt;/p&gt;
&lt;h2 id=&#34;19-减少cookie的大小&#34;&gt;19. 减少Cookie的大小&lt;/h2&gt;
&lt;p&gt;Cookie里面别塞那么多东西，因为每个请求都得带着他跑。&lt;/p&gt;
&lt;h2 id=&#34;20-使用无cookie的域&#34;&gt;20. 使用无cookie的域&lt;/h2&gt;
&lt;p&gt;比如CSS、js、图片等，客户端请求静态文件的时候，减少了 Cookie 的反复传输对主域名的影响。&lt;/p&gt;
&lt;h2 id=&#34;21-不要使用滤镜&#34;&gt;21. 不要使用滤镜&lt;/h2&gt;
&lt;p&gt;IE独有属性AlphaImageLoader用于修正7.0以下版本中显示PNG图片的半透明效果。这个滤镜的问题在于浏览器加载图片时它会终止内容的呈现并且冻结浏览器。在每一个元素（不仅仅是图片）它都会运算一次，增加了内存开支，因此它的问题是多方面的。&lt;/p&gt;
&lt;p&gt;完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。&lt;/p&gt;
&lt;h2 id=&#34;22-不要在html中缩放图片&#34;&gt;22. 不要在HTML中缩放图片&lt;/h2&gt;
&lt;p&gt;比如你需要的图片尺寸是50* 50&lt;/p&gt;
&lt;p&gt;那就不用用一张500*500的大尺寸图片，影响加载&lt;/p&gt;
&lt;h2 id=&#34;23-缩小faviconico并缓存&#34;&gt;23. 缩小favicon.ico并缓存&lt;/h2&gt;
&lt;h1 id=&#34;2-前端监控和前端埋点方案设计&#34;&gt;2. 前端监控和前端埋点方案设计&lt;/h1&gt;
&lt;p&gt;在线上项目中,需要统计产品中用户行为和使用情况，从而可以从用户和产品的角度去了解用户群体，从而升级和迭代产品，使其更加贴近用户。用户行为数据可以通过&lt;strong&gt;前端数据监控&lt;/strong&gt;的方式获得，除此之外，前端还需要实现&lt;strong&gt;性能监控&lt;/strong&gt;和&lt;strong&gt;异常监控&lt;/strong&gt;。性能监控包括首屏加载时间、白屏时间、http请求时间和http响应时间。异常监控包括前端脚本执行报错等。&lt;/p&gt;
&lt;p&gt;实现前端监控有三个步骤：&lt;code&gt;前端埋点和上报&lt;/code&gt;、&lt;code&gt;数据处理&lt;/code&gt;和&lt;code&gt;数据分析&lt;/code&gt;。本文针对整个前端监控，设计适用的方案。本文的主要内容分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么需要前端监控&lt;/li&gt;
&lt;li&gt;常用前端埋点方案总结&lt;/li&gt;
&lt;li&gt;前端埋点方案选型和前端上报方案设计&lt;/li&gt;
&lt;li&gt;前端监控结果可视化展示系统的设计&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-为什么需要前端监控&#34;&gt;1. 为什么需要前端监控&lt;/h2&gt;
&lt;p&gt;前端监控的目的是：&lt;br&gt;
&lt;strong&gt;获取用户行为以及跟踪产品在用户端的使用情况，并以监控数据为基础，指明产品优化的方向&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;前端监控可以分为三类：&lt;code&gt;数据监控&lt;/code&gt;、&lt;code&gt;性能监控&lt;/code&gt;和&lt;code&gt;异常监控&lt;/code&gt;。下面我们来一一的了解。&lt;/p&gt;
&lt;h3 id=&#34;1-数据监控&#34;&gt;1. 数据监控&lt;/h3&gt;
&lt;p&gt;数据监控，顾名思义就是监听&lt;code&gt;用户的行为&lt;/code&gt;。常见的数据监控包括：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619663303697.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
统计这些数据是有意义的，比如我们知道了&lt;code&gt;用户来源的渠道&lt;/code&gt;，可以促进产品的推广，知道用户在&lt;code&gt;每一个页面停留的时间&lt;/code&gt;，可以针对停留较长的页面，&lt;code&gt;增加广告推送&lt;/code&gt;等等。&lt;/p&gt;
&lt;h3 id=&#34;2-性能监控&#34;&gt;2. 性能监控&lt;/h3&gt;
&lt;p&gt;性能监控指的是监听前端的性能，主要包括监听网页或者说产品在用户端的体验。常见的性能监控数据包括：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619663360531.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这些性能监控的结果，可以展示前端性能的好坏，根据性能监测的结果可以进一步的去优化前端性能，比如兼容低版本浏览器的动画效果，&lt;code&gt;加快首屏加载&lt;/code&gt;等等。&lt;/p&gt;
&lt;h3 id=&#34;3-异常监控&#34;&gt;3. 异常监控&lt;/h3&gt;
&lt;p&gt;此外，产品的前端代码在执行过程中也会发生异常，因此需要引入异常监控。及时的上报异常情况，可以避免线上故障的发上。虽然大部分异常可以通过try catch的方式捕获，但是比如内存泄漏以及其他偶现的异常难以捕获。常见的需要监控的异常包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Javascript的异常监控&lt;/li&gt;
&lt;li&gt;样式丢失的异常监控&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-常用前端埋点方案总结&#34;&gt;2. 常用前端埋点方案总结&lt;/h2&gt;
&lt;p&gt;首要的步骤就是前端埋点和上报，也就是&lt;code&gt;数据的收集阶段&lt;/code&gt;。数据收集的丰富性和准确性会影响对产品线上效果的判别结果。&lt;/p&gt;
&lt;p&gt;目前常见的前端埋点方法分为三种：&lt;code&gt;代码埋点&lt;/code&gt;、&lt;code&gt;可视化埋点&lt;/code&gt;和&lt;code&gt;无痕埋点&lt;/code&gt;。下面一一介绍每一种埋点的方法。&lt;/p&gt;
&lt;h3 id=&#34;1-代码埋点&#34;&gt;1. 代码埋点&lt;/h3&gt;
&lt;p&gt;代码埋点，就是以&lt;code&gt;嵌入代码的形式进行埋点&lt;/code&gt;，比如需要监控用户的点击事件，会选择在&lt;strong&gt;用户点击时，插入一段代码，保存这个监听行为&lt;/strong&gt;或者直接将监听行为以某一种数据格式直接传递给server端。此外比如需要统计产品的PV和UV的时候，需要在网页的初始化时，发送用户的访问信息等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码埋点的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以在任意时刻，精确的发送或保存所需要的数据信息。&lt;br&gt;
&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;工作量较大，每一个组件的埋点都需要添加相应的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-可视化埋点&#34;&gt;2. 可视化埋点&lt;/h3&gt;
&lt;p&gt;通过可视化交互的手段，代替代码埋点。将&lt;code&gt;业务代码&lt;/code&gt;和&lt;code&gt;埋点代码&lt;/code&gt;分离，提供一个可视化交互的页面，输入为业务代码，通过这个可视化系统，可以在业务代码中自定义的增加埋点事件等等，最后输出的代码耦合了业务代码和埋点代码。&lt;/p&gt;
&lt;p&gt;可视化埋点听起来比较高大上，实际上跟代码埋点还是区别不大。&lt;strong&gt;也就是用一个系统来实现手动插入代码埋点的过程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可视化埋点可以埋点的控件有限，不能手动定制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-无埋点&#34;&gt;3. 无埋点&lt;/h3&gt;
&lt;p&gt;无埋点并不是说不需要埋点，而是&lt;code&gt;全部埋点&lt;/code&gt;，前端的任意一个事件都被绑定一个标识，所有的事件都别记录下来。通过定期上传记录文件，配合文件解析，解析出来我们想要的数据，并生成可视化报告供专业人员分析因此实现“无埋点”统计。&lt;/p&gt;
&lt;p&gt;从语言层面实现无埋点也很简单，比如&lt;strong&gt;从页面的js代码中，找出dom上被绑定的事件，然后进行全埋点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无埋点的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于采集的是全量数据，所以产品迭代过程中是不需要关注埋点逻辑的，也不会出现漏埋、误埋等现象&lt;br&gt;
&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;无埋点采集全量数据，给数据传输和服务器增加压力&lt;/li&gt;
&lt;li&gt;无法灵活的定制各个事件所需要上传的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-前端埋点方案选型和前端上报方案设计&#34;&gt;3. 前端埋点方案选型和前端上报方案设计&lt;/h2&gt;
&lt;p&gt;第一章中介绍了前端所需要&lt;code&gt;监听的信息&lt;/code&gt;，在第二章中介绍了前端&lt;code&gt;埋点&lt;/code&gt;的常见方式，本文来根据需求，来定制我们的埋点和&lt;code&gt;上报方案&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;1-监控数据&#34;&gt;1. 监控数据&lt;/h3&gt;
&lt;p&gt;首先我们需要明确一个产品或者网页，普遍需要监控和上报的数据。监控的分为三个阶段：&lt;code&gt;用户进入网页首页&lt;/code&gt;、&lt;code&gt;用户在网页内部交互&lt;/code&gt;和&lt;code&gt;交互中报错&lt;/code&gt;。每一个阶段需要监控和上报的数据如下图所示：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619671671411.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-埋点方案&#34;&gt;2. 埋点方案&lt;/h3&gt;
&lt;p&gt;在实际项目中考虑到上报数据的灵活定制，以及减少数据传输和服务器的压力，在所需埋点处不多的情况下，常用的方式是&lt;code&gt;代码埋点&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;以用户进入首页为例，我们在首页渲染完成后会发送事件类型和类型相关的数据给server端，告知首页的监控信息。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619671695601.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-上报周期和上报数据类型&#34;&gt;3. 上报周期和上报数据类型&lt;/h3&gt;
&lt;p&gt;如果埋点的事件&lt;code&gt;不是很多&lt;/code&gt;，上报可以&lt;code&gt;时时进行&lt;/code&gt;，比如监控用户的交互事件，可以在用户触发事件后，立刻上报用户所触发的事件类型。如果埋点的&lt;code&gt;事件较多&lt;/code&gt;，或者说网页内部交互频繁，可以通过&lt;code&gt;本地存储的方式先缓存上报信息，然后定期上报&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接着来确定需要埋点上报的数据，上报的信息包括用户个人信息以及用户行为，主要数据可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;who: appid(系统或者应用的id),userAgent(用户的系统、网络等信息)&lt;/li&gt;
&lt;li&gt;when: timestamp(上报的时间戳)&lt;/li&gt;
&lt;li&gt;from where: currentUrl(用户当前url)，fromUrl(从哪一个页面跳转到当前页面)，type(上报的事件类型),element(触发上报事件的元素）&lt;/li&gt;
&lt;li&gt;what: 上报的自定义扩展数据data:{},扩展数据中可以按需求定制，比如包含uid等信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上报数据的对象为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{   
    ----------------上报接口本身提供--------------------
    currentUrl,  
    fromUrl,
    timestamp,
    userAgent:{
       os,
       netWord,
    }
    ----------------业务代码配置和自定义上报数据------------
    type,
    appid,
    element,
    data:{
        uid,
        uname
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-埋点和上报举例&#34;&gt;4. 埋点和上报举例&lt;/h3&gt;
&lt;p&gt;我们以上报&lt;code&gt;首屏加载&lt;/code&gt;事件为例，DOM提供了&lt;code&gt;document&lt;/code&gt;的&lt;code&gt;DOMContentLoaded&lt;/code&gt;事件来监听dom挂载，提供了window的load事件来监听页面所有资源加载渲染完毕。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
  var start=Date.now();
  document.addEventListener(&#39;DOMContentLoaded&#39;, function() {
     fetch(&#39;some api&#39;,{
         type:&#39;dom complete&#39;,
         data:{
           domCompletedTime:Date.now()-start
         }
     })
  });
  window.addEventListener(&#39;load&#39;, function() {
     fetch(&#39;some api&#39;,{
         type:&#39;load complete&#39;,
         data:{
           LoadCompletedTime:Date.now()-start
         }
     })
  });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-前端埋点系统的前后端通信加密&#34;&gt;5. 前端埋点系统的前后端通信加密&lt;/h3&gt;
&lt;p&gt;在上报数据的前后端通信中，需要和server端协商加密机制，利用 OpenSSL库来实现的加密，OpenSSL已经是一个广泛被采用的加密算法。前端可以采用node的crypto模块。&lt;/p&gt;
&lt;p&gt;首先来看hash算法，crypto.createHash() 来创建一个Hash实例，可利用的hash算法如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;md5&lt;/li&gt;
&lt;li&gt;sha1&lt;/li&gt;
&lt;li&gt;sha256&lt;/li&gt;
&lt;li&gt;sha512&lt;/li&gt;
&lt;li&gt;ripemd160&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以sha256算法加密为例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const str=&amp;quot;123445&amp;quot;;//需要加密的字段
const hash=crypto.createHash(&#39;sha256&#39;);//指定加密算法
hash.update(str); //通过算法加密相应的字段
const result=hash.digest(&#39;hex&#39;);//转化成十六进制
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-前端监控结果可视化展示系统的设计&#34;&gt;4. 前端监控结果可视化展示系统的设计&lt;/h2&gt;
&lt;p&gt;当后端得到前端上报的信息之后，经过数据分析和处理，&lt;strong&gt;需要前端可视化的展示数据分析后的结果&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;可以在开源中后台系统ant-design-pro的基础上进行二次开发，首先要明确展示信息。展示的信息包括单个用户和整体应用。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619671886590.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">【面】前端性能优化与埋点监控</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/mian-qian-duan-zhi-shi-dian-shu-li-html/"" data-c="
          &lt;h1 id=&#34;1-语义化&#34;&gt;1. 语义化&lt;/h1&gt;
&lt;h2 id=&#34;11-语义化作用&#34;&gt;1.1 语义化作用&lt;/h2&gt;
&lt;p&gt;见标签知其意，让代码结构清晰，方便阅读，有利于其他设备解析。&lt;/p&gt;
&lt;p&gt;循W3规范以语义化标签渲染网页更利于搜索引擎的优化（SEO），网络不佳时（无样式），网页也更具可读性。&lt;/p&gt;
&lt;h2 id=&#34;12-常见语义化标签&#34;&gt;1.2 常见语义化标签&lt;/h2&gt;
&lt;p&gt;&amp;lt;title&amp;gt;：页面主体内容。&lt;/p&gt;
&lt;p&gt;&amp;lt;hn&amp;gt;：h1~h6，分级标题，&amp;lt;h1&amp;gt; 与 &amp;lt;title&amp;gt; 协调有利于搜索引擎优化。&lt;/p&gt;
&lt;p&gt;&amp;lt;ul&amp;gt;：无序列表。&lt;/p&gt;
&lt;p&gt;&amp;lt;ol&amp;gt;：有序列表。&lt;/p&gt;
&lt;p&gt;&amp;lt;header&amp;gt;：页眉通常包括网站标志、主导航、全站链接以及搜索框。&lt;/p&gt;
&lt;p&gt;&amp;lt;nav&amp;gt;：标记导航，仅对文档中重要的链接群使用。&lt;/p&gt;
&lt;p&gt;&amp;lt;main&amp;gt;：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。&lt;/p&gt;
&lt;p&gt;&amp;lt;article&amp;gt;：定义外部的内容，其中的内容独立于文档的其余部分。&lt;/p&gt;
&lt;p&gt;&amp;lt;section&amp;gt;：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。&lt;/p&gt;
&lt;h2 id=&#34;13-html对seo的优化&#34;&gt;1.3 html对SEO的优化&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;meta标签，这个是重中之重&lt;/li&gt;
&lt;li&gt;img标签，img标签增加alt属性&lt;/li&gt;
&lt;li&gt;页面结构清晰，使用语义化标签比如header、footer、content、section，js、css使用外部文件&lt;/li&gt;
&lt;li&gt;增加外部链接&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;2-html新特性新标签&#34;&gt;2. Html新特性新标签&lt;/h1&gt;
&lt;h2 id=&#34;21-新特性&#34;&gt;2.1 新特性&lt;/h2&gt;
&lt;p&gt;1）语义化&lt;br&gt;
2）本地存储&lt;br&gt;
3）设备兼容&lt;br&gt;
4）连接特性，能够帮助我们将数据推送到客户端&lt;br&gt;
5）网页多媒体特性&lt;br&gt;
6）三维、图形及特效特性&lt;br&gt;
7）性能与集成特性&lt;br&gt;
8）css3特性&lt;/p&gt;
&lt;h2 id=&#34;22-新标签&#34;&gt;2.2 新标签&lt;/h2&gt;
&lt;p&gt;1）结构标签&lt;br&gt;
&amp;lt;head&amp;gt;定义页面或者区域头部&lt;br&gt;
&amp;lt;main&amp;gt;规定文档主要内容&lt;br&gt;
&amp;lt;footer&amp;gt;定义页面或者区域底部&lt;br&gt;
&amp;lt;article&amp;gt;定义一篇文章&lt;br&gt;
&amp;lt;nav&amp;gt;定义导航链接&lt;br&gt;
&amp;lt;scetion&amp;gt;定义一个区域&lt;br&gt;
&amp;lt;aside&amp;gt;定义页面内容部分侧边栏&lt;br&gt;
&amp;lt;hgroup&amp;gt;用于对网页或者区域段的标题组合&lt;br&gt;
&amp;lt;figure&amp;gt;定义一组媒体内容以及标题&lt;br&gt;
&amp;lt;figcaption&amp;gt;定义figure元素标题&lt;br&gt;
&amp;lt;address&amp;gt;定义文章拥有者的联系信息&lt;br&gt;
2）行标记&lt;br&gt;
&amp;lt;time&amp;gt;定义时间、日期&lt;br&gt;
&amp;lt;mark&amp;gt;高亮显示文字&lt;br&gt;
3）多媒体交互标签&lt;br&gt;
&amp;lt;video&amp;gt;定义一个视频&lt;br&gt;
&amp;lt;audio&amp;gt;定义一个音频&lt;br&gt;
&amp;lt;source&amp;gt;定义媒体资源标签&lt;br&gt;
&amp;lt;canvas&amp;gt;定义图形&lt;br&gt;
&amp;lt;embed&amp;gt;定义可交互的内容或者插件&lt;br&gt;
4）web应用标签&lt;br&gt;
&amp;lt;progress&amp;gt;状态标签、进度条&lt;br&gt;
&amp;lt;mark&amp;gt;定义有标记的文本（默认是黄色选中内容）&lt;br&gt;
&amp;lt;output&amp;gt;定义一些输出内容，计算表单结果配合oninput事件&lt;br&gt;
&amp;lt;datalist&amp;gt;为input标记定义一个下拉option&lt;/p&gt;
&lt;h1 id=&#34;3-input和textarea的区别&#34;&gt;3. input和textarea的区别&lt;/h1&gt;
&lt;p&gt;&amp;lt;input&amp;gt;是&lt;code&gt;单行文本框&lt;/code&gt;，不会换行。通过size属性指定显示字符的长度，注意：当使用css限定了宽高，那么size属性就不再起作用。&lt;br&gt;
value属性指定初始值，Maxlength属性指定文本框可以输入的最长长度。可以通过width和height设置宽高，但是也不会增加行数。&lt;/p&gt;
&lt;p&gt;&amp;lt;textarea&amp;gt;是&lt;code&gt;多行文本输入框&lt;/code&gt;，文本区中可容纳无限数量的文本，无value属性，其中的文本的默认字体是等宽字体（通常是Courier） ，可以通 过 cols 和 rows 属性来规定 textarea 的尺寸，不过更好的办法是使用 CSS 的 height 和 width 属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
	input:&amp;lt;input value=&amp;quot;啦啦啦啦啦&amp;quot; style=&amp;quot;height:200px;width: 500px;&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div style=&amp;quot;margin-top: 20px;&amp;quot;&amp;gt;
	textarea:&amp;lt;/textarea&amp;gt;&amp;lt;textarea  value=&amp;quot;嘻嘻嘻&amp;quot; style=&amp;quot;height:200px;width: 500px;&amp;quot;&amp;gt; 
   &amp;lt;/textarea&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到：textarea中设置的value并没有显示，同时input文本依然只有一行，并且居中显示。&lt;/p&gt;
&lt;h1 id=&#34;4-用div模拟textarea&#34;&gt;4. 用div模拟textarea&lt;/h1&gt;
&lt;p&gt;作为多行文本域功能来讲，textarea满足了我们大部分的需求。然而，textarea有一个不足就是不能像普通div标签一样高度可以跟随内容自适应。textarea总是很自信地显摆它的滚动条，高度固执地岿然不动。&lt;/p&gt;
&lt;p&gt;要解决这个问题很简单，一个普通的block元素上加个&lt;code&gt;contenteditable=&amp;quot;true&amp;quot;&lt;/code&gt;就ok了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div contenteditable=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1614862550654.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
给div设置了一个最小高度，当超过最小高度但不超过最大高度时，div的高度根据文本自适应，当超过最大高度时，出现滚动条。&lt;/p&gt;
&lt;h1 id=&#34;5-html页面动态加载js文件&#34;&gt;5. html页面动态加载js文件&lt;/h1&gt;
&lt;p&gt;下面介绍三种异步执行加载Js 脚本的方法：&lt;/p&gt;
&lt;h2 id=&#34;1-直接documentwrite&#34;&gt;1. 直接document.write&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script language=&amp;quot;javascript&amp;quot;&amp;gt;
document.write(&amp;quot;&amp;lt;script src=&#39;test.js&#39;&amp;gt;&amp;lt;\/script&amp;gt;&amp;quot;);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-动态改变已有script的src属性&#34;&gt;2. 动态改变已有script的src属性&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&#39;&#39; id=&amp;quot;s1&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script language=&amp;quot;javascript&amp;quot;&amp;gt;
s1.src=&amp;quot;test.js&amp;quot;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-动态创建-script元素&#34;&gt;3. 动态创建 script元素&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var script = document.createElement(&#39;script&#39;);
script.type = &amp;quot;text/javascript&amp;quot;;
script.src = &amp;quot;abc.js&amp;quot;;
document.body.appendChild(script);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;6-移动设备忽略将页面中的数字识别为电话号码的方法&#34;&gt;6. 移动设备忽略将页面中的数字识别为电话号码的方法&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;标准的电话号码格式是这样的:&amp;lt;a  href=&amp;quot;tel:1-408-555-5555&amp;quot;&amp;gt;1-408-555-5555&amp;lt;/a&amp;gt;，点击后会自动打开电话功能；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但有时候不是电话号码的数字也会被浏览器自动解析为电话号码, 并把数字的颜色和样式都改了；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果忽略页面中的数字识别为电话号码, 只要把这个默认行为关闭就行，只要一行代码:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta name = &amp;quot;format-detection&amp;quot; content = &amp;quot;telephone=no&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;这个关闭不会影响真正电话号码的识别；&lt;/li&gt;
&lt;/ol&gt;
">【面】前端知识点梳理（Html）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/mian-qian-duan-zhi-shi-dian-shu-li-css-xia/"" data-c="
          &lt;h1 id=&#34;0-行内元素与块级元素的区别&#34;&gt;0. 行内元素与块级元素的区别&lt;/h1&gt;
&lt;h2 id=&#34;1-区别&#34;&gt;1. 区别&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;行内元素和其他行内元素都会在一条水平线上排列，都是在同一行的；块级元素却总是会在新的一行开始排列，各个块级元素独占一行，垂直向下排列，若想使其水平方向排序，可使用左右浮动（float：left/right）让其水平方向排列。&lt;/li&gt;
&lt;li&gt;行内元素不可以设置宽高，宽度高度随文本内容的变化而变化，但是可以设置行高（line-height），同时在设置外边距margin上下无效，左右有效，内填充padding上下无效，左右有效；块级元素可以设置宽高，并且宽度高度以及外边距，内填充都可随意控制。&lt;/li&gt;
&lt;li&gt;块级元素可以包含行内元素和块级元素，还可以容纳内联元素和其他元素；行内元素不能包含块级元素，只能容纳文本或者其他行内元素。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-css样式继承&#34;&gt;2. Css样式继承&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1619598673120.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;1-盒模型box-model&#34;&gt;1. 盒模型（box model）&lt;/h1&gt;
&lt;h2 id=&#34;1基本概念&#34;&gt;1.基本概念&lt;/h2&gt;
&lt;p&gt;盒子模型，个人的理解，就是一个来装html标签的矩形容器，由四部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内容区（content）&lt;/li&gt;
&lt;li&gt;内边距（padding）&lt;/li&gt;
&lt;li&gt;外框（border）&lt;/li&gt;
&lt;li&gt;外边距（margin）&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614738716059.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2标准模型与ie模型的区别&#34;&gt;2.标准模型与IE模型的区别&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;标准模型&lt;/strong&gt;与&lt;strong&gt;IE 模型&lt;/strong&gt;的区别在于宽高的计算方式不同。&lt;br&gt;
标准模型计算元素的宽高只算 content 的宽高，IE模型是 content + padding + border 的总尺寸。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614739310471.jfif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
从上图可以看到标准 &lt;code&gt;W3C 盒子模型的范围包括 margin、border、padding、content，并且 content 部分不包含其他部分。&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614739313417.jfif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
从上图可以看到&lt;code&gt;IE 盒子模型的范围也包括 margin、border、padding、content，和标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 pading。&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-如何设置这两种模型&#34;&gt;3、如何设置这两种模型&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;//设置标准模型
box-sizing: content-box;
//设置IE模型
box-sizing: border-box;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-外边距合并&#34;&gt;4. 外边距合并&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1619602593954.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;2flex布局&#34;&gt;2.flex布局&lt;/h1&gt;
&lt;p&gt;flex，即弹性布局。一个由css3引入，为我们的盒子属性带来灵活性的一种布局方式。一旦父级采用了flex布局，里边的子控件将收flex布局限制，部分原本的样式（如float:left）也会失效。&lt;/p&gt;
&lt;p&gt;特别注意： flex:0 0 30%的意义： 等于flex-grow=0（默认不放大）+flex-shrink=0（不缩小）+flex-basis=30%（ 项目占据主轴的空间）&lt;/p&gt;
&lt;h2 id=&#34;1flex布局使用&#34;&gt;1.flex布局使用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;任何一个容器都可以指定为 Flex 布局。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.box{
  display: flex;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;行内元素也可以使用 Flex 布局。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.box{
  display: inline-flex;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，设为 Flex 布局以后，子元素的&lt;code&gt;float&lt;/code&gt;、&lt;code&gt;clear&lt;/code&gt;和&lt;code&gt;vertical-align&lt;/code&gt;属性将失效。&lt;/p&gt;
&lt;h2 id=&#34;2基本概念&#34;&gt;2.基本概念&lt;/h2&gt;
&lt;p&gt;采用 Flex 布局的元素，称为 Flex 容器（flex container），简称&amp;quot;容器&amp;quot;。它的所有&lt;strong&gt;子元素&lt;/strong&gt;自动成为容器成员，称为 Flex 项目（flex item），简称&amp;quot;项目&amp;quot;。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614742656456.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做&lt;code&gt;main start&lt;/code&gt;，结束位置叫做&lt;code&gt;main end&lt;/code&gt;；交叉轴的开始位置叫做&lt;code&gt;cross start&lt;/code&gt;，结束位置叫做&lt;code&gt;cross end&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;项目默认沿主轴排列。单个项目占据的主轴空间叫做&lt;code&gt;main size&lt;/code&gt;，占据的交叉轴空间叫做&lt;code&gt;cross size&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;3容器的属性&#34;&gt;3.容器的属性&lt;/h2&gt;
&lt;h3 id=&#34;31-主轴的方向flex-direction&#34;&gt;3.1 &lt;strong&gt;主轴的方向(flex-direction)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;flex-direction&lt;/code&gt;: row | row-reverse | column | column-reverse;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;row（默认值）：主轴为水平方向，起点在左端。&lt;/li&gt;
&lt;li&gt;row-reverse：主轴为水平方向，起点在右端。&lt;/li&gt;
&lt;li&gt;column：主轴为垂直方向，起点在上沿。&lt;/li&gt;
&lt;li&gt;column-reverse：主轴为垂直方向，起点在下沿。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614742821013.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-换行属性flex-wrap&#34;&gt;3.2 &lt;strong&gt;换行属性(flex-wrap)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;flex-wrap&lt;/code&gt;: nowrap | wrap | wrap-reverse;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nowrap（默认）：不换行。&lt;/li&gt;
&lt;li&gt;wrap：换行，第一行在上方。&lt;/li&gt;
&lt;li&gt;wrap-reverse：换行，第一行在下方。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;简写&lt;/code&gt;：&lt;strong&gt;方向 + 换行&lt;/strong&gt;&lt;br&gt;
flex-flow: &lt;code&gt;&amp;lt;flex-direction&amp;gt;&lt;/code&gt; || &lt;code&gt;&amp;lt;flex-wrap&amp;gt;&lt;/code&gt;;&lt;/p&gt;
&lt;h3 id=&#34;33-主轴对齐方式justify-content&#34;&gt;3.3 &lt;strong&gt;主轴对齐方式(justify-content)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;justify-content&lt;/code&gt;: flex-start | flex-end | center | space-between | space-around;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex-start（默认值）：左对齐&lt;/li&gt;
&lt;li&gt;flex-end：右对齐&lt;/li&gt;
&lt;li&gt;center： 居中&lt;/li&gt;
&lt;li&gt;space-between：两端对齐，项目之间的间隔都相等。&lt;/li&gt;
&lt;li&gt;space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614743145091.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;34-交叉轴对齐方式align-items&#34;&gt;3.4 &lt;strong&gt;交叉轴对齐方式(align-items)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;align-items&lt;/code&gt;: flex-start | flex-end | center | baseline | stretch;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex-start：交叉轴的起点对齐。&lt;/li&gt;
&lt;li&gt;flex-end：交叉轴的终点对齐。&lt;/li&gt;
&lt;li&gt;center：交叉轴的中点对齐。&lt;/li&gt;
&lt;li&gt;baseline: 项目的第一行文字的基线对齐。&lt;/li&gt;
&lt;li&gt;stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614743221850.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;35-多根轴线对齐方式align-content&#34;&gt;3.5 &lt;strong&gt;多根轴线对齐方式(align-content)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;align-content&lt;/code&gt;: flex-start | flex-end | center | space-between | space-around | stretch;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex-start：与交叉轴的起点对齐。&lt;/li&gt;
&lt;li&gt;flex-end：与交叉轴的终点对齐。&lt;/li&gt;
&lt;li&gt;center：与交叉轴的中点对齐。&lt;/li&gt;
&lt;li&gt;space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。&lt;/li&gt;
&lt;li&gt;space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。&lt;/li&gt;
&lt;li&gt;stretch（默认值）：轴线占满整个交叉轴。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614743313971.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4项目的属性&#34;&gt;4.项目的属性&lt;/h2&gt;
&lt;p&gt;排列顺序，数值越小，排列越靠前，默认为0。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;order: &amp;lt;integer&amp;gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;项目的放大比例,默认为0，即如果存在剩余空间，也不放大。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex-grow: &amp;lt;number&amp;gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;项目的缩小比例,默认为1，即如果空间不足，该项目将缩小。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex-shrink: &amp;lt;number&amp;gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;项目占据的空间,默认值为auto，即项目的本来大小&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex-basis: &amp;lt;length&amp;gt; | auto;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;简写flex:&lt;/code&gt;：&lt;strong&gt;flex-grow, flex-shrink 和 flex-basis&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;flex&lt;/code&gt;属性是&lt;code&gt;flex-grow&lt;/code&gt;, &lt;code&gt;flex-shrink&lt;/code&gt; 和&lt;code&gt;flex-basis&lt;/code&gt;的简写，默认值为&lt;code&gt;0 1 auto&lt;/code&gt;。后两个属性可选。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;独立的对齐方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;align-self: auto | flex-start | flex-end | center | baseline | stretch;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614743733611.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;3css单位&#34;&gt;3.CSS单位&lt;/h1&gt;
&lt;p&gt;CSS 有几个不同的单位用于表示长度。&lt;/p&gt;
&lt;p&gt;一些设置 CSS 长度的属性有 width, margin, padding, font-size, border-width, 等。&lt;/p&gt;
&lt;p&gt;长度有一个数字和单位组成如 10px, 2em, 等。&lt;/p&gt;
&lt;p&gt;数字与单位之间不能出现空格。如果长度值为 0，则可以省略单位。&lt;/p&gt;
&lt;p&gt;对于一些 CSS 属性，长度可以是负数。&lt;/p&gt;
&lt;p&gt;有两种类型的长度单位：&lt;strong&gt;相对和绝对&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;31-相对长度&#34;&gt;3.1 相对长度&lt;/h2&gt;
&lt;p&gt;相对长度单位指定了一个长度相对于另一个长度的属性。对于&lt;strong&gt;不同的设备&lt;/strong&gt;相对长度更适用。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;单位&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;em&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;它是描述相对于应用在当前元素的字体尺寸，所以它也是相对长度单位。一般浏览器字体大小默认为16px，则2em == 32px；&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ex&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;依赖于英文字母小 x 的高度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ch&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数字 0 的宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;rem&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;rem 是根 em（root em）的缩写，rem作用于非根元素时，相对于根元素字体大小；rem作用于根元素字体大小时，相对于其出初始字体大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;vw&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;viewpoint width，视窗宽度，1vw=视窗宽度的1%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;vh&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;viewpoint height，视窗高度，1vh=视窗高度的1%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;vmin&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;vw和vh中较小的那个。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;vmax&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;vw和vh中较大的那个。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;提示: rem与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-绝对长度&#34;&gt;3.2 绝对长度&lt;/h2&gt;
&lt;p&gt;绝对长度单位是一个固定的值，它反应一个真实的物理尺寸。绝对长度单位视输出介质而定，不依赖于环境（显示器、分辨率、操作系统等）。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;单位&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;cm&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;厘米&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;mm&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;毫米&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;in&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;英寸 (1in = 96px = 2.54cm)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;px&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;像素 (1px = 1/96th of 1in)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pt&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;point，大约1/72英寸； (1pt = 1/72in)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pc&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pica，大约 12pt，1/6英寸； (1pc = 12 pt)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;4伪类-与-选择器&#34;&gt;4.伪类 与 选择器&lt;/h1&gt;
&lt;h2 id=&#34;41-伪类和伪元素的区别&#34;&gt;4.1 伪类和伪元素的区别？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档数外的元素。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;伪类和伪元素的最大区别就在于有没有创建一个文档树以外的元素。伪元素创建了一个文档树以外的元素（虚拟容器）并为他添加样式，这个容器不包含任何DOM元素但是可以包含内容。换句话说伪类和伪元素的区别就是伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档树以外的元素。&lt;/p&gt;
&lt;h3 id=&#34;1-伪类&#34;&gt;1. 伪类&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;css伪类：css伪类用于向某些选择器添加特殊效果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;伪类其实与普通的css类相类似，可以为已有的元素添加样式，但是他只有处于dom无法描述的状态下才能为文档树中的元素添加样式，所以将其称为伪类。(这种文档树无法描述的状态是什么呢？当一个元素在用户的不同行为下就变化成不同的状态这个行为的变化dom就无法描述，就要产生伪类，来为一些选择器添加特殊的效果)。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1629294101158.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;a标签的伪类&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a:link   /* 未访问的链接 */
a:visited  /* 已访问的链接 */
a:hover  /* 鼠标移动到链接上 */
a:active  /* 选定的链接 */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;input获取焦点 :focus&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input class=&amp;quot;ccc&amp;quot; type=&amp;quot;text&amp;quot; value=&amp;quot;test&amp;quot; /&amp;gt;
.ccc:focus{background-color:yellow;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;hover鼠标滑过&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p:hover {color: #FF00FF}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-伪元素&#34;&gt;2. 伪元素&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;伪元素：伪元素用于创建一些不在文档树中的元素，并且为他添加样式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个例子：使用伪元素‘&lt;strong&gt;::before&lt;/strong&gt;’可以在一个元素前边增加一些文本，并且可以为这些文本添加一些样式，虽然用户可以看到这写文本，但是这些文本是不存在于文档树中的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;伪元素的content属性&lt;/code&gt;&lt;br&gt;
伪元素的content属性，不仅仅可以简单直接的设置一个字符串作为伪元素的内容，它还具备一定限度的编程能力，如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;div::after{
    content: &amp;quot;普通字符串&amp;quot;;
    content: attr(父元素的html属性名称);
    content: url(图片、音频、视频等资源的url);
    /* 使用unicode字符集，采用4位16进制编码
     * 但不同的浏览器显示存在差异，而且移动端识别度更差
     */
    content: &amp;quot;\21e0&amp;quot;;
    /* content的多个值可以任意组合，各部分通过空格分隔 */
    content: &amp;quot;&#39;&amp;quot; attr(title) &amp;quot;&#39;&amp;quot;;
    
    /* 自增计数器，用于插入数字/字母/罗马数字编号
     * counter-reset: [&amp;lt;identifier&amp;gt; &amp;lt;integer&amp;gt;?]+，必选，用于标识自增计数器的作用范围，&amp;lt;identifier&amp;gt;为自定义名称，&amp;lt;integer&amp;gt;为起始编号默认为0。
     * counter-increment: [&amp;lt;identifier&amp;gt; &amp;lt;integer&amp;gt;?]+，用于标识计数器与实际关联的范围，&amp;lt;identifier&amp;gt;为counter-reset中的自定义名称，&amp;lt;integer&amp;gt;为步长默认为1。
     * &amp;lt;list-style-type&amp;gt;: disc | circle | square | decimal | decimal-leading-zero | lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | lower-alpha | upper-alpha
     */
    content: counter(&amp;lt;identifier&amp;gt;, &amp;lt;list-style-type&amp;gt;);
    
    /* 以父附属元素的qutoes值作为content的值
     */
    content: open-quote | close-quote | no-open-quote | no-close-quote;
}
/* Content接受6种类型，和一种组合方式 */
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1629294446197.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;42基础选择器&#34;&gt;4.2基础选择器&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1614746568376.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
“选择器”指明了{}中的“样式”的作用对象，也就是“样式”作用于网页中的哪些元素&lt;br&gt;
1.&lt;strong&gt;通配选择器&lt;/strong&gt; *: 所有的标签都变色&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;标签(元素)选择器&lt;/strong&gt;：匹配所有使用p标签的样式 p{color:red}&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;id选择器&lt;/strong&gt;：匹配指定的标签  #p2{color:red}&lt;/p&gt;
&lt;p&gt;4.&lt;strong&gt;class类选择器&lt;/strong&gt;：谁指定class谁的变色，可选多个  .c1{color:red} 或者 div.c1{color:red}&lt;/p&gt;
&lt;h2 id=&#34;43-复合选择器&#34;&gt;4.3 复合选择器&lt;/h2&gt;
&lt;p&gt;1.&lt;strong&gt;交集选择器&lt;/strong&gt;（合着写）&lt;br&gt;
&lt;strong&gt;作用&lt;/strong&gt;：选中同时复合多个条件的元素&lt;br&gt;
&lt;strong&gt;语法&lt;/strong&gt;：选择器1选择器2选择器3选择器n{}&lt;br&gt;
&lt;strong&gt;注意点&lt;/strong&gt;：交集选择器中如果有元素选择器，必须使用元素选择器开头&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;并集选择器&lt;/strong&gt;（逗号隔开）&lt;br&gt;
&lt;strong&gt;作用&lt;/strong&gt;：同时选择多个选择器对应的元素&lt;br&gt;
&lt;strong&gt;语法&lt;/strong&gt;：选择器1,选择器2,选择器3,选择器n{}&lt;br&gt;
&lt;strong&gt;例子&lt;/strong&gt;：#b1,.p1,h1,span,div.red{}&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;关系选择器&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;(1)子元素选择器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用：选中指定父元素的指定子元素&lt;/li&gt;
&lt;li&gt;语法：父元素 &amp;gt; 子元素&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;div.box &amp;gt; span{
        color: orange;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;(2)后代元素选择器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用：选中指定元素内的指定后代元素&lt;/li&gt;
&lt;li&gt;语法：祖先 后代&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;div span{
      color: skyblue
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;(3)兄弟元素选择器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择下一个兄弟&lt;br&gt;
语法：前一个 + 下一个&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;p + span{
     color: red;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;选择下边所有的兄弟&lt;br&gt;
语法：兄 ~ 弟&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt; p ~ span{
      color: red;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.&lt;strong&gt;属性选择器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[属性名] 选择含有指定属性的元素&lt;/li&gt;
&lt;li&gt;[属性名=属性值] 选择含有指定属性和属性值的元素&lt;/li&gt;
&lt;li&gt;[属性名^=属性值] 选择属性值以指定值开头的元素&lt;/li&gt;
&lt;li&gt;[属性名$=属性值] 选择属性值以指定值结尾的元素&lt;/li&gt;
&lt;li&gt;[属性名*=属性值] 选择属性值中含有某值的元素的元素&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt; p[title*=e]{
      color: orange;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.&lt;strong&gt;伪类选择器&lt;/strong&gt;&lt;br&gt;
伪类一般情况下都是使用&lt;code&gt;:&lt;/code&gt;开头&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;:first-child 第一个子元素&lt;/li&gt;
&lt;li&gt;:last-child 最后一个子元素&lt;/li&gt;
&lt;li&gt;:nth-child() 选中第n个子元素&lt;/li&gt;
&lt;li&gt;:first-of-type&lt;/li&gt;
&lt;li&gt;:last-of-type&lt;/li&gt;
&lt;li&gt;:nth-of-type()          - 他们是在同类型元素中进行排序&lt;/li&gt;
&lt;li&gt;:not() 否定伪类        - 将符合条件的元素从选择器中去除&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;ul &amp;gt; li:nth-child(2n+1){
      color: red;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;44-css优先级&#34;&gt;4.4 CSS优先级&lt;/h2&gt;
&lt;p&gt;当两个规则都作用到了同一个html元素上时，如果定义的属性有冲突，那么应该用谁的值的，CSS有一套优先级的定义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不同级别&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。&lt;/li&gt;
&lt;li&gt;作为style属性写在元素内的样式&lt;/li&gt;
&lt;li&gt;id选择器&lt;/li&gt;
&lt;li&gt;类选择器&lt;/li&gt;
&lt;li&gt;标签选择器&lt;/li&gt;
&lt;li&gt;通配符选择器&lt;/li&gt;
&lt;li&gt;浏览器自定义或继承&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;总结排序：!important &amp;gt; 行内样式&amp;gt;ID选择器 &amp;gt; 类选择器 &amp;gt; 标签 &amp;gt; 通配符 &amp;gt; 继承 &amp;gt; 浏览器默认属性&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同一级别&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同一级别中后写的会覆盖先写的样式&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619086185333.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;5bfc-清除浮动&#34;&gt;5.bfc 清除浮动&lt;/h1&gt;
&lt;p&gt;BFC(Block Formatting Context) 块级格式化环境&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;BFC是一个CSS中的一个隐含的属性，可以为一个元素开启BFC&lt;br&gt;
开启BFC该元素会变成一个独立的布局区域&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;元素开启BFC后的特点：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;开启BFC的元素不会被浮动元素所覆盖&lt;/li&gt;
&lt;li&gt;开启BFC的元素子元素和父元素外边距不会重叠&lt;/li&gt;
&lt;li&gt;开启BFC的元素可以包含浮动的子元素&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;可以通过一些特殊方式来开启元素的BFC：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;设置元素的浮动（不推荐）&lt;/li&gt;
&lt;li&gt;将元素设置为行内块元素（不推荐）&lt;/li&gt;
&lt;li&gt;将元素的overflow设置为一个非visible的值&lt;br&gt;
&lt;code&gt;常用的方式 为元素设置 overflow:hidden 开启其BFC&lt;/code&gt; 以使其可以包含浮动元素&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，除了BFC，还有IFC、GFC、FFC的概念。我们简单了解一下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GFC：可简单理解为grid布局&lt;/li&gt;
&lt;li&gt;FFC：可简单理解为flex布局。&lt;/li&gt;
&lt;li&gt;IFC:内联格式化上下文，简单理解为：inline-block。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;水平方向上的 margin，border 和 padding在框之间得到保留。框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐。包含那些框的长方形区域，会形成一行，叫做行框。 inline-block的元素的内部是一个BFC，但是它本身可以和其它inline元素一起形成IFC。&lt;/p&gt;
&lt;h1 id=&#34;6层叠上下文&#34;&gt;6.层叠上下文&lt;/h1&gt;
&lt;h2 id=&#34;1层叠上下文stacking-context&#34;&gt;1.层叠上下文(Stacking Context)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1614762081794.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
层叠上下文1 (Stacking Context 1)是由文档根元素形成的， 层叠上下文2和3 (Stacking Context 2, 3) 都是层叠上下文1 (Stacking Context 1) 上的层叠层。 他们各自也都形成了新的层叠上下文，其中包含着新的层叠层。&lt;/p&gt;
&lt;p&gt;在层叠上下文中，其子元素按照上面解释的规则进行层叠。形成层叠上下文的方法有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根元素 &amp;lt;html&amp;gt;&amp;lt;/html&amp;gt;&lt;/li&gt;
&lt;li&gt;position值为 absolute|relative，且 z-index值不为 auto&lt;/li&gt;
&lt;li&gt;position 值为 fixed|sticky&lt;/li&gt;
&lt;li&gt;z-index 值不为 auto 的flex元素，即：父元素 display:flex|inline-flex&lt;/li&gt;
&lt;li&gt;opacity 属性值小于 1 的元素&lt;/li&gt;
&lt;li&gt;transform 属性值不为 none的元素&lt;/li&gt;
&lt;li&gt;mix-blend-mode 属性值不为 normal 的元素&lt;/li&gt;
&lt;li&gt;filter、 perspective、 clip-path、 mask、 mask-image、 mask-border、 motion-path 值不为none 的元素&lt;/li&gt;
&lt;li&gt;perspective 值不为 none 的元素&lt;/li&gt;
&lt;li&gt;isolation 属性被设置为 isolate 的元素&lt;/li&gt;
&lt;li&gt;will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值&lt;/li&gt;
&lt;li&gt;-webkit-overflow-scrolling 属性被设置 touch的元素&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总结:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;层叠上下文可以包含在其他层叠上下文中，并且一起组建了一个有层级的层叠上下文&lt;/li&gt;
&lt;li&gt;每个层叠上下文完全独立于它的兄弟元素，当处理层叠时只考虑子元素，这里类似于BFC&lt;/li&gt;
&lt;li&gt;每个层叠上下文是自包含的：当元素的内容发生层叠后，整个该元素将会&lt;strong&gt;在父级叠上下文&lt;/strong&gt;中按顺序进行层叠&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-层叠等级-stacking-level&#34;&gt;2. 层叠等级 (Stacking Level)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;层叠等级&lt;/strong&gt; (层叠水平, Stacking Level) 决定了同一个层叠上下文中元素在z轴上的显示顺序的&lt;strong&gt;概念&lt;/strong&gt;；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通元素的层叠等级优先由其所在的层叠上下文决定&lt;/li&gt;
&lt;li&gt;层叠等级的比较只有在同一个层叠上下文元素中才有意义&lt;/li&gt;
&lt;li&gt;在同一个层叠上下文中，层叠等级描述定义的是该层叠上下文中的元素在Z轴上的上下顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;，层叠等级并不一定由 z-index 决定，只有定位元素的层叠等级才由 z-index 决定，其他类型元素的层叠等级由层叠顺序、他们在HTML中出现的顺序、他们的父级以上元素的层叠等级一同决定，详细的规则见下面层叠顺序的介绍。&lt;/p&gt;
&lt;h2 id=&#34;3-z-index&#34;&gt;3. z-index&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在 CSS 2.1 中, 所有的盒模型元素都处于三维坐标系中。 除了我们常用的横坐标和纵坐标， 盒模型元素还可以沿着&amp;quot;z 轴&amp;quot;层叠摆放， 当他们相互覆盖时， z 轴顺序就变得十分重要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;z-index 只适用于定位的元素，对非定位元素无效，它可以被设置为正整数、负整数、0、auto，如果一个定位元素没有设置 z-index，那么默认为auto；&lt;/p&gt;
&lt;p&gt;元素的 z-index 值只在同一个层叠上下文中有意义。如果父级层叠上下文的层叠等级低于另一个层叠上下文的，那么它 z-index 设的再高也没用。所以如果你遇到 z-index 值设了很大，但是不起作用的话，就去看看它的父级层叠上下文是否被其他层叠上下文盖住了。&lt;/p&gt;
&lt;h2 id=&#34;4-层叠顺序-stacking-order&#34;&gt;4. 层叠顺序 (Stacking Order)&lt;/h2&gt;
&lt;p&gt;这里其实是涉及了所谓的层叠水平（stacking level)，有一张图可以很好的诠释：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614774762413.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;形成堆叠上下文环境的元素的背景与边框&lt;/li&gt;
&lt;li&gt;拥有负 z-index 的子堆叠上下文元素 （负的越高越堆叠层级越低）&lt;/li&gt;
&lt;li&gt;正常流式布局，非 inline-block，无 position 定位（static除外）的子元素&lt;/li&gt;
&lt;li&gt;无 position 定位（static除外）的 float 浮动元素&lt;/li&gt;
&lt;li&gt;正常流式布局， inline-block元素，无 position 定位（static除外）的子元素（包括 display:table 和 display:inline ）&lt;/li&gt;
&lt;li&gt;拥有 z-index:0 的子堆叠上下文元素&lt;/li&gt;
&lt;li&gt;拥有正 z-index: 的子堆叠上下文元素（正的越低越堆叠层级越低）&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;7-常见页面布局&#34;&gt;7. 常见页面布局&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;三栏布局&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目：假设高度已知，请写出三栏布局，其中左栏、右栏宽度各为 300px，中间自适应。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解答：可以有很多种布局方式，这里列出五种：float布局，absolute布局，flex布局，table布局，grid布局，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
	&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
	&amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=edge&amp;quot;&amp;gt;
	&amp;lt;title&amp;gt;三栏布局&amp;lt;/title&amp;gt;
	&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;&amp;quot;&amp;gt;
	&amp;lt;style type=&amp;quot;text/css&amp;quot; media=&amp;quot;screen&amp;quot;&amp;gt;
		html *{
			margin: 0;
			padding: 0;
		}
	&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
	&amp;lt;section class=&amp;quot;layout float&amp;quot;&amp;gt;
		&amp;lt;style type=&amp;quot;text/css&amp;quot; media=&amp;quot;screen&amp;quot;&amp;gt;
			.layout.float .wrapper&amp;gt;div{
				min-height: 100px;
			}
			.layout.float .left{
				float: left;
				width: 300px;
				background: red;
			}
			.layout.float .center{
				background: yellow;
			}
			.layout.float .right{
				float: right;
				width: 300px;
				background: blue;
			}
			
		&amp;lt;/style&amp;gt;
		&amp;lt;article class=&amp;quot;wrapper&amp;quot;&amp;gt;
			&amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt;
				&amp;lt;h1&amp;gt;float布局&amp;lt;/h1&amp;gt;
				1.我是float布局的中间部分
				2.我是float布局的中间部分
			&amp;lt;/div&amp;gt;
		&amp;lt;/article&amp;gt;
	&amp;lt;/section&amp;gt;


	&amp;lt;section class=&amp;quot;layout absolute&amp;quot;&amp;gt;
		&amp;lt;style type=&amp;quot;text/css&amp;quot; media=&amp;quot;screen&amp;quot;&amp;gt;
			.layout.absolute .wrapper{
				width: 100%;
				margin-top: 20px;
			}
			.layout.absolute .wrapper&amp;gt;div{
				min-height: 100px;
			}
			.layout.absolute .left{
				position: absolute;
				left: 0;
				width: 300px;
				background: red;
			}
			.layout.absolute .center{
				position: absolute;
				left: 300px;
				right: 300px;
				background: yellow;
			}
			.layout.absolute .right{
				position: absolute;
				right: 0;
				width: 300px;
				background: blue;
			}
		&amp;lt;/style&amp;gt;
		&amp;lt;article class=&amp;quot;wrapper&amp;quot;&amp;gt;
			&amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt;
				&amp;lt;h1&amp;gt;absolute布局&amp;lt;/h1&amp;gt;
				1.我是absolute布局的中间部分
				2.我是absolute布局的中间部分
			&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
		&amp;lt;/article&amp;gt;
	&amp;lt;/section&amp;gt;


	&amp;lt;section class=&amp;quot;layout flex&amp;quot;&amp;gt;
		&amp;lt;style type=&amp;quot;text/css&amp;quot; media=&amp;quot;screen&amp;quot;&amp;gt;
			.layout.flex .wrapper{
				width: 100%;
				min-height: 100px;
				display: flex;
				margin-top: 140px;
			}
			.layout.flex .left{
				width: 300px;
				background: red;
			}
			.layout.flex .center{
				flex: 1;
				background: yellow;
			}
			.layout.flex .right{
				width: 300px;
				background: blue;
			}
		&amp;lt;/style&amp;gt;
		&amp;lt;article class=&amp;quot;wrapper&amp;quot;&amp;gt;
			&amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt;
				&amp;lt;h1&amp;gt;flex布局&amp;lt;/h1&amp;gt;
				1.我是flex布局的中间部分
				2.我是flex布局的中间部分
			&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
		&amp;lt;/article&amp;gt;
	&amp;lt;/section&amp;gt;


	&amp;lt;section class=&amp;quot;layout table&amp;quot;&amp;gt;
		&amp;lt;style type=&amp;quot;text/css&amp;quot; media=&amp;quot;screen&amp;quot;&amp;gt;
			.layout.table .wrapper{
				display: table;
				width: 100%;
				min-height: 100px;
				margin-top: 20px;
			}
			.layout.table .left{
				display: table-cell;
				width: 300px;
				background: red;
			}
			.layout.table .center{
				display: table-cell;
				background: yellow;
			}
			.layout.table .right{
				display: table-cell;
				width: 300px;
				background: blue;
			}
			
		&amp;lt;/style&amp;gt;
		&amp;lt;article class=&amp;quot;wrapper&amp;quot;&amp;gt;
			&amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt;
				&amp;lt;h1&amp;gt;table布局&amp;lt;/h1&amp;gt;
				1.我是table布局的中间部分
				2.我是table布局的中间部分
			&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
		&amp;lt;/article&amp;gt;
	&amp;lt;/section&amp;gt;


	&amp;lt;section class=&amp;quot;layout grid&amp;quot;&amp;gt;
		&amp;lt;style type=&amp;quot;text/css&amp;quot; media=&amp;quot;screen&amp;quot;&amp;gt;
			.layout.grid .wrapper{
				display: grid;
				grid-template-columns: 300px auto 300px;
				grid-template-rows: 100px;
				width: 100%;
				margin-top: 20px;
			}
			.layout.grid .left{
				background: red;
			}
			.layout.grid .center{
				background: yellow;
			}
			.layout.grid .right{
				background: blue;
			}
			
		&amp;lt;/style&amp;gt;
		&amp;lt;article class=&amp;quot;wrapper&amp;quot;&amp;gt;
			&amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt;
				&amp;lt;h1&amp;gt;grid布局&amp;lt;/h1&amp;gt;
				1.我是grid布局的中间部分
				2.我是grid布局的中间部分
			&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
		&amp;lt;/article&amp;gt;
	&amp;lt;/section&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;71-每种布局的优缺点&#34;&gt;7.1 每种布局的优缺点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;float 布局&lt;/code&gt;&lt;br&gt;
优点： 比较简单，兼容性也比较好。只要清除浮动做的好，是没有什么问题的&lt;br&gt;
缺点：浮动元素是脱离文档流，要做清除浮动，这个处理不好的话，会带来很多问题，比如高度塌陷等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;绝对布局&lt;/code&gt;&lt;br&gt;
优点：很快捷，设置很方便，而且也不容易出问题&lt;br&gt;
缺点：绝对定位是脱离文档流的，意味着下面的所有子元素也会脱离文档流，这就导致了这种方法的有效性和可使用性是比较差的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;flex 布局&lt;/code&gt;&lt;br&gt;
优点：简单快捷&lt;br&gt;
缺点：不支持 IE8 及以下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;table布局&lt;/code&gt;&lt;br&gt;
优点：实现简单，代码少&lt;br&gt;
缺点：当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的，而有时候这种效果不是我们想要的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;grid布局&lt;/code&gt;&lt;br&gt;
跟 flex 相似。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;72-水平垂直居中&#34;&gt;7.2 水平垂直居中&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;absolute + 负margin&lt;/strong&gt;&lt;br&gt;
这种方式比较好理解，兼容性也很好，缺点是需要知道子元素的宽高&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;out&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;inner&amp;quot;&amp;gt;12345&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
  .out{
    position: relative;
    width: 300px;
    height: 300px;
    background: red;
  }

  .inner{
    position: absolute;
    width: 100px;
    height: 100px;
    background: yellow;
    left: 50%;
    top: 50%;
    margin-left: -50px;
    margin-top: -50px;
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;absolute + auto margin&lt;/strong&gt;&lt;br&gt;
这种方法兼容性也很好，缺点是需要知道子元素的宽高&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
  .out{
    position: relative;
    width: 300px;
    height: 300px;
    background: red;
  }

  .inner{
    position: absolute;
    width: 100px;
    height: 100px;
    background: yellow;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    margin: auto;
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;absolute + calc&lt;/strong&gt;&lt;br&gt;
这种方法的兼容性依赖于 calc，且也需要知道宽高&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
  .out{
    position: relative;
    width: 300px;
    height: 300px;
    background: red;
  }

  .inner{
    position: absolute;
    width: 100px;
    height: 100px;
    background: yellow;
    left: calc(50% - 50px);
    top: calc(50% - 50px);
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;absolute + transform&lt;/strong&gt;&lt;br&gt;
兼容性依赖 translate，不需要知道子元素宽高&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
  .out{
    position: relative;
    width: 300px;
    height: 300px;
    background: red;
  }

  .inner{
    position: absolute;
    background: yellow;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;table&lt;/strong&gt;&lt;br&gt;
css新增的table属性，可以让我们把普通元素，变为table元素的显示效果，通过这个特性也可以实现水平垂直居中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种方法兼容性也不错。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
  .out{
    display: table-cell;
    width: 300px;
    height: 300px;
    text-align: center;
    vertical-align: middle;
    background: red;
  }

  .inner{
    display: inline-block;
    background: yellow;
    width: 100px;
    height: 100px;
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;strong&gt;flex&lt;/strong&gt;&lt;br&gt;
flex 实现起来比较简单，三行代码即可搞定。可通过父元素指定子元素的对齐方式，也可通过 子元素自己指定自己的对齐方式来实现。第二种方式见 grid 布局。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
  .out{
    display: flex;
    justify-content: center;
    align-items: center;
    width: 300px;
    height: 300px;
    background: red;
  }

  .inner{
    background: yellow;
    width: 100px;
    height: 100px;
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;&lt;strong&gt;grid&lt;/strong&gt;&lt;br&gt;
grid 布局也很强大，大体上属性跟 flex 差不多。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
  .out{
    display: grid;
    width: 300px;
    height: 300px;
    background: red;
  }

  .inner{
    background: yellow;
    width: 100px;
    height: 100px;
    align-self: center;
    justify-self: center;
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;页面布局小结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语义化掌握到位&lt;/li&gt;
&lt;li&gt;页面布局理解深刻&lt;/li&gt;
&lt;li&gt;CSS基础知识扎实&lt;/li&gt;
&lt;li&gt;思维灵活且积极上进&lt;/li&gt;
&lt;li&gt;代码书写规范&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;8-响应式布局&#34;&gt;8. 响应式布局&lt;/h1&gt;
&lt;p&gt;响应式设计与自适应设计的区别：响应式开发一套界面，通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容；自适应需要开发多套界面，通过检测视口分辨率，来判断当前访问的设备是pc端、平板、手机，从而请求服务层，返回不同的页面。&lt;/p&gt;
&lt;h2 id=&#34;81-媒体查询&#34;&gt;8.1 媒体查询&lt;/h2&gt;
&lt;p&gt;CSS3媒体查询可以让我们针对不同的媒体类型定义不同的样式，当重置浏览器窗口大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。&lt;/p&gt;
&lt;p&gt;不管是移动优先还是PC优先，都是依据当随着屏幕宽度增大或减小的时候，后面的样式会覆盖前面的样式。因此，移动端优先首先使用的是min-width，PC端优先使用的max-width。&lt;/p&gt;
&lt;h2 id=&#34;82-百分比布局&#34;&gt;8.2 百分比布局&lt;/h2&gt;
&lt;p&gt;通过百分比单位，可以使得浏览器中组件的宽和高随着浏览器的高度的变化而变化，从而实现响应式的效果。Bootstrap里面的栅格系统就是利用百分比来定义元素的宽高，CSS3支持最大最小高，可以将百分比和max(min)一起结合使用来定义元素在不同设备下的宽高。&lt;/p&gt;
&lt;p&gt;计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。&lt;/p&gt;
&lt;p&gt;各个属性中如果使用百分比，相对父元素的属性并不是唯一的。比如width和height相对于父元素的width和height，而margin、padding不管垂直还是水平方向都相对比父元素的宽度、border-radius则是相对于元素自身等等，造成我们使用百分比单位容易使布局问题变得复杂。&lt;/p&gt;
&lt;h2 id=&#34;83-rem布局&#34;&gt;8.3 rem布局&lt;/h2&gt;
&lt;p&gt;REM是CSS3新增的单位，并且移动端的支持度很高，Android2.x+,ios5+都支持。rem单位都是相对于根元素html的font-size来决定大小的,根元素的font-size相当于提供了一个基准，当页面的size发生变化时，只需要改变font-size的值，那么以rem为固定单位的元素的大小也会发生响应的变化。 因此，如果通过rem来实现响应式的布局，只需要根据视图容器的大小，动态的改变font-size即可（而em是相对于父元素的）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rem响应式的布局思想：&lt;/strong&gt;&lt;br&gt;
一般不要给元素设置具体的宽度，但是对于一些小图标可以设定具体宽度值&lt;/p&gt;
&lt;p&gt;高度值可以设置固定值，设计稿有多大，我们就严格有多大&lt;/p&gt;
&lt;p&gt;所有设置的固定值都用rem做单位（首先在HTML总设置一个基准值：px和rem的对应比例，然后在效果图上获取px值，布局的时候转化为rem值)&lt;/p&gt;
&lt;p&gt;js获取真实屏幕的宽度，让其除以设计稿的宽度，算出比例，把之前的基准值按照比例进行重新的设定，这样项目就可以在移动端自适应了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rem布局的缺点：&lt;/strong&gt;&lt;br&gt;
在响应式布局中，必须通过js来动态控制根元素font-size的大小，也就是说css样式和js代码有一定的耦合性，且必须将改变font-size的代码放在css样式之前&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;REM布局也是目前多屏幕适配的最佳方式&lt;/strong&gt;。默认情况下我们html标签的font-size为16px,我们利用媒体查询，设置在不同设备下的字体大小。&lt;/p&gt;
&lt;h2 id=&#34;84-视口单位&#34;&gt;8.4 视口单位&lt;/h2&gt;
&lt;p&gt;css3中引入了一个新的单位vw/vh，与视图窗口有关，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。各个单位具体的含义如下：&lt;/p&gt;
&lt;p&gt;用视口单位度量，视口宽度为100vw，高度为100vh（左侧为竖屏情况，右侧为横屏情况）。例如，在桌面端浏览器视口尺寸为650px，那么 1vw = 650 * 1% = 6.5px（这是理论推算的出，如果浏览器不支持0.5px，那么实际渲染结果可能是7px）。&lt;/p&gt;
&lt;p&gt;使用视口单位来实现响应式有两种做法：&lt;/p&gt;
&lt;p&gt;1.仅使用vw作为CSS单位&lt;br&gt;
2.搭配vw和rem&lt;/p&gt;
&lt;h2 id=&#34;85-图片响应式&#34;&gt;8.5 图片响应式&lt;/h2&gt;
&lt;p&gt;这里的图片响应式包括两个方面，一个就是大小自适应，这样能够保证图片在不同的屏幕分辨率下出现压缩、拉伸的情况；一个就是根据不同的屏幕分辨率和设备像素比来尽可能选择高分辨率的图片，也就是当在小屏幕上不需要高清图或大图，这样我们用小图代替，就可以减少网络带宽了。&lt;/p&gt;
&lt;p&gt;1.使用max-width（图片自适应）:&lt;br&gt;
图片自适应意思就是图片能随着容器的大小进行缩放&lt;/p&gt;
&lt;p&gt;2.使用srcset    &amp;lt;img srcset=&amp;quot;photo_w350.jpg 1x, photo_w640.jpg 2x&amp;quot; src=&amp;quot;photo_w350.jpg&amp;quot; alt=&amp;quot;&amp;quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;3.使用background-image&lt;/p&gt;
&lt;p&gt;4.使用picture标签&lt;/p&gt;
&lt;h2 id=&#34;86响应式布局的要点&#34;&gt;8.6响应式布局的要点&lt;/h2&gt;
&lt;p&gt;在实际项目中，我们可能需要综合上面的方案，比如用rem来做字体的适配，用srcset来做图片的响应式，宽度可以用rem，flex，栅格系统等来实现响应式，然后可能还需要利用媒体查询来作为响应式布局的基础，因此综合上面的实现方案，项目中实现响应式布局需要注意下面几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置viewport&lt;/li&gt;
&lt;li&gt;媒体查询&lt;/li&gt;
&lt;li&gt;字体的适配（字体单位）&lt;/li&gt;
&lt;li&gt;百分比布局&lt;/li&gt;
&lt;li&gt;图片的适配（图片的响应式）&lt;/li&gt;
&lt;li&gt;结合flex，grid，BFC，栅格系统等已经成型的方案&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;9-css预处理后处理&#34;&gt;9. css预处理，后处理&lt;/h1&gt;
&lt;h2 id=&#34;91-css-预处理器&#34;&gt;9.1 CSS 预处理器&lt;/h2&gt;
&lt;p&gt;CSS 预处理器用一种专门的编程语言，进行 Web 页面样式设计，然后再编译成正常的 CSS 文件，以供项目使用。&lt;strong&gt;CSS 预处理器为 CSS 增加一些编程的特性，无需考虑浏览器的兼容性问题。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CSS语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器；&lt;/li&gt;
&lt;li&gt;没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Sass、LESS、Stylus 是目前最主流的 CSS 预处理器。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现原理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取到 &lt;strong&gt;DSL&lt;/strong&gt; 源代码 的 &lt;strong&gt;分析树&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将含有 &lt;strong&gt;动态生成&lt;/strong&gt; 相关节点的 &lt;strong&gt;分析树&lt;/strong&gt; 转换为 &lt;strong&gt;静态分析树&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将 &lt;strong&gt;静态分析树&lt;/strong&gt; 转换为 CSS 的 &lt;strong&gt;静态分析树&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将 CSS 的** 静态分析树** 转换为 &lt;strong&gt;CSS 代码&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现实中的 &lt;strong&gt;CSS 预处理器&lt;/strong&gt; 更复杂一点儿，因为大多功能要同时支持 &lt;strong&gt;特有 DSL 与 原生 CSS&lt;/strong&gt;，一件事情要同时考虑两种情况下的处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：语言级逻辑处理，动态特性，改善项目结构&lt;/li&gt;
&lt;li&gt;缺点：采用特殊语法，框架耦合度高，复杂度高&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;92-css-后处理器&#34;&gt;9.2 CSS 后处理器&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;CSS 后处理器&lt;/strong&gt; 是对 CSS 进行处理，并最终生成 CSS 的 &lt;code&gt;预处理器&lt;/code&gt;，它属于广义上的 &lt;strong&gt;CSS 预处理器&lt;/strong&gt;。 我们很久以前就在用 &lt;strong&gt;CSS 后处理器&lt;/strong&gt; 了，最典型的例子是 &lt;strong&gt;CSS 压缩工具&lt;/strong&gt;（如 &lt;code&gt;clean-css&lt;/code&gt;），只不过以前没单独拿出来说过。 还有最近比较火的 &lt;code&gt;Autoprefixer&lt;/code&gt;，以 Can I Use 上的 &lt;strong&gt;浏览器支持数据&lt;/strong&gt;为基础，自动处理兼容性问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现原理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 &lt;strong&gt;源代码&lt;/strong&gt; 做为 &lt;strong&gt;CSS&lt;/strong&gt; 解析，获得 &lt;strong&gt;分析树&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;对 &lt;strong&gt;CSS&lt;/strong&gt; 的 &lt;strong&gt;分析树&lt;/strong&gt; 进行 &lt;strong&gt;后处理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将 &lt;strong&gt;CSS&lt;/strong&gt; 的 &lt;strong&gt;分析树&lt;/strong&gt; 转换为 &lt;strong&gt;CSS 代码&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;优缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：使用 CSS 语法，容易进行模块化，贴近 CSS 的未来标准&lt;/li&gt;
&lt;li&gt;缺点：逻辑处理能力有限&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;10-css3新特性&#34;&gt;10. css3新特性&lt;/h1&gt;
&lt;h2 id=&#34;1-transition的属性&#34;&gt;1. transition的属性&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;CSS3的过渡功能就像是一种黄油，可以让CSS的一些变化变得平滑。因为原生的CSS过渡在客户端需要处理的资源要比用JavaScript和Flash少的多，所以才会更平滑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1614826493004.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;transition-property&lt;br&gt;
不是所有属性都能过渡，只有属性具有一个中间点值才具备过渡效果。&lt;/li&gt;
&lt;li&gt;transition-duration&lt;br&gt;
指定从一个属性到另一个属性过渡所要花费的时间。默认值为0，为0时，表示变化是瞬时的，看不到过渡效果。&lt;/li&gt;
&lt;li&gt;transiton-timing-function&lt;br&gt;
过渡函数，有如下几种：&lt;br&gt;
liner ：匀速&lt;br&gt;
ease-in：减速&lt;br&gt;
ease-out：加速&lt;br&gt;
ease-in-out：先加速再减速&lt;br&gt;
cubic-bezier：三次贝塞尔曲线&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;触发过渡&lt;/code&gt;&lt;br&gt;
单纯的代码不会触发任何过渡操作，需要通过用户的行为（如点击，悬浮等）触发，可触发的方式有：&lt;br&gt;
&lt;strong&gt;:hoever :focus :checked 媒体查询触发 JavaScript触发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;局限性&lt;/code&gt;&lt;br&gt;
transition的优点在于简单易用，但是它有几个很大的局限。 &lt;br&gt;
（1）transition需要事件触发，所以没法在网页加载时自动发生。 &lt;br&gt;
（2）transition是一次性的，不能重复发生，除非一再触发。 &lt;br&gt;
（3）transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。 &lt;br&gt;
（4）一条transition规则，只能定义一个属性的变化，不能涉及多个属性。 &lt;br&gt;
CSS Animation就是为了解决这些问题而提出的。&lt;/p&gt;
&lt;h2 id=&#34;2-animation的属性&#34;&gt;2. animation的属性&lt;/h2&gt;
&lt;p&gt;CSS3的animation属性可以像Flash制作动画一样，通过控制关键帧来控制动画的每一步，实现更为复杂的动画效果。ainimation实现动画效果主要由两部分组成：&lt;br&gt;
1）通过类似Flash动画中的帧来声明一个动画；&lt;br&gt;
2）在animation属性中调用关键帧声明的动画。&lt;br&gt;
&lt;code&gt;动画属性&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614826993212.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
（1）animation-name：none为默认值，将没有任何动画效果，其可以用来覆盖任何动画 &lt;br&gt;
（2）animation-duration：默认值为0，意味着动画周期为0，也就是没有任何动画效果 &lt;br&gt;
（3）animation-timing-function：与transition-timing-function一样 &lt;br&gt;
（4）animation-delay：在开始执行动画时需要等待的时间 &lt;br&gt;
（5）animation-iteration-count：定义动画的播放次数，默认为1，如果为infinite，则无限次循环播放 &lt;br&gt;
（6）animation-direction：默认为nomal，每次循环都是向前播放，（0-100），另一个值为alternate，动画播放为偶数次则向前播放，如果为基数词就反方向播放 &lt;br&gt;
（7）animation-state：默认为running，播放，paused，暂停 &lt;br&gt;
（8）animation-fill-mode：定义动画开始之前和结束之后发生的操作，默认值为none，动画结束时回到动画没开始时的状态；forwards，动画结束后继续应用最后关键帧的位置，即保存在结束状态；backwards，让动画回到第一帧的状态；both：轮流应用forwards和backwards规则。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@keyframes&lt;/code&gt;&lt;br&gt;
CSS3的animation制作动画效果主要包括两部分：1. 用关键帧声明一个动画，2.在animation调用关键帧声明的的动画。&lt;/p&gt;
&lt;h2 id=&#34;3区别&#34;&gt;3.区别&lt;/h2&gt;
&lt;p&gt;animation属性类似于transition，他们都是随着时间改变元素的属性值，其主要区别在于：transition需要触发一个事件才会随着时间改变其CSS属性；animation在不需要触发任何事件的情况下，也可以显式的随时间变化来改变元素CSS属性，达到一种动画的效果。&lt;/p&gt;
&lt;h1 id=&#34;11display哪些取值&#34;&gt;11.display哪些取值&lt;/h1&gt;
&lt;h2 id=&#34;111-none-此元素不会被显示&#34;&gt;11.1 none ：此元素不会被显示&lt;/h2&gt;
&lt;p&gt;（1） none此单词的意思是没有一个、毫无的意思；所以当display的属性值设置为none的时候，表示的是没有框类型，没有框类型的元素，是无法在浏览器中显示的，就实现隐藏元素的作用了；&lt;br&gt;
（2）有很多标签，display的属性值默认是none，比如 &lt;code&gt;head&lt;/code&gt; &lt;code&gt;meta&lt;/code&gt; &lt;code&gt;style&lt;/code&gt; &lt;code&gt;link&lt;/code&gt;等等；&lt;br&gt;
（3）项目应用中，做二级导航效果或者鼠标悬停效果动态时，会经常用到这个属性值，下次我们写一个好玩的二级效果再来展示这个属性值的作用；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614838389050.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;112-block此元素将显示为块级元素此元素前后会带有换行符&#34;&gt;11.2 block：此元素将显示为块级元素，此元素前后会带有换行符。&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1614838392829.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;113-inline-默认此元素会被显示为内联元素元素前后没有换行符&#34;&gt;11.3 inline 默认此元素会被显示为内联元素，元素前后没有换行符。&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1614838421481.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;114-inline-block-行内块元素css21-新增的值&#34;&gt;11.4 inline-block 行内块元素（CSS2.1 新增的值）&lt;/h2&gt;
&lt;p&gt;说明：行内块元素既具备行内元素的特性也具备块状元素的特性，具备行内元素前后没有换行符可以在一行内并列显示的特性，具备块状元素可以正确解释盒模型属性的特性。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614838503882.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;115-list-item-此元素会作为列表显示&#34;&gt;11.5 list-item 此元素会作为列表显示。&lt;/h2&gt;
&lt;p&gt;(1) 此属性值表示将元素显示为列表项标签，li标签默认的display的属性值是list-item，display的属性值为list-item的标签也属于块状元素；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614838546316.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
(2) li标签作为列表项标签，前面会有列表项标记，下面给div标签设置为list-item，div也会有列表项标记&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614838588128.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;116-run-in-此元素会根据上下文作为块级元素或内联元素显示&#34;&gt;11.6 run-in 此元素会根据上下文作为块级元素或内联元素显示。&lt;/h2&gt;
&lt;h2 id=&#34;117-table-此元素会作为块级表格来显示表格前后带有换行符&#34;&gt;11.7 table 此元素会作为块级表格来显示，表格前后带有换行符。&lt;/h2&gt;
&lt;p&gt;（1）table标签默认的元素类型是table，显示为块级表格，可以设置大小并且单独占据一行；&lt;br&gt;
（2）当table标签的元素类型是table时，并且设置宽度和高度之后，后代td标签的宽度和高度，默认是由table根据内容的多少去分配的；&lt;br&gt;
(3) table属于块状元素，但是对比别的块状元素，有自己的特点， table会单独占据一行，但是在没有设置width的情况下，不会与父元素同宽，而是根据内容而定；&lt;br&gt;
(4) 其他标签设置display的属性值为table，也不会具有表格的特性；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;总结&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过以上的测试，可以总结出：&lt;br&gt;
display的属性值为&lt;strong&gt;block，table&lt;/strong&gt;的标签都为&lt;code&gt;块状元素&lt;/code&gt;；&lt;br&gt;
display的属性值为&lt;strong&gt;inline，inline-table，inline-block&lt;/strong&gt;的标签为&lt;code&gt;行内级元素&lt;/code&gt;；&lt;/p&gt;
&lt;h1 id=&#34;12-相邻的两个inline-block节点为什么会出现间隔该如何解决&#34;&gt;12. 相邻的两个inline-block节点为什么会出现间隔，该如何解决&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1614841169302.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;121-原因&#34;&gt;12.1 原因&lt;/h2&gt;
&lt;p&gt;其实，html的原因。我们回顾一下这段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;看这里➡️&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;⬅️看这里➡️&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;⬅️看这里&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们不仅看到元素节点，属性节点还有文本节点，问题就是处在文本节点的渲染导致3px(chrome)的间隔。那如何解决它？&lt;/p&gt;
&lt;h2 id=&#34;122-解决办法&#34;&gt;12.2 解决办法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;方法一、删除空白节点&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;看这里➡️&amp;lt;/div
&amp;gt;&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;⬅️看这里➡️&amp;lt;/div
&amp;gt;&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;⬅️看这里&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上的这些方法，无一列外破坏了代码的可读性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法二、负的marigin值&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.box {
    margin: -3px; /*左右缩小3px*/
    display: inline-block;
    width: 100px;
    height: 50px;
    background-color: #ddd;
    text-align: center;
    line-height: 50px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样的方式，可以解决chrome下面的问题。但是不建议使用。因为在某些游览器上面，这个文本节点可能设置成4px的间隔。因为解决问题，引入了新的问题，那就尴尬！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法三、font-size: 0&lt;/strong&gt;&lt;br&gt;
既然是文本节点导致的，那我们就把文本节点设置成0不就ok?顺着这个思路，我们这些写： 我们先给div加一个父级节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;wrapper&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;看这里➡️&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;⬅️看这里➡️&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;⬅️看这里&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.wrapper{
    font-size: 0;
}
.box {
    font-size: 14px;
    display: inline-block;
    width: 100px;
    height: 50px;
    background-color: #ddd;
    text-align: center;
    line-height: 50px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主要： 因为font-size是默认继承的属性。所以父级给了0，子级要重新设置font-size： 14px。&lt;/p&gt;
&lt;h1 id=&#34;13-meta-viewport-移动端适配&#34;&gt;13. meta viewport 移动端适配&lt;/h1&gt;
&lt;h2 id=&#34;131-什么是viewport&#34;&gt;13.1 什么是Viewport?&lt;/h2&gt;
&lt;p&gt;手机浏览器会把页面放入到一个虚拟的“视口”（viewpoint）中，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域大，也可能比浏览器的可视区域小。通常这个虚拟的“视口”（viewport）比屏幕宽，会把网页挤到一个很小的窗口。&lt;br&gt;
如果不显示地设置viewport，那么浏览器就会把width默认设置为980。但后果是浏览器出现横向滚动条，因为浏览器可视区域的宽度比默认的viewport的宽度小。&lt;br&gt;
然后浏览器引进了 viewport 这个 meta tag，让网页开发者来控制 viewport 的大小和缩放。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;132-meta-viewport-的6个属性&#34;&gt;13.2 meta viewport 的6个属性：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;width ： 设置viewport 的宽度&lt;/li&gt;
&lt;li&gt;height： 设置viewport 的高度&lt;/li&gt;
&lt;li&gt;initial-scale ： 设置页面的初始缩放值&lt;/li&gt;
&lt;li&gt;minimum-scale ：允许用户的最小缩放值&lt;/li&gt;
&lt;li&gt;maximum-scale：允许用户的最大缩放值&lt;/li&gt;
&lt;li&gt;user-scalable： 是否允许用户进行缩放，值为&amp;quot;no&amp;quot;或&amp;quot;yes&amp;quot;, no 代表不允许，yes代表允许&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;133-3个viewport&#34;&gt;13.3 3个viewport：&lt;/h2&gt;
&lt;p&gt;（1）&lt;strong&gt;布局视口 layout viewport&lt;/strong&gt;&lt;br&gt;
如果把移动设备上浏览器的可视区域设为viewport的话，某些网站会因为viewport太窄而显示错乱，所以这些浏览器就默认会把viewport设为一个较宽的值，比如980px，使得即使是那些为PC浏览器设计的网站也能在移动设备浏览器上正常显示。这个浏览器默认的viewport叫做 layout viewport。layout viewport的宽度可以通过 document.documentElement.clientWidth来获取。&lt;/p&gt;
&lt;p&gt;（2）&lt;strong&gt;视觉视口 visual viewport&lt;/strong&gt;&lt;br&gt;
layout viewport的宽度是大于浏览器可视区域的宽度的，所以还需要一个viewport来代表浏览器可视区域的大小，这个viewport叫做 visual viewport。visual viewport的宽度可以通过 document.documentElement.innerWidth来获取。&lt;/p&gt;
&lt;p&gt;（3）&lt;strong&gt;理想视口 ideal viewport&lt;/strong&gt;&lt;br&gt;
ideal viewport是一个能完美适配移动设备的viewport。首先，不需要缩放和横向滚动条就能正常查看网站的所有内容；其次，显示的文字、图片大小合适，如14px的文字不会因为在一个高密度像素的屏幕里显示得太小而无法看清，无论是在何种密度屏幕，何种分辨率下，显示出来的大小都差不多。这个viewport叫做 ideal viewport。&lt;/p&gt;
&lt;p&gt;ideal viewport并没有一个固定的尺寸，不同的设备有不同的ideal viewport。例如，所有的iphone的ideal viewport宽度都是320px，无论它的屏幕宽度是320还是640。&lt;br&gt;
ideal viewport 的意义在于，无论在何种分辨率的屏幕下，针对ideal viewport 而设计的网站，不需要缩放和横向滚动条都可以完美地呈现给用户。&lt;/p&gt;
&lt;h2 id=&#34;134-终极方案&#34;&gt;13.4  终极方案：&lt;/h2&gt;
&lt;p&gt;将&lt;code&gt;meta:vp&lt;/code&gt;标签的属性值设置为&lt;code&gt;width=device-width, initial-scale=1&lt;/code&gt;就不仅能够将页面的布局视口自动设置为各个移动设备的理想视口，还能够同时兼容iphone、ipad的Safari以及WP7 IE浏览器的横屏问题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;14-动画和过渡animation-和-transition&#34;&gt;14. 动画和过渡（Animation 和 Transition）&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;animation：CSS 动画，将元素的样式配置转换到另一个CSS配置。包括动画所使用的样式规则，以及用于指定动画开始、结束以及中间多个节点的关键帧；&lt;/li&gt;
&lt;li&gt;transition：CSS过渡属性，为一个元素在不同状态切换的时候定义不同的过渡效果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CSS 中，如果按一秒24帧的画法来写代码，未免太过繁琐。所以我们把动画拆解为&lt;code&gt;动作(transition)&lt;/code&gt;，一个动作表示从一个状态到另一个状态的变化，然后把一组动作串起来，即是 CSS 中的&lt;code&gt;动画(animation)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-transition&#34;&gt;1. Transition&lt;/h2&gt;
&lt;p&gt;transition 直译为过渡，即&lt;strong&gt;给属性变化添加过渡效果&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们知道，如果两个样式属性被赋在同一个元素上，后一个样式属性会覆盖前一个，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.blueball {
  ...
  opacity: 1; /* 不透明 */
}
.blueball:hover {
  opacity: 0.3; /* 透明度 30% */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我们把鼠标放在蓝球上时，蓝球会&lt;strong&gt;立刻&lt;/strong&gt;变透明&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619149280679.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
而如果我们给蓝球增加 transition 属性，其透明度变化会有一个过渡&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.blueball {
  ...
  opacity: 1;
  transition: opacity 1s;  /* 改变 opacity 属性，持续1秒 */
}
.blueball:hover {
  opacity: 0.3;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1619149305472.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里的 transition 属性其实是一个简写形式，它由&lt;strong&gt;四部分组成&lt;/strong&gt;，分别是（冒号后为默认值）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;transition-property: all; /* 过渡属性 */
transition-duration: 0; /* 耗时 */
transition-timing-function: ease; /* 效果，默认 ease（缓入缓出） */
transition-delay: 0; /* 延迟 */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果考虑到默认值，上面过渡效果的例子中，可以进一步简写成&lt;code&gt;transition: 1s&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;transition 可以同时给多个属性添加过渡效果，比如可以在移动元素的同时，改变其透明度。&lt;code&gt;但不管有多少个属性同时在变化，这种过渡效果只能是一次性的，也就是单个动作&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;2-animation&#34;&gt;2. Animation&lt;/h2&gt;
&lt;p&gt;transition 只能做单个动作，如果动画包含多个动作，这时候就需要 animation&lt;/p&gt;
&lt;p&gt;我们先来看个例子：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619150620116.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这个动画明显由两个动作组成：蓝变绿，绿变橙。&lt;/p&gt;
&lt;p&gt;两个连续的线段有三个关键点，两个连续的动作必然也有三个&lt;strong&gt;关键帧&lt;/strong&gt;（keyframe），我们通过定义这三个关键帧（起点，蓝变绿，终点）来定义这两个动作。&lt;/p&gt;
&lt;p&gt;我们来看一下这个动画的 CSS 代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.blueball {
  ...
  background-color: #0080ff; /* 蓝色 */
  position: relative;
  animation: forward 4s; /* 执行 forward 动画，耗时 4s */
}

/* 三个关键帧： 起点（蓝色），蓝变绿，终点（橙色） */
@keyframes forward {
  0% {left: 0; }
  50% {left: 200px; background-color: #009a61;}
  100% {left: 400px; background-color: orange;}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;@keyframes中的百分比，代表时间尺度上的百分比 ，后面跟着的是此时间点的样式。&lt;/p&gt;
&lt;p&gt;同样的，animation: forward 4s;也是简写形式，完整的 animation 属性包括（冒号后为默认值）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;animation-name: none; /* 动画名称 */
animation-duration: 0; /* 耗时 */
animation-timing-function: ease; /* 效果，默认缓入缓出 */
animation-delay: 0; /* 延迟 */
animation-iteration-count: 1; /* 循环次数 */
animation-direction: normal; /* 正放 or 倒放 */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CSS 动画的知识点，就这么些，但目前看来，我们只能动动元素的大小，位置，透明度，颜色什么的，有点单调。为了给动画加点料，下面介绍一下 &lt;code&gt;transform&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-transform&#34;&gt;3. transform&lt;/h2&gt;
&lt;p&gt;transform 直译为变换，虽然名字和 transition 有点像，但是它和动画无关。transition 是一个状态到另一个状态的变化过程，而 transform 仅仅是&lt;strong&gt;静止的最终状态&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如：如果想把蓝球从水平排列中，向下移动100px&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619151581634.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;即可以使用&lt;strong&gt;相对定位&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.blueball {
  ...
  position: relative;
  top: 100px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以使用 &lt;strong&gt;transform&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.blueball {
  ...
  transform: translateY(100px);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它们的效果是一致的，都是把蓝球向下移动 100px&lt;/p&gt;
&lt;p&gt;除了位移，tranform 还可以做很多变换&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;matrix 矩阵变换&lt;/li&gt;
&lt;li&gt;translate 位移&lt;/li&gt;
&lt;li&gt;scale 缩放&lt;/li&gt;
&lt;li&gt;rotate 绕轴旋转&lt;/li&gt;
&lt;li&gt;skew 倾斜&lt;/li&gt;
&lt;li&gt;perspective 透视距离&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;这里有几点需要说明:&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-transform-原点位于元素中心&#34;&gt;1. transform 原点位于元素中心&lt;/h3&gt;
&lt;p&gt;我们知道 CSS 元素默认的坐标系，原点在左上角；而 transform 变换的原点位于元素中心&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619151713261.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
图中亦标识了绕轴旋转（rotate）时的默认方向，为了便于记忆，你可以理解为：你站在原点位置，看向正轴方向，默认旋转方向为&lt;strong&gt;逆时针旋转&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-理解-skew倾斜&#34;&gt;2. 理解 skew（倾斜）&lt;/h3&gt;
&lt;p&gt;skew 倾斜变换并不直观，为了便于记忆，你可以这样想像：&lt;br&gt;
你拉住了矩形的&lt;code&gt;右下角&lt;/code&gt;，左右横拉，即是沿X轴倾斜&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619151914829.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
同样的，skewY 即是抓住右下角上下拉&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619151918106.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-理解-perspective透视&#34;&gt;3. 理解 perspective（透视）&lt;/h3&gt;
&lt;p&gt;perspective 表示透视距离，可简单理解为眼睛离屏幕的距离&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;transform: translateZ(100x); /* 向Z轴正向移动 100px */
perspective: 200px; /* 透视距离 200px */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们用一张图来说明一下&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619151963081.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;d 为透视距离 200px&lt;/li&gt;
&lt;li&gt;Z 为元素在Z轴上移动的距离 100px&lt;/li&gt;
&lt;li&gt;虚线的圆表示元素实际的位置&lt;/li&gt;
&lt;li&gt;而蓝色的圆，是元素在屏幕上的投影，也是最终展示的效果&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;15-css性能优化&#34;&gt;15. CSS性能优化&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;下面我们开始介绍&lt;strong&gt;实践型&lt;/strong&gt;的3个优化技巧，先从首屏关键CSS开始。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1-内联首屏关键csscritical-css&#34;&gt;1. 内联首屏关键CSS（Critical CSS）&lt;/h2&gt;
&lt;p&gt;性能优化中有一个重要的指标——&lt;code&gt;首次有效绘制&lt;/code&gt;（First Meaningful Paint，简称FMP）即指页面的首要内容（primary content）出现在屏幕上的时间。这一指标影响用户看到页面前所需等待的时间，而**内联首屏关键CSS（即Critical CSS，可以称之为首屏关键CSS）**能减少这一时间。&lt;/p&gt;
&lt;p&gt;大家应该都习惯于通过link标签引用外部CSS文件。但需要知道的是，将CSS直接内联到HTML文档中能使CSS更快速地下载。而使用外部CSS文件时，需要在HTML文档下载完成后才知道所要引用的CSS文件，然后才下载它们。所以说，内联CSS能够使浏览器开始页面渲染的时间提前，因为在HTML下载完成之后就能渲染了。&lt;/p&gt;
&lt;p&gt;既然已经知道内联首屏关键CSS能够优化性能了，那下一步就是如何确定首屏关键CSS了。显然，我们不需要手动确定哪些内容是首屏关键CSS。Github上有一个项目Critical CSS4，可以将属于首屏的关键样式提取出来，大家可以看一下该项目，结合自己的构建工具进行使用。当然为了保证正确，大家最好再亲自确认下提取出的内容是否有缺失。&lt;/p&gt;
&lt;h2 id=&#34;2-异步加载css&#34;&gt;2. 异步加载CSS&lt;/h2&gt;
&lt;p&gt;CSS会阻塞渲染，在CSS文件请求、下载、解析完成之前，浏览器将不会渲染任何已处理的内容。有时，这种阻塞是必须的，因为我们并不希望在所需的CSS加载之前，浏览器就开始渲染页面。那么将首屏关键CSS内联后，剩余的CSS内容的阻塞渲染就不是必需的了，可以使用外部CSS，并且异步加载。&lt;/p&gt;
&lt;p&gt;第一种方式是使用JavaScript动态创建样式表link元素，并插入到DOM中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 创建link标签
const myCSS = document.createElement( &amp;quot;link&amp;quot; );
myCSS.rel = &amp;quot;stylesheet&amp;quot;;
myCSS.href = &amp;quot;mystyles.css&amp;quot;;
// 插入到header的最后位置
document.head.insertBefore( myCSS, document.head.childNodes[ document.head.childNodes.length - 1 ].nextSibling );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，&lt;code&gt;rel=&amp;quot;preload&amp;quot;&lt;/code&gt;这一Web标准指出了如何异步加载资源，包括CSS类资源。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;link rel=&amp;quot;preload&amp;quot; href=&amp;quot;mystyles.css&amp;quot; as=&amp;quot;style&amp;quot; onload=&amp;quot;this.rel=&#39;stylesheet&#39;&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，&lt;code&gt;as&lt;/code&gt;是必须的。忽略&lt;code&gt;as&lt;/code&gt;属性，或者错误的&lt;code&gt;as&lt;/code&gt;属性会使&lt;code&gt;preload&lt;/code&gt;等同于&lt;code&gt;XHR&lt;/code&gt;请求，浏览器不知道加载的是什么内容，因此此类资源加载&lt;strong&gt;优先级会非常低&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;看起来，rel=&amp;quot;preload&amp;quot;的用法和上面两种没什么区别，都是通过更改某些属性，使得浏览器异步加载CSS文件但不解析，直到加载完成并将修改还原，然后开始解析。&lt;/p&gt;
&lt;p&gt;但是它们之间其实有一个很重要的不同点，那就是使用&lt;code&gt;preload&lt;/code&gt;，比使用不匹配的media方法能够更早地开始加载CSS。所以尽管这一标准的支持度还不完善，仍建议优先使用该方法。&lt;/p&gt;
&lt;h2 id=&#34;3-文件压缩&#34;&gt;3. 文件压缩&lt;/h2&gt;
&lt;p&gt;性能优化时有一个最容易想到，也最常使用的方法，那就是文件压缩，这一方案往往效果显著。&lt;/p&gt;
&lt;p&gt;文件的大小会直接影响浏览器的加载速度，这一点在网络较差时表现地尤为明显。相信大家都早已习惯对CSS进行压缩，现在的构建工具，如webpack、gulp/grunt、rollup等也都支持CSS压缩功能。压缩后的文件能够明显减小，可以大大降低了浏览器的加载时间。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;前面已经说完了实践型的3个优化技巧，下面我们介绍下&lt;strong&gt;建议型&lt;/strong&gt;的3个技巧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1-有选择地使用选择器&#34;&gt;1. 有选择地使用选择器&lt;/h2&gt;
&lt;p&gt;我们在使用选择器时，只需要记住以下几点，其他的可以全凭喜好。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;保持简单，不要使用嵌套过多过于复杂的选择器。&lt;/li&gt;
&lt;li&gt;通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用。&lt;/li&gt;
&lt;li&gt;不要使用类选择器和ID选择器修饰元素标签，如h3#markdown-content，这样多此一举，还会降低效率。&lt;/li&gt;
&lt;li&gt;不要为了追求速度而放弃可读性与可维护性。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-优化重排与重绘&#34;&gt;2. 优化重排与重绘&lt;/h2&gt;
&lt;h3 id=&#34;1-减少重排&#34;&gt;1. 减少重排&lt;/h3&gt;
&lt;p&gt;重排会导致浏览器重新计算整个文档，重新构建渲染树，这一过程会降低浏览器的渲染速度。如下所示，有很多操作会触发重排，我们应该避免频繁触发这些操作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;改变font-size和font-family&lt;/li&gt;
&lt;li&gt;改变元素的内外边距&lt;/li&gt;
&lt;li&gt;通过JS改变CSS类&lt;/li&gt;
&lt;li&gt;通过JS获取DOM元素的位置相关属性（如width/height/left等）&lt;/li&gt;
&lt;li&gt;CSS伪类激活&lt;/li&gt;
&lt;li&gt;滚动滚动条或者改变窗口大小&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;值得一提的是，某些CSS属性具有更好的重排性能。如使用Flex时，比使用inline-block和float时重排更快，所以在布局时可以优先考虑&lt;code&gt;Flex&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;2-避免不必要的重绘&#34;&gt;2. 避免不必要的重绘&lt;/h3&gt;
&lt;p&gt;当元素的外观（如color，background，visibility等属性）发生改变时，会触发重绘。在网站的使用过程中，&lt;strong&gt;重绘是无法避免的&lt;/strong&gt;。不过，浏览器对此做了优化，它会将多次的重排、重绘操作合并为一次执行。不过我们仍需要&lt;strong&gt;避免不必要的重绘&lt;/strong&gt;，如页面滚动时触发的hover事件，可以在滚动的时候禁用hover事件，这样页面在滚动时会更加流畅。&lt;/p&gt;
&lt;p&gt;如果需要在移动端访问的，最好将速度限制更低，因为移动端的性能往往更差。&lt;/p&gt;
&lt;h2 id=&#34;3-不要使用import&#34;&gt;3. 不要使用@import&lt;/h2&gt;
&lt;p&gt;最后提一下，不要使用@import引入CSS，相信大家也很少使用。&lt;/p&gt;
&lt;p&gt;不建议使用@import主要有以下两点原因。&lt;/p&gt;
&lt;p&gt;首先，使用@import引入CSS会影响浏览器的并行下载。使用@import引用的CSS文件只有在引用它的那个css文件被下载、解析之后，浏览器才会知道还有另外一个css需要下载，这时才去下载，然后下载后开始解析、构建render tree等一系列操作。这就导致浏览器无法并行下载所需的样式文件。&lt;/p&gt;
&lt;p&gt;其次，多个@import会导致下载顺序紊乱。在IE中，@import会引发资源文件的下载顺序被打乱，即&lt;strong&gt;排列在@import后面的js文件先于@import下载，并且打乱甚至破坏@import自身的并行下载。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以不要使用这一方法，使用link标签就行了。&lt;/p&gt;
&lt;h1 id=&#34;16-移动端dom优化&#34;&gt;16. 移动端dom优化&lt;/h1&gt;
&lt;h2 id=&#34;1-原因&#34;&gt;1. 原因&lt;/h2&gt;
&lt;p&gt;从上面可以看出随着dom的增加 ，HTMLLIElement占用的内存逐渐增加，这是由于下拉加载过程中在页面中添加了LI元素。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Shallow Size：&lt;br&gt;
Shallow size就是对象本身占用内存的大小，不包含其引用的对象。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;常规对象（非数组）的 Shallow size 由其成员变量的数量和类型决定。&lt;/li&gt;
&lt;li&gt;数组的shallow size有数组元素的类型（对象类型、基本类型）和数组长度决定。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Retained Size:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;对象的Retained Size = 对象本身的Shallow Size + 对象能直接或间接访问到的对象的Shallow Size&lt;/li&gt;
&lt;li&gt;也就是说 Retained Size 就是该对象被 GC（Garbage Collection） 之后所能回收内存的总和。&lt;br&gt;
这里GC是指垃圾回收，浏览器的主流垃圾回收机制时标记清除（ie中存在引用计数清除）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;除了dom节点内存增大，监听事件占用的内存也逐渐加大&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;随着内存的占用增大，到一定程度时，网页就出现了卡顿。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-解决办法&#34;&gt;2. 解决办法：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;重复利用dom结构，创建虚拟列表&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用事件委托，将监听事件绑定到父元素上&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;虚拟 dom 渲染&lt;/strong&gt;：长列表方案，手动假分页，只渲染当前和上下两页数据&lt;br&gt;
&lt;strong&gt;清理页面&lt;/strong&gt;：删除不必要或者暂时隐藏的元素，调整图片大小。如果可以的话，调整一下页面设计，两数据分开展示，避免一次渲染过多。可以考虑滚动加载&lt;/p&gt;
&lt;h2 id=&#34;3-实现思路&#34;&gt;3. 实现思路&lt;/h2&gt;
&lt;p&gt;因为 DOM 元素的创建和渲染需要的时间成本很高，在大数据的情况下，完整渲染列表所需要的时间不可接收。其中一个解决思路就是在任何情况下只对「可见区域」进行渲染，可以达到极高的初次渲染性能。&lt;/p&gt;
&lt;p&gt;虚拟列表指的就是「可视区域渲染」的列表，重要的基本就是两个概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可滚动区域：假设有 1000 条数据，每个列表项的高度是 30，那么可滚动的区域的高度就是 1000 * 30。当用户改变列表的滚动条的当前滚动值的时候，会造成可见区域的内容的变更。&lt;/li&gt;
&lt;li&gt;可见区域：比如列表的高度是 300，右侧有纵向滚动条可以滚动，那么视觉可见的区域就是可见区域。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现虚拟列表就是处理滚动条滚动后的可见区域的变更，其中具体步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算当前可见区域起始数据的 startIndex&lt;/li&gt;
&lt;li&gt;计算当前可见区域结束数据的 endIndex&lt;/li&gt;
&lt;li&gt;计算当前可见区域的数据，并渲染到页面中&lt;/li&gt;
&lt;li&gt;计算 startIndex 对应的数据在整个列表中的偏移位置 startOffset，并设置到列表上&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1627194719639.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;17-css画一个三角形&#34;&gt;17. CSS画一个三角形&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;CSS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
        /* css3绘制三角形 */
        .triangle{
            width: 0px;                           /*设置宽高为0，所以div的内容为空，从才能形成三角形尖角*/
            height: 0px;
            border-bottom: 200px solid #00a3af;
            border-left: 200px solid transparent;    /*transparent 表示透明*/
            border-right: 200px solid transparent;
        }
    &amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Html&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;div class=&amp;quot;triangle&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1614860077842.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;18-1像素边框问题&#34;&gt;18. 1像素边框问题&lt;/h1&gt;
&lt;h2 id=&#34;181-为什么1px变粗了&#34;&gt;18.1 为什么1px变粗了？&lt;/h2&gt;
&lt;p&gt;UI设计师要求的1px是指设备的物理像素1px，而CSS里记录的像素是逻辑像素，它们之间存在一个比例关系，可以用javascript中的window.devicePixelRatio来获取&lt;/p&gt;
&lt;p&gt;移动端开发常需要在html的header里添加如下一句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这句话定义了本页面的viewport的宽度为设备宽度，初始缩放值和最大缩放值都为1，并禁止了用户缩放。&lt;/p&gt;
&lt;h2 id=&#34;182-修改方案&#34;&gt;18.2 修改方案&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;viewport + rem 方案&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;该方案是对上述方案的优化，整体思路就是利用viewport + rem + js 动态的修改页面的缩放比例，实现小于1像素的显示。在页面初始化时，在头部引入原始默认状态如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html;charset=UTF-8&amp;quot;&amp;gt;  
&amp;lt;meta name=&amp;quot;viewport&amp;quot; id=&amp;quot;WebViewport&amp;quot; content=&amp;quot;initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&amp;quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来的任务就是js的动态修改缩放比 以及 实现rem根元素字体大小的设置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var viewport = document.querySelector(&amp;quot;meta[name=viewport]&amp;quot;)
if (window.devicePixelRatio == 1) {
    viewport.setAttribute(&#39;content&#39;, &#39;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&#39;)
} 
if (window.devicePixelRatio == 2) {
    viewport.setAttribute(&#39;content&#39;, &#39;width=device-width, initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&#39;)
} 
if (window.devicePixelRatio == 3) {
    viewport.setAttribute(&#39;content&#39;, &#39;width=device-width, initial-scale=0.333333333, maximum-scale=0.333333333, minimum-scale=0.333333333, user-scalable=no&#39;)
} 

var docEl = document.documentElement;
var fontsize = 10 * (docEl.clientWidth / 320) + &#39;px&#39;;
docEl.style.fontSize = fontsize;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;transform: scale(0.5) 方案 - 推荐: 很灵活&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置height: 1px，根据媒体查询结合&lt;code&gt;transform&lt;/code&gt;缩放为相应尺寸。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;div {
    height:1px;
    background:#000;
    -webkit-transform: scaleY(0.5);
    -webkit-transform-origin:0 0;
    overflow: hidden;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;用&lt;code&gt;::after&lt;/code&gt;和&lt;code&gt;::befor&lt;/code&gt;,设置&lt;code&gt;border-bottom：1px solid #000&lt;/code&gt;,然后在缩放&lt;code&gt;-webkit-transform: scaleY(0.5)&lt;/code&gt;;可以实现两根边线的需求&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;div::after{
    content:&#39;&#39;;width:100%;
    border-bottom:1px solid #000;
    transform: scaleY(0.5);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;用&lt;code&gt;::after&lt;/code&gt;设置&lt;code&gt;border：1px solid #000; width:200%; height:200%&lt;/code&gt;,然后再缩放&lt;code&gt;scaleY(0.5)&lt;/code&gt;; 优点可以实现圆角，京东就是这么实现的，缺点是按钮添加active比较麻烦。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;.div::after {
    content: &#39;&#39;;
    width: 200%;
    height: 200%;
    position: absolute;
    top: 0;
    left: 0;
    border: 1px solid #bfbfbf;
    border-radius: 4px;
    -webkit-transform: scale(0.5,0.5);
    transform: scale(0.5,0.5);
    -webkit-transform-origin: top left;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;19-移动端适配&#34;&gt;19. 移动端适配&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;meta标签到底做了什么事情&lt;/strong&gt;&lt;br&gt;
做过移动端适配的小伙伴一定有遇到过这行代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是，很多小伙伴只是感性的认识：噢，我加了这行代码，然后页面的宽度就会跟我的设备宽度一致。然而，这种理解是很片面的。那么，这句话的本质到底是什么呢？&lt;/p&gt;
&lt;p&gt;不急，我们先往下面看，这里先留个悬念。&lt;/p&gt;
&lt;h2 id=&#34;1-几个专有名词和单位&#34;&gt;1. 几个专有名词和单位&lt;/h2&gt;
&lt;p&gt;这里，我们先来辨析一下在适配的时候经常会遇到的一些名词、数值单位。&lt;/p&gt;
&lt;p&gt;首先，先来看一下&lt;strong&gt;物理像素&lt;/strong&gt;。&lt;br&gt;
以iphone6为例，可知道：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分辨率&lt;/strong&gt;：1334pt x 750pt&lt;br&gt;
指的是屏幕上垂直有1334个物理像素，水平有750个物理像素。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;屏幕尺寸&lt;/strong&gt;：4.7in&lt;br&gt;
注意英寸是长度单位，不是面积单位。4.7英寸指的是屏幕对角线的长度，1英寸等于2.54cm。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;屏幕像素密度&lt;/strong&gt;：326ppi&lt;br&gt;
指的是每英寸屏幕所拥有的像素数，在显示器中，dpi=ppi。dpi强调的是每英寸多少点。同时，&lt;strong&gt;屏幕像素密度=分辨率/屏幕尺寸&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接着，我们来看一下其他的单位。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;设备独立像素&lt;/strong&gt;：设备独立像素，不同于设备像素（物理像素），它是虚拟化的。比如说css像素，我们常说的10px其实指的就是它。需要注意的是，&lt;strong&gt;物理像素&lt;/strong&gt;开发者是无法获取的，它是自然存在的一种东西，该是多少就是多少。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设备像素比&lt;/strong&gt;：缩写简称dpr，也就是我们经常在谷歌控制台移动端调试顶端会看到的一个值。&lt;strong&gt;设备像素比 = 设备像素 / css像素&lt;/strong&gt;（垂直方向或水平方向）。可以通过JS来获取：&lt;code&gt;window.devicePixelRatio&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-pc和移动端不同的视口&#34;&gt;2. PC和移动端不同的视口&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注：以下涉及的像素均为CSS像素。并且默认不考虑缩放。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-布局视口&#34;&gt;1. 布局视口&lt;/h3&gt;
&lt;p&gt;写过css的小伙伴应该知道，我们在&lt;code&gt;html、body&lt;/code&gt;设置&lt;code&gt;width:100%;height:100%&lt;/code&gt;;的时候，它并不是无效的。我们都知道&lt;code&gt;100%&lt;/code&gt;这种百分数应该是继承父元素而来的。那在这里是继承哪里的呢？&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;PC浏览器&lt;/strong&gt;中，有一个用来约束CSS布局视口的东西，又叫做初始包含块。这也就是所有宽高继承的由来。除去&lt;code&gt;margin&lt;/code&gt;、&lt;code&gt;padding&lt;/code&gt;，布局视口和浏览器可视窗口宽度是一致的，同时也和浏览器本身的宽度一致。&lt;/p&gt;
&lt;p&gt;但是在移动端，就大不一样了。&lt;br&gt;
以下的例子是在不加&lt;code&gt;meta&lt;/code&gt;标签的前提下进行演示的。&lt;br&gt;
假如我们现在做一个二八分的左右布局，那么如果在PC端上面的话，显示的效果非常完美，这没什么好说的。&lt;br&gt;
那如果是在手机端呢，这里以iphone6为例子来讲解：&lt;br&gt;
图例如下：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1628424884711.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* {
    margin: 0;
    padding: 0;
}

html,
body {
    height: 100%;
    width: 100%;
}

.left {
    float: left;
    width: 20%;
    height: 100%;
    background: red;
}

.right {
    float: right;
    width: 80%;
    height: 100%;
    background: green;
}
----
&amp;lt;body&amp;gt;
    &amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我们会看到，为什么body的宽度是980px，而浏览器的宽度只有375px，那么这个980px到底是从哪里来的呢？&lt;br&gt;
其实，这里的980px就是移动端所谓的&lt;strong&gt;布局视口&lt;/strong&gt;了。&lt;/p&gt;
&lt;p&gt;在移动端，默认的情况下，布局视口的宽度是要远远大于浏览器的宽度的。这两个视口不同于PC端，是&lt;strong&gt;相互独立存在&lt;/strong&gt;的。为什么呢？试想一下，如果一个网页不对移动端进行适配，用户进行阅读的时候，如果默认情况下布局视口的宽度等于浏览器宽度，那是不是展示起来更加的不友好。也就是说，如果一个&lt;code&gt;div&lt;/code&gt;的宽度为20%，那么它在布局视口宽度为&lt;code&gt;980px&lt;/code&gt;的时候，展示给用户的像素还有196px，而如果宽度只有&lt;code&gt;375px&lt;/code&gt;的情况下，宽度只有&lt;code&gt;75px&lt;/code&gt;，展示的大小相差特别大。&lt;/p&gt;
&lt;p&gt;所以，浏览器厂商为了让用户在小屏幕下网页也能够显示地很好，所以把布局视口宽度设置地很大，一般在&lt;code&gt;768px ~ 1024px&lt;/code&gt;之间，最常见的宽度是&lt;code&gt;980px&lt;/code&gt;。这个宽度可以通过&lt;code&gt;document.documentElement.clientWidth&lt;/code&gt;得到。&lt;/p&gt;
&lt;h3 id=&#34;2-视觉视口&#34;&gt;2. 视觉视口&lt;/h3&gt;
&lt;p&gt;对于视觉视口来说，这个东西是呈现给用户的，它是用户看到网页区域内CSS像素的数量。由于用户可以自行进行缩放控制，所以这个视口并不是开发者需要重点关注的。&lt;/p&gt;
&lt;p&gt;值得注意的是，在&lt;strong&gt;移动端&lt;/strong&gt;缩放不会改变布局视口的宽度，当缩小的时候，屏幕覆盖的css像素变多，视觉视口变大，反之亦然。&lt;br&gt;
而在&lt;strong&gt;PC端&lt;/strong&gt;，缩放对应布局宽度和视觉窗口宽度都是&lt;strong&gt;联动&lt;/strong&gt;的。而浏览器宽度本身是固定的，无论怎么缩放都不受影响。&lt;/p&gt;
&lt;p&gt;如果对上面的宽度还是很乱，那么这里有一个表格可以帮助你理清思路。&lt;br&gt;
以下表格横向都以浏览器窗口的宽度作为基准：&lt;br&gt;
对于PC端来说：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1628425034633.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
对于移动端来说：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1628425041492.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-理想视口&#34;&gt;3. 理想视口&lt;/h3&gt;
&lt;p&gt;以上，布局视口很明显对用户十分的不友好，完全忽略了手机本来的尺寸。&lt;/p&gt;
&lt;p&gt;所以苹果引入了理想视口的概念，它是对设备来说最理想的布局视口尺寸。理想视口中的网页用户最理想的宽度，用户进入页面的时候不需要缩放。&lt;/p&gt;
&lt;p&gt;那么很明显，所谓的理想宽度就是浏览器（屏幕）的宽度了。&lt;br&gt;
所以就有了下面的这段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然而，这段代码其实也并不完美，在IE浏览器中，由于横屏竖屏的切换会对其造成影响，为了解决这个兼容性的问题，最后再加上一句，就有了现在的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;width=device-width&lt;/code&gt; 这句代码可以把布局视口设置成为浏览器（屏幕）的宽度。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;initial-scale=1&lt;/code&gt; 的意思是初始缩放的比例是1，使用它的时候，同时也会将布局视口的尺寸设置为缩放后的尺寸。而缩放的尺寸就是基于屏幕的宽度来的，也就起到了和&lt;code&gt;width=device-width&lt;/code&gt;同样的效果。&lt;/p&gt;
&lt;p&gt;另外，值得一提的是，我们在进行媒体查询的时候，查询的宽度值其实也是布局视口的宽度值。&lt;/p&gt;
&lt;h2 id=&#34;3-retina屏幕普通屏幕模糊的由来&#34;&gt;3. Retina屏幕&amp;amp;普通屏幕，模糊的由来&lt;/h2&gt;
&lt;h3 id=&#34;1-dpr的具体表现&#34;&gt;1. dpr的具体表现&lt;/h3&gt;
&lt;p&gt;有时候我们会发现，当我们在适某一机型的时候，显示上没什么问题。但是一旦我换到另外一部手机，发现出现了模糊的情况，尤其以图片更为显著。&lt;/p&gt;
&lt;p&gt;其实这个问题，就是涉及到了上面讲到的一个属性：&lt;strong&gt;设备像素比&lt;/strong&gt;，即我们经常说的&lt;strong&gt;dpr&lt;/strong&gt;。下面先来看&lt;strong&gt;dpr&lt;/strong&gt;的表现：&lt;/p&gt;
&lt;p&gt;假设现在有一台iphone6，那么它的设备独立像素是375x667，dpr为2，尺寸是4.7in，那么物理像素就是750x1334。&lt;br&gt;
同样的我们也有一台不知名的设备，它的设备独立像素刚好也是375x667，尺寸也是4.7in，但是dpr为1，此时的物理像素就是375x667。&lt;/p&gt;
&lt;p&gt;于是，它们的屏幕表现如下：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1628425204251.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在不同的屏幕上，无论是普通屏幕还是retina屏幕，&lt;strong&gt;css像素所呈现的大小是一致的&lt;/strong&gt;。（如果不理解这句话，可以写一个2px的正方形使用谷歌控制台移动设备调试，在不同的设备之间来回切换，你会发现大小其实是一样的。一开始我总以为这个css像素的实际宽高因为受到dpr的影响而在不同设备上的长宽是不一致的。）&lt;br&gt;
不同的是，1个css像素对应（覆盖）的物理像素个数。&lt;/p&gt;
&lt;p&gt;所以，如果我们想要在这两个屏幕显示这么一个css样式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;width: 2px;
heigth: 2px;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在普通屏幕下，也就是dpr为1的屏幕中，1个css像素对应（覆盖）的是一个物理像素。在retina屏幕下，1个css像素对应（覆盖）的是4个物理像素。换句话说，就是dpr为2的设备。看下面这张图：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1628425251728.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
浅显的理解就是可以看作是2cmx2cm的正方形被切割成四块，然后遇到dpr为2的时候，被切割的四块又被分别切割成四块，但是总面积不变。&lt;/p&gt;
&lt;h3 id=&#34;2-模糊的产生&#34;&gt;2. 模糊的产生&lt;/h3&gt;
&lt;p&gt;知道了1个css像素覆盖的物理像素可能不同，就好理解为什么会出现模糊的情况了。&lt;/p&gt;
&lt;p&gt;这里又讲到一个名词：&lt;strong&gt;位图像素&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;位图像素是栅格图像（如：png,jpg,gif等）最小的数据单元。每一个位图像素都包含着一些自身的显示信息。（如：显示位置，颜色值，透明度等）&lt;/p&gt;
&lt;p&gt;理论上来说，&lt;strong&gt;1个位图像素对应1个物理像素，图片才能达到完美清晰的展示&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但是上面说过，在retina屏幕上，会出现1个位图像素对应多个物理像素。&lt;/p&gt;
&lt;p&gt;还是以iphone6为例，1个位图像素对应4个物理像素。由于单个位图像素已经是最小的数据单位了，它不能再被进行切割。于是为了能够显示出来，就只能就近取色，从而导致所谓的图片模糊问题。如下：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1628425292725.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-如何解决&#34;&gt;3. 如何解决&lt;/h3&gt;
&lt;p&gt;很明显，由于位图像素不够分而产生模糊的情况，解决的办法十分简单，就是使用跟dpr同个倍数大小的图片。比如iphone6，一个200x300的&lt;code&gt;img&lt;/code&gt;标签，原图就要提供400x600的大小。&lt;/p&gt;
&lt;p&gt;那么当加载到&lt;code&gt;img&lt;/code&gt;标签中，浏览器会自动对每1px的css像素减半，可以理解为此时还是维持着1:1的css像素:物理像素，不产生模糊。&lt;/p&gt;
&lt;p&gt;这个做法其实就是手淘团队在做retina适配的一个重要的原理之一，后面会讲到，这里先放着不说。&lt;/p&gt;
&lt;h3 id=&#34;4-其他&#34;&gt;4. 其他&lt;/h3&gt;
&lt;p&gt;反向思考一下，如果普通屏幕，也就是dpr为1的屏幕，也使用了两倍的图片，会发生什么样的情况呢？&lt;/p&gt;
&lt;p&gt;很明显，在普通屏幕下，200×300的&lt;code&gt;img&lt;/code&gt;标签，所对应的物理像素个数就是200×300个，而两倍图片的位图像素个数则是200x300x4，于是就出现一个物理像素点对应4个位图像素点，所以它的取色也只能通过一定的算法进行缩减，显示结果就是一张只有原图像素总数四分之一，肉眼看上去虽然图片不会模糊，但是会觉得有点色差。（其实就是模糊的逆向过程）&lt;br&gt;
用图片来表示就是：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1628425382498.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里摘取了网上一篇博文的demo来阐述上面所说的问题。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1628425395928.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
以上是一张100x100的图片，分别放在了100x100，50x50，25x25的容器中，在retina屏幕下面的显示效果。&lt;/p&gt;
&lt;p&gt;通过取色器放大镜可以看出边界像素点的差别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在图一中，边界像素点就近取色，色值介于红白之间，偏淡，图片看上去会模糊(可以理解为图片拉伸)。&lt;/li&gt;
&lt;li&gt;在图二中，图片正常，很清晰。&lt;/li&gt;
&lt;li&gt;在图三中，边界像素点就近取色，色值介于红白之间，偏浓，图片看上去有色差。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-手淘团队flexiblejs布局&#34;&gt;4. 手淘团队flexible.js布局&lt;/h2&gt;
&lt;p&gt;现今，适配手机端的传统rem布局已经逐步被手淘团队的一套flexible布局代替。&lt;br&gt;
具体的实现方式以及细节这里也不铺开来说，具体参考w3cplus的一篇文章，很容易读懂和理解。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1628734320201.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里我更想分析一下flexible.js做法的意义和原因。&lt;br&gt;
读过文章之后，相信大家应该对整个开发适配的流程比较熟悉了。&lt;br&gt;
假设现在要适配一个iphone6的设备。上面已经说过了iphone6的各个参数，这里不再赘述，需要的自行上移查看。&lt;br&gt;
&lt;strong&gt;于是&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设计师给了一个750px宽度的设计稿（注意这里是750px而不是375px）&lt;/li&gt;
&lt;li&gt;前端工程师用750px的这个比例开始还原&lt;/li&gt;
&lt;li&gt;把宽高是px的转换成rem&lt;/li&gt;
&lt;li&gt;字体使用px而不使用rem&lt;/li&gt;
&lt;li&gt;flexible.js会自动判断dpr进行整个布局视口的放缩&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;1-rem布局和字体的处理&#34;&gt;1. rem布局和字体的处理&lt;/h3&gt;
&lt;p&gt;从flexible.js中可见，在宽高中使用的是rem，这是为了保证在不同宽度尺寸的设备中能够保证布局的等比例缩放。&lt;/p&gt;
&lt;p&gt;而为什么字体不使用rem而是采用px呢？&lt;/p&gt;
&lt;p&gt;首先，用过rem单位的小伙伴都会发现，使用rem后由于不同的尺寸，换算之后出现各种奇奇怪怪的数值，最为明显的就是更多的小数位，比如&lt;code&gt;13.755px&lt;/code&gt;之类的数值。在浏览器中，各浏览器中对小数点的计算存在偏差，而且有些带小数的&lt;code&gt;font-size&lt;/code&gt;值在特定的浏览器显示并不够清晰。&lt;/p&gt;
&lt;p&gt;其次，我们希望在小屏幕下面显示跟大屏幕同等量的字体。并且如果使用rem的话，那么由于等比例的存在，在小屏幕下就会存在小屏幕字体更小的情况，不利于我们更好的去阅读，违背了适配的初衷。所以，对于字体的适配，更好的做法就是使用px和媒体查询来进行适配。&lt;/p&gt;
&lt;p&gt;所以，也就不难解释为什么要对&lt;code&gt;font-size&lt;/code&gt;进行放大的处理了，如下的sass代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@mixin font-dpr($font-size) {
    font-size: $font-size;
    [data-dpr=&amp;quot;2&amp;quot;] &amp;amp; {
        font-size: $font-size * 2;
    }
    [data-dpr=&amp;quot;3&amp;quot;] &amp;amp; {
        font-size: $font-size * 3;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于retina屏幕下dpr的不同，我们又想显示的字体一样大，于是就给字体再增大dpr的倍数，这样当缩小dpr倍的时候，那么字体也就和设计稿所示的大小一样大了，在不同的手机中显示的大小也是一致的。&lt;/p&gt;
&lt;h3 id=&#34;2-retina屏幕下的处理与安卓手机的适配&#34;&gt;2. Retina屏幕下的处理与安卓手机的适配&lt;/h3&gt;
&lt;p&gt;从flexible.js的代码中可以知道，flexible布局仅仅只是针对iPhone进行适配，而默认所有的安卓设备都强制性设置dpr为1。&lt;/p&gt;
&lt;p&gt;于是，因为这个缘故，很多小伙伴可能就会产生这样的问题：&lt;strong&gt;为什么安卓不用retina屏幕，安卓下面是不是就不会有模糊的问题？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实不然，&lt;strong&gt;模糊的本质是因为dpr&lt;/strong&gt;，而安卓手机不同的设备的dpr也是不尽相同的。也就是说，安卓手机下也存在模糊的情况。只不过它的屏幕不叫retina屏幕，没有这个叫法，所以很多小伙伴都误认为安卓手机没有这个毛病。&lt;/p&gt;
&lt;p&gt;那么问题又来了？既然也有模糊的毛病，那么为什么安卓手机不进行适配呢？&lt;/p&gt;
&lt;p&gt;问题就在这里了，有兴趣的小伙伴可以去看一下大中华的安卓手机，dpr参数五花八门，从1到4，连1.75、2.75这种奇葩的数字也有，所以个人觉得权衡之下，直接简单“粗暴”把安卓手机全部设置为1，是效率和收益更高的做法。&lt;/p&gt;
&lt;p&gt;当然，也有人进行了flexible.js的改进，就是对dpr比较正常的安卓手机进行适配，也就是说只适配dpr为整数的安卓设备。对于那些奇葩的dpr为1.75的设备直接忽略。实现这个并不难，有兴趣的小伙伴们可以试下。&lt;/p&gt;
&lt;h2 id=&#34;5-适配方案&#34;&gt;5. 适配方案：&lt;/h2&gt;
&lt;p&gt;上面讲了一些基础概念，下面讲具体适配。&lt;/p&gt;
&lt;p&gt;对于ui设计师给的一张设计稿，怎么将其还原到页面上？对于不同手机屏幕，其dpr不同，屏幕尺寸也不同，考虑到各种情况，有很多适配方案，所以不同的适配方案，实现方法不同，处理复杂度也不同，还原程度也不同。&lt;/p&gt;
&lt;h3 id=&#34;方案一&#34;&gt;方案一：&lt;/h3&gt;
&lt;p&gt;固定高度，宽度自适应。&lt;br&gt;
这种方案是目前使用较多的方案，也是相对较简单的实现方案：&lt;br&gt;
该方法使用了理想视口：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;垂直方向使用固定的值，水平方向使用弹性布局，元素采用定值、百分比、flex布局等。这种方案相对简单，还原度也非常低。&lt;/p&gt;
&lt;h3 id=&#34;方案二&#34;&gt;方案二：&lt;/h3&gt;
&lt;p&gt;固定布局视口宽度，使用viewport进行缩放&lt;/p&gt;
&lt;p&gt;固定布局视口，宽度设置固定的值，总宽度为640px，根据屏幕宽度动态生成viewport。（设计稿应该是640px的）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=640, minimum-scale = 0.5625, maximum-scale = 0.5625, target-densitydpi=device-dpi&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方式布局如荔枝FM的网页宽度始终为640px。缩放比例scale为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var scale = window.screen.width / 640
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设计稿为640px时，正好可以1:1以px来写样式。但是1px所对应的物理像素就不一定是1了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(window.screen.width * dpr) / 640   // 1px对应的物理像素
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1628426387739.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;方案三&#34;&gt;方案三：&lt;/h3&gt;
&lt;p&gt;根据不同屏幕动态写入font-size，以rem作为宽度单位，固定布局视口。&lt;br&gt;
如网易新闻：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以640px设计稿和750px的视觉稿，网易这样处理的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var width = document.documentElement.clientWidth;   // 屏幕的布局视口宽度
var rem = width / 7.5;                              // 750px设计稿将布局视口分为7.5份
var rem = width / 6.4;                              // 640px设计稿将布局视口分为6.4份
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样不管是750px设计稿还是640px设计稿，1rem 等于设计稿上的100px。故px转换rem时：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rem = px * 0.01;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在750px设计稿上：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;75px 对应 0.75rem, 距离占设计稿的10%；

在ipone6上：
width = document.documentElement.clientWidth = 375px；
rem = 375px / 7.5 = 50px;
0.75rem = 37.5px;   (37.5/375=10%；占屏幕10%)
                     
在ipone5上：
width = document.documentElement.clientWidth = 320px；
rem = 320px / 7.5 = 42.667px;
0.75rem = 32px; (32/320=10%；占屏幕10%)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;故对于设计稿上任何一个尺寸换成rem后，在任何屏下对应的尺寸占屏幕宽度的百分比相同。故这种布局可以百分比还原设计图。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1628426475710.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;方案四&#34;&gt;方案四：&lt;/h3&gt;
&lt;p&gt;以rem作为宽度单位，动态写入viewport和font-size进行缩放。&lt;/p&gt;
&lt;p&gt;根据设置的dpr设置font-size。如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;document.documentElement.style.fontSize = 50 * dpr;
// dpr 为设置的设备像素比。（注意不是设备自身的设备像素比，而是认为设置的dpr）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种情况下，dpr = 1时，1rem = 50px;&lt;br&gt;
dpr = 2时， 1rem = 100px;&lt;br&gt;
当设计以iphone6为标准，出750px的设计稿时，此时dpr=2，故1rem 等于100px，将图上的尺寸转换为rem非常方便，除以100就行。&lt;/p&gt;
&lt;p&gt;所以该方案，1rem在所有屏幕上对应的肉眼距离相同，故不同屏幕下，总的rem数不同，大屏下总的rem数大于小屏下，如iphone6下，总宽度为7.5rem，iphone5下，总宽度为6.4rem。&lt;strong&gt;故此方案不能百分比还原设计稿，故写样式时，对于大块元素应该用百分比，flex等布局，不能直接用rem。&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1628426585110.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;方案五&#34;&gt;方案五：&lt;/h3&gt;
&lt;p&gt;根据不同屏幕动态写入font-size和viewport，以rem作为宽度单位&lt;br&gt;
将屏幕分为固定的&lt;code&gt;块数10&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var width = document.documentElement.clientWidth;   // 屏幕的布局视口宽度
var rem = width / 10;                               // 将布局视口分为10份
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样在任何屏幕下，总长度都为10rem。1rem对应的值也不固定，与屏幕的布局视口宽度有关。&lt;br&gt;
对于动态生成viewport，他们原理差不多，根据dpr来设置缩放。看看淘宝的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var devicePixelRatio = window.devicePixelRatio;
var isIPhone = window.navigator.appVersion.match(/iphone/gi);
var dpr,scale;
if (isIPhone) {
  if (devicePixelRatio &amp;gt;=3) {
    dpr = 3;
  } else if (devicePixelRatio &amp;gt;=2) {
    dpr = 2;
  } else {
    dpr = 1;
  }
} else {
  dpr = 1;
}
scale = 1 / dpr;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;淘宝只对iphone做了缩放处理，对于android所有dpr=1，scale=1即没有缩放处理。&lt;/p&gt;
&lt;p&gt;此方案与方案三相似，只是做了viewport缩放，能百分比还原设计稿。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1628426655488.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;适配中要解决的问题&#34;&gt;适配中要解决的问题 ：&lt;/h3&gt;
&lt;p&gt;移动端适配最主要的是使在不同屏幕下不用缩放页面就能正常显示整个页面。以上方案都完成了这一需求。其次有几个需求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;解决高清屏下1px的问题，其实有很多hack方法，这里只讲了缩放视口。先将布局视口设置为高清屏的物理像素。这样css中1px就是1个物理像素，这样看到的线条才是真正的1px。但是此时视口宽度大于设备的宽度，就会出现滚动条。故对视口进行缩放，使视口宽度缩放到设备宽度。&lt;br&gt;
淘宝团队在处理安卓端的缩放存在很多问题，所以dpr都做1处理，所以安卓端就没有解决1px的问题。&lt;/li&gt;
&lt;li&gt;在大屏手机中一行看到的段落文字应该比小屏手机的多。&lt;br&gt;
由于淘宝和网易新闻rem都是百分比，故如果用rem一行显示的文字个数应该是相同的。故对于段落文本不能用rem作为单位，应该用px处理，对于不同的dpr下设置不同的字体。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;6-响应式与自适应的选择&#34;&gt;6. 响应式与自适应的选择&lt;/h2&gt;
&lt;p&gt;最后，对于响应式和自适应的区别，网上有各种各样的解释。&lt;/p&gt;
&lt;p&gt;个人认为，其实没必要把它讲得那么复杂，知乎上有个小伙伴讲我觉得就很白话文：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;响应式针对的是不同分辨率设备而进行的适配式设计，以利用@media规则为主要手段，而自适应则忽略@media以比例布局为主，目的是适应不同的浏览器窗口大小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是我们会发现，现今大型网站，例如说淘宝网，已经没有做响应式了。什么意思呢？&lt;/p&gt;
&lt;p&gt;我们会发现，淘宝网手机端和网页端使用的是两个域名，也就是说，不同的客户端已经不再共用一套dom结构了。而是区分开来做自适应。然后每次用户访问的时候它就根据客户端的类型重定向。&lt;/p&gt;
&lt;p&gt;为什么呢？&lt;/p&gt;
&lt;p&gt;试想一下淘宝这种大型网站，一个分页下的商品条目特别多，并且每个商品条目的dom结构又十分复杂，而且pc端往往显示的信息是要比手机端更多的。如果不分开做两套，而是直接用响应式的话，那么pc端上显示的很多dom就要在手机端上隐藏，结果这些dom都没有被用到，但是却加载了。在这个流量和速度至上的时代，代码冗余先不说，多加载的这些无用的代码而消耗的流量，从某种意义上来说就已经损失了很多的效益。&lt;/p&gt;
&lt;h2 id=&#34;7-最后&#34;&gt;7. 最后&lt;/h2&gt;
&lt;p&gt;考虑到兼容性的问题，原先我们在文章头部说到的那段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从&lt;code&gt;Chrome32+&lt;/code&gt;版本开始是会默认禁用用户缩放的，但是考虑到兼容大部分设备，还是要加上其他设置，让&lt;code&gt;meta&lt;/code&gt;标签能够有更好的容错性。也就是下面这段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, 
 user-scalable=no;&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是，在ios10+以上，尽管开发者设置了&lt;code&gt;user-scalable=no&lt;/code&gt;，&lt;code&gt;Safari&lt;/code&gt;还是允许用户通过手势来缩放。（安卓手机各大厂商的内置浏览器也逐渐开放用户缩放，即使使用&lt;code&gt;meta&lt;/code&gt;标签进行设置）&lt;/p&gt;
&lt;p&gt;解决的方法也很简单，只需要检测&lt;code&gt;touch&lt;/code&gt;相关事件来阻止事件的触发即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;window.onload = function() {
    // 同时按下两个手指
    document.addEventListener(&#39;touchstart&#39;, function(event) {
        if(event.touches.length &amp;gt; 1) {
            event.preventDefault()
        }
    })
    var lastTouchEnd = 0;
    // 特别注意300ms时差的设置
    document.addEventListener(&#39;touchend&#39;, function(event) {
        var now = (new Date()).getTime();
        if(now-lastTouchEnd &amp;lt;= 300) {
            event.preventDefault();
        }
        lastTouchEnd = now;
    })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上，就是本文的全部啦。&lt;/p&gt;
&lt;p&gt;文章有借鉴，借鉴的链接都会在这里放出来。&lt;/p&gt;
&lt;p&gt;前辈们的经验和知识很宝贵，我们需要做的，是站在巨人的肩膀上，去提炼这些东西，有自己更好的理解、思考和开拓新知识面。&lt;/p&gt;
">【面】前端知识点梳理（CSS）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/javascript-shi-xian-pai-xu-suan-fa/"" data-c="
          &lt;h1 id=&#34;0-算法的时间与空间复杂度&#34;&gt;0. 算法的时间与空间复杂度&lt;/h1&gt;
&lt;p&gt;主要还是从算法所占用的「时间」和「空间」两个维度去考量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。&lt;/li&gt;
&lt;li&gt;空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-时间复杂度&#34;&gt;1. 时间复杂度&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;「 大O符号表示法 」，即 T(n) = O(f(n))&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常见的时间复杂度量级有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常数阶O(1)：&lt;code&gt;没有循环&lt;/code&gt;等复杂结构&lt;/li&gt;
&lt;li&gt;对数阶O(logN)：在&lt;code&gt;while&lt;/code&gt;循环里面，每次都&lt;code&gt;将 i 乘以 2&lt;/code&gt;，乘完之后，i 距离 n 就越来越近了。&lt;/li&gt;
&lt;li&gt;线性阶O(n)：&lt;code&gt;for循环里面&lt;/code&gt;的代码会执行n遍&lt;/li&gt;
&lt;li&gt;线性对数阶O(nlogN)：将时间复杂度为O(logn)的代码循环N遍&lt;/li&gt;
&lt;li&gt;平方阶O(n²)：如果把 O(n) 的代码&lt;code&gt;再嵌套循环一遍&lt;/code&gt;，它的时间复杂度就是 O(n²)&lt;/li&gt;
&lt;li&gt;立方阶O(n³)&lt;/li&gt;
&lt;li&gt;K次方阶O(n^k)&lt;/li&gt;
&lt;li&gt;指数阶(2^n)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-空间复杂度&#34;&gt;2. 空间复杂度&lt;/h2&gt;
&lt;p&gt;空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。&lt;/p&gt;
&lt;p&gt;空间复杂度比较常用的有：O(1)、O(n)、O(n²)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;空间复杂度 O(1)&lt;br&gt;
如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空间复杂度 O(n)&lt;br&gt;
第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;1大o表示法&#34;&gt;1.大O表示法&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;大O表示法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在计算机中采用&lt;strong&gt;粗略的度量&lt;/strong&gt;来描述计算机算法的&lt;strong&gt;效率&lt;/strong&gt;，这种方法被称为**“大O”表示法**&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;数据项个数&lt;/strong&gt;发生改变时，&lt;strong&gt;算法的效率&lt;/strong&gt;也会跟着改变。所以说算法A比算法B快两倍，这样的比较是&lt;strong&gt;没有意义&lt;/strong&gt;的。&lt;/li&gt;
&lt;li&gt;因此我们通常使用&lt;strong&gt;算法的速度&lt;/strong&gt;随着&lt;strong&gt;数据量的变化&lt;/strong&gt;会如何变化的方式来表示算法的效率，大O表示法就是方式之一。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;常见的大O表示形式&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;符号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;名称&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;O(1)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;常数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;O(log(n))&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;O(n)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;线性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;O(nlog(n))&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;线性和对数乘积&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;O(n²)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;平方&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;O(2n)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;指数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;不同大O形式的时间复杂度：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614691100516.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到效率从大到小分别是：O(1)&amp;gt;O(logn)&amp;gt; O(n)&amp;gt; O(nlog(n))&amp;gt;O(n²)&amp;gt;O(2^n)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推导大O表示法的三条规则：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;规则一&lt;/strong&gt;：用常量1取代运行时间中所有的加法常量。如7 + 8 = 15，用1表示运算结果15，大O表示法表示为O（1）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规则二&lt;/strong&gt;：运算中只保留最高阶项。如N^3 + 3n +1，大O表示法表示为：O（N^3）;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规则三&lt;/strong&gt;：若最高阶项的常数不为1，可将其省略。如4N&lt;sup&gt;2，大O表示法表示为：O（N&lt;/sup&gt;2）;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2排序算法&#34;&gt;2.排序算法&lt;/h1&gt;
&lt;p&gt;这里主要介绍几种简单排序和高级排序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;简单排序&lt;/strong&gt;：冒泡排序、选择排序、插入排序；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高级排序&lt;/strong&gt;：希尔排序、快速排序；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此处创建一个列表类ArrayList并添加一些属性和方法，用于存放这些排序方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //创建列表类
    function ArrayList() {
      //属性
      this.array = []

      //方法
      //封装将数据插入到数组中方法
      ArrayList.prototype.insert = function(item){
        this.array.push(item)
      }

      //toString方法
      ArrayList.prototype.toString = function(){
        return this.array.join(&#39;-&#39;)
      }

      //交换两个位置的数据
      ArrayList.prototype.swap = function(m, n){
        let temp  = this.array[m]
        this.array[m] = this.array[n]
        this.array[n] = temp
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;排序算法&#34;&gt;排序算法！！&lt;/h1&gt;
&lt;h2 id=&#34;21冒泡排序&#34;&gt;2.1.冒泡排序&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;冒泡排序的思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对未排序的各元素&lt;strong&gt;从头到尾&lt;/strong&gt;依次比较&lt;strong&gt;相邻的两个元素&lt;/strong&gt;大小关系；&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;左边的人员高&lt;/strong&gt;，则将两人&lt;strong&gt;交换位置&lt;/strong&gt;。比如1比2矮，不交换位置；&lt;/li&gt;
&lt;li&gt;向&lt;strong&gt;右移动一位&lt;/strong&gt;，继续比较2和3，最后比较 length - 1 和 length - 2这两个数据；&lt;/li&gt;
&lt;li&gt;当到达&lt;strong&gt;最右端&lt;/strong&gt;时，&lt;strong&gt;最高的人&lt;/strong&gt;一定被放在了&lt;strong&gt;最右边&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;按照这个思路，从最左端重新开始时，只需要走到&lt;strong&gt;倒数第二个位置&lt;/strong&gt;即可；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614691535117.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两层循环：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外层循环控制冒泡趟数：&lt;br&gt;
- 第一次：j = length - 1，比较到倒数第一个位置 ；&lt;br&gt;
- 第二次：j = length - 2，比较到倒数第二个位置 ；&lt;/li&gt;
&lt;li&gt;内层循环控制每趟比较的次数：&lt;br&gt;
- 第一次比较： i = 0，比较 0 和 1 位置的两个数据；&lt;br&gt;
- 最后一次比较：i = length - 2,比较length - 2和 length - 1两个数据；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详细过程如下图所示：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614691654684.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
动态过程：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614691678173.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; //冒泡排序
      ArrayList.prototype.bubblesor = function(){
        //1.获取数组的长度
        let length = this.array.length

        //外层循环控制冒泡趟数
        for(let j = length - 1; j &amp;gt;= 0; j--){
          //内层循环控制每趟比较的次数
          for(let i = 0; i &amp;lt; j; i++){
          if (this.array[i] &amp;gt; this.array[i+1]) {
            //交换两个数据
            let temp  = this.array[i]
        	this.array[i] = this.array[i+1]
        	this.array[i+1] = temp
          }
        }
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; //测试类
    let list = new ArrayList()

    //插入元素
    list.insert(66)
    list.insert(88)
    list.insert(12)
    list.insert(87)
    list.insert(100)
    list.insert(5)
    list.insert(566)
    list.insert(23)
    
    //验证冒泡排序
    list.bubblesor()
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614691724569.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;冒泡排序的效率：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上面所讲的对于7个数据项，比较次数为：6 + 5 + 4 + 3 + 2 + 1;&lt;/li&gt;
&lt;li&gt;对于N个数据项，&lt;strong&gt;比较次数&lt;/strong&gt;为：(N - 1) + (N - 2) + (N - 3) + ... + 1 = N * (N - 1) / 2；如果两次比较交换一次，那么&lt;strong&gt;交换次数&lt;/strong&gt;为：N * (N - 1) / 4；&lt;/li&gt;
&lt;li&gt;使用大O表示法表示比较次数和交换次数分别为：O（ N * (N - 1) / 2）和O（ N * (N - 1) / 4），根据大O表示法的三条规则都化简为：&lt;strong&gt;O（N^2）&lt;/strong&gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;22选择排序&#34;&gt;2.2.选择排序&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;选择排序改进了冒泡排序：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将&lt;strong&gt;交换次数&lt;/strong&gt;由&lt;strong&gt;O（N^2）&lt;strong&gt;减小到&lt;/strong&gt;O（N）&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;但是&lt;strong&gt;比较次数&lt;/strong&gt;依然是&lt;strong&gt;O（N^2）&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;选择排序的思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选定&lt;strong&gt;第一个索引的位置&lt;/strong&gt;比如1，然后依次和后面的元素&lt;strong&gt;依次进行比较&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;如果后面的元素，&lt;strong&gt;小于&lt;/strong&gt;索引1位置的元素，则&lt;strong&gt;交换位置&lt;/strong&gt;到索引1处；&lt;/li&gt;
&lt;li&gt;经过一轮的比较之后，可以确定一开始指定的索引1位置的元素是&lt;strong&gt;最小的&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;随后使用同样的方法除索引1以外&lt;strong&gt;逐个比较剩下的元素&lt;/strong&gt;即可；&lt;/li&gt;
&lt;li&gt;可以看出选择排序，&lt;strong&gt;第一轮&lt;/strong&gt;会选出&lt;strong&gt;最小值&lt;/strong&gt;，&lt;strong&gt;第二轮&lt;/strong&gt;会选出&lt;strong&gt;第二小的值&lt;/strong&gt;，直到完成排序。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614691924469.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两层循环：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外层循环控制指定的索引：&lt;br&gt;
- 第一次：j = 0，指定第一个元素 ；&lt;br&gt;
- 最后一次：j = length - 1，指定最后一个元素 ；&lt;/li&gt;
&lt;li&gt;内层循环负责将指定索引（i）的元素与剩下（i - 1）的元素进行比较；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;动态过程：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614691958714.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; //选择排序
      ArrayList.prototype.selectionSort = function(){
        //1.获取数组的长度
        let length = this.array.length

        //2.外层循环：从0开始获取元素
        for(let j = 0; j &amp;lt; length - 1; j++){
          let min = j
          //内层循环：从i+1位置开始，和后面的元素进行比较
        for(let i = min + 1; i &amp;lt; length; i++){
          if (this.array[min] &amp;gt; this.array[i]) {
            min = i
          }
        }
        this.swap(min, j)
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  //测试类
    let list = new ArrayList()

    //插入元素
    list.insert(66)
    list.insert(88)
    list.insert(12)
    list.insert(87)
    list.insert(100)
    list.insert(5)
    list.insert(566)
    list.insert(23)
    
    //验证选择排序
    list.selectionSort()
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614691999487.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;选择排序的效率：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择排序的&lt;strong&gt;比较次数&lt;/strong&gt;为：N * (N - 1) / 2，用大O表示法表示为：&lt;strong&gt;O（N^2）&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;选择排序的&lt;strong&gt;交换次数&lt;/strong&gt;为：(N - 1) / 2，用大O表示法表示为：&lt;strong&gt;O（N）&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;所以选择排序的效率高于冒泡排序；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;23插入排序&#34;&gt;2.3.插入排序&lt;/h2&gt;
&lt;p&gt;插入排序是简单排序中效率最高的一种排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;插入排序的思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入排序思想的核心是&lt;strong&gt;局部有序&lt;/strong&gt;。如图所示，X左边的人称为&lt;strong&gt;局部有序&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;首先指定一数据X（从第一个数据开始），并将数据X的左边变成局部有序状态；&lt;/li&gt;
&lt;li&gt;随后将X右移一位，再次达到局部有序之后，继续右移一位，重复前面的操作直至X移至最后一个元素。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614692091547.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
插入排序的详细过程：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614692103001.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
动态过程：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614692113197.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;   //插入排序
      ArrayList.prototype.insertionSort = function(){
        //1.获取数组的长度
        let length = this.array.length

        //2.外层循环:从第二个数据开始，向左边的已经局部有序数据进行插入
        for(let i = 1; i &amp;lt; length; i++){
          //3.内层循环：获取i位置的元素，使用while循环(重点)与左边的局部有序数据依次进行比较
          let temp = this.array[i]
          let j = i
          while(this.array[j - 1] &amp;gt; temp &amp;amp;&amp;amp; j &amp;gt; 0){
            this.array[j] = this.array[j - 1]//大的数据右移
            j--
          }
          //4.while循环结束后，index = j左边的数据变为局部有序且array[j]最大。此时将array[j]重置为排序前的数据array[i]，方便下一次for循环
          this.array[j] = temp
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试类
    let list = new ArrayList()

    //插入元素
    list.insert(66)
    list.insert(88)
    list.insert(12)
    list.insert(87)
    list.insert(100)
    list.insert(5)
    list.insert(566)
    list.insert(23)
    // console.log(list);

    //验证插入排序
    list.insertionSort()
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614692171244.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;插入排序的效率：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;比较次数&lt;/strong&gt;：第一趟时，需要的最大次数为1；第二次最大为2；以此类推，最后一趟最大为N-1；所以，插入排序的总比较次数为N * (N - 1) / 2；但是，实际上每趟发现插入点之前，平均只有全体数据项的一半需要进行比较，所以比较次数为：&lt;strong&gt;N * (N - 1) / 4&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;交换次数&lt;/strong&gt;：指定第一个数据为X时交换0次，指定第二个数据为X最多需要交换1次，以此类推，指定第N个数据为X时最多需要交换N - 1次，所以一共需要交换N * (N - 1) / 2次，平均次数为&lt;strong&gt;N * (N - 1) / 2&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;虽然用大O表示法表示插入排序的效率也是&lt;strong&gt;O（N^2）&lt;/strong&gt;，但是插入排序整体操作次数更少，因此，在简单排序中，插入排序&lt;strong&gt;效率最高&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;24希尔排序&#34;&gt;2.4.希尔排序&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;希尔排序&lt;/strong&gt;是&lt;strong&gt;插入排序&lt;/strong&gt;的一种高效的&lt;strong&gt;改进版&lt;/strong&gt;，效率比插入排序要高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;希尔排序的历史背景：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;希尔排序按其设计者希尔（Donald Shell）的名字命名，该算法由&lt;strong&gt;1959年公布&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;希尔算法首次突破了计算机界一直认为的**算法的时间复杂度都是O（N^2）**的大关，为了纪念该算法里程碑式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;意义，用&lt;strong&gt;Shell&lt;/strong&gt;来命名该算法；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;插入排序的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设一个&lt;strong&gt;很小的数据项&lt;/strong&gt;在&lt;strong&gt;很靠近右端的位置&lt;/strong&gt;上，这里本应该是&lt;strong&gt;较大的数据项的位置&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;将这个&lt;strong&gt;小数据项移动到左边&lt;/strong&gt;的正确位置，所有的&lt;strong&gt;中间数据项都必须向右移动一位&lt;/strong&gt;，这样效率非常低；&lt;/li&gt;
&lt;li&gt;如果通过&lt;strong&gt;某种方式&lt;/strong&gt;，不需要&lt;strong&gt;一个个移动所有中间的数据项&lt;/strong&gt;，就能把较小的数据项移到左边，那么这个算法的执行速度就会有很大的改进。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;希尔排序的实现思路&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;希尔排序主要通过对数据进行&lt;strong&gt;分组&lt;/strong&gt;实现快速排序；&lt;/li&gt;
&lt;li&gt;根据设定的增量（gap）将数据分为gap个组（&lt;strong&gt;组数等于gap&lt;/strong&gt;），再在每个分组中进行局部排序；&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;假如有数组有10个数据，第1个数据为黑色，增量为5。那么第二个为黑色的数据index=5，第3个数据为黑色的数据index = 10（不存在）。所以黑色的数据每组只有2个，10 / 2 = 5一共可分5组，即&lt;strong&gt;组数等于增量gap&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;排序之后，减小增量，继续分组，再次进行局部排序，直到增量gap=1为止。随后只需进行微调就可完成数组的排序；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;具体过程如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排序之前的，储存10个数据的原始数组为：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614692424549.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;设初始增量gap = length / 2 = 5，即数组被分为了5组，如图所示分别为：[8, 3]、[9, 5]、[1, 4]、[7, 6]、[2, 0]：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614692441093.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;随后分别在每组中对数据进行局部排序，5组的顺序如图所示，变为：[3, 8]、[5, 9]、[1, 4]、[6, 7]、[0, 2]：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614692472580.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;然后缩小增量gap = 5 / 2 = 2，即数组被分为了2组，如图所示分别为：[3，1，0，9，7]、[5，6，8，4，2]：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614692484750.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;随后分别在每组中对数据进行局部排序，两组的顺序如图所示，变为：[0，1，3，7，9]、[2，4，5，6，8]：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614692502384.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;然后然后缩小增量gap = 2 / 1 = 1，即数组被分为了1组，如图所示为：[0，2，1，4，3，5，7，6，9，8]：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614692651803.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;最后只需要对该组数据进行插入排序即可完成整个数组的排序：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614692674191.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
动态过程：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614692702587.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
图中d表示增量gap。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;增量的选择：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原稿&lt;/strong&gt;中希尔建议的初始间距为&lt;strong&gt;N / 2&lt;/strong&gt;，比如对于N = 100的数组，增量序列为：50，25，12，6，3，1，可以发现不能整除时向下取整。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hibbard增量序列&lt;/strong&gt;：增量序列算法为：2^k - 1，即1，3，5，7... ...等；这种情况的最坏复杂度为O（N&lt;sup&gt;3/2）**,平均复杂度为**O（N&lt;/sup&gt;5/4）但未被证明；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sedgewcik增量序列&lt;/strong&gt;：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614692851848.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下代码实现中采用希尔排序原稿中建议的增量即&lt;strong&gt;N / 2&lt;/strong&gt; 。&lt;br&gt;
&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   //希尔排序
      ArrayList.prototype.shellSort = function(){
        //1.获取数组的长度
        let length = this.array.length

        //2.初始化增量
        let gap = Math.floor(length / 2)

        //3.第一层循环：while循环(使gap不断减小)
        while(gap &amp;gt;= 1 ){
          //4.第二层循环：以gap为增量，进行分组，对分组进行插入排序
          //重点为：将index = gap作为选中的第一个数据
          for(let i = gap; i &amp;lt; length; i++){
            let temp = this.array[i]
            let j = i
            //5.第三层循环:寻找正确的插入位置
            while(this.array[j - gap] &amp;gt; temp &amp;amp;&amp;amp; j &amp;gt; gap - 1){
              this.array[j] = this.array[j - gap]
              j -= gap
            }
          //6.将j位置的元素设置为temp
          this.array[j] = temp
          }

          gap = Math.floor(gap / 2)
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里解释一下上述代码中的三层循环：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第一层循环&lt;/strong&gt;：while循环，控制gap递减到1；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二层循环&lt;/strong&gt;：分别取出根据g增量gap分成的gap组数据：将index = gap的数据作为选中的第一个数据，如下图所示，gap=5，则index = gap的数据为3，index = gap - 1的数据为8，两个数据为一组。随后gap不断加1右移，直到gap &amp;lt; length，此时实现了将数组分为5组。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614692920473.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三层循环&lt;/strong&gt;：对每一组数据进行插入排序；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; //测试类
    let list = new ArrayList()

    //插入元素
    list.insert(66)
    list.insert(88)
    list.insert(12)
    list.insert(87)
    list.insert(100)
    list.insert(5)
    list.insert(566)
    list.insert(23)
    // console.log(list);

    //验证希尔排序
    list.shellSort()
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614692964709.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;希尔排序的效率：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;希尔排序的效率和增量有直接关系，即使使用原稿中的增量效率都高于简单排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;25快速排序&#34;&gt;2.5.快速排序&lt;/h2&gt;
&lt;p&gt;快速排序的介绍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;快速排序&lt;/strong&gt;可以说是&lt;strong&gt;目前所有排序算法&lt;/strong&gt;中，&lt;strong&gt;最快&lt;/strong&gt;的一种排序算法。当然，没有任何一种算法是在任意情况下都是最优的。但是，大多数情况下快速排序是比较好的选择。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;快速排序&lt;/strong&gt;其实是&lt;strong&gt;冒泡排序&lt;/strong&gt;的升级版；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;快速排序的核心思想是&lt;strong&gt;分而治之&lt;/strong&gt;，先选出一个数据（比如65），将比其小的数据都放在它的左边，将比它大的数据都放在它的右边。这个数据称为&lt;strong&gt;枢纽&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和冒泡排序的不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们选择的65可以一次性将它放在最正确的位置，之后就不需要做任何移动；&lt;/li&gt;
&lt;li&gt;而冒泡排序即使已经找到最大值，也需要继续移动最大值，直到将它移动到最右边；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614693046918.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;快速排序的枢纽：&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第一种方案&lt;/strong&gt;：直接选择第一个元素作为枢纽。但是，当第一个元素就是最小值的情况下，效率不高；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二种方案&lt;/strong&gt;：使用随机数。随机数本身十分消耗性能，不推荐；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优秀的解决方法&lt;/strong&gt;：取index为头、中、位的三个数据排序后的中位数；如下图所示，按下标值取出的三个数据为：92，31，0，经排序后变为：0，31，92，取其中的中位数31作为&lt;strong&gt;枢纽&lt;/strong&gt;（当（length-1）/2不整除时可向下或向上取整）：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614693609653.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现枢纽选择：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//交换两个位置的数据
let swap = function(arr, m, n){
    let temp  = arr[m]
    arr[m] = arr[n]
    arr[n] = temp
}

//快速排序
//1.选择枢纽
let median = function(arr){
  //1.取出中间的位置
  let center = Math.floor(arr.length / 2)
  let right = arr.length - 1 
  let left = 0

  //2.判断大小并进行交换
  if (arr[left] &amp;gt; arr[center]) {
    swap(arr, left, center)
  }
  if (arr[center] &amp;gt; arr[right]){
    swap(arr, center, right)
  }
  if (arr[left] &amp;gt; arr[right]) {
    swap(arr, left, right)
  }
  //3.返回枢纽
  return center
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组经过获取枢纽函数操作之后，选出的3个下标值对应的数据位置变为：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614693640946.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;动态过程：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614693653899.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;快速排序代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//2.快速排序
let QuickSort = function(arr){
  if (arr.length == 0) {
    return []
  }
  let center = median(arr)
  let c = arr.splice(center, 1)
  let l = []
  let r = []

  for (let i = 0; i &amp;lt; arr.length; i++) {
      if (arr[i] &amp;lt; c) {
        l.push(arr[i])
      }else{
        r.push(arr[i])
      }        
  }
  return QuickSort(l).concat(c, QuickSort(r))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;算法的巧妙之处在于通过:&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;QuickSort(l).concat(c, QuickSort(r))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;递归调用&lt;code&gt;QuickSort&lt;/code&gt;函数实现了枢纽&lt;code&gt;Center&lt;/code&gt;左边数据&lt;code&gt;l&lt;/code&gt;和右边数据&lt;code&gt;r&lt;/code&gt;的排序；&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [0, 13, 81, 43, 31, 27, 56, 92]
console.log(QuickSort(arr));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614693906304.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快速排序的效率：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快速排序最坏情况下的效率：每次选择的枢纽都是最左边或最右边的数据，此时效率等同于冒泡排序，时间复杂度为&lt;strong&gt;O(n^2)&lt;/strong&gt;。可根据不同的枢纽选择避免这一情况；&lt;/li&gt;
&lt;li&gt;快速排序的平均效率：为&lt;strong&gt;O(N*logN)&lt;/strong&gt;，虽然其他算法效率也可达到O(N*logN)，但是其中快速排序是&lt;strong&gt;最好的&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;26-归并排序&#34;&gt;2.6 归并排序&lt;/h2&gt;
&lt;p&gt;归并排序采用的是分治的思想，首先是“分”，将一个数组反复二分为两个小数组，直到每个数组只有一个元素；其次是“治”，从最小数组开始，两两按大小顺序合并，直到并为原始数组大小，下面是图解：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619613292190.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;观察下“治”的过程，可以看出，“治”实际上是将已经有序的数组合并为更大的有序数组。那么怎样将已经有序的数组合并为更大的有序数组？很简单，创建一个临时数组C，比较A[0]，B[0]，将较小值放到C[0]，再比较A[1]与B[0]（或者A[0]，B[1]），将较小值放到C[1]，直到对A，B都遍历一遍。可以看出数组A，B都只需遍历一遍，所以对两个有序数组的排序的时间复杂度为O(n)。&lt;/p&gt;
&lt;p&gt;而“分”就是将原始数组逐次二分，直到每个数组只剩一个元素，一个元素的数组自然是有序的，所以就可以开始“治”的过程了。时间复杂度为 O(nlogn)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;实现分析：
将数组从中间切分为两个数组
切分到最小之后，开始归并操作，即合并两个已排序的数组
递归合并的过程，由于是从小到大合并，所以待合并的两个数组总是已排序的，一直做同样的归并操作就可以
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;对比归并排序与快速排序&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;都用了分治的思想。相比选择排序和冒泡排序，归并排序与快速排序使用了切分而不是直接遍历，这有效减少了交换次数。&lt;/li&gt;
&lt;li&gt;归并排序是先切分、后排序，过程可以描述为：切分、切分、切分……排序、排序、排序……&lt;/li&gt;
&lt;li&gt;快速排序是分区、排序交替进行，过程可以描述为：分区、排序、分区、排序……&lt;/li&gt;
&lt;li&gt;上两条所说的“排序”，在归并排序与快速排序中并非同样的操作，归并排序中的操作是将两个数组合并为一（归并操作），而快速排序中的操作是交换。&lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av86801505?from=search&amp;amp;seid=4967761411915016256&#34;&gt;参考资料：JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现排序算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/javascript-shi-xian-tu-jie-gou/"" data-c="
          &lt;h1 id=&#34;1图论&#34;&gt;1.图论&lt;/h1&gt;
&lt;h2 id=&#34;11图的简介&#34;&gt;1.1.图的简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;什么是图？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;图结构&lt;/strong&gt;是一种与&lt;strong&gt;树结构&lt;/strong&gt;有些相似的数据结构；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;图论&lt;/strong&gt;是数学的一个分支，并且，在数学中，树是图的一种；&lt;/li&gt;
&lt;li&gt;图论以图为研究对象，研究&lt;strong&gt;顶点&lt;/strong&gt;和&lt;strong&gt;边&lt;/strong&gt;组成的&lt;strong&gt;图形&lt;/strong&gt;的数学理论和方法；&lt;/li&gt;
&lt;li&gt;主要的研究目的为：&lt;strong&gt;事物之间的联系&lt;/strong&gt;，&lt;strong&gt;顶点&lt;/strong&gt;代表&lt;strong&gt;事物&lt;/strong&gt;，&lt;strong&gt;边&lt;/strong&gt;代表两个事物间的&lt;strong&gt;关系&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;图的特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一组顶点&lt;/strong&gt;：通常用&lt;strong&gt;V&lt;/strong&gt;（Vertex）表示顶点的集合；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一组边&lt;/strong&gt;：通常用 &lt;strong&gt;E&lt;/strong&gt;（Edge）表示边的集合；&lt;br&gt;
1. 边是顶点和顶点之间的连线；&lt;br&gt;
2. 边可以是有向的，也可以是无向的。比如A----B表示无向，A ---&amp;gt; B 表示有向；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;图的常用术语：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;顶点&lt;/strong&gt;：表示图中的一个&lt;strong&gt;节点&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;边&lt;/strong&gt;：表示&lt;strong&gt;顶点和顶点&lt;/strong&gt;给之间的&lt;strong&gt;连线&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;相邻顶点&lt;/strong&gt;：由一条边连接在一起的顶点称为&lt;strong&gt;相邻顶点&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;度&lt;/strong&gt;：一个顶点的&lt;strong&gt;度&lt;/strong&gt;是&lt;strong&gt;相邻顶点的数量&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路径&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;简单路径：简单路径要求不包含重复的顶点；&lt;/li&gt;
&lt;li&gt;回路：第一个顶点和最后一个顶点&lt;strong&gt;相同&lt;/strong&gt;的路径称为回路；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无向图&lt;/strong&gt;：图中的所有边都是&lt;strong&gt;没有&lt;/strong&gt;方向的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有向图&lt;/strong&gt;：图中的所有边都是&lt;strong&gt;有&lt;/strong&gt;方向的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无权图&lt;/strong&gt;：无权图中的边没有任何权重意义；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;带权图&lt;/strong&gt;：带权图中的边有一定的权重含义；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12图的表示&#34;&gt;1.2.图的表示&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;邻接矩阵&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;表示图的常用方式为：&lt;strong&gt;邻接矩阵&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以使用二维数组来表示邻接矩阵；&lt;/li&gt;
&lt;li&gt;邻接矩阵让&lt;strong&gt;每个节点&lt;/strong&gt;和&lt;strong&gt;一个整数相关联&lt;/strong&gt;，该&lt;strong&gt;整数作为数组的下标值&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;使用一个&lt;strong&gt;二维数组&lt;/strong&gt;来表示顶点之间的&lt;strong&gt;连接&lt;/strong&gt;；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614605612152.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如上图所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二维数组中的0表示没有连线，1表示有连线；&lt;/li&gt;
&lt;li&gt;如：A[ 0 ] [ 3 ] = 1，表示 A 和 C 之间有连接；&lt;/li&gt;
&lt;li&gt;邻接矩阵的对角线上的值都为0，表示A - A ，B - B，等自回路都没有连接（自己与自己之间没有连接）；&lt;/li&gt;
&lt;li&gt;若为无向图，则邻接矩阵应为对角线上元素全为0的对称矩阵；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;邻接矩阵的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果图是一个&lt;strong&gt;稀疏图&lt;/strong&gt;，那么邻接矩阵中将存在&lt;strong&gt;大量的 0&lt;/strong&gt;，造成存储空间的浪费；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;邻接表&lt;/code&gt;&lt;br&gt;
另外一种表示图的常用方式为：&lt;strong&gt;邻接表。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邻接表由图中&lt;strong&gt;每个顶点&lt;/strong&gt;以及&lt;strong&gt;和顶点相邻的顶点列表&lt;/strong&gt;组成；&lt;/li&gt;
&lt;li&gt;这个列表可用多种方式存储，比如：**数组/链表/字典(哈希表)**等都可以；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614605685712.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如上图所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图中可清楚看到&lt;strong&gt;A&lt;/strong&gt;与&lt;strong&gt;B、C、D&lt;/strong&gt;相邻，假如要表示这些与A顶点相邻的顶点（边），可以通过将它们作为A的值（value）存入到对应的&lt;strong&gt;数组/链表/字典&lt;/strong&gt;中。&lt;/li&gt;
&lt;li&gt;之后，通过键（key）A可以十分方便地取出对应的数据；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;邻接表的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邻接表可以简单地得出&lt;strong&gt;出度&lt;/strong&gt;，即某一顶点指向其他顶点的个数；&lt;/li&gt;
&lt;li&gt;但是，邻接表计算&lt;strong&gt;入度&lt;/strong&gt;（指向某一顶点的其他顶点的个数称为该顶点的入度）十分困难。此时需要构造&lt;strong&gt;逆邻接表&lt;/strong&gt;才能有效计算入度；&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2封装图结构&#34;&gt;2.封装图结构&lt;/h1&gt;
&lt;p&gt;在实现过程中采用&lt;strong&gt;邻接表&lt;/strong&gt;的方式来表示边，使用&lt;strong&gt;字典类&lt;/strong&gt;来存储邻接表。&lt;/p&gt;
&lt;h2 id=&#34;21添加字典类和队列类&#34;&gt;2.1.添加字典类和队列类&lt;/h2&gt;
&lt;p&gt;首先需要引入之前实现的，之后会用到的字典类和队列类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//封装字典类
function Dictionary(){
  //字典属性
  this.items = {}

  //字典操作方法
  //一.在字典中添加键值对
  Dictionary.prototype.set = function(key, value){
    this.items[key] = value
  }

  //二.判断字典中是否有某个key
  Dictionary.prototype.has = function(key){
    return this.items.hasOwnProperty(key)
  }

  //三.从字典中移除元素
  Dictionary.prototype.remove = function(key){
    //1.判断字典中是否有这个key
    if(!this.has(key)) return false

    //2.从字典中删除key
    delete this.items[key]
    return true
  }

  //四.根据key获取value
  Dictionary.prototype.get = function(key){
    return this.has(key) ? this.items[key] : undefined
  }

  //五.获取所有keys
  Dictionary.prototype.keys = function(){
    return Object.keys(this.items)
  }

  //六.size方法
  Dictionary.prototype.keys = function(){
    return this.keys().length
  }

  //七.clear方法
  Dictionary.prototype.clear = function(){
    this.items = {}
  }
}

   // 基于数组封装队列类
    function Queue() {
    // 属性
      this.items = []
    // 方法
    // 1.将元素加入到队列中
    Queue.prototype.enqueue = element =&amp;gt; {
      this.items.push(element)
    }

    // 2.从队列中删除前端元素
    Queue.prototype.dequeue = () =&amp;gt; {
      return this.items.shift()
    }

    // 3.查看前端的元素
    Queue.prototype.front = () =&amp;gt; {
      return this.items[0]
    }

    // 4.查看队列是否为空
    Queue.prototype.isEmpty = () =&amp;gt; {
      return this.items.length == 0;
    }

    // 5.查看队列中元素的个数
    Queue.prototype.size = () =&amp;gt; {
      return this.items.length
    }

    // 6.toString方法
    Queue.prototype.toString = () =&amp;gt; {
      let resultString = &#39;&#39;
        for (let i of this.items){
          resultString += i + &#39; &#39;
        }
        return resultString
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;22创建图类&#34;&gt;2.2.创建图类&lt;/h2&gt;
&lt;p&gt;先创建图类Graph，并添加基本属性，再实现图类的常用方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //封装图类
    function Graph (){
      //属性：顶点(数组)/边(字典)
      this.vertexes = []  //顶点
      this.edges = new Dictionary() //边
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;23添加顶点与边&#34;&gt;2.3.添加顶点与边&lt;/h2&gt;
&lt;p&gt;如图所示：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614685887261.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;创建一个数组对象vertexes存储图的顶点；创建一个字典对象edges存储图的边，其中key为顶点，value为存储key顶点相邻顶点的数组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     //添加方法
      //一.添加顶点
      Graph.prototype.addVertex = function(v){
        this.vertexes.push(v)
        this.edges.set(v, []) //将边添加到字典中，新增的顶点作为键，对应的值为一个存储边的空数组
      }
      //二.添加边
      Graph.prototype.addEdge = function(v1, v2){//传入两个顶点为它们添加边
        this.edges.get(v1).push(v2)//取出字典对象edges中存储边的数组，并添加关联顶点
        this.edges.get(v2).push(v1)//表示的是无向表，故要添加互相指向的两条边
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;24转换为字符串输出&#34;&gt;2.4.转换为字符串输出&lt;/h2&gt;
&lt;p&gt;为图类Graph添加toString方法，实现以邻接表的形式输出图中各顶点。&lt;br&gt;
&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; //三.实现toString方法:转换为邻接表形式
      Graph.prototype.toString = function (){
        //1.定义字符串，保存最终结果
        let resultString = &amp;quot;&amp;quot;

        //2.遍历所有的顶点以及顶点对应的边
        for (let i = 0; i &amp;lt; this.vertexes.length; i++) {//遍历所有顶点
          resultString += this.vertexes[i] + &#39;--&amp;gt;&#39;
          let vEdges = this.edges.get(this.vertexes[i])
          for (let j = 0; j &amp;lt; vEdges.length; j++) {//遍历字典中每个顶点对应的数组
            resultString += vEdges[j] + &#39;  &#39;;
          }
          resultString += &#39;\n&#39;
        }
        return resultString
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试代码
    //1.创建图结构
    let graph = new Graph()

    //2.添加顶点
    let myVertexes = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;]
    for (let i = 0; i &amp;lt; myVertexes.length; i++) {
      graph.addVertex(myVertexes[i])
    }

    //3.添加边
    graph.addEdge(&#39;A&#39;, &#39;B&#39;)
    graph.addEdge(&#39;A&#39;, &#39;C&#39;)
    graph.addEdge(&#39;A&#39;, &#39;D&#39;)
    graph.addEdge(&#39;C&#39;, &#39;D&#39;)
    graph.addEdge(&#39;C&#39;, &#39;G&#39;)
    graph.addEdge(&#39;D&#39;, &#39;G&#39;)
    graph.addEdge(&#39;D&#39;, &#39;H&#39;)
    graph.addEdge(&#39;B&#39;, &#39;E&#39;)
    graph.addEdge(&#39;B&#39;, &#39;F&#39;)
    graph.addEdge(&#39;E&#39;, &#39;I&#39;)

    //4.输出结果
    console.log(graph.toString());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614686639566.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;25图的遍历&#34;&gt;2.5.图的遍历&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;图的遍历思想：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图的遍历思想与树的遍历思想一样，意味着需要将图中&lt;strong&gt;所有的顶点&lt;/strong&gt;都访问一遍，并且不能有&lt;strong&gt;重复的访问&lt;/strong&gt;（上面的toString方法会重复访问）；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;遍历图的两种算法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;广度优先搜索（Breadth - First Search，简称&lt;strong&gt;BFS&lt;/strong&gt;）;&lt;/li&gt;
&lt;li&gt;深度优先搜索（Depth - First Search，简称&lt;strong&gt;DFS&lt;/strong&gt;）;&lt;/li&gt;
&lt;li&gt;两种遍历算法都需要指定&lt;strong&gt;第一个被访问的顶点&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了记录顶点是否被访问过，使用&lt;strong&gt;三种颜色&lt;/strong&gt;来表示它们的状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;白色&lt;/strong&gt;：表示该顶点还没有被访问过；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;灰色&lt;/strong&gt;：表示该顶点被访问过，但其相邻顶点并未完全被访问过；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;黑色&lt;/strong&gt;：表示该顶点被访问过，且其所有相邻顶点都被访问过；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先封装initializeColor方法将图中的所有顶点初始化为白色，代码实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //四.初始化状态颜色
      Graph.prototype.initializeColor = function(){
        let colors = []
        for (let i = 0; i &amp;lt; this.vertexes.length; i++) {
           colors[this.vertexes[i]] = &#39;white&#39;;
        }
        return colors
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;广度优先搜索&lt;/code&gt;&lt;br&gt;
广度优先搜索算法的思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻顶点，就像一次访问图的一层；&lt;/li&gt;
&lt;li&gt;也可以说是&lt;strong&gt;先宽后深&lt;/strong&gt;地遍历图中的各个顶点；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614686757512.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于&lt;strong&gt;队列&lt;/strong&gt;可以简单地实现广度优先搜索算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先创建一个队列Q（尾部进，首部出）；&lt;/li&gt;
&lt;li&gt;调用封装的initializeColor方法将所有顶点初始化为白色；&lt;/li&gt;
&lt;li&gt;指定第一个顶点A，将A标注为灰色（被访问过的节点），并将A放入队列Q中；&lt;/li&gt;
&lt;li&gt;循环遍历队列中的元素，只要队列Q非空，就执行以下操作：&lt;br&gt;
1. 先将灰色的A从Q的首部取出；&lt;br&gt;
2. 取出A后，将A的所有未被访问过（白色）的相邻顶点依次从队列Q的尾部加入队列，并变为灰色。以此保证，灰色的相邻顶点不重复加入队列；&lt;br&gt;
3. A的全部相邻节点加入Q后，A变为黑色，在下一次循环中被移除Q外；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;       //五.实现广度搜索(BFS)
      //传入指定的第一个顶点和处理结果的函数
      Graph.prototype.bfs = function(initV, handler){
        //1.初始化颜色
        let colors = this.initializeColor()

        //2.创建队列
        let que = new Queue()

        //3.将顶点加入到队列中
        que.enqueue(initV)

        //4.循环从队列中取出元素，队列为空才停止
        while(!que.isEmpty()){
          //4.1.从队列首部取出一个顶点
          let v = que.dequeue()

          //4.2.从字典对象edges中获取和该顶点相邻的其他顶点组成的数组
          let vNeighbours = this.edges.get(v)

          //4.3.将v的颜色变为灰色
          colors[v] = &#39;gray&#39;

          //4.4.遍历v所有相邻的顶点vNeighbours,并且加入队列中
          for (let i = 0; i &amp;lt; vNeighbours.length; i++) {
            const a = vNeighbours[i];
            //判断相邻顶点是否被探测过，被探测过则不加入队列中；并且加入队列后变为灰色，表示被探测过
            if (colors[a] == &#39;white&#39;) {
              colors[a] = &#39;gray&#39;
              que.enqueue(a)
            }
          }

          //4.5.处理顶点v
          handler(v)

          //4.6.顶点v所有白色的相邻顶点都加入队列后，将顶点v设置为黑色。此时黑色顶点v位于队列最前面，进入下一次while循环时会被取出
          colors[v] = &#39;black&#39;
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下为指定的第一个顶点为A时的遍历过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如 a 图所示，将在字典edges中取出的与A相邻的且未被访问过的白色顶点B、C、D放入队列que中并变为灰色，随后将A变为黑色并移出队列；&lt;/li&gt;
&lt;li&gt;接着，如图 b 所示，将在字典edges中取出的与B相邻的且未被访问过的白色顶点E、F放入队列que中并变为灰色，随后将B变为黑色并移出队列；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614686915234.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;如 c 图所示，将在字典edges中取出的与C相邻的且未被访问过的白色顶点G（A，D也相邻不过已变为灰色，所以不加入队列）放入队列que中并变为灰色，随后将C变为黑色并移出队列；&lt;/li&gt;
&lt;li&gt;接着，如图 d 所示，将在字典edges中取出的与D相邻的且未被访问过的白色顶点H放入队列que中并变为灰色，随后将D变为黑色并移出队列。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614686933411.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如此循环直到队列中元素为0，即所有顶点都变黑并移出队列后才停止，此时图中顶点已被全部遍历。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   //测试代码
    //1.创建图结构
    let graph = new Graph()

    //2.添加顶点
    let myVertexes = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;]
    for (let i = 0; i &amp;lt; myVertexes.length; i++) {
      graph.addVertex(myVertexes[i])
    }

    //3.添加边
    graph.addEdge(&#39;A&#39;, &#39;B&#39;)
    graph.addEdge(&#39;A&#39;, &#39;C&#39;)
    graph.addEdge(&#39;A&#39;, &#39;D&#39;)
    graph.addEdge(&#39;C&#39;, &#39;D&#39;)
    graph.addEdge(&#39;C&#39;, &#39;G&#39;)
    graph.addEdge(&#39;D&#39;, &#39;G&#39;)
    graph.addEdge(&#39;D&#39;, &#39;H&#39;)
    graph.addEdge(&#39;B&#39;, &#39;E&#39;)
    graph.addEdge(&#39;B&#39;, &#39;F&#39;)
    graph.addEdge(&#39;E&#39;, &#39;I&#39;)
    
    //4.测试bfs遍历方法
    let result = &amp;quot;&amp;quot;
    graph.bfs(graph.vertexes[0], function(v){
      result += v + &amp;quot;-&amp;quot;
    })
    console.log(result);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614686966585.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可见，安装了广度优先搜索的顺序&lt;strong&gt;不重复&lt;/strong&gt;地遍历了&lt;strong&gt;所有&lt;/strong&gt;顶点。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;深度优先搜索&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;深度优先算法的思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;深度优先搜索算法将会从指定的第一个顶点开始遍历图，沿着一条路径遍历直到该路径的最后一个顶点都被访问过为止；&lt;/li&gt;
&lt;li&gt;接着沿原来路径回退并探索下一条路径，即&lt;strong&gt;先深后宽&lt;/strong&gt;地遍历图中的各个顶点；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614687004548.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以使用&lt;strong&gt;栈&lt;/strong&gt;结构来实现深度优先搜索算法；&lt;/li&gt;
&lt;li&gt;深度优先搜索算法的遍历顺序与二叉搜索树中的先序遍历较为相似，同样可以使用&lt;strong&gt;递归&lt;/strong&gt;来实现（递归的本质就是&lt;strong&gt;函数栈&lt;/strong&gt;的调用）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于递归实现深度优先搜索算法：定义dfs方法用于调用递归方法dfsVisit，定义dfsVisit方法用于递归访问图中的各个顶点。&lt;/p&gt;
&lt;p&gt;在dfs方法中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，调用initializeColor方法将所有顶点初始化为白色；&lt;/li&gt;
&lt;li&gt;然后，调用dfsVisit方法遍历图的顶点；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在dfsVisit方法中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，将传入的指定节点v标注为&lt;strong&gt;灰色&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;接着，处理顶点V；&lt;/li&gt;
&lt;li&gt;然后，访问V的相邻顶点；&lt;/li&gt;
&lt;li&gt;最后，将顶点v标注为黑色；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     //六.实现深度搜索(DFS)
      Graph.prototype.dfs = function(initV, handler){
        //1.初始化顶点颜色
        let colors = this.initializeColor()

        //2.从某个顶点开始依次递归访问
        this.dfsVisit(initV, colors, handler)
      }

      //为了方便递归调用，封装访问顶点的函数，传入三个参数分别表示：指定的第一个顶点、颜色、处理函数
      Graph.prototype.dfsVisit = function(v, colors, handler){
        //1.将颜色设置为灰色
        colors[v] = &#39;gray&#39;

        //2.处理v顶点
        handler(v)

        //3.访问V的相邻顶点
        let vNeighbours = this.edges.get(v)
        for (let i = 0; i &amp;lt; vNeighbours.length; i++) {
          let a = vNeighbours[i];
          //判断相邻顶点是否为白色，若为白色，递归调用函数继续访问
          if (colors[a] == &#39;white&#39;) {
            this.dfsVisit(a, colors, handler)
          }
          
        }

        //4.将v设置为黑色
        colors[v] = &#39;black&#39;
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里主要解释一下代码中的第3步操作：访问指定顶点的相邻顶点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以指定顶点A为例，先从储存顶点及其对应相邻顶点的字典对象edges中取出由顶点A的相邻顶点组成的数组：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614687096873.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第一步&lt;/strong&gt;：A顶点变为灰色，随后进入第一个for循环，遍历A白色的相邻顶点：B、C、D；在该for循环的第1次循环中（执行B），B顶点满足：colors == &amp;quot;white&amp;quot;，触发递归，重新调用该方法；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二步&lt;/strong&gt;：B顶点变为灰色，随后进入第二个for循环，遍历B白色的相邻顶点：E、F；在该for循环的第1次循环中（执行E），E顶点满足：colors == &amp;quot;white&amp;quot;，触发递归，重新调用该方法；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三步&lt;/strong&gt;：E顶点变为灰色，随后进入第三个for循环，遍历E白色的相邻顶点：I；在该for循环的第1次循环中（执行I），I顶点满足：colors == &amp;quot;white&amp;quot;，触发递归，重新调用该方法；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第四步&lt;/strong&gt;：I顶点变为灰色，随后进入第四个for循环，由于顶点I的相邻顶点E不满足：colors == &amp;quot;white&amp;quot;，停止递归调用。过程如下图所示：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614687132186.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第五步&lt;/strong&gt;：递归结束后一路向上返回，首先回到第三个for循环中继续执行其中的第2、3...次循环，每次循环的执行过程与上面的同理，直到递归再次结束后，再返回到第二个for循环中继续执行其中的第2、3...次循环....以此类推直到将图的所有顶点访问完为止。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图为遍历图中各顶点的完整过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;发现&lt;/strong&gt;表示访问了该顶点，状态变为&lt;strong&gt;灰色&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;探索&lt;/strong&gt;表示既访问了该顶点，也访问了该顶点的全部相邻顶点，状态变为&lt;strong&gt;黑色&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;由于在顶点变为灰色后就调用了处理函数handler，所以handler方法的输出顺序为发现顶点的顺序即：A、B、E、I、F、C、D、G、H 。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614687185004.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   //测试代码
    //1.创建图结构
    let graph = new Graph()

    //2.添加顶点
    let myVertexes = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;]
    for (let i = 0; i &amp;lt; myVertexes.length; i++) {
      graph.addVertex(myVertexes[i])
    }

    //3.添加边
    graph.addEdge(&#39;A&#39;, &#39;B&#39;)
    graph.addEdge(&#39;A&#39;, &#39;C&#39;)
    graph.addEdge(&#39;A&#39;, &#39;D&#39;)
    graph.addEdge(&#39;C&#39;, &#39;D&#39;)
    graph.addEdge(&#39;C&#39;, &#39;G&#39;)
    graph.addEdge(&#39;D&#39;, &#39;G&#39;)
    graph.addEdge(&#39;D&#39;, &#39;H&#39;)
    graph.addEdge(&#39;B&#39;, &#39;E&#39;)
    graph.addEdge(&#39;B&#39;, &#39;F&#39;)
    graph.addEdge(&#39;E&#39;, &#39;I&#39;)
    
    //4.测试dfs遍历顶点
    let result = &amp;quot;&amp;quot;
    graph.dfs(graph.vertexes[0], function(v){
      result += v + &amp;quot;-&amp;quot;
    })
    console.log(result);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614687223502.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;26完整实现&#34;&gt;2.6.完整实现&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;    //封装图结构
    function Graph (){
      //属性：顶点(数组)/边(字典)
      this.vertexes = []  //顶点
      this.edges = new Dictionary() //边

      //方法
      //添加方法
      //一.添加顶点
      Graph.prototype.addVertex = function(v){
        this.vertexes.push(v)
        this.edges.set(v, []) //将边添加到字典中，新增的顶点作为键，对应的值为一个存储边的空数组
      }
      //二.添加边
      Graph.prototype.addEdge = function(v1, v2){//传入两个顶点为它们添加边
        this.edges.get(v1).push(v2)//取出字典对象edges中存储边的数组，并添加关联顶点
        this.edges.get(v2).push(v1)//表示的是无向表，故要添加互相指向的两条边
      }

      //三.实现toString方法:转换为邻接表形式
      Graph.prototype.toString = function (){
        //1.定义字符串，保存最终结果
        let resultString = &amp;quot;&amp;quot;

        //2.遍历所有的顶点以及顶点对应的边
        for (let i = 0; i &amp;lt; this.vertexes.length; i++) {//遍历所有顶点
          resultString += this.vertexes[i] + &#39;--&amp;gt;&#39;
          let vEdges = this.edges.get(this.vertexes[i])
          for (let j = 0; j &amp;lt; vEdges.length; j++) {//遍历字典中每个顶点对应的数组
            resultString += vEdges[j] + &#39;  &#39;;
          }
          resultString += &#39;\n&#39;
        }
        return resultString
      }

      //四.初始化状态颜色
      Graph.prototype.initializeColor = function(){
        let colors = []
        for (let i = 0; i &amp;lt; this.vertexes.length; i++) {
           colors[this.vertexes[i]] = &#39;white&#39;;
        }
        return colors
      }

      //五.实现广度搜索(BFS)
      //传入指定的第一个顶点和处理结果的函数
      Graph.prototype.bfs = function(initV, handler){
        //1.初始化颜色
        let colors = this.initializeColor()

        //2.创建队列
        let que = new Queue()

        //3.将顶点加入到队列中
        que.enqueue(initV)

        //4.循环从队列中取出元素
        while(!que.isEmpty()){
          //4.1.从队列中取出一个顶点
          let v = que.dequeue()

          //4.2.获取和顶点相相邻的其他顶点
          let vNeighbours = this.edges.get(v)

          //4.3.将v的颜色变为灰色
          colors[v] = &#39;gray&#39;

          //4.4.遍历v所有相邻的顶点vNeighbours,并且加入队列中
          for (let i = 0; i &amp;lt; vNeighbours.length; i++) {
            const a = vNeighbours[i];
            //判断相邻顶点是否被探测过，被探测过则不加入队列中；并且加入队列后变为灰色，表示被探测过
            if (colors[a] == &#39;white&#39;) {
              colors[a] = &#39;gray&#39;
              que.enqueue(a)
            }
          }

          //4.5.处理顶点v
          handler(v)

          //4.6.顶点v所有白色的相邻顶点都加入队列后，将顶点v设置为黑色。此时黑色顶点v位于队列最前面，进入下一次while循环时会被取出
          colors[v] = &#39;black&#39;
        }
      }

      //六.实现深度搜索(DFS)
      Graph.prototype.dfs = function(initV, handler){
        //1.初始化顶点颜色
        let colors = this.initializeColor()

        //2.从某个顶点开始依次递归访问
        this.dfsVisit(initV, colors, handler)
      }

      //为了方便递归调用，封装访问顶点的函数，传入三个参数分别表示：指定的第一个顶点、颜色、处理函数
      Graph.prototype.dfsVisit = function(v, colors, handler){
        //1.将颜色设置为灰色
        colors[v] = &#39;gray&#39;

        //2.处理v顶点
        handler(v)

        //3.访问v相连的其他顶点
        let vNeighbours = this.edges.get(v)
        for (let i = 0; i &amp;lt; vNeighbours.length; i++) {
          let a = vNeighbours[i];
          //判断相邻顶点是否为白色，若为白色，递归调用函数继续访问
          if (colors[a] == &#39;white&#39;) {
            this.dfsVisit(a, colors, handler)
          }
          
        }

        //4.将v设置为黑色
        colors[v] = &#39;black&#39;
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;27-深度优先和广度优先区别&#34;&gt;2.7 深度优先和广度优先区别&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;bfs＝队列，入队列，出队列；dfs=栈，压栈，出栈&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619575966858.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1x7411L7Q7?from=search&amp;amp;seid=3912456004602554239&#34;&gt;参考资料:JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现图结构</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/javascript-shi-xian-hong-hei-shu/"" data-c="
          &lt;h1 id=&#34;1红黑树的五条规则&#34;&gt;1.红黑树的五条规则&lt;/h1&gt;
&lt;p&gt;红黑树除了符合二叉搜索树的基本规则外，还添加了以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;规则1：节点是红色或黑色的&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规则2：根节点是黑色的；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规则3：每个叶子节点都是黑色的空节点（NIL节点）；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规则4：每个红色节点的两个子节点都是黑色的（从每个叶子到根的所有路径上不可能有两个连续的红色节点）；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规则5：从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点；&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614602841856.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;红黑树的相对平衡&lt;/strong&gt;&lt;br&gt;
前面5条规则的约束确保了以下红黑树的关键特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从&lt;strong&gt;根到叶子节点&lt;/strong&gt;的&lt;strong&gt;最长路径&lt;/strong&gt;，不会超过&lt;strong&gt;最短路径&lt;/strong&gt;的&lt;strong&gt;两倍&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;结果就是这棵树&lt;strong&gt;基本&lt;/strong&gt;是平衡的；&lt;/li&gt;
&lt;li&gt;虽然没有做到绝对的平衡，但是可以保证在最坏的情况下，该树依然是高效的；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么可以做到&lt;strong&gt;最长路径不超过最短路径的两倍&lt;/strong&gt;呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;性质4&lt;/strong&gt;决定了路径上不能有两个相连的红色节点；&lt;/li&gt;
&lt;li&gt;所以，最长路径一定是红色节点和黑色节点交替而成的；&lt;/li&gt;
&lt;li&gt;由于根节点和叶子节点都是黑色的，最短路径可能都是黑色节点，并且最长路径中一定是黑色节点多于红色节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性质5&lt;/strong&gt;决定了所有路径上都有相同数目的黑色节点；&lt;/li&gt;
&lt;li&gt;这就表明了没有路径能多于其他任何路径两倍长。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2红黑树的三种变换&#34;&gt;2.红黑树的三种变换&lt;/h1&gt;
&lt;p&gt;插入一个新节点时，有可能树不再平衡，可以通过三种方式的变换使树保持平衡：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;变色&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;左旋转&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;右旋转&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;21变色&#34;&gt;2.1.变色&lt;/h2&gt;
&lt;p&gt;为了重新符合红黑树的规则，需要把&lt;strong&gt;红色&lt;/strong&gt;节点变为&lt;strong&gt;黑色&lt;/strong&gt;，或者把&lt;strong&gt;黑色&lt;/strong&gt;节点变为&lt;strong&gt;红色&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;插入的&lt;strong&gt;新节点&lt;/strong&gt;通常都是&lt;strong&gt;红色节点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当插入的节点为&lt;strong&gt;红色&lt;/strong&gt;的时候，大多数情况&lt;strong&gt;不违反&lt;/strong&gt;红黑树的任何规则；&lt;/li&gt;
&lt;li&gt;而&lt;strong&gt;插入黑色节点&lt;/strong&gt;，必然会导致一条路径上多了一个&lt;strong&gt;黑色节点&lt;/strong&gt;，这是很难调整的；&lt;/li&gt;
&lt;li&gt;红色节点虽然可能导致&lt;strong&gt;红红相连&lt;/strong&gt;的情况，但是这种情况可以通过&lt;strong&gt;颜色调换&lt;/strong&gt;和&lt;strong&gt;旋转&lt;/strong&gt;来调整；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;22左旋转&#34;&gt;2.2.左旋转&lt;/h2&gt;
&lt;p&gt;以节点X为根&lt;strong&gt;逆时针&lt;/strong&gt;旋转二叉搜索树，使得父节点原来的位置被自己的右子节点替代，左子节点的位置被父节点替代；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614604172318.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;详解：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，左旋转之后：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点X取代了节点a原来的位置；&lt;/li&gt;
&lt;li&gt;节点Y取代了节点X原来的位置；&lt;/li&gt;
&lt;li&gt;节点X的&lt;strong&gt;左子树&lt;/strong&gt; a 仍然是节点X的&lt;strong&gt;左子树&lt;/strong&gt;（这里X的左子树只有一个节点，有多个节点时同样适用，以下同理）；&lt;/li&gt;
&lt;li&gt;节点Y的&lt;strong&gt;右子树 &lt;strong&gt;c 仍然是节点Y的&lt;/strong&gt;右子树&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;节点Y的&lt;strong&gt;左子树&lt;/strong&gt; b 向&lt;strong&gt;左平移&lt;/strong&gt;成为了节点X的&lt;strong&gt;右子树&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外，二叉搜索树左旋转之后仍为二叉搜索树：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614604239227.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;23右旋转&#34;&gt;2.3.右旋转&lt;/h2&gt;
&lt;p&gt;以节点X为根&lt;strong&gt;顺时针&lt;/strong&gt;旋转二叉搜索树，使得父节点原来的位置被自己的左子节点替代，右子节点的位置被父节点替代；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614604262297.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;详解：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，右旋转之后：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点X取代了节点a原来的位置；&lt;/li&gt;
&lt;li&gt;节点Y取代了节点X原来的位置；&lt;/li&gt;
&lt;li&gt;节点X的&lt;strong&gt;右子树&lt;/strong&gt; a 仍然是节点X的&lt;strong&gt;右子树&lt;/strong&gt;（这里X的右子树虽然只有一个节点，但是多个节点时同样适用，以下同理）；&lt;/li&gt;
&lt;li&gt;节点Y的&lt;strong&gt;左子树&lt;/strong&gt; b 仍然是节点Y的&lt;strong&gt;左子树&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;节点Y的&lt;strong&gt;右子树 c 向右平移&lt;/strong&gt;成为了节点X的&lt;strong&gt;左子树&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外，二叉搜索树右旋转之后仍为二叉搜索树：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614604315554.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3红黑树的插入操作&#34;&gt;3.红黑树的插入操作&lt;/h1&gt;
&lt;p&gt;首先需要明确，在保证满足红黑树5条规则的情况下，新插入的节点必然是&lt;strong&gt;红色节点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为了方便说明，规定以下四个节点：新插入节点为&lt;strong&gt;N&lt;/strong&gt;（Node），N的父节点为&lt;strong&gt;P&lt;/strong&gt;（Parent），P的兄弟节点为&lt;strong&gt;U&lt;/strong&gt;（Uncle），U的父节点为&lt;strong&gt;G&lt;/strong&gt;（Grandpa），如下图所示：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614604357068.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;31情况1&#34;&gt;3.1.情况1&lt;/h2&gt;
&lt;p&gt;当插入的新节点N位于树的根上时，没有父节点。&lt;/p&gt;
&lt;p&gt;这种情况下，只需要将红色节点变为黑色节点即可满足规则2 。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614604378412.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;32情况2&#34;&gt;3.2.情况2&lt;/h2&gt;
&lt;p&gt;新界点N的父节点P为黑色节点，此时不需要任何变化。&lt;/p&gt;
&lt;p&gt;此时既满足规则4也满足规则5。尽管新节点是红色的，但是新节点N有两个黑色节点NIL，所以通向它的路径上黑色节点的个数依然相等，因此满足规则5 。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614604403948.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;33情况3&#34;&gt;3.3.情况3&lt;/h2&gt;
&lt;p&gt;节点P为红色，节点U也为红色，此时节点G必为黑色，即&lt;strong&gt;父红叔红祖黑&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在这种情况下需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先将父节点P变为黑色；&lt;/li&gt;
&lt;li&gt;再将叔叔节点U变为黑色；&lt;/li&gt;
&lt;li&gt;最后将祖父节点G变为红色；&lt;/li&gt;
&lt;li&gt;即变为父黑叔黑祖红，如下图所示：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即变为&lt;strong&gt;父黑叔黑祖红&lt;/strong&gt;，如下图所示：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614604452528.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;可能出现的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;N的祖父节点G的父节点也可能是红色，这就违反了规则4，此时可以通过递归调整节点颜色；&lt;/li&gt;
&lt;li&gt;当递归调整到根节点时就需要旋转了，如下图节点A和节点B所示，具体情况后面会介绍；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614604474905.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;34情况4&#34;&gt;3.4.情况4&lt;/h2&gt;
&lt;p&gt;节点P是红色节点，节点U是黑色节点，并且节点N为节点P的&lt;strong&gt;左子节点&lt;/strong&gt;，此时节点G一定是黑色节点，即&lt;strong&gt;父红叔黑祖黑&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在这种情况下需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先变色：将父节点P变为黑色，将祖父节点G变为红色；&lt;/li&gt;
&lt;li&gt;后旋转：以祖父节点G为根进行右旋转；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614604502174.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;35情况5&#34;&gt;3.5.情况5&lt;/h2&gt;
&lt;p&gt;节点P是红色节点，节点U是黑色节点，并且节点N为节点P的&lt;strong&gt;右子节点&lt;/strong&gt;，此时节点G一定是黑色节点，即&lt;strong&gt;父红叔黑祖黑&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在这种情况下需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先以节点P为根进行左旋转，旋转后如图b所示；&lt;/li&gt;
&lt;li&gt;随后将&lt;strong&gt;红色&lt;/strong&gt;节点&lt;strong&gt;P&lt;/strong&gt;和&lt;strong&gt;黑色&lt;/strong&gt;节点&lt;strong&gt;B&lt;/strong&gt;看成一个整体的&lt;strong&gt;红色&lt;/strong&gt;节点&lt;strong&gt;N1&lt;/strong&gt;，将新插入的&lt;strong&gt;红色&lt;/strong&gt;节点&lt;strong&gt;N&lt;/strong&gt;看成&lt;strong&gt;红色&lt;/strong&gt;节点&lt;strong&gt;P1&lt;/strong&gt; 如图c所示。此时整体就转换为了情况4。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614604584661.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接着可以按照情况4进行处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先变色：将N1节点的父节点P1变为黑色，将祖父节点G变为红色；&lt;/li&gt;
&lt;li&gt;后旋转：以祖父节点G为根进行右旋转，旋转后如图 e 所示；&lt;/li&gt;
&lt;li&gt;最后将节点N1和P1变换回来，完成节点N的插入，如图 f 所示；&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1614604622077.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;36案例&#34;&gt;3.6.案例&lt;/h2&gt;
&lt;p&gt;在二叉树中依次插入节点：10，9，8，7，6，5，4，3，2，1 。&lt;/p&gt;
&lt;p&gt;如果直接采用普通的二叉搜索树，节点全部插入后是这样的：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614604643226.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;是一个严重的&lt;strong&gt;不平衡树&lt;/strong&gt;，相当于一个链表，不能体现出二叉搜索树的高效率。而按照红黑树的五条规则插入节点就能最大程度保证搜索二叉树是一棵&lt;strong&gt;平衡树&lt;/strong&gt;。以下为过程详解：&lt;strong&gt;为了方便解释省略了部分红黑树的叶子节点（NIL）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;插入10&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;符合&lt;strong&gt;情况1：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入节点10；&lt;/li&gt;
&lt;li&gt;将节点10的颜色变为黑色；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614604704418.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;插入9&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;符合&lt;strong&gt;情况2&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不需要任何变化；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614604750380.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;插入8&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;快速判断属于情况3还是情况4的方法：&lt;br&gt;
从新插入的节点N出发，按图示箭头经过的四个节点，若为&lt;strong&gt;红红黑红&lt;/strong&gt;3个红色节点则为情况3，若为&lt;strong&gt;红红黑黑&lt;/strong&gt;两个红色节点则为情况4；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614604802506.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;符合&lt;strong&gt;情况4：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点9变成黑，祖父节点10变为红；&lt;/li&gt;
&lt;li&gt;以祖父节点为根进行右旋转；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614604830569.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;插入7&lt;/code&gt;&lt;br&gt;
符合&lt;strong&gt;情况3&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点8和叔节点10变为黑，祖父节点9变为红；&lt;/li&gt;
&lt;li&gt;此时会出现问题：不符合规则2，即根节点不为黑，此时可以把以9为根节点的二叉搜索树当作一个整体作为一个新插入的节点N，而此时又符合情况1，只需要把9变回黑色即可。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614604863568.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;插入6&lt;/code&gt;&lt;br&gt;
符合&lt;strong&gt;情况4：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点7变为黑，祖父节点8变为红；&lt;/li&gt;
&lt;li&gt;以祖父节点8为根进行右旋转；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614604890220.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;插入5&lt;/code&gt;&lt;br&gt;
符合&lt;strong&gt;情况3&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点6和叔节点8变为黑，祖父节点7变为红；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614604951192.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;插入4&lt;/code&gt;&lt;br&gt;
符合&lt;strong&gt;情况4&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点5变为黑，祖父节点6变为红；&lt;/li&gt;
&lt;li&gt;以祖父节点6为根进行右旋转；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614604975864.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;插入3&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;第一次变换&lt;/strong&gt;：符合&lt;strong&gt;情况3&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点4和叔节点6变为黑，祖父节点5变为红；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;变换之后发现5和7为相连的两个红色节点，于是把以5为根的整个子树看成一个新插入的节点N1，再进行第二次变换。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614605014069.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二次变换&lt;/strong&gt;：符合&lt;strong&gt;情况4&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点7变为黑，祖父节点9变为红；&lt;/li&gt;
&lt;li&gt;以祖父节点9为根进行右旋转；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614605037802.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后复原N1得到变换后的红黑树：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614605062771.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;插入2&lt;/code&gt;&lt;br&gt;
符合&lt;strong&gt;情况4&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点3变为黑，祖父节点4变为红；&lt;/li&gt;
&lt;li&gt;以祖父节点4为根进行右旋转；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614605088621.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;插入1&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;第一次变换&lt;/strong&gt;：符合&lt;strong&gt;情况3&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点2和叔节点4变为黑，祖父节点3变为红；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;变换之后发现3和5为相连的两个红色节点，于是把以3为根的整个子树看成一个新插入的节点N1，再进行第二次变换。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614605114950.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二次变换&lt;/strong&gt;：符合&lt;strong&gt;情况3&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点5和叔节点9变为黑，祖父节点7变为红；即由图 b -&amp;gt; 图 c 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;变换之后发现根节点7为红色不符合规则2，所以把以7为根节点的红黑树看成一个新插入的节点N2，再进行第三次变换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三次变换&lt;/strong&gt;：符合&lt;strong&gt;情况1&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接将根节点7变为黑色即可。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614605156139.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由此，完成了1~10节点的插入，虽然没有遇到情况5，不过情况5经过左旋转的操作便可转换为情况4，原理一样。如下图所示，将这棵红黑树的叶子节点NIL补全之后，经检验满足红黑树的五条规则，并且基本属于&lt;strong&gt;平衡树&lt;/strong&gt;，效率较高。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614605184855.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;4红黑树的删除操作&#34;&gt;4.红黑树的删除操作&lt;/h1&gt;
&lt;p&gt;红黑树的删除操作结合了复杂的&lt;strong&gt;二叉树的删除操作&lt;/strong&gt;和复杂的&lt;strong&gt;红黑树的插入规则&lt;/strong&gt;，整体来说难度非常大，篇幅较长，这里暂不进行探讨。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av86801505?from=search&amp;amp;seid=4967761411915016256&#34;&gt;参考资料：JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现平衡树（红黑树）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/javascript-shi-xian-shu-jie-gou/"" data-c="
          &lt;h1 id=&#34;1树结构简介&#34;&gt;1.树结构简介&lt;/h1&gt;
&lt;h2 id=&#34;11简单了解树结构&#34;&gt;1.1.简单了解树结构&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;什么是树？&lt;/strong&gt;&lt;br&gt;
真实的树：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614430459970.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;树的特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树一般都有一个&lt;strong&gt;根&lt;/strong&gt;，连接着根的是&lt;strong&gt;树干&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;树干会发生分叉，形成许多&lt;strong&gt;树枝&lt;/strong&gt;，树枝会继续分化成更小的&lt;strong&gt;树枝&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;树枝的最后是&lt;strong&gt;叶子&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现实生活中很多结构都是树的抽象，模拟的树结构相当于旋转180°的树。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614430500028.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;树结构对比于数组/链表/哈希表有哪些优势呢：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数组：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：可以通过&lt;strong&gt;下标值访问&lt;/strong&gt;，效率高；&lt;/li&gt;
&lt;li&gt;缺点：查找数据时需要先对数据进行&lt;strong&gt;排序&lt;/strong&gt;，生成&lt;strong&gt;有序数组&lt;/strong&gt;，才能提高查找效率；并且在插入和删除元素时，需要大量的&lt;strong&gt;位移操作&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;链表：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：数据的插入和删除操作效率都很高；&lt;/li&gt;
&lt;li&gt;缺点：&lt;strong&gt;查找&lt;/strong&gt;效率低，需要从头开始依次查找，直到找到目标数据为止；当需要在链表中间位置插入或删除数据时，插入或删除的效率都不高。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;哈希表：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：哈希表的插入/查询/删除效率都非常高；&lt;/li&gt;
&lt;li&gt;缺点：&lt;strong&gt;空间利用率不高&lt;/strong&gt;，底层使用的数组中很多单元没有被利用；并且哈希表中的元素是&lt;strong&gt;无序&lt;/strong&gt;的，不能按照固定顺序遍历哈希表中的元素；而且不能快速找出哈希表中&lt;strong&gt;最大值或最小值&lt;/strong&gt;这些特殊值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;树结构：&lt;/strong&gt;&lt;br&gt;
优点：树结构综合了上述三种结构的优点，同时也弥补了它们存在的缺点（虽然效率不一定都比它们高），比如树结构中数据都是有序的，查找效率高；空间利用率高；并且可以快速获取最大值和最小值等。&lt;/p&gt;
&lt;p&gt;总的来说：&lt;strong&gt;每种数据结构都有自己特定的应用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;树结构：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;树（Tree）&lt;/strong&gt;:由 n（n ≥ 0）个节点构成的&lt;strong&gt;有限集合&lt;/strong&gt;。当 n = 0 时，称为&lt;strong&gt;空树&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于任一棵非空树（n &amp;gt; 0），它具备以下性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数中有一个称为**根（Root）**的特殊节点，用 **r **表示；&lt;/li&gt;
&lt;li&gt;其余节点可分为 m（m &amp;gt; 0）个互不相交的有限集合 T1，T2，...，Tm，其中每个集合本身又是一棵树，称为原来树的&lt;strong&gt;子树（SubTree）&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;树的常用术语：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614430719871.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;节点的度（Degree）&lt;/strong&gt;：节点的&lt;strong&gt;子树个数&lt;/strong&gt;，比如节点B的度为2；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;树的度&lt;/strong&gt;：树的所有节点中&lt;strong&gt;最大的度数&lt;/strong&gt;，如上图树的度为2；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;叶节点（Leaf）&lt;/strong&gt;：&lt;strong&gt;度为0的节点&lt;/strong&gt;（也称为叶子节点），如上图的H，I等；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;父节点（Parent）&lt;/strong&gt;：度不为0的节点称为父节点，如上图节点B是节点D和E的父节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;子节点（Child）&lt;/strong&gt;：若B是D的父节点，那么D就是B的子节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;兄弟节点（Sibling）&lt;/strong&gt;：具有同一父节点的各节点彼此是兄弟节点，比如上图的B和C，D和E互为兄弟节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路径和路径长度&lt;/strong&gt;：路径指的是一个节点到另一节点的通道，路径所包含边的个数称为路径长度，比如A-&amp;gt;H的路径长度为3；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;节点的层次（Level）&lt;/strong&gt;：规定&lt;strong&gt;根节点在1层&lt;/strong&gt;，其他任一节点的层数是其父节点的&lt;strong&gt;层数加1&lt;/strong&gt;。如B和C节点的层次为2；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;树的深度（Depth）&lt;/strong&gt;：树种所有节点中的&lt;strong&gt;最大层次&lt;/strong&gt;是这棵树的深度，如上图树的深度为4；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12树结构的表示方式&#34;&gt;1.2.树结构的表示方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;最普通的表示方法：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1614430807590.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如图，树结构的组成方式类似于链表，都是由一个个节点连接构成。不过，根据每个父节点子节点数量的不同，每一个父节点需要的引用数量也不同。比如节点A需要3个引用，分别指向子节点B，C，D；B节点需要2个引用，分别指向子节点E和F；K节点由于没有子节点，所以不需要引用。&lt;/p&gt;
&lt;p&gt;这种方法缺点在于我们无法确定某一结点的引用数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;儿子-兄弟表示法：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614430840465.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这种表示方法可以完整地记录每个节点的数据，比如：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;//节点A
Node{
  //存储数据
  this.data = data
  //统一只记录左边的子节点
  this.leftChild = B
  //统一只记录右边的第一个兄弟节点
  this.rightSibling = null
}

//节点B
Node{
  this.data = data
  this.leftChild = E
  this.rightSibling = C
}

//节点F
Node{
  this.data = data
  this.leftChild = null
  this.rightSibling = null
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种表示法的优点在于每一个节点中引用的数量都是确定的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;儿子-兄弟表示法旋转&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下为儿子-兄弟表示法组成的树结构：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614430881094.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
将其顺时针旋转45°之后：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614430888569.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这样就成为了一棵&lt;strong&gt;二叉树&lt;/strong&gt;，由此我们可以得出结论：&lt;strong&gt;任何树都可以通过二叉树进行模拟&lt;/strong&gt;。但是这样父节点不是变了吗？其实，父节点的设置只是为了方便指向子节点，在代码实现中谁是父节点并没有关系，只要能正确找到对应节点即可。&lt;/p&gt;
&lt;h1 id=&#34;2二叉树&#34;&gt;2.二叉树&lt;/h1&gt;
&lt;h2 id=&#34;21二叉树简介&#34;&gt;2.1.二叉树简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;二叉树的概念&lt;/strong&gt;：如果树中的每一个节点最多只能由&lt;strong&gt;两个子节点&lt;/strong&gt;，这样的树就称为&lt;strong&gt;二叉树&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;二叉树十分重要，不仅仅是因为简单，更是因为几乎所有的树都可以表示成二叉树形式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二叉树的组成&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二叉树可以为空，也就是没有节点；&lt;/li&gt;
&lt;li&gt;若二叉树不为空，则它由根节点和称为其左子树TL和右子树TR的两个不相交的二叉树组成；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;二叉树的五种形态：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614430959785.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
上图分别表示：空的二叉树、只有一个节点的二叉树、只有左子树TL的二叉树、只有右子树TR的二叉树和有左右两个子树的二叉树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二叉树的特性：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个二叉树的第 i 层的最大节点树为：2(i-1)，i &amp;gt;= 1；&lt;/li&gt;
&lt;li&gt;深度为k的二叉树的最大节点总数为：2k - 1 ，k &amp;gt;= 1；&lt;/li&gt;
&lt;li&gt;对任何非空二叉树，若 n0 表示叶子节点的个数，n2表示度为2的非叶子节点个数，那么两者满足关系：n0 = n2 + 1；如下图所示：H，E，I，J，G为叶子节点，总数为5；A，B，C，F为度为2的非叶子节点，总数为4；满足n0 = n2 + 1的规律。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1614430990764.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;22特殊的二叉树&#34;&gt;2.2.特殊的二叉树&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;完美二叉树&lt;/strong&gt;&lt;br&gt;
完美二叉树（Perfect Binary Tree）也成为满二叉树（Full Binary Tree），在二叉树中，除了最下一层的叶子节点外，每层节点都有2个子节点，这就构成了完美二叉树。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614431028944.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完全二叉树&lt;/strong&gt;&lt;br&gt;
完全二叉树（Complete Binary Tree）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;除了二叉树最后一层外，其他各层的节点数都达到了最大值；&lt;/li&gt;
&lt;li&gt;并且，最后一层的叶子节点从左向右是连续存在，只缺失右侧若干叶子节点；&lt;/li&gt;
&lt;li&gt;完美二叉树是特殊的完全二叉树；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1614431051756.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在上图中，由于H缺失了右子节点，所以它不是完全二叉树。&lt;/p&gt;
&lt;h2 id=&#34;23二叉树的数据存储&#34;&gt;2.3.二叉树的数据存储&lt;/h2&gt;
&lt;p&gt;常见的二叉树存储方式为&lt;strong&gt;数组&lt;/strong&gt;和&lt;strong&gt;链表&lt;/strong&gt;：&lt;br&gt;
&lt;strong&gt;使用数组：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完全二叉树：按从上到下，从左到右的方式存储数据。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614431087611.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;节点&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;A&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;B&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;C&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;E&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;F&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;G&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;H&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;序号&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;使用数组存储时，取数据的时候也十分方便：左子节点的序号等于父节点序号 * 2，右子节点的序号等于父节点序号 * 2 + 1 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非完全二叉树：非完全二叉树需要转换成完全二叉树才能按照上面的方案存储，这样会浪费很大的存储空间。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614431341849.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614431447014.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;使用链表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;二叉树最常见的存储方式为&lt;strong&gt;链表&lt;/strong&gt;：每一个节点封装成一个Node，Node中包含存储的数据、左节点的引用和右节点的引用。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614431472922.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3二叉搜索树&#34;&gt;3.二叉搜索树&lt;/h1&gt;
&lt;h2 id=&#34;31认识二叉搜索树&#34;&gt;3.1.认识二叉搜索树&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;二叉搜索树&lt;/strong&gt;（&lt;strong&gt;BST&lt;/strong&gt;，Binary Search Tree），也称为&lt;strong&gt;二叉排序树&lt;/strong&gt;和&lt;strong&gt;二叉查找树&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;二叉搜索树是一棵二叉树，可以为空；&lt;/p&gt;
&lt;p&gt;如果不为空，则满足以下&lt;strong&gt;性质&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;条件1：非空左子树的&lt;strong&gt;所有&lt;/strong&gt;键值&lt;strong&gt;小于&lt;/strong&gt;其根节点的键值。比如三中节点6的所有非空左子树的键值都小于6；&lt;/li&gt;
&lt;li&gt;条件2：非空右子树的&lt;strong&gt;所有&lt;/strong&gt;键值&lt;strong&gt;大于&lt;/strong&gt;其根节点的键值；比如三中节点6的所有非空右子树的键值都大于6；&lt;/li&gt;
&lt;li&gt;条件3：左、右子树本身也都是二叉搜索树；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614431547872.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如上图所示，树二和树三符合3个条件属于二叉树，树一不满足条件3所以不是二叉树。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：二叉搜索树的特点主要是&lt;strong&gt;较小的值&lt;/strong&gt;总是保存在&lt;strong&gt;左节点&lt;/strong&gt;上，相对&lt;strong&gt;较大的值&lt;/strong&gt;总是保存在&lt;strong&gt;右节点&lt;/strong&gt;上。这种特点使得二叉搜索树的查询效率非常高，这也就是二叉搜索树中&amp;quot;搜索&amp;quot;的来源。&lt;/p&gt;
&lt;h2 id=&#34;32二叉搜索树应用举例&#34;&gt;3.2.二叉搜索树应用举例&lt;/h2&gt;
&lt;p&gt;下面是一个二叉搜索树：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614431584847.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
若想在其中查找数据10，只需要查找4次，查找效率非常高。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第1次：将10与根节点9进行比较，由于10 &amp;gt; 9，所以10下一步与根节点9的右子节点13比较；&lt;/li&gt;
&lt;li&gt;第2次：由于10 &amp;lt; 13，所以10下一步与父节点13的左子节点11比较；&lt;/li&gt;
&lt;li&gt;第3次：由于10 &amp;lt; 11，所以10下一步与父节点11的左子节点10比较；&lt;/li&gt;
&lt;li&gt;第4次：由于10 = 10，最终查找到数据10 。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614431605019.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
同样是15个数据，在排序好的数组中查询数据10，需要查询10次：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614431617619.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实：如果是排序好的数组，可以通过二分查找：第一次找9，第二次找13，第三次找15...。我们发现如果把每次二分的数据拿出来以树的形式表示的话就是&lt;strong&gt;二叉搜索树&lt;/strong&gt;。这就是数组二分法查找效率之所以高的原因。&lt;/p&gt;
&lt;h1 id=&#34;4二叉搜索树的封装&#34;&gt;4.二叉搜索树的封装&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;二叉树搜索树的基本属性&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;如图所示：二叉搜索树有四个最基本的属性：指向节点的&lt;strong&gt;根&lt;/strong&gt;（root），节点中的&lt;strong&gt;键&lt;/strong&gt;（key）、&lt;strong&gt;左指针&lt;/strong&gt;（right）、&lt;strong&gt;右指针&lt;/strong&gt;（right）。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614431790313.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
所以，二叉搜索树中除了定义root属性外，还应定义一个节点内部类，里面包含每个节点中的left、right和key三个属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //封装二叉搜索树
    function BinarySearchTree(){

      //节点内部类
      function Node(key){
        this.key = key
        this.left = null
        this.right = null
      }

      //属性
      this.root = null
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;二叉搜索树的常见操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insert（key）：向树中插入一个新的键；&lt;/li&gt;
&lt;li&gt;search（key）：在树中查找一个键，如果节点存在，则返回true；如果不存在，则返回false；&lt;/li&gt;
&lt;li&gt;inOrderTraverse：通过中序遍历方式遍历所有节点；&lt;/li&gt;
&lt;li&gt;preOrderTraverse：通过先序遍历方式遍历所有节点；&lt;/li&gt;
&lt;li&gt;postOrderTraverse：通过后序遍历方式遍历所有节点；&lt;/li&gt;
&lt;li&gt;min：返回树中最小的值/键；&lt;/li&gt;
&lt;li&gt;max：返回树中最大的值/键；&lt;/li&gt;
&lt;li&gt;remove（key）：从树中移除某个键；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;41插入数据&#34;&gt;4.1.插入数据&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先根据传入的key创建节点对象；&lt;/li&gt;
&lt;li&gt;然后判断根节点是否存在，不存在时通过：this.root = newNode，直接把新节点作为二叉搜索树的根节点。&lt;/li&gt;
&lt;li&gt;若存在根节点则重新定义一个内部方法insertNode（）用于查找插入点。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    //insert方法:对外向用户暴露的方法
      BinarySearchTree.prototype.insert = function(key){
        //1.根据key创建节点
        let newNode = new Node(key)
          
        //2.判断根节点是否存在
        if (this.root == null) {
          this.root = newNode
          //根节点存在时
        }else {
          this.insertNode(this.root, newNode)
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;内部方法insertNode（）的实现思路:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据比较传入的两个节点，一直查找新节点适合插入的位置，直到成功插入新节点为止。&lt;/p&gt;
&lt;p&gt;当newNode.key &amp;lt; node.key向左查找:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：当node无左子节点时，直接插入：&lt;/li&gt;
&lt;li&gt;情况2：当node有左子节点时，递归调用insertNode(),直到遇到无左子节点成功插入newNode后，不再符合该情况，也就不再调用insertNode()，递归停止。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1614431894630.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当newNode.key &amp;gt;= node.key向右查找，与向左查找类似：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：当node无右子节点时，直接插入：&lt;/li&gt;
&lt;li&gt;情况2：当node有右子节点时，依然递归调用insertNode(),直到遇到传入insertNode方法的node无右子节点成功插入newNode为止：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614431913325.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;insertNode()代码实现：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    //内部使用的insertNode方法:用于比较节点从左边插入还是右边插入
      BinarySearchTree.prototype.insertNode = function(node, newNode){
        //当newNode.key &amp;lt; node.key向左查找
/*----------------------分支1:向左查找--------------------------*/      
        if(newNode.key &amp;lt; node.key){
          //情况1：node无左子节点，直接插入
/*----------------------分支1.1--------------------------*/
          if (node.left == null) {
            node.left = newNode
          //情况2：node有左子节点，递归调用insertNode(),直到遇到无左子节点成功插入newNode后，不再符合该情况，也就不再调用insertNode()，递归停止。
/*----------------------分支1.2--------------------------*/
          }else{
            this.insertNode(node.left, newNode)
          }
        //当newNode.key &amp;gt;= node.key向右查找
/*-----------------------分支2:向右查找--------------------------*/        
        }else{
          //情况1：node无右子节点，直接插入
/*-----------------------分支2.1--------------------------*/ 
          if(node.right == null){
            node.right == newNode
          //情况2：node有右子节点，依然递归调用insertNode(),直到遇到无右子节点成功插入newNode为止
/*-----------------------分支2.2--------------------------*/ 
          }else{
            this.insertNode(node.right, newNode)
          }
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
为了更好理解以下列二叉搜索树为例：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614431949845.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
想要上述的二叉搜索树（蓝色）中插入数据10：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先把key = 10 传入insert方法，由于存在根节点 9，所以直接调用insetNode方法，传入的参数：node = 9，newNode = 10；&lt;/li&gt;
&lt;li&gt;由于10 &amp;gt; 9，进入分支2，向右查找适合插入的位置；&lt;/li&gt;
&lt;li&gt;由于根节点 9 的右子节点存在且为 13 ，所以进入分支2.2，递归调用insertNode方法，传入的参数：node = 13，newNode = 10；&lt;/li&gt;
&lt;li&gt;由于 10 &amp;lt; 13 ，进入分支1，向左查找适合插入的位置；&lt;/li&gt;
&lt;li&gt;由于父节点 13 的左子节点存在且为11，所以进入分支1.2，递归调用insertNode方法，传入的参数：node = 11，newNode = 10；&lt;/li&gt;
&lt;li&gt;由于 10 &amp;lt; 11，进入分支1，向左查找适合插入的位置；&lt;/li&gt;
&lt;li&gt;由于父节点 11 的左子节点不存在，所以进入分支1.1，成功插入节点 10 。由于不符合分支1.2的条件所以不会继续调用insertNode方法，递归停止。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试代码
    //1.创建BinarySearchTree
    let bst = new BinarySearchTree()

    //2.插入数据
    bst.insert(11);
    bst.insert(7);
    bst.insert(15);
    bst.insert(5);
    bst.insert(9);
	console.log(bst);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应得到下图所示的二叉搜索树：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614432007528.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试结果&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614432014572.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;42遍历数据&#34;&gt;4.2.遍历数据&lt;/h2&gt;
&lt;p&gt;这里所说的树的遍历不仅仅针对二叉搜索树，而是适用于所有的二叉树。由于树结构不是线性结构，所以遍历方式有多种选择，常见的三种二叉树遍历方式为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先序遍历；&lt;/li&gt;
&lt;li&gt;中序遍历；&lt;/li&gt;
&lt;li&gt;后序遍历；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有层序遍历，使用较少。&lt;/p&gt;
&lt;h3 id=&#34;421先序遍历&#34;&gt;4.2.1.先序遍历&lt;/h3&gt;
&lt;p&gt;先序遍历的过程为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，遍历根节点；&lt;/li&gt;
&lt;li&gt;然后，遍历其左子树；&lt;/li&gt;
&lt;li&gt;最后，遍历其右子树；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1614432186175.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如上图所示，二叉树的节点遍历顺序为：A -&amp;gt; B -&amp;gt; D -&amp;gt; H -&amp;gt; I -&amp;gt; E -&amp;gt; C -&amp;gt; F -&amp;gt; G。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	  //先序遍历
      //掺入一个handler函数方便之后对得到的key进行处理
      BinarySearchTree.prototype.preOrderTraversal = function(handler){
        this.preOrderTraversalNode(this.root, handler)
      }

      //封装内部方法，对某个节点进行遍历
      BinarySearchTree.prototype.preOrderTraversalNode = function(node,handler){
        if (node != null) {
          //1.处理经过的节点
          handler(node.key)
/*----------------------递归1----------------------------*/
          //2.遍历左子树中的节点
          this.preOrderTraversalNode(node.left, handler)
/*----------------------递归2----------------------------*/
          //3.遍历右子树中的节点
          this.preOrderTraversalNode(node.right, handler)
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
以遍历以下二叉搜索树为例：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614432234410.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先调用preOrderTraversal方法，在方法里再调用preOrderTraversalNode方法用于遍历二叉搜索树。在preOrderTraversalNode方法中，递归1负责遍历左子节点，递归2负责遍历右子节点。先执行递归1，执行过程如下图所示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;记：preOrderTraversalNode() 为 A()&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614432256706.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看到一共递归调用了4次方法A，分别传入11、7、5、3，最后遇到null不满足 node != null 条件结束递归1；注意此时只是执行完最开始的递归1，并没有执行递归2，并且递归1执行到null停止后要一层层地往上返回，按顺序将调用的函数压出函数调用栈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于函数调用栈：之前的四次递归共把4个函数压入了函数调用栈，现在递归执行完了一层层地把函数压出栈。&lt;/p&gt;
&lt;p&gt;值得注意的是：每一层函数都只是执行完了递归1，当返回到该层函数时，比如A（3）要继续执行递归2遍历二叉搜索树中的右子节点；&lt;/p&gt;
&lt;p&gt;在执行递归2的过程中会不断调用方法A，并依次执行递归1和递归2，以此类推直到遇到null不满足 node != null 条件为止，才停止递归并一层层返回，如此循环。同理A（5）层、A（7）层、A（11）层都要经历上述循环，直到将二叉搜索树中的节点全部遍历完为止。&lt;/p&gt;
&lt;p&gt;具体过程如下图所示：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614432285791.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试代码
    //1.创建BinarySearchTree
    let bst = new BinarySearchTree()

    //2.插入数据
    bst.insert(11);
    bst.insert(7);
    bst.insert(15);
    bst.insert(5);
    bst.insert(3);
    bst.insert(9);
    bst.insert(8);
    bst.insert(10);
    bst.insert(13);
    bst.insert(12);
    bst.insert(14);
    bst.insert(20);
    bst.insert(18);
    bst.insert(25);
    bst.insert(6);
    
    //3.测试遍历
    let resultString = &amp;quot;&amp;quot;
    //掺入处理节点值的处理函数
    bst.preOrderTraversal(function(key){
      resultString += key + &amp;quot;-&amp;gt;&amp;quot;
    })
    alert(resultString)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应输出这样的顺序：11 -&amp;gt; 7 -&amp;gt; 5 -&amp;gt; 3 -&amp;gt; 6 -&amp;gt; 9 -&amp;gt; 8 -&amp;gt; 10 -&amp;gt; 15 -&amp;gt; 13 -&amp;gt;12 -&amp;gt; 14 -&amp;gt; 20 -&amp;gt; 18 -&amp;gt; 25 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614432317782.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;422中序遍历&#34;&gt;4.2.2.中序遍历&lt;/h3&gt;
&lt;p&gt;实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，遍历其左子树；&lt;/li&gt;
&lt;li&gt;然后，遍历根（父）节点；&lt;/li&gt;
&lt;li&gt;最后，遍历其右子树；&lt;br&gt;
&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    //中序遍历
      BinarySearchTree.prototype.midOrderTraversal = function(handler){
        this.midOrderTraversalNode(this.root, handler)
      }

      BinarySearchTree.prototype.midOrderTraversalNode = function(node, handler){
        if (node != null) {
          //1.遍历左子树中的节点
          this.midOrderTraversalNode(node.left, handler)
          
          //2.处理节点
          handler(node.key)

          //3.遍历右子树中的节点
          this.midOrderTraversalNode(node.right, handler)
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
遍历的顺序应如下图所示：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614432386478.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先调用midOrderTraversal方法，在方法里再调用midOrderTraversalNode方法用于遍历二叉搜索树。先使用递归1遍历左子树中的节点；然后，处理父节点；最后，遍历右子树中的节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     //测试代码
    //1.创建BinarySearchTree
    let bst = new BinarySearchTree()

    //2.插入数据
    bst.insert(11);
    bst.insert(7);
    bst.insert(15);
    bst.insert(5);
    bst.insert(3);
    bst.insert(9);
    bst.insert(8);
    bst.insert(10);
    bst.insert(13);
    bst.insert(12);
    bst.insert(14);
    bst.insert(20);
    bst.insert(18);
    bst.insert(25);
    bst.insert(6);	
    
    //3.测试中序遍历
    let resultString2 =&amp;quot;&amp;quot;
    bst.midOrderTraversal(function(key){
      resultString2 += key + &amp;quot;-&amp;gt;&amp;quot;
    })
    alert(resultString2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出节点的顺序应为：3 -&amp;gt; 5 -&amp;gt; 6 -&amp;gt; 7 -&amp;gt; 8 -&amp;gt; 9 -&amp;gt; 10 -&amp;gt; 11 -&amp;gt; 12 -&amp;gt; 13 -&amp;gt; 14 -&amp;gt; 15 -&amp;gt; 18 -&amp;gt; 25-&amp;gt; 20 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614432578638.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;423后续遍历&#34;&gt;4.2.3.后续遍历&lt;/h3&gt;
&lt;p&gt;实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，遍历其左子树；&lt;/li&gt;
&lt;li&gt;然后，遍历其右子树；&lt;/li&gt;
&lt;li&gt;最后，遍历根（父）节点；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //后序遍历
      BinarySearchTree.prototype.postOrderTraversal = function(handler){
        this.postOrderTraversalNode(this.root, handler)
      }

      BinarySearchTree.prototype.postOrderTraversalNode = function(node, handler){
        if (node != null) {
          //1.遍历左子树中的节点
          this.postOrderTraversalNode(node.left, handler)
          
          //2.遍历右子树中的节点
          this.postOrderTraversalNode(node.right, handler)

          //3.处理节点
          handler(node.key)
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
遍历的顺序应如下图所示：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614432643528.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先调用postOrderTraversal方法，在方法里再调用postOrderTraversalNode方法用于遍历二叉搜索树。先使用递归1遍历左子树中的节点；然后，遍历右子树中的节点；最后，处理父节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试代码
    //1.创建BinarySearchTree
    let bst = new BinarySearchTree()

    //2.插入数据
    bst.insert(11);
    bst.insert(7);
    bst.insert(15);
    bst.insert(5);
    bst.insert(3);
    bst.insert(9);
    bst.insert(8);
    bst.insert(10);
    bst.insert(13);
    bst.insert(12);
    bst.insert(14);
    bst.insert(20);
    bst.insert(18);
    bst.insert(25);
    bst.insert(6);
    
    //3.测试后序遍历
    let resultString3 =&amp;quot;&amp;quot;
    bst.postOrderTraversal(function(key){
      resultString3 += key + &amp;quot;-&amp;gt;&amp;quot;
    })
    alert(resultString3)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出节点的顺序应为：3 -&amp;gt; 6 -&amp;gt; 5 -&amp;gt; 8 -&amp;gt; 10 -&amp;gt; 9 -&amp;gt; 7 -&amp;gt; 12 -&amp;gt; 14 -&amp;gt; 13 -&amp;gt; 18 -&amp;gt; 25 -&amp;gt; 20 -&amp;gt; 15 -&amp;gt; 11 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614432682849.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：以遍历根（父）节点的顺序来区分三种遍历方式。比如：先序遍历先遍历根节点、中序遍历第二遍历根节点、后续遍历最后遍历根节点。&lt;/p&gt;
&lt;h2 id=&#34;43查找数据&#34;&gt;4.3.查找数据&lt;/h2&gt;
&lt;h3 id=&#34;431查找最大值最小值&#34;&gt;4.3.1.查找最大值&amp;amp;最小值&lt;/h3&gt;
&lt;p&gt;在二叉搜索树中查找最值非常简单，最小值在二叉搜索树的最左边，最大值在二叉搜索树的最右边。只需要一直向左/右查找就能得到最值，如下图所示：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614432719664.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //寻找最大值
      BinarySearchTree.prototype.max = function () {
        //1.获取根节点
        let node = this.root
        //2.定义key保存节点值
        let key = null
        //3.依次向右不断查找，直到节点为null
        while (node != null) {
          key = node.key
          node = node.right
        }
        return key
      }

      //寻找最小值
      BinarySearchTree.prototype.min = function(){
         //1.获取根节点
         let node = this.root
        //2.定义key保存节点值
        let key = null
        //3.依次向左不断查找，直到节点为null
        while (node != null) {
          key = node.key
          node = node.left
        }
        return key
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试代码
    //1.创建BinarySearchTree
    let bst = new BinarySearchTree()

    //2.插入数据
    bst.insert(11);
    bst.insert(7);
    bst.insert(15);
    bst.insert(5);
    bst.insert(3);
    bst.insert(9);
    bst.insert(8);
    bst.insert(10);
    bst.insert(13);
    bst.insert(12);
    bst.insert(14);
    bst.insert(20);
    bst.insert(18);
    bst.insert(25);
    bst.insert(6);
    
    //4.测试最值
    console.log(bst.max());
    console.log(bst.min());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614432766498.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;432查找特定值&#34;&gt;4.3.2.查找特定值&lt;/h3&gt;
&lt;p&gt;查找二叉搜索树当中的特定值效率也非常高。只需要从根节点开始将需要查找节点的key值与之比较，若&lt;strong&gt;node.key &amp;lt; root&lt;/strong&gt;则向左查找，若&lt;strong&gt;node.key &amp;gt; root&lt;/strong&gt;就向右查找，直到找到或查找到null为止。这里可以使用递归实现，也可以采用循环来实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //查找特定的key
      BinarySearchTree.prototype.search = function(key){
        //1.获取根节点
        let node = this.root

        //2.循环搜索key
        while(node != null){
          if (key &amp;lt; node.key) {
            //小于根(父)节点就往左边找
            node = node.left
            //大于根(父)节点就往右边找
          }else if(key &amp;gt; node.key){
            node = node.right
          }else{
            return true
          }
        } 
        return false
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试代码
    //1.创建BinarySearchTree
    let bst = new BinarySearchTree()

    //2.插入数据
    bst.insert(11);
    bst.insert(7);
    bst.insert(15);
    bst.insert(5);
    bst.insert(3);
    bst.insert(9);
    bst.insert(8);
    bst.insert(10);
    bst.insert(13);
    bst.insert(12);
    bst.insert(14);
    bst.insert(20);
    bst.insert(18);
    bst.insert(25);
    bst.insert(6);
    
    //3.测试搜索方法
    console.log(bst.search(24));//false
    console.log(bst.search(13));//true
    console.log(bst.search(2));//false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614432854806.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;44删除数据&#34;&gt;4.4.删除数据&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;第一步&lt;/strong&gt;：先找到需要删除的节点，若没找到，则不需要删除；&lt;/p&gt;
&lt;p&gt;首先定义变量current用于保存需要删除的节点、变量parent用于保存它的父节点、变量isLeftChild保存current是否为parent的左节点，这样方便之后删除节点时改变相关节点的指向。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现代码&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	    //1.1.定义变量
        let current = this.root
        let parent = null
        let isLeftChild = true

        //1.2.开始寻找删除的节点
        while (current.key != key) {
          parent = current
          // 小于则往左查找
          if (key &amp;lt; current.key) {
            isLeftChild = true
            current = current.left
          } else{
            isLeftChild = false
            current = current.rigth
          }
          //找到最后依然没有找到相等的节点
          if (current == null) {
            return false
          }
        }
        //结束while循环后：current.key = key
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第二步&lt;/strong&gt;：删除找到的指定节点，后分3种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除叶子节点；&lt;/li&gt;
&lt;li&gt;删除只有一个子节点的节点；&lt;/li&gt;
&lt;li&gt;删除有两个子节点的节点；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;441情况1没有子节点&#34;&gt;4.4.1.情况1：没有子节点&lt;/h3&gt;
&lt;p&gt;没有子节点时也有两种情况：&lt;/p&gt;
&lt;p&gt;当该叶子节点为根节点时，如下图所示，此时&lt;strong&gt;current == this.root&lt;/strong&gt;，直接通过：&lt;strong&gt;this.root = null&lt;/strong&gt;，删除根节点。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614432946911.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当该叶子节点不为根节点时也有两种情况，如下图所示：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614432958464.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
若current = 8，可以通过：parent.left = null，删除节点8；&lt;/p&gt;
&lt;p&gt;若current = 10，可以通过：parent.right = null，删除节点10；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     //情况1：删除的是叶子节点(没有子节点)
        if (current.left == null &amp;amp;&amp;amp; current.right ==null) {
          if (current == this.root) {
            this.root = null
          }else if(isLeftChild){
            parent.left = null
          }else {
            parent.right =null
          }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;442情况2有一个子节点&#34;&gt;4.4.2.情况2：有一个子节点&lt;/h3&gt;
&lt;p&gt;有六种情况分别是：&lt;/p&gt;
&lt;p&gt;当current存在左子节点时（current.right == null）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：current为根节点（current == this.root），如节点11，此时通过：this.root = current.left，删除根节点11；&lt;/li&gt;
&lt;li&gt;情况2：current为父节点parent的左子节点（isLeftChild == true），如节点5，此时通过：parent.left = current.left，删除节点5；&lt;/li&gt;
&lt;li&gt;情况3：current为父节点parent的右子节点（isLeftChild == false），如节点9，此时通过：parent.right = current.left，删除节点9；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1614433008524.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当current存在右子节点时（current.left = null）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况4：current为根节点（current == this.root），如节点11，此时通过：this.root = current.right，删除根节点11。&lt;/li&gt;
&lt;li&gt;情况5：current为父节点parent的左子节点（isLeftChild == true），如节点5，此时通过：parent.left = current.right，删除节点5；&lt;/li&gt;
&lt;li&gt;情况6：current为父节点parent的右子节点（isLeftChild == false），如节点9，此时通过：parent.right = current.right，删除节点9；&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1614433035143.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;实现代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        //情况2：删除的节点有一个子节点
        //当current存在左子节点时
        else if(current.right == null){
            if (current == this.root) {
              this.root = current.left
            } else if(isLeftChild) {
                parent.left = current.left
            } else{
                parent.right = current.left
            }
        //当current存在右子节点时
      } else if(current.left == null){
            if (current == this.root) {
              this.root = current.rigth
            } else if(isLeftChild) {
                parent.left = current.right
            } else{
                parent.right = current.right
            } 
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;443情况3有两个子节点&#34;&gt;4.4.3.情况3：有两个子节点&lt;/h3&gt;
&lt;p&gt;这种情况&lt;strong&gt;十分复杂&lt;/strong&gt;，首先依据以下二叉搜索树，讨论这样的问题：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614433090866.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;删除节点9&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在保证删除节点9后原二叉树仍为二叉搜索树的前提下，有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方式1：从节点9的左子树中选择一合适的节点替代节点9，可知节点8符合要求；&lt;/li&gt;
&lt;li&gt;方式2：从节点9的右子树中选择一合适的节点替代节点9，可知节点10符合要求；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614433110249.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;删除节点7&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在保证删除节点7后原二叉树仍为二叉搜索树的前提下，也有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方式1：从节点7的左子树中选择一合适的节点替代节点7，可知节点5符合要求；&lt;/li&gt;
&lt;li&gt;方式2：从节点7的右子树中选择一合适的节点替代节点7，可知节点8符合要求；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614433138554.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;删除节点15&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在保证删除节点15后原树二叉树仍为二叉搜索树的前提下，同样有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方式1：从节点15的左子树中选择一合适的节点替代节点15，可知节点14符合要求；&lt;/li&gt;
&lt;li&gt;方式2：从节点15的右子树中选择一合适的节点替代节点15，可知节点18符合要求；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614433162474.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相信你已经发现其中的规律了！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规律总结&lt;/strong&gt;：如果要删除的节点有两个子节点，甚至子节点还有子节点，这种情况下需要从要删除节点&lt;strong&gt;下面的子节点中找到一个合适的节点&lt;/strong&gt;，来替换当前的节点。&lt;/p&gt;
&lt;p&gt;若用current表示需要删除的节点，则合适的节点指的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;current左子树中比current&lt;strong&gt;小一点点的节点&lt;/strong&gt;，即current&lt;strong&gt;左子树&lt;/strong&gt;中的&lt;strong&gt;最大值&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;current右子树中比current&lt;strong&gt;大一点点的节点&lt;/strong&gt;，即current&lt;strong&gt;右子树&lt;/strong&gt;中的&lt;strong&gt;最小值&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;前驱&amp;amp;后继&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在二叉搜索树中，这两个特殊的节点有特殊的名字：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比current小一点点的节点，称为current节点的&lt;strong&gt;前驱&lt;/strong&gt;。比如下图中的节点5就是节点7的前驱；&lt;/li&gt;
&lt;li&gt;比current大一点点的节点，称为current节点的&lt;strong&gt;后继&lt;/strong&gt;。比如下图中的节点8就是节点7的后继；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614433240999.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查找需要被删除的节点current的后继时，需要在current的&lt;strong&gt;右子树&lt;/strong&gt;中查找&lt;strong&gt;最小值&lt;/strong&gt;，即在current的&lt;strong&gt;右子树&lt;/strong&gt;中一直&lt;strong&gt;向左遍历&lt;/strong&gt;查找；&lt;/li&gt;
&lt;li&gt;查找前驱时，则需要在current的&lt;strong&gt;左子树&lt;/strong&gt;中查找&lt;strong&gt;最大值&lt;/strong&gt;，即在current的&lt;strong&gt;左子树&lt;/strong&gt;中一直&lt;strong&gt;向右遍历&lt;/strong&gt;查找。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面只讨论查找current后继的情况，查找前驱的原理相同，这里暂不讨论。&lt;/p&gt;
&lt;h3 id=&#34;444完整实现&#34;&gt;4.4.4.完整实现&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;    //删除节点
      BinarySearchTree.prototype.remove = function(key){
/*------------------------------1.寻找要删除的节点---------------------------------*/
        //1.1.定义变量current保存删除的节点，parent保存它的父节点。isLeftChild保存current是否为parent的左节点
        let current = this.root
        let parent = null
        let isLeftChild = true

        //1.2.开始寻找删除的节点
        while (current.key != key) {
          parent = current
          // 小于则往左查找
          if (key &amp;lt; current.key) {
            isLeftChild = true
            current = current.left
          } else{
            isLeftChild = false
            current = current.right
          }
          //找到最后依然没有找到相等的节点
          if (current == null) {
            return false
          }
        }
        //结束while循环后：current.key = key

/*------------------------------2.根据对应情况删除节点------------------------------*/
        //情况1：删除的是叶子节点(没有子节点)
        if (current.left == null &amp;amp;&amp;amp; current.right ==null) {
          if (current == this.root) {
            this.root = null
          }else if(isLeftChild){
            parent.left = null
          }else {
            parent.right =null
          }
        }
        //情况2：删除的节点有一个子节点
        //当current存在左子节点时
        else if(current.right == null){
            if (current == this.root) {
              this.root = current.left
            } else if(isLeftChild) {
                parent.left = current.left
            } else{
                parent.right = current.left
            }
        //当current存在右子节点时
      } else if(current.left == null){
            if (current == this.root) {
              this.root = current.right
            } else if(isLeftChild) {
                parent.left = current.right
            } else{
                parent.right = current.right
            } 
      }
        //情况3：删除的节点有两个子节点
        else{
          //1.获取后继节点
          let successor = this.getSuccessor(current)

          //2.判断是否根节点
          if (current == this.root) {
            this.root = successor
          }else if (isLeftChild){
            parent.left = successor
          }else{
            parent.right = successor
          }

          //3.将后继的左子节点改为被删除节点的左子节点
          successor.left = current.left
        }
      }

      //封装查找后继的方法
      BinarySearchTree.prototype.getSuccessor = function(delNode){
        //1.定义变量,保存找到的后继
        let successor = delNode
        let current = delNode.right
        let successorParent = delNode

        //2.循环查找current的右子树节点
        while(current != null){
          successorParent = successor
          successor = current
          current = current.left
        }

        //3.判断寻找到的后继节点是否直接就是删除节点的right节点
        if(successor != delNode.right){
          successorParent.left = successor.right
          successor.right = delNode.right 
        }
        return successor
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试代码
    //1.创建BinarySearchTree
    let bst = new BinarySearchTree()

    //2.插入数据
    bst.insert(11);
    bst.insert(7);
    bst.insert(15);
    bst.insert(5);
    bst.insert(3);
    bst.insert(9);
    bst.insert(8);
    bst.insert(10);
    bst.insert(13);
    bst.insert(12);
    bst.insert(14);
    bst.insert(20);
    bst.insert(18);
    bst.insert(25);
    bst.insert(6);
    bst.insert(19);
    
   //3.测试删除代码
    //删除没有子节点的节点
    bst.remove(3)
    bst.remove(8)
    bst.remove(10)

    //删除有一个子节点的节点
    bst.remove(5)
    bst.remove(19)

    //删除有两个子节点的节点
    bst.remove(9)
    bst.remove(7)
    bst.remove(15)

    //遍历二叉搜索树并输出
    let resultString = &amp;quot;&amp;quot;
    bst.midOrderTraversal(function(key){
      resultString += key + &amp;quot;-&amp;gt;&amp;quot;
    })
    alert(resultString)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614433417414.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可见三种情况的节点都被成功删除了。&lt;/p&gt;
&lt;h2 id=&#34;45二叉搜索树完整封装&#34;&gt;4.5.二叉搜索树完整封装&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;    //封装二叉搜索树
    function BinarySearchTree(){

      //节点内部类
      function Node(key){
        this.key = key
        this.left = null
        this.right = null
      }

      //属性
      this.root = null

      //方法
      //一.插入数据：insert方法:对外向用户暴露的方法
      BinarySearchTree.prototype.insert = function(key){
        //1.根据key创建节点
        let newNode = new Node(key)
          
        //2.判断根节点是否存在
        if (this.root == null) {
          this.root = newNode
          //根节点存在时
        }else {
          this.insertNode(this.root, newNode)
        }
      }

      //内部使用的insertNode方法:用于比较节点从左边插入还是右边插入
      BinarySearchTree.prototype.insertNode = function(node, newNode){
        //当newNode.key &amp;lt; node.key向左查找
        if(newNode.key &amp;lt; node.key){
          //情况1：node无左子节点，直接插入
          if (node.left == null) {
            node.left = newNode
          //情况2：node有左子节点，递归调用insertNode(),直到遇到无左子节点成功插入newNode后，不再符合该情况，也就不再调用insertNode()，递归停止。
          }else{
            this.insertNode(node.left, newNode)
          }
        //当newNode.key &amp;gt;= node.key向右查找
        }else{
          //情况1：node无右子节点，直接插入
          if(node.right == null){
            node.right = newNode
          //情况2：node有右子节点，依然递归调用insertNode(),直到遇到无右子节点成功插入newNode为止
          }else{
            this.insertNode(node.right, newNode)
          }
        }
      }

      //二.树的遍历
      //1.先序遍历
      //掺入一个handler函数对得到的key进行处理
      BinarySearchTree.prototype.preOrderTraversal = function(handler){
        this.preOrderTraversalNode(this.root, handler)
      }

      //封装内部方法，对某个节点进行遍历
      BinarySearchTree.prototype.preOrderTraversalNode = function(node,handler){
        if (node != null) {
          //1.处理经过的节点
          handler(node.key)

          //2.遍历经过节点的左子节点
          this.preOrderTraversalNode(node.left, handler)

          //3.遍历经过节点的右子节点
          this.preOrderTraversalNode(node.right, handler)
        }
      }

      //2.中序遍历
      BinarySearchTree.prototype.midOrderTraversal = function(handler){
        this.midOrderTraversalNode(this.root, handler)
      }

      BinarySearchTree.prototype.midOrderTraversalNode = function(node, handler){
        if (node != null) {
          //1.遍历左子树中的节点
          this.midOrderTraversalNode(node.left, handler)
          
          //2.处理节点
          handler(node.key)

          //3.遍历右子树中的节点
          this.midOrderTraversalNode(node.right, handler)
        }
      }

      //3.后序遍历
      BinarySearchTree.prototype.postOrderTraversal = function(handler){
        this.postOrderTraversalNode(this.root, handler)
      }

      BinarySearchTree.prototype.postOrderTraversalNode = function(node, handler){
        if (node != null) {
          //1.遍历左子树中的节点
          this.postOrderTraversalNode(node.left, handler)
          
          //2.遍历右子树中的节点
          this.postOrderTraversalNode(node.right, handler)

          //3.处理节点
          handler(node.key)
        }
      }

      //三.寻找最值
      //寻找最大值
      BinarySearchTree.prototype.max = function () {
        //1.获取根节点
        let node = this.root
        //2.定义key保存节点值
        let key = null
        //3.依次向右不断查找，直到节点为null
        while (node != null) {
          key = node.key
          node = node.right
        }
        return key
      }

      //寻找最小值
      BinarySearchTree.prototype.min = function(){
         //1.获取根节点
         let node = this.root
        //2.定义key保存节点值
        let key = null
        //3.依次向左不断查找，直到节点为null
        while (node != null) {
          key = node.key
          node = node.left
        }
        return key
      }

      //查找特定的key
      BinarySearchTree.prototype.search = function(key){
        //1.获取根节点
        let node = this.root

        //2.循环搜索key
        while(node != null){
          if (key &amp;lt; node.key) {
            //小于根(父)节点就往左边找
            node = node.left
            //大于根(父)节点就往右边找
          }else if(key &amp;gt; node.key){
            node = node.right
          }else{
            return true
          }
        } 
        return false
      }

      //四.删除节点
      BinarySearchTree.prototype.remove = function(key){
/*------------------------------1.寻找要删除的节点---------------------------------*/
        //1.1.定义变量current保存删除的节点，parent保存它的父节点。isLeftChild保存current是否为parent的左节点
        let current = this.root
        let parent = null
        let isLeftChild = true

        //1.2.开始寻找删除的节点
        while (current.key != key) {
          parent = current
          // 小于则往左查找
          if (key &amp;lt; current.key) {
            isLeftChild = true
            current = current.left
          } else{
            isLeftChild = false
            current = current.right
          }
          //找到最后依然没有找到相等的节点
          if (current == null) {
            return false
          }
        }
        //结束while循环后：current.key = key

/*------------------------------2.根据对应情况删除节点------------------------------*/
        //情况1：删除的是叶子节点(没有子节点)
        if (current.left == null &amp;amp;&amp;amp; current.right ==null) {
          if (current == this.root) {
            this.root = null
          }else if(isLeftChild){
            parent.left = null
          }else {
            parent.right =null
          }
        }
        //情况2：删除的节点有一个子节点
        //当current存在左子节点时
        else if(current.right == null){
            if (current == this.root) {
              this.root = current.left
            } else if(isLeftChild) {
                parent.left = current.left
            } else{
                parent.right = current.left
            }
        //当current存在右子节点时
      } else if(current.left == null){
            if (current == this.root) {
              this.root = current.right
            } else if(isLeftChild) {
                parent.left = current.right
            } else{
                parent.right = current.right
            } 
      }
        //情况3：删除的节点有两个子节点
        else{
          //1.获取后继节点
          let successor = this.getSuccessor(current)

          //2.判断是否根节点
          if (current == this.root) {
            this.root = successor
          }else if (isLeftChild){
            parent.left = successor
          }else{
            parent.right = successor
          }

          //3.将后继的左子节点改为被删除节点的左子节点
          successor.left = current.left
        }
      }

      //封装查找后继的方法
      BinarySearchTree.prototype.getSuccessor = function(delNode){
        //1.定义变量,保存找到的后继
        let successor = delNode
        let current = delNode.right
        let successorParent = delNode

        //2.循环查找current的右子树节点
        while(current != null){
          successorParent = successor
          successor = current
          current = current.left
        }

        //3.判断寻找到的后继节点是否直接就是删除节点的right节点
        if(successor != delNode.right){
          successorParent.left = successor.right
          successor.right = delNode.right 
        }
        return successor
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5平衡树&#34;&gt;5.平衡树&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;二叉搜索树的缺陷：&lt;/strong&gt;&lt;br&gt;
当插入的数据是有序的数据，就会造成二叉搜索树的深度过大。比如原二叉搜索树右 11 7 15 组成，如下图所示：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614433630544.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当插入一组有序数据：6 5 4 3 2就会变成深度过大的搜索二叉树，会严重影响二叉搜索树的性能。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614433639468.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非平衡树&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比较好的二叉搜索树，它的数据应该是&lt;strong&gt;左右均匀分布&lt;/strong&gt;的；&lt;/li&gt;
&lt;li&gt;但是插入&lt;strong&gt;连续数据&lt;/strong&gt;后，二叉搜索树中的数据分布就变得&lt;strong&gt;不均匀了&lt;/strong&gt;，我们称这种树为&lt;strong&gt;非平衡树&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;对于一棵&lt;strong&gt;平衡二叉树&lt;/strong&gt;来说，插入/查找等操作的效率是&lt;strong&gt;O（logN）&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;而对于一棵&lt;strong&gt;非平衡二叉树&lt;/strong&gt;来说，相当于编写了一个链表，查找效率变成了&lt;strong&gt;O（N）&lt;/strong&gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;树的平衡性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了能以&lt;strong&gt;较快的时间O（logN）&lt;strong&gt;来操作一棵树，我们需要&lt;/strong&gt;保证树总是平衡&lt;/strong&gt;的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;起码大部分是平衡的，此时的时间复杂度也是接近O（logN）的；&lt;/li&gt;
&lt;li&gt;这就要求树中&lt;strong&gt;每个节点左边的子孙节点&lt;/strong&gt;的个数，应该尽可能地等于&lt;strong&gt;右边的子孙节点&lt;/strong&gt;的个数；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;常见的平衡树&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;AVL树&lt;/strong&gt;：是最早的一种平衡树，它通过在每个节点多存储一个额外的数据来保持树的平衡。由于AVL树是平衡树，所以它的时间复杂度也是O（logN）。但是它的整体效率不如红黑树，开发中比较少用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;红黑树&lt;/strong&gt;：同样通过一些&lt;strong&gt;特性&lt;/strong&gt;来保持树的平衡，时间复杂度也是O（logN）。进行插入/删除等操作时，性能优于AVL树，所以平衡树的应用基本都是红黑树。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;6-字典树&#34;&gt;6. 字典树&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;字典树适合查找，后缀树适合存储&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-定义&#34;&gt;1. 定义&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;定义：Trie树，即字典树，又称单词查找树或键树。是一种用于快速检索的多叉树结构。
    Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。
优点：最大限度地减少无谓的字符串比较。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们给定字符串集合为{b abc abd bcd abcd efg hii}，那么这个字符串的字典树为：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619572990429.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;对于一颗字典树来说，应该具有以下性质：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619573241644.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
第二条性质中的到某个结点，就是指到红色结点。&lt;/p&gt;
&lt;h2 id=&#34;2-字典树的构建&#34;&gt;2. 字典树的构建&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1619573363448.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
现在给出了，许多的字符串，我们从第一个字符串CAI开始构建。首先构建根节点，其次构建出CAI三个结点&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619573381140.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
现在构建字符串CAO因为CA已经存在，所以遍历到A，发现O结点并不存在，生成O结点。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619573403573.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
以此类推，最后生成的字典树，如上图所示。这个构建过程，每一次都相当于遍历了一个字符串的长度。&lt;br&gt;
假如有n个字符串，那么它的&lt;code&gt;时间复杂度&lt;/code&gt;就是，&lt;code&gt;n乘上字符串的平均长度&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1619573434882.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
对于字典树，在空间上的花费为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;空间花费：平均单词长度*结点长度*单词数
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-字典树的查询&#34;&gt;3. 字典树的查询&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1619573574154.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先我们根据给出的单词，构建出了相应的字典树。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619573596240.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
现在，我们要对inn这个单词进行查询，当然是从根节点先开始。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619573882704.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
按照结点进行查询，最后可以找到inn这个字符串。那么它的时间复杂度就是这个字符串的长度O(len)。&lt;/p&gt;
&lt;h2 id=&#34;4-字典树的插入&#34;&gt;4. 字典树的插入&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1619573911453.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
现在我们要插入新的字符串atm，那应该怎么做呢？&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619573929269.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在走到t结点时，发现没有m结点，所以构造出m结点，并变为红色。&lt;/p&gt;
&lt;h2 id=&#34;5-字典树的删除&#34;&gt;5. 字典树的删除&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1619573951867.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
现在我们要删除字典树中的ant字符串，当然是从根节点开始去做一个查询。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619573969658.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
最后找到，结点t并且n结点也并没有其他分支，所以在删除时，会将n-&amp;gt;t全部删除。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1619573985600.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
最后结果如图所示，时间复杂度也为O(len)。&lt;/p&gt;
&lt;h2 id=&#34;6-字典树的应用&#34;&gt;6. 字典树的应用&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1619574013354.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;7-后缀树&#34;&gt;7. 后缀树&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;定义：后缀树是一棵压缩字典树，其次，后缀树中存储的关键词为所有的后缀。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1-后缀树的构建&#34;&gt;1. 后缀树的构建&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1619574786201.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;规则1：遇到叶子节点时只需往叶子所在的边上面的字符串后面插入字符就好了，不用改变树的结构；
规则2：遇到内部节点的时候，先看看插入的字符是否出现在显式节点后紧跟的字符
      集合中,如果插入的字符出现在集合中，那么什么也不要做（是指不用改变构），
      因为已经存在了；如果没有出现，在显式节点后面增加一个叶子，边上标注为这个字符。
规则3：遇到隐式节点时，先看看隐式节点后面的字符是不是当前将要插入的字符，
      如果有则不用管了，没有则需要将当前隐式节点变为显式节点，再增加新叶子。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-后缀树的作用&#34;&gt;2. 后缀树的作用&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1619575214408.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av86801505?from=search&amp;amp;seid=4967761411915016256&#34;&gt;参考资料：JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现树结构</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/javascript-shi-xian-ha-xi-biao/"" data-c="
          &lt;h1 id=&#34;1哈希表简介&#34;&gt;1.哈希表简介&lt;/h1&gt;
&lt;h2 id=&#34;11认识哈希表&#34;&gt;1.1.认识哈希表&lt;/h2&gt;
&lt;p&gt;哈希表通常是基于&lt;strong&gt;数组&lt;/strong&gt;实现的，但是相对于数组，它存在更多优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哈希表可以提供非常快速的&lt;strong&gt;插入-删除-查找操作&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;无论多少数据，插入和删除值都只需要非常短的时间，即O(1)的时间级。实际上，只需要&lt;strong&gt;几个机器指令&lt;/strong&gt;即可完成；&lt;/li&gt;
&lt;li&gt;哈希表的速度比&lt;strong&gt;树还要快&lt;/strong&gt;，基本可以瞬间查找到想要的元素。但是相对于树来说编码要简单得多。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;哈希表同样存在不足之处：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哈希表中的数据是&lt;strong&gt;没有顺序&lt;/strong&gt;的，所以不能以一种固定的方式（比如从小到大 ）来遍历其中的元素。&lt;/li&gt;
&lt;li&gt;通常情况下，哈希表中的key是&lt;strong&gt;不允许重复&lt;/strong&gt;的，不能放置相同的key，用于保存不同的元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;哈希表是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哈希表并不好理解，不像数组、链表和树等可通过图形的形式表示其结构和原理。&lt;/li&gt;
&lt;li&gt;哈希表的结构就是&lt;strong&gt;数组&lt;/strong&gt;，但它神奇之处在于对&lt;strong&gt;下标值的一种变换&lt;/strong&gt;，这种变换我们可以称之为&lt;strong&gt;哈希函数&lt;/strong&gt;，通过哈希函数可以获取&lt;strong&gt;HashCode&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;通过以下案例了解哈希表：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;案例一：公司想要存储1000个人的信息，每一个工号对应一个员工的信息。若使用数组，增删数据时比较麻烦；使用链表，获取数据时比较麻烦。有没有一种数据结构，能把某一员工的姓名转换为它对应的工号，再根据工号查找该员工的完整信息呢？没错此时就可以使用哈希表的哈希函数来实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;案例二：存储联系人和对应的电话号码：当要查找张三（比如）的号码时，若使用数组：由于不知道存储张三数据对象的下标值，所以查找起来十分麻烦，使用链表时也同样麻烦。而使用哈希表就能通过哈希函数把张三这个名称转换为它对应的下标值，再通过下标值查找效率就非常高了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是说：哈希表最后还是基于数据来实现的，只不过哈希表能够通过哈希函数把字符串转化为对应的&lt;strong&gt;下标值&lt;/strong&gt;，建立字符串和下标值的对应关系。&lt;/p&gt;
&lt;h2 id=&#34;12哈希化的方式&#34;&gt;1.2.哈希化的方式&lt;/h2&gt;
&lt;p&gt;为了把字符串转化为对应的下标值，需要有一套编码系统，为了方便理解我们创建这样一套编码系统：比如&lt;strong&gt;a为1，b为2，c为3，以此类推z为26，空格为27（不考虑大写情况）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;有了编码系统后，将字母转化为数字也有很多种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方式一：数字相加。例如&lt;strong&gt;cats转化为数字&lt;/strong&gt;：3+1+20+19=43，那么就把43作为cats单词的下标值储存在数组中；&lt;br&gt;
但是这种方式会存在这样的问题：很多的单词按照该方式转化为数字后都是43，比如was。而在数组中&lt;strong&gt;一个下标值&lt;/strong&gt;只能&lt;strong&gt;储存一个数据&lt;/strong&gt;，所以该方式不合理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方式二：幂的连乘。我们平时使用的&lt;strong&gt;大于10的数字&lt;/strong&gt;，就是用&lt;strong&gt;幂的连乘&lt;/strong&gt;来表示它的唯一性的。比如： 6543=6 * 103 + 5 * 102 + 4 * 10 + 3；这样单词也可以用该种方式来表示：cats = 3 * 273 + 1 * 272 + 20 * 27 + 17 =60337;&lt;br&gt;
虽然该方式可以保证字符的唯一性，但是如果是较长的字符（如aaaaaaaaaa）所表示的数字就非常大，此时要求很大容量的数组，然而其中却有许多下标值指向的是无效的数据（比如不存在zxcvvv这样的单词），造成了数组空间的浪费。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;两种方案总结：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一种方案（让数字相加求和）产生的&lt;strong&gt;数组下标太少；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;第二种方案（与27的幂相乘求和）产生的&lt;strong&gt;数组下标又太多；&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在需要一种&lt;strong&gt;压缩方法&lt;/strong&gt;，把幂的连乘方案系统中得到的&lt;strong&gt;巨大整数范围&lt;/strong&gt;压缩到&lt;strong&gt;可接受的数组范围&lt;/strong&gt;中。可以通过取余操作来实现。虽然取余操作得到的结构也有可能重复，但是可以通过其他方式解决。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;哈希表的一些概念：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;哈希化&lt;/strong&gt;：将&lt;strong&gt;大数字&lt;/strong&gt;转化成&lt;strong&gt;数组范围内下标&lt;/strong&gt;的过程，称之为&lt;strong&gt;哈希化&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;哈希函数&lt;/strong&gt;：我们通常会将&lt;strong&gt;单词&lt;/strong&gt;转化成&lt;strong&gt;大数字&lt;/strong&gt;，把&lt;strong&gt;大数字&lt;/strong&gt;进行&lt;strong&gt;哈希化&lt;/strong&gt;的代码实现放在一个函数中，该函数就称为&lt;strong&gt;哈希函数&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;哈希表&lt;/strong&gt;：对最终数据插入的&lt;strong&gt;数组&lt;/strong&gt;进行整个&lt;strong&gt;结构的封装&lt;/strong&gt;，得到的就是&lt;strong&gt;哈希表&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;仍然需要解决的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哈希化过后的下标依然可能&lt;strong&gt;重复&lt;/strong&gt;，如何解决这个问题呢？这种情况称为&lt;strong&gt;冲突&lt;/strong&gt;，冲突是&lt;strong&gt;不可避免&lt;/strong&gt;的，我们只能&lt;strong&gt;解决冲突&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;13解决冲突的方法&#34;&gt;1.3.解决冲突的方法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;解决冲突常见的两种方案：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方案一：&lt;strong&gt;链地址法（拉链法）&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下图所示，我们将每一个数字都对&lt;strong&gt;10&lt;/strong&gt;进行取余操作，则余数的范围&lt;strong&gt;0~9&lt;/strong&gt;作为数组的下标值。并且，数组每一个下标值对应的位置存储的不再是一个数字了，而是存储由经过取余操作后得到相同余数的数字组成的&lt;strong&gt;数组&lt;/strong&gt;或&lt;strong&gt;链表&lt;/strong&gt;。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614344975950.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这样可以根据下标值获取到整个数组或链表，之后继续在数组或链表中查找就可以了。而且，产生冲突的元素一般不会太多。&lt;br&gt;
&lt;strong&gt;总结&lt;/strong&gt;：链地址法解决冲突的办法是&lt;strong&gt;每个数组单元&lt;/strong&gt;中存储的不再是&lt;strong&gt;单个数据&lt;/strong&gt;，而是一条&lt;strong&gt;链条&lt;/strong&gt;，这条链条常使用的数据结构为&lt;strong&gt;数组&lt;/strong&gt;或&lt;strong&gt;链表&lt;/strong&gt;，两种数据结构查找的效率相当（因为链条的元素一般不会太多）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方案二：&lt;strong&gt;开放地址法&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开放地址法的主要工作方式是&lt;strong&gt;寻找空白的单元格&lt;/strong&gt;来放置&lt;strong&gt;冲突&lt;/strong&gt;的数据项。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614345198909.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
根据探测空白单元格位置方式的不同，可分为三种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线性探测&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;二次探测&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;再哈希法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;14寻找空白单元格的方式&#34;&gt;1.4.寻找空白单元格的方式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;线性探测&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;当插入13时&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;经过哈希化（对10取余）之后得到的下标值index=3，但是该位置已经放置了数据33。而线性探测就是从&lt;strong&gt;index位置+1&lt;/strong&gt;开始向后一个一个来查找&lt;strong&gt;合适的位置&lt;/strong&gt;来放置13，所谓合适的位置指的是&lt;strong&gt;空的位置&lt;/strong&gt;，如上图中index=4的位置就是合适的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;当查询13时：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先13经过哈希化得到index=3，如果index=3的位置存放的数据与需要查询的数据13相同，就直接返回；&lt;/li&gt;
&lt;li&gt;不相同时，则线性查找，从&lt;strong&gt;index+1&lt;/strong&gt;位置开始一个一个位置地查找数据13；&lt;/li&gt;
&lt;li&gt;查询过程中不会遍历整个哈希表，只要查询到&lt;strong&gt;空位置，就停止&lt;/strong&gt;，因为插入13时不会跳过空位置去插入其他位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;当删除13时&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除操作和上述两种情况类似，但需要注意的是，删除一个数据项时，&lt;strong&gt;不能&lt;/strong&gt;将该位置下标的&lt;strong&gt;内容设置为null&lt;/strong&gt;，否则会&lt;strong&gt;影响到之后其他的查询操作&lt;/strong&gt;，因为一遇到为null的位置就会停止查找。&lt;/li&gt;
&lt;li&gt;通常&lt;strong&gt;删除一个位置的数据项&lt;/strong&gt;时，我们可以&lt;strong&gt;将它进行特殊处理&lt;/strong&gt;（比如设置为-1），这样在查找时遇到-1就知道要&lt;strong&gt;继续查找&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;线性探测存在的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性探测存在一个比较严重的问题，就是&lt;strong&gt;聚集&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;如哈希表中还没插入任何元素时，插入23、24、25、26、27，这就意味着下标值为3、4、5、6、7的位置都放置了数据，这种&lt;strong&gt;一连串填充单元&lt;/strong&gt;就称为&lt;strong&gt;聚集&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;聚集会影响哈希表的&lt;strong&gt;性能&lt;/strong&gt;，无论是插入/查询/删除都会影响；&lt;/li&gt;
&lt;li&gt;比如插入13时就会发现，连续的单元3~7都不允许插入数据，并且在插入的过程中需要经历多次这种情况。二次探测法可以解决该问题。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614345460679.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;二次探测&lt;/code&gt;&lt;br&gt;
上文所说的&lt;strong&gt;线性探测存在的问题&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果之前的数据是&lt;strong&gt;连续插入&lt;/strong&gt;的，那么新插入的一个数据可能需要&lt;strong&gt;探测很长的距离&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;二次探测是在线性探测的基础上进行了&lt;strong&gt;优化&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;线性探测&lt;/strong&gt;：我们可以看成是&lt;strong&gt;步长为1&lt;/strong&gt;的探测，比如从下表值x开始，那么线性探测就是按照下标值：x+1、x+2、x+3等依次探测；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;二次探测&lt;/strong&gt;：对步长进行了优化，比如从下标值x开始探测：x+12、x+22、x+33 。这样&lt;strong&gt;一次性探测比较长的距离&lt;/strong&gt;，避免了数据聚集带来的影响。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;二次探测存在的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当插入数据分布性较大的一组数据时，比如：13-163-63-3-213，这种情况会造成&lt;strong&gt;步长不一的一种聚集&lt;/strong&gt;（虽然这种情况出现的概率较线性探测的聚集要小），同样会影响性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;再哈希化&lt;/code&gt;&lt;br&gt;
在开放地址法中寻找空白单元格的最好的解决方式为&lt;strong&gt;再哈希化&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二次探测的步长是固定的：1，4，9，16依次类推；&lt;/li&gt;
&lt;li&gt;现在需要一种方法：产生一种&lt;strong&gt;依赖关键字(数据)的探测序列&lt;/strong&gt;，而不是每个关键字探测步长都一样；&lt;/li&gt;
&lt;li&gt;这样，&lt;strong&gt;不同的关键字&lt;/strong&gt;即使映射到&lt;strong&gt;相同的数组下标&lt;/strong&gt;，也可以使用&lt;strong&gt;不同的探测序列&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;再哈希法的做法为：把关键字用&lt;strong&gt;另一个&lt;/strong&gt;哈希函数，&lt;strong&gt;再做一次哈希化&lt;/strong&gt;，用这次哈希化的&lt;strong&gt;结果作为该关键字的步长&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;第二次哈希化需要满足以下两点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和&lt;strong&gt;第一个哈希函数不同&lt;/strong&gt;，不然哈希化后的结果仍是原来位置；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不能输出为0&lt;/strong&gt;，否则每次探测都是原地踏步的死循环；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;优秀的哈希函数：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;stepSize = constant - （key % constant）&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;其中constant是&lt;strong&gt;质数&lt;/strong&gt;，且小于数组的容量；&lt;/li&gt;
&lt;li&gt;例如：stepSize = 5 - （key % 5），满足需求，并且结果不可能为0；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;哈希化的效率&lt;/strong&gt;&lt;br&gt;
哈希表中执行插入和搜索操作效率是非常高的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果没有&lt;strong&gt;发生冲突&lt;/strong&gt;，那么效率就会更高；&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;发生冲突&lt;/strong&gt;，存取时间就依赖后来的探测长度；&lt;/li&gt;
&lt;li&gt;平均探测长度以及平均存取时间，取决于装填因子，随着&lt;strong&gt;装填因子&lt;/strong&gt;变大，探测长度会越来越长。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;理解概念&lt;strong&gt;装填因子&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;装填因子表示当前哈希表中已经&lt;strong&gt;包含的数据项&lt;/strong&gt;和&lt;strong&gt;整个哈希表长度&lt;/strong&gt;的&lt;strong&gt;比值&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;装填因子 = 总数据项 / 哈希表长度&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开放地址法的装填因子&lt;/strong&gt;最大为1，因为只有空白的单元才能放入元素；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链地址法的装填因子&lt;/strong&gt;可以&lt;strong&gt;大于1&lt;/strong&gt;，因为只要愿意，拉链法可以无限延伸下去；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;15不同探测方式性能的比较&#34;&gt;1.5.不同探测方式性能的比较&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线性探测&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，随着装填因子的增大，平均探测长度呈指数形式增长，性能较差。实际情况中，最好的装填因子取决于存储效率和速度之间的平衡，随着装填因子变小，存储效率下降，而速度上升。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614347865771.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;二次探测和再哈希化的性能&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二次探测和再哈希法性能相当，它们的性能比线性探测略好。由下图可知，随着装填因子的变大，平均探测长度呈指数形式增长，需要探测的次数也呈指数形式增长，性能不高。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614347917941.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;链地址法的性能&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到随着装填因子的增加，平均探测长度呈线性增长，较为平缓。在开发中使用链地址法较多，比如Java中的HashMap中使用的就是&lt;strong&gt;链地址法&lt;/strong&gt;。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614347946852.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;16优秀的哈希函数&#34;&gt;1.6.优秀的哈希函数&lt;/h2&gt;
&lt;p&gt;哈希表的优势在于它的速度，所以哈希函数不能采用消耗性能较高的复杂算法。提高速度的一个方法是在哈希函数中&lt;strong&gt;尽量减少乘法和除法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;性能高的哈希函数应具备以下两个优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;快速的计算&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;均匀的分布&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;快速计算&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;霍纳法则&lt;/strong&gt;：在中国霍纳法则也叫做&lt;strong&gt;秦久韶算法&lt;/strong&gt;，具体算法为：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614352364784.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
求多项式的值时，首先计算最内层括号内一次多项式的值，然后由内向外逐层计算一次多项式的值。这种算法把求n次多项式f(x)的值就转化为求n个一次多项式的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;变换之前：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;乘法次数：n（n+1）/2次；&lt;/li&gt;
&lt;li&gt;加法次数：n次；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;变换之前：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;乘法次数：n次；&lt;/li&gt;
&lt;li&gt;加法次数：n次；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果使用大O表示时间复杂度的话，直接从变换前的&lt;strong&gt;O(N2)&lt;strong&gt;降到了&lt;/strong&gt;O(N)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;均匀分布&lt;/code&gt;&lt;br&gt;
为了保证数据在哈希表中&lt;strong&gt;均匀分布&lt;/strong&gt;，当我们需要&lt;strong&gt;使用常量的地方&lt;/strong&gt;，尽量使用&lt;strong&gt;质数&lt;/strong&gt;；比如：哈希表的长度、N次幂的底数等。&lt;/p&gt;
&lt;p&gt;Java中的HashMap采用的是链地址法，哈希化采用的是公式为：&lt;strong&gt;index = HashCode（key）&amp;amp;（Length-1）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即将数据化为二进制进行&lt;strong&gt;与&lt;/strong&gt;运算，而不是取余运算。这样计算机直接运算二进制数据，效率更高。但是JavaScript在进行叫大数据的&lt;strong&gt;与&lt;/strong&gt;运算时会出现问题，所以以下使用JavaScript实现哈希化时还是采用取余运算。&lt;/p&gt;
&lt;h1 id=&#34;2初步封装哈希表&#34;&gt;2.初步封装哈希表&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;哈希表的常见操作为&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;put（key，value）：插入或修改操作；&lt;/li&gt;
&lt;li&gt;get（key）：获取哈希表中特定位置的元素；&lt;/li&gt;
&lt;li&gt;remove（key）：删除哈希表中特定位置的元素；&lt;/li&gt;
&lt;li&gt;isEmpty（）：如果哈希表中不包含任何元素，返回trun，如果哈希表长度大于0则返回false；&lt;/li&gt;
&lt;li&gt;size（）：返回哈希表包含的元素个数；&lt;/li&gt;
&lt;li&gt;resize（value）：对哈希表进行扩容操作；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;21哈希函数的简单实现&#34;&gt;2.1.哈希函数的简单实现&lt;/h2&gt;
&lt;p&gt;首先使用霍纳法则计算hashCode的值，通过取余操作实现哈希化，此处先简单地指定数组的大小。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //设计哈希函数
    //1.将字符串转成比较大的数字：hashCede
    //2.将大的数字hasCode压缩到数组范围(大小)之内
    function hashFunc(str, size){
      //1.定义hashCode变量
      let hashCode = 0

      //2.霍纳法则，计算hashCode的值
      //cats -&amp;gt; Unicode编码
      for(let i = 0 ;i &amp;lt; str.length; i++){
        // str.charCodeAt(i)//获取某个字符对应的unicode编码
        hashCode = 37 * hashCode + str.charCodeAt(i)
      }

      //3.取余操作
      let index = hashCode % size
      return index
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     //测试哈希函数
    console.log(hashFunc(&#39;123&#39;, 7));
    console.log(hashFunc(&#39;NBA&#39;, 7));
    console.log(hashFunc(&#39;CBA&#39;, 7));
    console.log(hashFunc(&#39;CMF&#39;, 7));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614352556116.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;22创建哈希表&#34;&gt;2.2.创建哈希表&lt;/h2&gt;
&lt;p&gt;封装哈希表的数组结构模型：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614352568255.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先创建哈希表类HashTable，并添加必要的属性和上面实现的哈希函数，再进行其他方法的实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //封装哈希表类
    function HashTable() {
      //属性
      this.storage = []
      this.count = 0//计算已经存储的元素个数
      //装填因子：loadFactor &amp;gt; 0.75时需要扩容；loadFactor &amp;lt; 0.25时需要减少容量
      this.limit = 7//初始长度

      //方法
      //哈希函数
      HashTable.prototype.hashFunc = function(str, size){
      //1.定义hashCode变量
      let hashCode = 0

      //2.霍纳法则，计算hashCode的值
      //cats -&amp;gt; Unicode编码
      for(let i = 0 ;i &amp;lt; str.length; i++){
        // str.charCodeAt(i)//获取某个字符对应的unicode编码
        hashCode = 37 * hashCode + str.charCodeAt(i)
      }

      //3.取余操作
      let index = hashCode % size
      return index
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;23putkeyvalue&#34;&gt;2.3.put(key,value)&lt;/h2&gt;
&lt;p&gt;哈希表的插入和修改操作是同一个函数：因为，当使用者传入一个&amp;lt;key，value&amp;gt;时，如果原来不存在该key，那么就是插入操作，如果原来已经存在该key，那么就是修改操作。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614352604336.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，根据key获取索引值index，目的为将数据插入到storage的对应位置；&lt;/li&gt;
&lt;li&gt;然后，根据索引值取出bucket，如果bucket不存在，先创建bucket，随后放置在该索引值的位置；&lt;/li&gt;
&lt;li&gt;接着，判断新增还是修改原来的值。如果已经有值了，就修改该值；如果没有，就执行后续操作。&lt;/li&gt;
&lt;li&gt;最后，进行新增数据操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //插入&amp;amp;修改操作
    HashTable.prototype.put = function (key, value){
      //1.根据key获取对应的index
      let index = this.hashFunc(key, this.limit)

      //2.根据index取出对应的bucket
      let bucket = this.storage[index]

      //3.判断该bucket是否为null
      if (bucket == null) {
        bucket = []
        this.storage[index] = bucket
      }

      //4.判断是否是修改数据
      for (let i = 0; i &amp;lt; bucket.length; i++) {
        let tuple = bucket[i];
        if (tuple[0] == key) {
          tuple[1] = value
          return//不用返回值
        }
      }

      //5.进行添加操作
      bucket.push([key, value])
      this.count += 1
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   //测试哈希表
    //1.创建哈希表
    let ht = new HashTable()

    //2.插入数据
    ht.put(&#39;class1&#39;,&#39;Tom&#39;)
    ht.put(&#39;class2&#39;,&#39;Mary&#39;)
    ht.put(&#39;class3&#39;,&#39;Gogo&#39;)
    ht.put(&#39;class4&#39;,&#39;Tony&#39;)
    ht.put(&#39;class4&#39;, &#39;Vibi&#39;)
    console.log(ht);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614352672421.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;24getkey&#34;&gt;2.4.get(key)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，根据key通过哈希函数获取它在storage中对应的索引值index；&lt;/li&gt;
&lt;li&gt;然后，根据索引值获取对应的bucket；&lt;/li&gt;
&lt;li&gt;接着，判断获取到的bucket是否为null，如果为null，直接返回null；&lt;/li&gt;
&lt;li&gt;随后，线性遍历bucket中每一个key是否等于传入的key。如果等于，直接返回对应的value；&lt;/li&gt;
&lt;li&gt;最后，遍历完bucket后，仍然没有找到对应的key，直接return null即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    //获取操作
    HashTable.prototype.get = function(key){
      //1.根据key获取对应的index
      let index = this.hashFunc(key, this.limit)

      //2.根据index获取对应的bucket
      let bucket = this.storage[index]

      //3.判断bucket是否等于null
      if (bucket == null) {
        return null
      }

      //4.有bucket，那么就进行线性查找
      for (let i = 0; i &amp;lt; bucket.length; i++) {
        let tuple = bucket[i];
        if (tuple[0] == key) {//tuple[0]存储key，tuple[1]存储value
          return tuple[1]
        }
      }

      //5.依然没有找到，那么返回null
      return null
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试哈希表
    //1.创建哈希表
    let ht = new HashTable()
    
	//2.插入数据
    ht.put(&#39;class1&#39;,&#39;Tom&#39;)
    ht.put(&#39;class2&#39;,&#39;Mary&#39;)
    ht.put(&#39;class3&#39;,&#39;Gogo&#39;)
    ht.put(&#39;class4&#39;,&#39;Tony&#39;)
    
    //3.获取数据
    console.log(ht.get(&#39;class3&#39;));
    console.log(ht.get(&#39;class2&#39;));
    console.log(ht.get(&#39;class1&#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614352753473.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;25removekey&#34;&gt;2.5.remove(key)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，根据key通过哈希函数获取它在storage中对应的索引值index；&lt;/li&gt;
&lt;li&gt;然后，根据索引值获取对应的bucket；&lt;/li&gt;
&lt;li&gt;接着，判断获取到的bucket是否为null，如果为null，直接返回null；&lt;/li&gt;
&lt;li&gt;随后，线性查找bucket，寻找对应的数据，并且删除；&lt;/li&gt;
&lt;li&gt;最后，依然没有找到，返回null；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //删除操作
    HashTable.prototype.remove = function(key){
      //1.根据key获取对应的index
      let index = this.hashFunc(key, this.limit)

      //2.根据index获取对应的bucket
      let bucket = this.storage[index]

      //3.判断bucket是否为null
      if (bucket == null) {
        return null
      }

      //4.有bucket,那么就进行线性查找并删除
      for (let i = 0; i &amp;lt; bucket.length; i++) {
        let tuple = bucket[i]
        if (tuple[0] == key) {
          bucket.splice(i,1)
          this.count -= 1 
          return tuple[1]
        }
    }

      //5.依然没有找到，返回null
      return null
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   //测试哈希表
   //1.创建哈希表
   let ht = new HashTable()
   
   //2.插入数据
   ht.put(&#39;class1&#39;,&#39;Tom&#39;)
   ht.put(&#39;class2&#39;,&#39;Mary&#39;)
   ht.put(&#39;class3&#39;,&#39;Gogo&#39;)
   ht.put(&#39;class4&#39;,&#39;Tony&#39;)
   
   //3.删除数据
   console.log( ht.remove(&#39;class2&#39;));
   console.log(ht.get(&#39;class2&#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614352863082.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;26其他方法的实现&#34;&gt;2.6.其他方法的实现&lt;/h2&gt;
&lt;p&gt;其他方法包括：&lt;strong&gt;isEmpty()、size()&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  //判断哈希表是否为null
  HashTable.prototype.isEmpty = function(){
    return this.count == 0
  }

  //获取哈希表中元素的个数
  HashTable.prototype.size = function(){
    return this.count
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  //测试哈希表
  //1.创建哈希表
  let ht = new HashTable()

  //2.插入数据
  ht.put(&#39;class1&#39;,&#39;Tom&#39;)
  ht.put(&#39;class2&#39;,&#39;Mary&#39;)
  ht.put(&#39;class3&#39;,&#39;Gogo&#39;)
  ht.put(&#39;class4&#39;,&#39;Tony&#39;)
  
  //3.测试isEmpty()
  console.log(ht.isEmpty());
  //4.测试isEmpty()
  console.log(ht.size());
  console.log(ht);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614352923431.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3哈希表的扩容&#34;&gt;3.哈希表的扩容&lt;/h1&gt;
&lt;h2 id=&#34;31扩容与压缩&#34;&gt;3.1.扩容与压缩&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;为什么需要扩容？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前面我们在哈希表中使用的是&lt;strong&gt;长度为7的数组&lt;/strong&gt;，由于使用的是&lt;strong&gt;链地址法&lt;/strong&gt;，**装填因子(loadFactor)**可以大于1，所以这个哈希表可以无限制地插入新数据。&lt;/li&gt;
&lt;li&gt;但是，随着&lt;strong&gt;数据量的增多&lt;/strong&gt;，storage中每一个index对应的bucket数组（链表）就会越来越长，这就会造成哈希表&lt;strong&gt;效率的降低&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;什么情况下需要扩容？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常见的情况是&lt;strong&gt;loadFactor &amp;gt; 0.75&lt;/strong&gt;的时候进行扩容；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;如何进行扩容？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单的扩容可以直接扩大&lt;strong&gt;两倍&lt;/strong&gt;（关于质数，之后讨论）；&lt;/li&gt;
&lt;li&gt;扩容之后&lt;strong&gt;所有的&lt;/strong&gt;数据项都要进行&lt;strong&gt;同步修改&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现思路:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，定义一个变量，比如oldStorage指向原来的storage；&lt;/li&gt;
&lt;li&gt;然后，创建一个新的容量更大的数组，让this.storage指向它；&lt;/li&gt;
&lt;li&gt;最后，将oldStorage中的每一个bucket中的每一个数据取出来依次添加到this.storage指向的新数组中；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1614353051852.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //哈希表扩容
  HashTable.prototype.resize = function(newLimit){
    //1.保存旧的storage数组内容
    let oldStorage = this.storage

    //2.重置所有的属性
    this.storage = []
    this.count = 0
    this.limit = newLimit

    //3.遍历oldStorage中所有的bucket
    for (let i = 0; i &amp;lt; oldStorage.length; i++) {
      //3.1.取出对应的bucket
      const bucket = oldStorage[i];

      //3.2.判断bucket是否为null
      if (bucket == null) {
        continue
      }      

      //3.3.bucket中有数据，就取出数据重新插入
      for (let j = 0; j &amp;lt; bucket.length; j++) {
        const tuple = bucket[j];
        this.put(tuple[0], tuple[1])//插入数据的key和value
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述定义的哈希表的resize方法，既可以实现哈希表的&lt;strong&gt;扩容&lt;/strong&gt;，也可以实现哈希表容量的&lt;strong&gt;压缩&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;装填因子 = 哈希表中数据 / 哈希表长度，即 loadFactor = count / HashTable.length。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;通常情况下当&lt;strong&gt;装填因子laodFactor &amp;gt; 0.75&lt;/strong&gt;时，对哈希表进行扩容。在哈希表中的添加方法（push方法）中添加如下代码，判断是否需要调用扩容函数进行扩容：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;     //判断是否需要扩容操作
      if(this.count &amp;gt; this.limit * 0.75){
        this.resize(this.limit * 2)
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;当装填因子&lt;strong&gt;laodFactor &amp;lt; 0.25&lt;/strong&gt;时，对哈希表容量进行压缩。在哈希表中的删除方法（remove方法）中添加如下代码，判断是否需要调用扩容函数进行压缩：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    //缩小容量
    if (this.limit &amp;gt; 7 &amp;amp;&amp;amp; this.count &amp;lt; this.limit * 0.25) {
      this.resize(Math.floor(this.limit / 2))
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;32选择质数作为容量&#34;&gt;3.2.选择质数作为容量&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;质数的判断&lt;/strong&gt;&lt;br&gt;
首先我们来复习一下，判断质数的方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意1不是质数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;方法一：针对质数的特点：只能被1和num整除，不能被2 ~ (num-1)整除。遍历2 ~ (num-1) 。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;function isPrime(num){
      if(num &amp;lt;= 1 ){
        return false
      } 
      for(let i = 2; i &amp;lt;= num - 1; i++){
        if(num % i ==0){
          return false
        }
      }
        return true
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方法虽然能实现质数的判断，但是效率不高。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法二：只需要遍历2 ~ num的平方根即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    function isPrime(num){
      if (num &amp;lt;= 1) {
        return false
      }
      //1.获取num的平方根:Math.sqrt(num)
      //2.循环判断
      for(var i = 2; i&amp;lt;= Math.sqrt(num); i++ ){
        if(num % i == 0){
          return false;
        }
      }
        return true;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;实现扩容后的哈希表容量为质数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;br&gt;
2倍扩容之后，通过循环调用isPrime判断得到的容量是否为质数，不是则+1，直到是为止。比如原长度：7，2倍扩容后长度为14，14不是质数，14 + 1 = 15不是质数，15 + 1 = 16不是质数，16 + 1 = 17是质数，停止循环，由此得到质数17。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步：首先需要为HashTable类添加判断质数的isPrime方法和获取质数的getPrime方法：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;  //判断传入的num是否质数
  HashTable.prototype.isPrime = function(num){
      if (num &amp;lt;= 1) {
        return false
      }
      //1.获取num的平方根:Math.sqrt(num)
      //2.循环判断
      for(var i = 2; i&amp;lt;= Math.sqrt(num); i++ ){
        if(num % i == 0){
          return false;
        }
      }
        return true;
    }

    //获取质数的方法
    HashTable.prototype.getPrime = function(num){
       //7*2=14,+1=15,+1=16,+1=17(质数)
      while (!this.isPrime(num)) {
        num++
      }
      return num
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;第二步：修改添加元素的put方法和删除元素的remove方法中关于数组扩容的相关操作：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在put方法中添加如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //判断是否需要扩容操作
      if(this.count &amp;gt; this.limit * 0.75){
        let newSize = this.limit * 2
        let newPrime = this.getPrime(newSize)
        this.resize(newPrime)
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在remove方法中添加如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     //缩小容量
          if (this.limit &amp;gt; 7 &amp;amp;&amp;amp; this.count &amp;lt; this.limit * 0.25) {
            let newSize = Math.floor(this.limit / 2)
            let newPrime = this.getPrime(newSize)
            this.resize(newPrime)
          }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  let ht = new HashTable()

    ht.put(&#39;class1&#39;,&#39;Tom&#39;)
    ht.put(&#39;class2&#39;,&#39;Mary&#39;)
    ht.put(&#39;class3&#39;,&#39;Gogo&#39;)
    ht.put(&#39;class4&#39;,&#39;Tony&#39;)
    ht.put(&#39;class5&#39;,&#39;5&#39;)
    ht.put(&#39;class6&#39;,&#39;6&#39;)
    ht.put(&#39;class7&#39;,&#39;7&#39;)
    ht.put(&#39;class8&#39;,&#39;8&#39;)
    ht.put(&#39;class9&#39;,&#39;9&#39;)
    ht.put(&#39;class10&#39;,&#39;10&#39;)
    console.log(ht.size());//10
    console.log(ht.limit);//17
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1614353404211.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;4哈希表的完整实现&#34;&gt;4.哈希表的完整实现&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;    //封装哈希表类
    function HashTable() {
      //属性
      this.storage = []
      this.count = 0//计算已经存储的元素个数
      //装填因子：loadFactor &amp;gt; 0.75时需要扩容；loadFactor &amp;lt; 0.25时需要减少容量
      this.limit = 7//初始长度

      //方法
      //哈希函数
      HashTable.prototype.hashFunc = function(str, size){
      //1.定义hashCode变量
      let hashCode = 0

      //2.霍纳法则，计算hashCode的值
      //cats -&amp;gt; Unicode编码
      for(let i = 0 ;i &amp;lt; str.length; i++){
        // str.charCodeAt(i)//获取某个字符对应的unicode编码
        hashCode = 37 * hashCode + str.charCodeAt(i)
      }

      //3.取余操作
      let index = hashCode % size
      return index
    }

    //一.插入&amp;amp;修改操作
    HashTable.prototype.put = function (key, value){
      //1.根据key获取对应的index
      let index = this.hashFunc(key, this.limit)

      //2.根据index取出对应的bucket
      let bucket = this.storage[index]

      //3.判断该bucket是否为null
      if (bucket == null) {
        bucket = []
        this.storage[index] = bucket
      }

      //4.判断是否是修改数据
      for (let i = 0; i &amp;lt; bucket.length; i++) {
        let tuple = bucket[i];
        if (tuple[0] == key) {
          tuple[1] = value
          return//不用返回值
        }
      }

      //5.进行添加操作
      bucket.push([key, value])
      this.count += 1

      //6.判断是否需要扩容操作
      if(this.count &amp;gt; this.limit * 0.75){
        let newSize = this.limit * 2
        let newPrime = this.getPrime(newSize)
        this.resize(newPrime)
      }
    }

    //二.获取操作
    HashTable.prototype.get = function(key){
      //1.根据key获取对应的index
      let index = this.hashFunc(key, this.limit)

      //2.根据index获取对应的bucket
      let bucket = this.storage[index]

      //3.判断bucket是否等于null
      if (bucket == null) {
        return null
      }

      //4.有bucket，那么就进行线性查找
      for (let i = 0; i &amp;lt; bucket.length; i++) {
        let tuple = bucket[i];
        if (tuple[0] == key) {//tuple[0]存储key，tuple[1]存储value
          return tuple[1]
        }
      }

      //5.依然没有找到，那么返回null
      return null
    }

    //三.删除操作
    HashTable.prototype.remove = function(key){
      //1.根据key获取对应的index
      let index = this.hashFunc(key, this.limit)

      //2.根据index获取对应的bucket
      let bucket = this.storage[index]

      //3.判断bucket是否为null
      if (bucket == null) {
        return null
      }

      //4.有bucket,那么就进行线性查找并删除
      for (let i = 0; i &amp;lt; bucket.length; i++) {
        let tuple = bucket[i]
        if (tuple[0] == key) {
          bucket.splice(i,1)
          this.count -= 1 
          return tuple[1]

          //6.缩小容量
          if (this.limit &amp;gt; 7 &amp;amp;&amp;amp; this.count &amp;lt; this.limit * 0.25) {
            let newSize = Math.floor(this.limit / 2)
            let newPrime = this.getPrime(newSize)
            this.resize(newPrime)
          }
        }
    }

      //5.依然没有找到，返回null
      return null
    }

  /*------------------其他方法--------------------*/
  //判断哈希表是否为null
  HashTable.prototype.isEmpty = function(){
    return this.count == 0
  }

  //获取哈希表中元素的个数
  HashTable.prototype.size = function(){
    return this.count
  }


  //哈希表扩容
  HashTable.prototype.resize = function(newLimit){
    //1.保存旧的storage数组内容
    let oldStorage = this.storage

    //2.重置所有的属性
    this.storage = []
    this.count = 0
    this.limit = newLimit

    //3.遍历oldStorage中所有的bucket
    for (let i = 0; i &amp;lt; oldStorage.length; i++) {
      //3.1.取出对应的bucket
      const bucket = oldStorage[i];

      //3.2.判断bucket是否为null
      if (bucket == null) {
        continue
      }      

      //3.3.bucket中有数据，就取出数据重新插入
      for (let j = 0; j &amp;lt; bucket.length; j++) {
        const tuple = bucket[j];
        this.put(tuple[0], tuple[1])//插入数据的key和value
      }
    }
  }

  //判断传入的num是否质数
  HashTable.prototype.isPrime = function(num){
      if (num &amp;lt;= 1) {
        return false
      }
      //1.获取num的平方根:Math.sqrt(num)
      //2.循环判断
      for(var i = 2; i&amp;lt;= Math.sqrt(num); i++ ){
        if(num % i == 0){
          return false;
        }
      }
        return true;
    }

    //获取质数的方法
    HashTable.prototype.getPrime = function(num){
       //7*2=14,+1=15,+1=16,+1=17(质数)
      while (!this.isPrime(num)) {
        num++
      }
      return num
    }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1x7411L7Q7?from=search&amp;amp;seid=3912456004602554239&#34;&gt;参考资料:JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现哈希表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/fan-wai-cong-a-li-yun-ban-jia-dao-teng-xun-yun-de-tian-keng-zhi-lu/"" data-c="
          &lt;p&gt;原因：穷，续费超过花呗上限🙁&lt;br&gt;
目的：域名(备案)从阿里云转移到腾讯云&lt;br&gt;
题记：作为一个“敬业”的博主(其实是怕以后忘了)，随手记录并分享出来。&lt;/p&gt;
&lt;h1 id=&#34;一-域名转移&#34;&gt;一、域名转移&lt;/h1&gt;
&lt;h2 id=&#34;11-阿里云索取域名转移密码&#34;&gt;1.1 阿里云索取域名转移密码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.aliyun.com/minisite/goods?userCode=2rbhf9dd&#34;&gt;点我登陆&lt;/a&gt;阿里云控制台，进入域名控制台，在域名基本信息中点击【索取域名转移码】，这时阿里云会向域名管理邮箱发送一封带有转移密码的邮件，名头是“万网域名转出密码通知”。复制邮件中的转移密码。&lt;br&gt;
提示:如果提示“已开启[禁止更新锁],该功能暂不可用”，这是阿里云的安全机制作用了，需要你去手动关闭，在【安全设置】中关闭系统自带的“两把锁”，按照提示操作，提供相应的手机验证码即可。然后就能正常索取密码了。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1613741482839.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;12-腾讯云域名转入操作&#34;&gt;1.2 腾讯云域名转入操作&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://cloud.tencent.com/?fromSource=gwzcw.1293314.1293314.1293314&amp;amp;cps_key=5c28f3346f24fe86eb5b34852bad6c77&#34;&gt;点我打开&lt;/a&gt;腾讯云官网，进入控制台中的域名管理，先创建一份【域名信息模板】，按照页面要求填写完毕提交，等待审核完毕。正常审核时间为一个工作日，实际上1小时左右就能完成。&lt;br&gt;
然后在下图的【域名转入】页面中，输入域名和转移码，要求中间有空格，不懂的看系统提示。&lt;br&gt;
绑定域名信息模板后，提交。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1613741580974.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;13-等待域名转移和后悔期&#34;&gt;1.3 等待域名转移和后悔期&lt;/h2&gt;
&lt;p&gt;这时候阿里云再次发邮件给你，名头是“阿里云域名转出通知”，里面有转移到期的日期，意思是说如果你想转移域名，就可以忽略这封邮件。等待几天就会自动转移成功了。&lt;br&gt;
提示:在这期间有5~7天的后悔期，就是说转移不是马上就完成了，在这些天中如果你不想转移了，可以点击阿里云域名控制台或者邮件中的【取消】，来停止这场转移，这样域名仍旧留在阿里云了。&lt;/p&gt;
&lt;h2 id=&#34;14-域名转移到腾讯云&#34;&gt;1.4 域名转移到腾讯云&lt;/h2&gt;
&lt;p&gt;超过了到期时间后域名就会自动转移到腾讯云了，域名邮箱也会同时收到转移成功的邮件。这时候域名会借助域名信息模板自动实名，接下来就是网站备案，域名解析，安装环境及部署网站等一系列操作了。&lt;/p&gt;
&lt;h1 id=&#34;二-部署个人博客&#34;&gt;二、部署个人博客&lt;/h1&gt;
&lt;h2 id=&#34;21-所需工具&#34;&gt;2.1 所需工具&lt;/h2&gt;
&lt;p&gt;使用github托管个人博客静态网页，使用gridea作为静态网页生成器(操作简单)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;github账号&lt;a href=&#34;https://github.com/&#34;&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;gridea下载安装&lt;a href=&#34;https://gridea.dev/&#34;&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;22-创建仓库存储静态网页&#34;&gt;2.2 创建仓库存储静态网页&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1613742044871.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1613742050262.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;23-生成个人访问令牌&#34;&gt;2.3 生成个人访问令牌&lt;/h2&gt;
&lt;p&gt;依次点击，右上角头像-&amp;gt;Developer settings-&amp;gt;Personal access tokens-&amp;gt;Generate new token&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1613742116246.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1613742119740.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;24-在gridea填写域名仓库名称等信息同步&#34;&gt;2.4 在gridea填写域名，仓库名称等信息，同步&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1613742207612.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1613742210710.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
刷新一下github仓库网页，会看到多了很多文件&lt;/p&gt;
&lt;h1 id=&#34;三-github绑定自己的域名&#34;&gt;三、github绑定自己的域名&lt;/h1&gt;
&lt;h2 id=&#34;31-在仓库里添加cname文件并在文件中填写绑定的域名&#34;&gt;3.1 在仓库里添加CNAME文件并在文件中填写绑定的域名&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1613742323733.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
文件里填写的内容：要绑定的域名（不要包含Http://和www）&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1613742361386.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
进入设置&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1613742397702.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
找到 Custom domain添加域名后保存即可。&lt;br&gt;
（添加CNAME文件并在文件中填写绑定的域名后应该会自动保存，看看有没有自动保存）&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1613742412812.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-添加域名解析&#34;&gt;3.2 添加域名解析&lt;/h2&gt;
&lt;p&gt;ping你的http://github.io域名，得到一个IP&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1613742460079.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
修改你的域名解析记录；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1613742567477.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加两个记录分别为A和CNAME，A绑定刚才得到的ip地址，CNAME绑定自己的域名&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1613742731980.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;33-绑定成功&#34;&gt;3.3 绑定成功&lt;/h2&gt;
&lt;h1 id=&#34;四-本地dns更新&#34;&gt;四、本地DNS更新&lt;/h1&gt;
&lt;p&gt;域名指向新的服务器IP后不能访问的解决办法：&lt;br&gt;
不能访问是因为本地DNS缓存，缓存清除方法：dos命令窗口输入ipconfig/flushdns ，回车即可。&lt;/p&gt;
">【番外】从阿里云搬家到腾讯云的填坑之路</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/javascript-shi-xian-ji-he-yu-zi-dian/"" data-c="
          &lt;h1 id=&#34;1集合结构&#34;&gt;1.集合结构&lt;/h1&gt;
&lt;h2 id=&#34;11简介&#34;&gt;1.1.简介&lt;/h2&gt;
&lt;p&gt;集合比较常见的实现方式是&lt;strong&gt;哈希表&lt;/strong&gt;，这里使用JavaScript的Object类进行封装。&lt;br&gt;
集合通常是由一组&lt;strong&gt;无序的、不能重复&lt;/strong&gt;的元素构成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数学中常指的集合中的元素是可以重复的，但是计算机中集合的元素不能重复。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;集合是特殊的数组：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特殊之处在于里面的元素&lt;strong&gt;没有顺序，也不能重复&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;没有顺序意味着&lt;strong&gt;不能通过下标值进行访问&lt;/strong&gt;，不能重复意味着&lt;strong&gt;相同的对象&lt;/strong&gt;在集合中只会&lt;strong&gt;存在一份&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现集合类：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在ES6中的&lt;strong&gt;Set&lt;/strong&gt;类就是一个集合类，这里我们重新封装一个Set类，了解集合的底层实现。&lt;/li&gt;
&lt;li&gt;JavaScript中的&lt;strong&gt;Object&lt;/strong&gt;类中的&lt;strong&gt;key&lt;/strong&gt;就是一个集合，可以使用它来封装集合类Set。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;集合常见的操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;add（value）：向集合添加一个新的项；&lt;/li&gt;
&lt;li&gt;remove（value）：从集合中移除一个值；&lt;/li&gt;
&lt;li&gt;has（value）：如果值在集合中，返回true，否则返回false；&lt;/li&gt;
&lt;li&gt;clear（）：移除集合中的所有项；&lt;/li&gt;
&lt;li&gt;size（）：返回集合所包含元素的数量，与数组的length属性相似；&lt;/li&gt;
&lt;li&gt;values（）：返回一个包含集合中所有值的数组；&lt;br&gt;
还有其他的方法，用的不多这里不做封装；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12代码实现&#34;&gt;1.2.代码实现&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;     //封装集合类
    function Set() {
      //属性
      this.items = {}

      //方法
      //一.has方法
      Set.prototype.has = value =&amp;gt; {
        return this.items.hasOwnProperty(value)
      }

      //二.add方法
      Set.prototype.add = value =&amp;gt; {
        //判断集合中是否已经包含该元素
        if (this.has(value)) {
          return false
        }
        //将元素添加到集合中
        this.items[value] = value//表示该属性键和值都为value
        return true//表示添加成功
      }

      //三.remove方法
      Set.prototype.remove = (value) =&amp;gt; {
        //1.判断集合中是否包含该元素
        if (!this.has(value)) {
          return false
        }

        //2.将元素从属性中删除
        delete this.items[value]
        return true
      }

      //四.clear方法
      Set.prototype.clear = () =&amp;gt; {
        //原来的对象没有引用指向，会被自动回收
        this.items = {}
      }

      //五.size方法
      Set.prototype.size = () =&amp;gt; {
        return Object.keys(this.items).length
      }

      //获取集合中所有的值
      //六.values方法
      Set.prototype.values = function() {
        return Object.keys(this.items)
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试集合类
    //1.创建Set类对象
    let set = new Set()

    //添加元素
    //2.测试add方法
    console.log(set.add(&#39;a&#39;));									
    console.log(set.add(&#39;a&#39;));										
    console.log(set.add(&#39;b&#39;));									
    console.log(set.add(&#39;c&#39;));										
    console.log(set.add(&#39;d&#39;));										

    //3.测试values方法
    console.log(set.values());									

    //删除元素
    //4.测试remove方法
    console.log(set.remove(&#39;a&#39;));								
    console.log(set.remove(&#39;a&#39;));								
    console.log(set.values());										

    //5.测试has方法
    console.log(set.has(&#39;b&#39;));										

    //6.测试size方法和clear方法
    console.log(set.size());										
    set.clear()
    // 由于clear方法的实现原理为指向另外一个空对象，所以不影响原来的对象
    console.log(set.size());										
    console.log(set.values());				
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1613738370515.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;13集合间的操作&#34;&gt;1.3.集合间的操作&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;集合间操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合；&lt;/li&gt;
&lt;li&gt;交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合；&lt;/li&gt;
&lt;li&gt;差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合；&lt;/li&gt;
&lt;li&gt;子集：验证一个给定集合是否是另一个集合的子集；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1613738411477.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;并集的实现：&lt;/strong&gt;&lt;br&gt;
实现思路：创建集合C代表集合A和集合B的并集，先将集合A中的所有元素添加到集合C中，再遍历集合B，如果是集合C所没有的元素就把它添加到集合C中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Set.prototype.union = otherSet =&amp;gt; {
      // this:集合对象A
      // otherSet:集合对象B
      //1.创建一个新的集合
      let unionSet = new Set()

      //2.将A集合中的所有元素添加到新集合中
      let values = this.values()
      // for(let i of values){
      //   unionSet.add(i)
      // }
      for(let i = 0;i &amp;lt; values.length;i++){
        unionSet.add(values[i])
      }

      //3.取出B集合中的元素,判断是否需要加到新集合中
      values = otherSet.values()
      // for(let i of values){
      //   //由于集合的add方法已经对重复的元素进行了判断,所以这里可以直接添加
      //   unionSet.add(i)
      // }
      for(let i = 0;i &amp;lt; values.length;i++){
        unionSet.add(values[i])
      }
      return unionSet
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;交集的实现：&lt;/strong&gt;&lt;br&gt;
实现思路：遍历集合A，当取得的元素也存在于集合B时，就把该元素添加到另一个集合C中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; Set.prototype.intersection = otherSet =&amp;gt; {
      // this:集合A
      // otherSet:集合B
      //1.创建新的集合
      let intersectionSet = new Set()
      
      //2.从A中取出一个元素，判断是否同时存在于集合B中，是则放入新集合中
      let values = this.values()
      for(let i =0 ; i &amp;lt; values.length; i++){
        let item = values[i]
        if (otherSet.has(item)) {
          intersectionSet.add(item)
        }
      }
      return intersectionSet
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;差集的实现：&lt;/strong&gt;&lt;br&gt;
实现思路：遍历集合A，当取得的元素不存在于集合B时，就把该元素添加到另一个集合C中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Set.prototype.diffrence = otherSet =&amp;gt; {
        //this:集合A
        //otherSet:集合B
        //1.创建新的集合
        var diffrenceSet = new Set()

        //2.取出A集合中的每一个元素，判断是否同时存在于B中，不存在则添加到新集合中
        var values = this.values()
        for(var i = 0;i &amp;lt; values.length; i++){
          var item = values[i]
          if (!otherSet.has(item)) {
            diffrenceSet.add(item)
          }
        }
        return diffrenceSet
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;子集的实现：&lt;/strong&gt;&lt;br&gt;
实现思路：遍历集合A，当取得的元素中有一个不存在于集合B时，就说明集合A不是集合B的子集，返回false。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; Set.prototype.subset = otherSet =&amp;gt; {
        //this:集合A
        //otherSet：集合B
        //遍历集合A中的所有元素，如果发现，集合A中的元素，在集合B中不存在，那么放回false，如果遍历完整个集合A没有返回false，就返回true
        let values = this.values()
        for(let i = 0; i &amp;lt; values.length; i++){
          let item = values[i]
          if(!otherSet.has(item)){
            return false
          }
        }
        return true
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2字典结构&#34;&gt;2.字典结构&lt;/h1&gt;
&lt;h2 id=&#34;21简介&#34;&gt;2.1.简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;字典的特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字典存储的是键值对，主要特点是一一对应；&lt;/li&gt;
&lt;li&gt;比如保存一个人的信息：数组形式：[19，‘Tom’，1.65]，可通过下标值取出信息；字典形式：{&amp;quot;age&amp;quot;：19，&amp;quot;name&amp;quot;：&amp;quot;Tom&amp;quot;，&amp;quot;height&amp;quot;：165}，可以通过key取出value。&lt;/li&gt;
&lt;li&gt;此外，在字典中&lt;strong&gt;key&lt;/strong&gt;是&lt;strong&gt;不能重复&lt;/strong&gt;且&lt;strong&gt;无序&lt;/strong&gt;的，而&lt;strong&gt;Value&lt;/strong&gt;可以&lt;strong&gt;重复&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;字典和映射的关系：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有些编程语言中称这种映射关系为字典，如Swift中的Dictonary，Python中的dict；&lt;/li&gt;
&lt;li&gt;有些编程语言中称这种映射关系为Map，比如Java中的HashMap&amp;amp;TreeMap等；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;字典类常见的操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;set(key,value)：向字典中添加新元素。&lt;/li&gt;
&lt;li&gt;remove(key)：通过使用键值来从字典中移除键值对应的数据值。&lt;/li&gt;
&lt;li&gt;has(key)：如果某个键值存在于这个字典中，则返回true，反之则返回false。&lt;/li&gt;
&lt;li&gt;get(key)：通过键值查找特定的数值并返回。&lt;/li&gt;
&lt;li&gt;clear()：将这个字典中的所有元素全部删除。&lt;/li&gt;
&lt;li&gt;size()：返回字典所包含元素的数量。与数组的length属性类似。&lt;/li&gt;
&lt;li&gt;keys()：将字典所包含的所有键名以数组形式返回。&lt;/li&gt;
&lt;li&gt;values()：将字典所包含的所有数值以数组形式返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;22封装字典&#34;&gt;2.2.封装字典&lt;/h2&gt;
&lt;p&gt;字典类可以基于JavaScript中的对象结构来实现，比较简单，这里直接实现字典类中的常用方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//封装字典类
function Dictionary(){
  //字典属性
  this.items = {}

  //字典操作方法
  //一.在字典中添加键值对
  Dictionary.prototype.set = function(key, value){
    this.items[key] = value
  }

  //二.判断字典中是否有某个key
  Dictionary.prototype.has = function(key){
    return this.items.hasOwnProperty(key)
  }

  //三.从字典中移除元素
  Dictionary.prototype.remove = function(key){
    //1.判断字典中是否有这个key
    if(!this.has(key)) return false

    //2.从字典中删除key
    delete this.items[key]
    return true
  }

  //四.根据key获取value
  Dictionary.prototype.get = function(key){
    return this.has(key) ? this.items[key] : undefined
  }

  //五.获取所有keys
  Dictionary.prototype.keys = function(){
    return Object.keys(this.items)
  }

  //六.size方法
  Dictionary.prototype.keys = function(){
    return this.keys().length
  }

  //七.clear方法
  Dictionary.prototype.clear = function(){
    this.items = {}
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1x7411L7Q7?from=search&amp;amp;seid=3912456004602554239&#34;&gt;参考资料:JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现集合与字典</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/javascript-shi-xian-shuang-xiang-lian-biao/"" data-c="
          &lt;h1 id=&#34;1双向链表简介&#34;&gt;1.双向链表简介&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;双向链表&lt;/strong&gt;：既可以&lt;strong&gt;从头遍历到尾&lt;/strong&gt;，又可以&lt;strong&gt;从尾遍历到头&lt;/strong&gt;。也就是说链表连接的过程是&lt;strong&gt;双向&lt;/strong&gt;的，它的实现原理是：一个节点既有&lt;strong&gt;向前连接的引用&lt;/strong&gt;，也有一个&lt;strong&gt;向后连接的引用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;双向链表的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次在插入或删除某个节点时，都需要处理四个引用，而不是两个，实现起来会困难些；&lt;/li&gt;
&lt;li&gt;相对于单向链表，所占内存空间更大一些；&lt;/li&gt;
&lt;li&gt;但是，相对于双向链表的便利性而言，这些缺点微不足道。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;双向链表的结构：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612851991692.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双向链表不仅有&lt;strong&gt;head&lt;/strong&gt;指针指向第一个节点，而且有&lt;strong&gt;tail&lt;/strong&gt;指针指向最后一个节点；&lt;/li&gt;
&lt;li&gt;每一个节点由三部分组成：&lt;strong&gt;item&lt;/strong&gt;储存数据、&lt;strong&gt;prev&lt;/strong&gt;指向前一个节点、&lt;strong&gt;next&lt;/strong&gt;指向后一个节点；&lt;/li&gt;
&lt;li&gt;双向链表的第一个节点的&lt;strong&gt;prev&lt;/strong&gt;指向&lt;strong&gt;null&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;双向链表的最后一个节点的&lt;strong&gt;next&lt;/strong&gt;指向&lt;strong&gt;null&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;双向链表常见的操作（方法）：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;append（element）：向链表尾部添加一个新的项；&lt;/li&gt;
&lt;li&gt;inset（position，element）：向链表的特定位置插入一个新的项；&lt;/li&gt;
&lt;li&gt;get（element）：获取对应位置的元素；&lt;/li&gt;
&lt;li&gt;indexOf（element）：返回元素在链表中的索引，如果链表中没有元素就返回-1；&lt;/li&gt;
&lt;li&gt;update（position，element）：修改某个位置的元素；&lt;/li&gt;
&lt;li&gt;removeAt（position）：从链表的特定位置移除一项；&lt;/li&gt;
&lt;li&gt;isEmpty（）：如果链表中不包含任何元素，返回trun，如果链表长度大于0则返回false；&lt;/li&gt;
&lt;li&gt;size（）：返回链表包含的元素个数，与数组的length属性类似；&lt;/li&gt;
&lt;li&gt;toString（）：由于链表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值；&lt;/li&gt;
&lt;li&gt;forwardString（）：返回正向遍历节点字符串形式；&lt;/li&gt;
&lt;li&gt;backwordString（）：返回反向遍历的节点的字符串形式；&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2封装双向链表类&#34;&gt;2.封装双向链表类&lt;/h1&gt;
&lt;h2 id=&#34;21创建双向链表类&#34;&gt;2.1.创建双向链表类&lt;/h2&gt;
&lt;p&gt;先创建双向链表类DoubleLinklist，并添加基本属性，再实现双向链表的常用方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //封装双向链表类
    function DoubleLinklist(){
      //封装内部类：节点类
      function Node(data){
        this.data = data
        this.prev = null
        this.next = null
      }

      //属性
      this.head = null
      this.tail ==null
      this.length = 0
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;22appendelement&#34;&gt;2.2.append(element)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //append方法
      DoubleLinklist.prototype.append = data =&amp;gt; {
        //1.根据data创建新节点
        let newNode = new Node(data)

        //2.添加节点
        //情况1：添加的是第一个节点
        if (this.length == 0) {
          this.tail = newNode
          this.head = newNode 
        //情况2：添加的不是第一个节点
        }else {
          newNode.prev = this.tail
          this.tail.next = newNode
          this.tail = newNode
        }

        //3.length+1
        this.length += 1
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
添加节点时分为多种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：添加的是第一个节点：只需要让head和tail都指向新节点即可；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612852175479.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;情况2：添加的不是第一个节点，如下图所示：只需要改变相关引用的指向即可。&lt;br&gt;
通过：newNode.prev = this.tail：建立指向1；&lt;br&gt;
通过：this.tail.next = newNode：建立指向2；&lt;br&gt;
通过：this.tail = newNode：建立指向3&lt;br&gt;
要注意改变变量指向的顺序，最后修改tail指向，这样未修改前tail始终指向原链表的最后一个节点。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612852234410.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612852237080.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
   //1.创建双向链表
   let list = new DoubleLinklist()

    //2.测试append方法
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;next方向：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612852391457.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;prev方向：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612852402201.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;23tostring汇总&#34;&gt;2.3.toString()汇总&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //将链表转变为字符串形式
      //一.toString方法
      DoubleLinklist.prototype.toString = () =&amp;gt; {
        return this.backwardString()
      }

      //二.forwardString方法
      DoubleLinklist.prototype.forwardString = () =&amp;gt; {
        //1.定义变量
        let current =this.tail
        let resultString = &amp;quot;&amp;quot;
        //2.依次向前遍历，获取每一个节点
        while (current) {
          resultString += current.data + &amp;quot;--&amp;quot;
          current = current.prev 
        }
        return resultString
      }

      //三.backwardString方法
      DoubleLinklist.prototype.backwardString = () =&amp;gt; {
        //1.定义变量
        let current = this.head
        let resultString = &amp;quot;&amp;quot;

        //2.依次向后遍历，获取每一个节点
        while (current) {
          resultString += current.data + &amp;quot;--&amp;quot;
          current = current.next
        }
        return resultString
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
三种获取字符串的方法：toString（）、forwardString（）、backwardString（）实现原理相似，仅以backWardString方法为例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义current变量记录当前指向的节点。首先让current指向第一个节点，然后通过 current = current.next 依次向后遍历。在while循环中以(current)作为条件遍历链表，只要current ！= null就一直遍历，由此可获取链表所有节点的数据。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612852477706.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建双向链表
    let list = new DoubleLinklist()
    
    //2.测试字符串方法   
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)
    console.log(list.toString());
    console.log(list.forwardString());
    console.log(list.backwardString());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612852509395.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;24insertpositionelement&#34;&gt;2.4.insert(position,element)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      //insert方法
      DoubleLinklist.prototype.insert = (position, data) =&amp;gt; {
        //1.越界判断
        if (position &amp;lt; 0 || position &amp;gt; this.length) return false

        //2.根据data创建新的节点
        let newNode = new Node(data)

        //3.插入新节点
        //原链表为空
          //情况1：插入的newNode是第一个节点
        if (this.length == 0) {
          this.head = newNode
          this.tail = newNode
        //原链表不为空
        }else {
          //情况2：position == 0
          if (position == 0) {
            this.head.prev = newNode
            newNode.next = this.head
            this.head = newNode
          //情况3：position == this.length 
          } else if(position == this.length){
            this.tail.next = newNode
            newNode.prev = this.tail
            this.tail = newNode
            //情况4：0 &amp;lt; position &amp;lt; this.length
          }else{
            let current = this.head
            let index = 0
            while(index++ &amp;lt; position){
              current = current.next
            }
            //修改pos位置前后节点变量的指向
            newNode.next = current
            newNode.prev = current.prev
            current.prev.next = newNode
            current.prev = newNode
          }
        }
        //4.length+1
        this.length += 1
        return true//返回true表示插入成功
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
插入节点可分为多种情况：&lt;br&gt;
&lt;strong&gt;当原链表为空时：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：插入的新节点是链表的第一个节点；只需要让head和tail都指向newNode即可。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612852572211.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;当原链表不为空时：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;情况2：当position == 0，即在链表的首部添加节点：如下图所示：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612852606766.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先，通过：this.head.prev = newNode，改变指向1；&lt;br&gt;
然后，通过：newNode.next = this.head，改变指向2；&lt;br&gt;
最后，通过：this.head = newNode，改变指向3；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612852623273.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;情况3：position == this.length，即在链表的尾部添加节点，如下图所示：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612852636699.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;首先&lt;/strong&gt;，通过：this.tail.next = newNode，改变指向1；（注意这里使用this.tail指向原链表最后一个节点，而不是this.head。因为当length&amp;gt;1时，this.head != this.tail。）&lt;br&gt;
&lt;strong&gt;然后&lt;/strong&gt;，通过：newNode.prev = this.tail，改变指向2；&lt;br&gt;
&lt;strong&gt;最后&lt;/strong&gt;，通过：this.tail = newNode，改变指向3；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612852702385.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;情况4：0 &amp;lt; position &amp;lt; this.length，即在链表的中间插入新节点，假设在position = 1的位置插入，如下图所示：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612852718023.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先，需要定义变量current按照之前的思路，通过while循环找到position位置的后一个节点，循环结束后index = position&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612852732864.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如下图所示：当position = 1时，current就指向了Node2。这样操作current就等同于间接地操作Node2，还可以通过current.prev间接获取Node1。得到了newNode的前一个节点和后一个节点就可以通过改变它们的prev和next变量的指向来插入newNode了。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612852753700.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;通过&lt;/strong&gt;：newNode.next = current，改变指向1；&lt;br&gt;
&lt;strong&gt;通过&lt;/strong&gt;：newNode.prev = current.prev，改变指向2；&lt;br&gt;
&lt;strong&gt;通过&lt;/strong&gt;：current.prev.next = newNode，改变指向3；&lt;br&gt;
&lt;code&gt;注意必须最后才修改current.prev的指向，不然就无法通过current.prev获取需要操作的Node1了。&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;通过&lt;/strong&gt;：current.prev = current，改变指向4；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612852934567.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建双向链表
    let list = new DoubleLinklist()

	//2.测试insert方法
    list.insert(0, &#39;插入链表的第一个元素&#39;)
    list.insert(0, &#39;在链表首部插入元素&#39;)
    list.insert(1, &#39;在链表中间插入元素&#39;)
    list.insert(3, &#39;在链表尾部插入元素&#39;)
    console.log(list);
    alert(list)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612852974146.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612852977704.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;25getposition&#34;&gt;2.5.get(position)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      //get方法
      DoubleLinklist.prototype.get = position =&amp;gt; {
        //1.越界判断
        if (position &amp;lt; 0 || position &amp;gt;= this.length) {//获取元素时position不能等于length
          return null
        }

        //2.获取元素
        let current = null
        let index = 0
        //this.length / 2 &amp;gt; position:从头开始遍历
        if ((this.length / 2) &amp;gt; position) {
          current = this.head
          while(index++ &amp;lt; position){
          current = current.next
        }
        //this.length / 2 =&amp;lt; position:从尾开始遍历
        }else{
          current = this.tail
          index = this.length - 1
          while(index-- &amp;gt; position){
          current = current.prev
        }
        }
        return current.data
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
定义两个变量current和index，按照之前的思路通过while循环遍历分别获取当前节点和对应的索引值index，直到找到需要获取的position位置后的一个节点，此时index = pos =x，然后return current.data即可。&lt;/p&gt;
&lt;p&gt;如果链表的节点数量很多时，这种查找方式效率不高，改进方法为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一定要通过this.length来获取链表的节点数否则就会报错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;当this.length / 2 &amp;gt; position：从头（head）开始遍历；&lt;/li&gt;
&lt;li&gt;当this.length / 2 &amp;lt; position：从尾（tail）开始遍历；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612853079217.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建双向链表
    let list = new DoubleLinklist()
    
  	//2.测试get方法
    list.append(&#39;a&#39;)
    list.append(&#39;b&#39;)
    list.append(&#39;b1&#39;)
    list.append(&#39;b2&#39;)
    list.append(&#39;b3&#39;)
    list.append(&#39;b4&#39;)
    list.append(&#39;b5&#39;)
    list.append(&#39;b6&#39;)
    list.append(&#39;b7&#39;)
    console.log(list.get(0));
    console.log(list.get(7));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612853118806.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;26indexofelement&#34;&gt;2.6.indexOf(element)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      //indexOf方法
      DoubleLinklist.prototype.indexOf = data =&amp;gt; {
        //1.定义变量
        let current = this.head
        let index = 0

        //2.遍历链表，查找与data相同的节点
        while(current){
          if (current.data == data) {
            return index
          }
          current = current.next
          index += 1
        }
        return -1
      } 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
以（current）作为条件，通过while循环遍历链表中的所有节点（停止条件为current = null）。在遍历每个节点时将current指向的当前节点的data和传入的data进行比较即可。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612853385534.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建双向链表
    let list = new DoubleLinklist()
    
    //2.测试indexOf方法
    list.append(&#39;a&#39;)
    list.append(&#39;b&#39;)
    list.append(&#39;c&#39;)
    console.log(list.indexOf(&#39;a&#39;));
    console.log(list.indexOf(&#39;c&#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612853417022.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;28updatepositionelement&#34;&gt;2.8.update(position,element)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;        //update方法
      DoubleLinklist.prototype.update = (position, newData) =&amp;gt; {
        //1.越界判断
        if (position &amp;lt; 0 || position &amp;gt;= this.length) {
          return false
        }

        //2.寻找正确的节点
        let current = this.head
        let index = 0
        //this.length / 2 &amp;gt; position:从头开始遍历
        if (this.length / 2 &amp;gt; position) {
          while(index++ &amp;lt; position){
          current = current.next
        }
        //this.length / 2 =&amp;lt; position:从尾开始遍历
        }else{
          current = this.tail
          index = this.length - 1
          while (index -- &amp;gt; position) {
            current = current.prev
          }
        }

        //3.修改找到节点的data
        current.data = newData
        return true//表示成功修改
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
以（index++ &amp;lt; position）为条件，通过while循环遍历链表中的节点（停止条件为index = position）。循环结束后，current指向需要修改的节点。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612853464522.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建双向链表
    let list = new DoubleLinklist()
    
    //2.测试update方法
    list.append(&#39;a&#39;)
    list.append(&#39;b&#39;)
    console.log(list.update(1, &#39;c&#39;));
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612853512616.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;29removeatposition&#34;&gt;2.9.removeAt(position)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      //removeAt方法
      DoubleLinklist.prototype.removeAt = position =&amp;gt; {
        //1.越界判断
        if (position &amp;lt; 0 || position &amp;gt;= this.length) {
          return null
        }
        
        //2.删除节点
        //当链表中length == 1
        //情况1：链表只有一个节点
        let current = this.head//定义在最上面方便以下各种情况返回current.data
        if (this.length == 1) {
          this.head = null
          this.tail = null
        //当链表中length &amp;gt; 1
        } else{
          //情况2：删除第一个节点
          if (position == 0) {
            this.head.next.prev = null
            this.head = this.head.next
          //情况3：删除最后一个节点
          }else if(position == this.length - 1){
            current = this.tail//该情况下返回被删除的最后一个节点
            this.tail.prev.next = null
            this.tail = this.tail.prev
          }else{
          //情况4：删除链表中间的节点
            let index = 0
            while(index++ &amp;lt; position){
              current = current.next
            }
            current.next.prev = current.prev
            current.prev.next = current.next
          }
        }

        //3.length -= 1
        this.length -= 1
        return current.data//返回被删除节点的数据
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
删除节点时有多种情况：&lt;br&gt;
&lt;strong&gt;当链表的length = 1时：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：删除链表中的所有节点：只需要让链表的head和tail指向null即可。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612853571732.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;当链表的length &amp;gt; 1时：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;情况2：删除链表中的第一个节点：&lt;br&gt;
通过：this.head.next.prev = null，改变指向1；&lt;br&gt;
通过：this.head = this.head.next，改变指向2；&lt;br&gt;
虽然Node1有引用指向其它节点，但是没有引用指向Node1，那么Node1会被自动回收。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612853599140.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;情况3：删除链表中的最后一个节点：&lt;br&gt;
通过：this.tail.prev.next = null，修改指向1；&lt;br&gt;
通过：this.tail = this.tail.prev，修改指向2；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612853618439.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;情况4：删除链表中间的节点：&lt;br&gt;
通过while循环找到需要删除的节点，比如position = x，那么需要删除的节点就是Node(x+1)，如下图所示：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612853635573.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
通过：current.next.prev = current.prev，修改指向1；&lt;br&gt;
通过：current.prev.next = current.next，修改指向2；&lt;br&gt;
这样就没有引用指向Node(x+1)了（current虽指向Node(x+1)，但current时临时变量，该方法执行完就会被销毁），随后Node(x+1)就会被自动删除。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612853650608.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建双向链表
    let list = new DoubleLinklist()	
	
	//2.测试removeAt方法
    list.append(&#39;a&#39;)
    list.append(&#39;b&#39;)
    list.append(&#39;c&#39;)
    console.log(list.removeAt(1));
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612853684660.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;210其他方法&#34;&gt;2.10.其他方法&lt;/h2&gt;
&lt;p&gt;其他方法包括：&lt;strong&gt;remove(element)、isEmpty()、size()、getHead()、getTail()&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  //八.remove方法
  DoubleLinklist.prototype.remove = data =&amp;gt; {
    //1.根据data获取下标值
    let index = this.indexOf(data)
    
    //2.根据index删除对应位置的节点
    return this.removeAt(index)
  }

  //九.isEmpty方法
  DoubleLinklist.prototype.isEmpty = () =&amp;gt; {
    return this.length == 0
  }

  //十.size方法
  DoubleLinklist.prototype.size = () =&amp;gt; {
    return this.length
  }

  //十一.getHead方法：获取链表的第一个元素
  DoubleLinklist.prototype.getHead = () =&amp;gt; {
    return this.head.data
  }

  //十二.getTail方法：获取链表的最后一个元素
  DoubleLinklist.prototype.getTail = () =&amp;gt; {
    return this.tail.data
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//测试代码
    //1.创建双向链表
    let list = new DoubleLinklist()	

/*------------其他方法的测试--------------*/
    list.append(&#39;a&#39;)
    list.append(&#39;b&#39;)
    list.append(&#39;c&#39;)
    list.append(&#39;d&#39;)
    //remove方法
    console.log(list.remove(&#39;a&#39;));
    console.log(list);
    //isEmpty方法
    console.log(list.isEmpty());
    //size方法
    console.log(list.size());
    //getHead方法
    console.log(list.getHead());
    //getTead方法
    console.log(list.getTail());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612853763963.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;211完整实现&#34;&gt;2.11.完整实现&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//封装双向链表
function DoubleLinklist(){
  //封装内部类：节点类
  function Node(data){
    this.data = data
    this.prev = null
    this.next = null
  }

  //属性
  this.head = null
  this.tail ==null
  this.length = 0

  //常见的操作：方法
  //一.append方法
  DoubleLinklist.prototype.append = data =&amp;gt; {
    //1.根据data创建新节点
    let newNode = new Node(data)

    //2.添加节点
    //情况1：添加的是第一个节点
    if (this.length == 0) {
      this.tail = newNode
      this.head = newNode 
    //情况2：添加的不是第一个节点
    }else {
      newNode.prev = this.tail
      this.tail.next = newNode
      this.tail = newNode
    }

    //3.length+1
    this.length += 1
  }

  //二.将链表转变为字符串形式
  //2.1.toString方法
  DoubleLinklist.prototype.toString = () =&amp;gt; {
    return this.backwardString()
  }

  //2.2.forwardString方法
  DoubleLinklist.prototype.forwardString = () =&amp;gt; {
    //1.定义变量
    let current =this.tail
    let resultString = &amp;quot;&amp;quot;

    //2.依次向前遍历，获取每一个节点
    while (current) {
      resultString += current.data + &amp;quot;--&amp;quot;
      current = current.prev 
    }
    return resultString
  }

  //2.3.backwardString方法
  DoubleLinklist.prototype.backwardString = () =&amp;gt; {
    //1.定义变量
    let current = this.head
    let resultString = &amp;quot;&amp;quot;

    //2.依次向后遍历，获取每一个节点
    while (current) {
      resultString += current.data + &amp;quot;--&amp;quot;
      current = current.next
    }
    return resultString
  }

  //三.insert方法
  DoubleLinklist.prototype.insert = (position, data) =&amp;gt; {
    //1.越界判断
    if (position &amp;lt; 0 || position &amp;gt; this.length) return false

    //2.根据data创建新的节点
    let newNode = new Node(data)

    //3.插入新节点
    //原链表为空
      //情况1：插入的newNode是第一个节点
    if (this.length == 0) {
      this.head = newNode
      this.tail = newNode
    //原链表不为空
    }else {
      //情况2：position == 0
      if (position == 0) {
        this.head.prev = newNode
        newNode.next = this.head
        this.head = newNode
      //情况3：position == this.length 
      } else if(position == this.length){
        this.tail.next = newNode
        newNode.prev = this.tail
        this.tail = newNode
        //情况4：0 &amp;lt; position &amp;lt; this.length
      }else{
        let current = this.head
        let index = 0
        while(index++ &amp;lt; position){
          current = current.next
        }
        //修改pos位置前后节点变量的指向
        newNode.next = current
        newNode.prev = current.prev
        current.prev.next = newNode
        current.prev = newNode
      }
    }
    //4.length+1
    this.length += 1
    return true//返回true表示插入成功
  }

  //四.get方法
  DoubleLinklist.prototype.get = position =&amp;gt; {
    //1.越界判断
    if (position &amp;lt; 0 || position &amp;gt;= this.length) {//获取元素时position不能等于length
      return null
    }

    //2.获取元素
    let current = null
    let index = 0
    //this.length / 2 &amp;gt; position:从头开始遍历
    if ((this.length / 2) &amp;gt; position) {
      current = this.head
      while(index++ &amp;lt; position){
      current = current.next
    }
    //this.length / 2 =&amp;lt; position:从尾开始遍历
    }else{
      current = this.tail
      index = this.length - 1
      while(index-- &amp;gt; position){
      current = current.prev
    }
    }
    return current.data
  }

  //五.indexOf方法
  DoubleLinklist.prototype.indexOf = data =&amp;gt; {
    //1.定义变量
    let current = this.head
    let index = 0

    //2.遍历链表，查找与data相同的节点
    while(current){
      if (current.data == data) {
        return index
      }
      current = current.next
      index += 1
    }
    return -1
  } 

  //六.update方法
  DoubleLinklist.prototype.update = (position, newData) =&amp;gt; {
    //1.越界判断
    if (position &amp;lt; 0 || position &amp;gt;= this.length) {
      return false
    }

    //2.寻找正确的节点
    let current = this.head
    let index = 0
    //this.length / 2 &amp;gt; position:从头开始遍历
    if (this.length / 2 &amp;gt; position) {
      while(index++ &amp;lt; position){
      current = current.next
    }
    //this.length / 2 =&amp;lt; position:从尾开始遍历
    }else{
      current = this.tail
      index = this.length - 1
      while (index -- &amp;gt; position) {
        current = current.prev
      }
    }

    //3.修改找到节点的data
    current.data = newData
    return true//表示成功修改
  }

  //七.removeAt方法
  DoubleLinklist.prototype.removeAt = position =&amp;gt; {
    //1.越界判断
    if (position &amp;lt; 0 || position &amp;gt;= this.length) {
      return null
    }
    
    //2.删除节点
    //当链表中length == 1
    //情况1：链表只有一个节点
    let current = this.head//定义在最上面方便以下各种情况返回current.data
    if (this.length == 1) {
      this.head = null
      this.tail = null
    //当链表中length &amp;gt; 1
    } else{
      //情况2：删除第一个节点
      if (position == 0) {
        this.head.next.prev = null
        this.head = this.head.next
      //情况3：删除最后一个节点
      }else if(position == this.length - 1){
        current = this.tail//该情况下返回被删除的最后一个节点
        this.tail.prev.next = null
        this.tail = this.tail.prev
      }else{
      //情况4：删除链表中间的节点
        let index = 0
        while(index++ &amp;lt; position){
          current = current.next
        }
        current.next.prev = current.prev
        current.prev.next = current.next
      }
    }

    //3.length -= 1
    this.length -= 1
    return current.data//返回被删除节点的数据
  }
  /*--------------------其他方法-------------------*/
  //八.remove方法
  DoubleLinklist.prototype.remove = data =&amp;gt; {
    //1.根据data获取下标值
    let index = this.indexOf(data)
    
    //2.根据index删除对应位置的节点
    return this.removeAt(index)
  }

  //九.isEmpty方法
  DoubleLinklist.prototype.isEmpty = () =&amp;gt; {
    return this.length == 0
  }

  //十.size方法
  DoubleLinklist.prototype.size = () =&amp;gt; {
    return this.length
  }

  //十一.getHead方法：获取链表的第一个元素
  DoubleLinklist.prototype.getHead = () =&amp;gt; {
    return this.head.data
  }

  //十二.getTail方法：获取链表的最后一个元素
  DoubleLinklist.prototype.getTail = () =&amp;gt; {
    return this.tail.data
  }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3链表结构总结&#34;&gt;3.链表结构总结&lt;/h1&gt;
&lt;p&gt;单向链表有head和next两个属性，双向链表有head、tail、next、prev四个属性。处理好它们的指向，相当于将它们正确地连接在一起，这样就组成了一条链，这就是简单链表的实现。&lt;/p&gt;
&lt;p&gt;在实际开发中链表使用得非常多，比如Java中的&lt;strong&gt;LinkList&lt;/strong&gt;就是双向链表。&lt;/p&gt;
&lt;h2 id=&#34;31注意点&#34;&gt;3.1.注意点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在链表中current = current.next 可以从左往右看，看成是current --&amp;gt; current.next，即current指向current的下一个节点。&lt;/li&gt;
&lt;li&gt;删除节点的原理：只要没有引用指向该对象，无论该对象是否有引用指向其他对象，该对象都会被回收（删除）。&lt;/li&gt;
&lt;li&gt;参数中凡是有position的都要进行越界判断。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;32链表的增删改查&#34;&gt;3.2.链表的增删改查&lt;/h2&gt;
&lt;p&gt;以双向链表为例：&lt;strong&gt;链表的增删改查无非就是获取链表中相应的节点改变其中的prev和next两个变量的指向。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况一：只需要&lt;strong&gt;head&lt;/strong&gt;和&lt;strong&gt;tail&lt;/strong&gt;两个变量就可以获取需要操作的变量（这里指的是能够轻松获取，当然你想通过head.next.next...或tail.prev.prev...来获取想要的节点也可以），在这种情况下链表的长度length：&lt;strong&gt;0 &amp;lt;= length &amp;lt;=2&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;情况二：不能靠tail和head来获取到需要操作的变量时，可采用while循环遍历的方式，找到需要操作的节点：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612853909360.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在这种情况下，如果我们想要在链表的position = x的位置插入新节点，那么可以通过current获取position的后一个节点Node(x+1)，通过current.prev获取position位置的前一个节点Node(x)；之后修改Node(x+1)和Node(x)中的prev和next两个变量的指向即可在pos=x 的位置插入新节点。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612853922088.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;33修改链表引用指向&#34;&gt;3.3.修改链表引用指向&lt;/h2&gt;
&lt;p&gt;应先修改newNode引用的指向，再修改其他引用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：通过head和tail引用就能获取需要操作的节点时，最后更改head或tail变量的指向（因为它们分别指向链表的第一个和最后一个节点，获取其他节点时可能需要用到它们）。&lt;/li&gt;
&lt;li&gt;情况2：使用current获取到需要操作的节点时，最后更改curren.next或current.prev的指向。因为current.next和current.prev表示的是Node(x+2)和Node(x)这两个节点，如下图所示，一旦变更它们的指向就无法获取Node(x)或Node(x+2)了，&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612853947258.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;34遍历链表&#34;&gt;3.4.遍历链表&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;积累两种遍历思路&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取指定的position = x 位置的后一个节点和索引值：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612853980453.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612853983952.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
循环结束后index = position = x，变量current就指向了Node(x+1)，变量index的值为Node(x+1)的索引值x。&lt;/li&gt;
&lt;li&gt;遍历链表中的所有节点：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612854002125.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612854005730.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当current.next = null时停止循环，此时current指向链表的最后一个节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av86801505?from=search&amp;amp;seid=4967761411915016256&#34;&gt;参考资料：JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现双向链表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/javascript-shi-xian-dan-xiang-lian-biao/"" data-c="
          &lt;h1 id=&#34;1单向链表简介&#34;&gt;1.单向链表简介&lt;/h1&gt;
&lt;p&gt;链表和数组一样，可以用于&lt;strong&gt;存储一系列的元素&lt;/strong&gt;，但是链表和数组的&lt;strong&gt;实现机制完全不同&lt;/strong&gt;。链表的每个元素由一个存储&lt;strong&gt;元素本身的节点&lt;/strong&gt;和一个&lt;strong&gt;指向下一个元素的引用&lt;/strong&gt;（有的语言称为指针或连接）组成。类似于火车头，一节车厢载着乘客（数据），通过节点连接另一节车厢。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612443894132.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612443897959.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612443901003.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;head属性指向链表的第一个节点；&lt;/li&gt;
&lt;li&gt;链表中的最后一个节点指向null；&lt;/li&gt;
&lt;li&gt;当链表中一个节点也没有的时候，head直接指向null；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;链表是链式的存储结构；数组是顺序的存储结构&lt;/code&gt;&lt;br&gt;
&lt;code&gt;链表通过指针来连接元素与元素，数组则是把所有元素按次序依次存储&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数组存在的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组便于查询和修改&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;数组存在的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组的创建通常需要申请一段&lt;strong&gt;连续的内存空间&lt;/strong&gt;（一整块内存），并且大小是固定的。所以当原数组&lt;strong&gt;不能满足容量需求&lt;/strong&gt;时，需要&lt;strong&gt;扩容&lt;/strong&gt;（一般情况下是申请一个更大的数组，比如2倍，然后将原数组中的元素复制过去）。&lt;/li&gt;
&lt;li&gt;在数组的开头或中间位置插入数据的成本很高，需要进行大量元素的位移。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;数组操作时间复杂度：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;查找&lt;br&gt;
即便是排序好的数组，用二分查找，时间复杂度也为O(log2n)。所以正确的表述应该是数组支持随机访问，根据下标随机访问的时间复杂度为O(1)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插入和删除&lt;br&gt;
插入和删除操作对于数组来说比较低效，假设数组的长度为n，现在，如果我们需要将一个数据插入到数组中的第K个位置。为了把第k个位置腾出来，我们需要将第k~n的数据往后挪，那么来分析一下其时间复杂度：&lt;br&gt;
如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果&lt;br&gt;
在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是&lt;br&gt;
O(n)。因为在每个位置插入数据的概率是一样的所以时间复杂度平均为O(n/2)，省略常数1/2，即O(n)。&lt;br&gt;
删除同理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;链表的优势：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链表中的元素在内存中&lt;strong&gt;不必是连续的空间&lt;/strong&gt;，可以充分利用计算机的内存，实现灵活的&lt;strong&gt;内存动态管理&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;链表不必在创建时就&lt;strong&gt;确定大小&lt;/strong&gt;，并且大小可以&lt;strong&gt;无限地延伸&lt;/strong&gt;下去。&lt;/li&gt;
&lt;li&gt;链表在&lt;strong&gt;插入和删除&lt;/strong&gt;数据时，&lt;strong&gt;时间复杂度&lt;/strong&gt;可以达到O(1)，相对数组效率高很多。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;链表的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;寻找某个元素较为困难&lt;/li&gt;
&lt;li&gt;链表访问任何一个位置的元素时，都需要&lt;strong&gt;从头开始访问&lt;/strong&gt;（无法跳过第一个元素访问任何一个元素）。&lt;/li&gt;
&lt;li&gt;无法通过下标值直接访问元素，需要从头开始一个个访问，直到找到对应的元素。&lt;/li&gt;
&lt;li&gt;虽然可以轻松地到达&lt;strong&gt;下一个节点&lt;/strong&gt;，但是回到&lt;strong&gt;前一个节点&lt;/strong&gt;是很难的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;链表中的常见操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;append（element）：向链表尾部添加一个新的项；&lt;/li&gt;
&lt;li&gt;insert（position，element）：向链表的特定位置插入一个新的项；&lt;/li&gt;
&lt;li&gt;get（position）：获取对应位置的元素；&lt;/li&gt;
&lt;li&gt;indexOf（element）：返回元素在链表中的索引。如果链表中没有该元素就返回-1；&lt;/li&gt;
&lt;li&gt;update（position，element）：修改某个位置的元素；&lt;/li&gt;
&lt;li&gt;removeAt（position）：从链表的特定位置移除一项；&lt;/li&gt;
&lt;li&gt;remove（element）：从链表中移除一项；&lt;/li&gt;
&lt;li&gt;isEmpty（）：如果链表中不包含任何元素，返回trun，如果链表长度大于0则返回false；&lt;/li&gt;
&lt;li&gt;size（）：返回链表包含的元素个数，与数组的length属性类似；&lt;/li&gt;
&lt;li&gt;toString（）：由于链表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先需要弄清楚：下文中的position指的是两个节点之间，并且与index的关系如下图所示：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612444098945.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;position的值一般表示position所指位置的下一个节点。当position的值与index的值相等时，比如position = index = 1，那么它们都表示Node2。&lt;/p&gt;
&lt;h1 id=&#34;2封装单向链表类&#34;&gt;2.封装单向链表类&lt;/h1&gt;
&lt;h2 id=&#34;21创建单向链表类&#34;&gt;2.1.创建单向链表类&lt;/h2&gt;
&lt;p&gt;先创建单向链表类Linklist，并添加基本属性，再实现单向链表的常用方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    // 封装单向链表类
    function LinkList(){
      // 封装一个内部类：节点类
      function Node(data){
        this.data = data;
        this.next = null;
      }

      // 属性
      // 属性head指向链表的第一个节点
      this.head = null;
      this.length = 0;
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;22appendelement&#34;&gt;2.2.append(element)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;     // 一.实现append方法
      LinkList.prototype.append = data =&amp;gt; {
        //1.创建新节点
        let newNode = new Node(data)

        //2.添加新节点
        //情况1：只有一个节点时候
        if(this.length == 0){
          this.head = newNode
        //情况2：节点数大于1，在链表的最后添加新节点  
        }else {              
          //让变量current指向第一个节点
          let current = this.head
          //当current.next(下一个节点不为空)不为空时，一直循环，直到current指向最后一个节点
          while (current.next){
            current = current.next
          }
          // 最后节点的next指向新的节点
          current.next = newNode
        }
        //3.添加完新结点之后length+1
        this.length += 1
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先让current指向第一个节点：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612444270200.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;通过while循环使current指向最后一个节点，最后通过current.next = newNode，让最后一个节点指向新节点newNode：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612444281470.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建LinkList
    let list = new LinkList()
    
    //2.测试append方法
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)
    console.log(list);  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612444320368.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;23tostring&#34;&gt;2.3.toString()&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;     // 实现toString方法
      LinkList.prototype.toString = () =&amp;gt; {
        // 1.定义变量
        let current = this.head
        let listString = &amp;quot;&amp;quot;

        // 2.循环获取一个个的节点
        while(current){ 
          listString += current.data + &amp;quot; &amp;quot;
          current = current.next//千万不要忘了拼接完一个节点数据之后，让current指向下一个节点
        }
        return  listString
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建LinkList
    let list = new LinkList()
    
    //2.插入数据
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)
    
    //3.测试toString方法
    console.log(list.toString());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612444411617.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;24insertpositionelement&#34;&gt;2.4.insert(position,element)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    // 实现insert方法
      LinkList.prototype.insert = (position, data) =&amp;gt; {
      //理解positon的含义：position=0表示新界点插入后要成为第1个节点，position=2表示新界点插入后要成为第3个节点
        //1.对position进行越界判断:要求传入的position不能是负数且不能超过LinkList的length
        if(position &amp;lt; 0 || position &amp;gt; this.length){
          return false
        }
        //2.根据data创建newNode
        let newNode = new Node(data)

        //3.插入新节点
        //情况1：插入位置position=0
        if(position == 0){
          // 让新节点指向第一个节点
          newNode.next = this.head
          // 让head指向新节点
          this.head = newNode
        //情况2：插入位置position&amp;gt;0(该情况包含position=length)
        } else{
          let index = 0
          let previous = null
          let current = this.head
          //步骤1：通过while循环使变量current指向position位置的后一个节点(注意while循环的写法)
          while(index++ &amp;lt; position){
          //步骤2：在current指向下一个节点之前，让previous指向current当前指向的节点
            previous = current
            current = current.next
          }
          // 步骤3：通过变量current(此时current已经指向position位置的后一个节点)，使newNode指向position位置的后一个节点
          newNode.next = current
          //步骤4：通过变量previous，使position位置的前一个节点指向newNode
          previous.next = newNode
          /*
            启示：
            1.我们无法直接操作链表中的节点，但是可以通过变量指向这些节点，以此间接地操作节点(替身使者)；
            比如current指向节点3，想要节点3指向节点4只需要：current.next = 4即可。
            2.两个节点间是双向的，想要节点2的前一个节点为节点1，可以通过：1.next=2，来实现；
          */
        }
        //4.新节点插入后要length+1
        this.length += 1;

        return true
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
inset方法实现的过程：根据插入节点位置的不同可分为多种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：position = 0：&lt;br&gt;
通过： newNode.next = this.head，建立连接1；&lt;br&gt;
通过： this.head = newNode，建立连接2；（不能先建立连接2，否则this.head不再指向Node1）&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612444479910.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;情况2：position &amp;gt; 0：&lt;br&gt;
首先定义两个变量previous和curent分别指向需要插入位置pos = X的前一个节点和后一个节点；&lt;br&gt;
然后，通过：newNode.next = current，改变指向3；&lt;br&gt;
最后，通过：previous.next = newNode，改变指向4；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612444504059.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;情况2的特殊情形：position = length：&lt;br&gt;
情况2也包含了pos = length的情况，该情况下current和newNode.next都指向null；建立连接3和连接4的方式与情况2相同。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612444521406.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;     //测试代码
    //1.创建LinkList
    let list = new LinkList()
    
    //2.插入数据
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)
    
    //3.测试insert方法
    list.insert(0, &#39;在链表最前面插入节点&#39;);
    list.insert(2, &#39;在链表中第二个节点后插入节点&#39;);
    list.insert(5, &#39;在链表最后插入节点&#39;);
    alert(list);
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612444552747.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612444561625.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;25getposition&#34;&gt;2.5.get(position)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      //实现get方法
      LinkList.prototype.get = (position) =&amp;gt; {
        //1.越界判断
        // 当position = length时，取到的是null所以0 =&amp;lt; position &amp;lt; length
        if(position &amp;lt; 0 || position &amp;gt;= this.length){
          return null
        }
        //2.获取指定的positon位置的后一个节点的data
        //同样使用一个变量间接操作节点
        let current = this.head
        let index = 0
        while(index++ &amp;lt; position){
          current = current.next
        }
        return current.data
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
get方法的实现过程：以获取position = 2为例，如下图所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先使current指向第一个节点，此时index=0；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612444624072.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;通过while循环使current循环指向下一个节点，注意循环终止的条件index++ &amp;lt; position，即当index=position时停止循环，此时循环了1次，current指向第二个节点(Node2)，最后通过current.data返回Node2节点的数据；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612444638164.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建LinkList
    let list = new LinkList()
    
    //2.插入数据
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)	

	//3.测试get方法
    console.log(list.get(0));
    console.log(list.get(1));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612444676610.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;26indexofelement&#34;&gt;2.6.indexOf(element)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//实现indexOf方法
      LinkList.prototype.indexOf = data =&amp;gt; {
        //1.定义变量
        let current = this.head
        let index = 0

        //2.开始查找:只要current不指向null就一直循环
        while(current){
          if(current.data == data){
            return index
          }
          current = current.next
          index += 1
        } 

        //3.遍历完链表没有找到，返回-1
        return -1
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
indexOf方法的实现过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用变量current记录当前指向的节点，使用变量index记录当前节点的索引值（注意index = node数-1）：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612444722712.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建LinkList
    let list = new LinkList()
    
    //2.插入数据
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)	
    
    //3.测试indexOf方法
    console.log(list.indexOf(&#39;aaa&#39;));
    console.log(list.indexOf(&#39;ccc&#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612444758126.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;27updatepositionelement&#34;&gt;2.7.update(position,element)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;     //实现update方法
      LinkList.prototype.update = (position, newData) =&amp;gt; {
        //1.越界判断
        //因为被修改的节点不能为null，所以position不能等于length
        if(position &amp;lt; 0 || position &amp;gt;= this.length){
          return false
        }
        //2.查找正确的节点
        let current = this.head
        let index = 0
        while(index++ &amp;lt; position){
          current = current.next
        }
        //3.将position位置的后一个节点的data修改成newData
        current.data = newData
        //返回true表示修改成功
        return true
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建LinkList
    let list = new LinkList()
    
    //2.插入数据
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)	
    
    //3.测试update方法
    list.update(0, &#39;修改第一个节点&#39;)
    list.update(1, &#39;修改第二个节点&#39;)
    console.log(list);
    console.log(list.update(3, &#39;能修改么&#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612444815485.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;28removeatposition&#34;&gt;2.8.removeAt(position)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      //实现removeAt方法
      LinkList.prototype.removeAt = position =&amp;gt; {
        //1.越界判断
        if (position &amp;lt; 0 || position &amp;gt;= this.length) {//position不能为length
          return null
        }
        //2.删除元素
        //情况1：position = 0时(删除第一个节点)
        let current = this.head
        if (position ==0 ) {
        //情况2：position &amp;gt; 0时
          this.head = this.head.next
        }else{
          let index = 0
          let previous = null
          while (index++ &amp;lt; position) {
            previous = current
            current = current.next
          }
          //循环结束后，current指向position后一个节点，previous指向current前一个节点
          //再使前一个节点的next指向current的next即可
          previous.next = current.next
        }
        //3，length-1
        this.length -= 1

        //返回被删除节点的data，为此current定义在最上面
        return current.data
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
removeAt方法的实现过程：删除节点时存在多种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：position = 0，即移除第一个节点（Node1）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过：this.head = this.head.next，改变指向1即可；&lt;br&gt;
虽然Node1的next仍指向Node2，但是没有引用指向Node1，则Node1会被垃圾回收器自动回收，所以不用处理Node1指向Node2的引用next。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612444914446.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况2：positon &amp;gt; 0，比如pos = 2即移除第三个节点（Node3）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：position = length时position后一个节点为null不能删除，因此position != length；&lt;br&gt;
首先，定义两个变量previous和curent分别指向需要删除位置pos = x的前一个节点和后一个节点；&lt;br&gt;
然后，通过：previous.next = current.next，改变指向1即可；&lt;br&gt;
随后，没有引用指向Node3，Node3就会被自动回收，至此成功删除Node3 。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612445034409.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建LinkList
    let list = new LinkList()
    
    //2.插入数据
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)
  
  //3.测试removeAt方法
    console.log(list.removeAt(0));
    console.log(list.removeAt(0));
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612445073288.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;29其他方法&#34;&gt;2.9.其他方法&lt;/h2&gt;
&lt;p&gt;其他方法包括：&lt;strong&gt;remove(element)、isEmpty()、size()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/*-------------其他方法的实现--------------*/
      //一.实现remove方法
      LinkList.prototype.remove = (data) =&amp;gt; {
        //1.获取data在列表中的位置
        let position = this.indexOf(data)
        //2.根据位置信息，删除结点
        return this.removeAt(position)
      }

      //二.实现isEmpty方法
      LinkList.prototype.isEmpty = () =&amp;gt; {
        return this.length == 0
      }

      //三.实现size方法
      LinkList.prototype.size = () =&amp;gt; {
        return this.length
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  //测试代码
    //1.创建LinkList
    let list = new LinkList()
    
    //2.插入数据
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)

/*---------------其他方法测试----------------*/
  	//remove方法
  	console.log(list.remove(&#39;aaa&#39;));
  	console.log(list);
  	//isEmpty方法
  	console.log(list.isEmpty());
  	//size方法
  	console.log(list.size());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612445152104.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;210完整实现&#34;&gt;2.10.完整实现&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; // 封装链表类
    function LinkList(){
      // 封装一个内部类：节点类
      function Node(data){
        this.data = data;
        this.next = null;
      }

      // 属性
      // 属性head指向链表的第一个节点
      this.head = null;
      this.length = 0;

      // 一.实现append方法
      LinkList.prototype.append = data =&amp;gt; {
        //1.创建新节点
        let newNode = new Node(data)

        //2.添加新节点
        //情况1：只有一个节点时候
        if(this.length == 0){
          this.head = newNode
        //情况2：节点数大于1，在链表的最后添加新节点  
        }else {              
          //让变量current指向第一个节点
          let current = this.head
          //当current.next(下一个节点不为空)不为空时，一直循环，直到current指向最后一个节点
          while (current.next){
            current = current.next
          }
          // 最后节点的next指向新的节点
          current.next = newNode
        }
        //3.添加完新结点之后length+1
        this.length += 1
      }

      // 二.实现toString方法
      LinkList.prototype.toString = () =&amp;gt; {
        // 1.定义变量
        let current = this.head
        let listString = &amp;quot;&amp;quot;

        // 2.循环获取一个个的节点
        while(current){ 
          listString += current.data + &amp;quot; &amp;quot;
          current = current.next//千万不要忘了拼接完一个节点数据之后，让current指向下一个节点
        }
        return  listString
      }

      // 三.实现insert方法
      LinkList.prototype.insert = (position, data) =&amp;gt; {
      //理解positon的含义：position=0表示新界点插入后要成为第1个节点，position=2表示新界点插入后要成为第3个节点
        //1.对position进行越界判断:要求传入的position不能是负数且不能超过LinkList的length
        if(position &amp;lt; 0 || position &amp;gt; this.length){
          return false
        }
        //2.根据data创建newNode
        let newNode = new Node(data)

        //3.插入新节点
        //情况1：插入位置position=0
        if(position == 0){
          // 让新节点指向第一个节点
          newNode.next = this.head
          // 让head指向新节点
          this.head = newNode
        //情况2：插入位置position&amp;gt;0(该情况包含position=length)
        } else{
          let index = 0
          let previous = null
          let current = this.head
          //步骤1：通过while循环使变量current指向position位置的后一个节点(注意while循环的写法)
          while(index++ &amp;lt; position){
          //步骤2：在current指向下一个节点之前，让previous指向current当前指向的节点
            previous = current
            current = current.next
          }
          // 步骤3：通过变量current(此时current已经指向position位置的后一个节点)，使newNode指向position位置的后一个节点
          newNode.next = current
          //步骤4：通过变量previous，使position位置的前一个节点指向newNode
          previous.next = newNode
          
		//我们无法直接操作链表中的节点，但是可以通过变量指向这些节点，以此间接地操作节点；
        }
        //4.新节点插入后要length+1
        this.length += 1;

        return true
      }

      //四.实现get方法
      LinkList.prototype.get = (position) =&amp;gt; {
        //1.越界判断
        // 当position = length时，取到的是null所以0 =&amp;lt; position &amp;lt; length
        if(position &amp;lt; 0 || position &amp;gt;= this.length){
          return null
        }
        //2.获取指定的positon位置的后一个节点的data
        //同样使用一个变量间接操作节点
        let current = this.head
        let index = 0
        while(index++ &amp;lt; position){
          current = current.next
        }
        return current.data
      }

      //五.实现indexOf方法
      LinkList.prototype.indexOf = data =&amp;gt; {
        //1.定义变量
        let current = this.head
        let index = 0

        //2.开始查找:只要current不指向null就一直循环
        while(current){
          if(current.data == data){
            return index
          }
          current = current.next
          index += 1
        } 

        //3.遍历完链表没有找到，返回-1
        return -1
      }

      //六.实现update方法
      LinkList.prototype.update = (position, newData) =&amp;gt; {
        //1.越界判断
        //因为被修改的节点不能为null，所以position不能等于length
        if(position &amp;lt; 0 || position &amp;gt;= this.length){
          return false
        }
        //2.查找正确的节点
        let current = this.head
        let index = 0
        while(index++ &amp;lt; position){
          current = current.next
        }
        //3.将position位置的后一个节点的data修改成newData
        current.data = newData
        //返回true表示修改成功
        return true
      }

      //七.实现removeAt方法
      LinkList.prototype.removeAt = position =&amp;gt; {
        //1.越界判断
        if (position &amp;lt; 0 || position &amp;gt;= this.length) {
          return null
        }
        //2.删除元素
        //情况1：position = 0时(删除第一个节点)
        let current = this.head
        if (position ==0 ) {
        //情况2：position &amp;gt; 0时
          this.head = this.head.next
        }else{
          let index = 0
          let previous = null
          while (index++ &amp;lt; position) {
            previous = current
            current = current.next
          }
          //循环结束后，current指向position后一个节点，previous指向current前一个节点
          //再使前一个节点的next指向current的next即可
          previous.next = current.next
        }
        //3，length-1
        this.length -= 1

        //返回被删除节点的data，为此current定义在最上面
        return current.data
      }

/*-------------其他方法的实现--------------*/
      //八.实现remove方法
      LinkList.prototype.remove = (data) =&amp;gt; {
        //1.获取data在列表中的位置
        let position = this.indexOf(data)
        //2.根据位置信息，删除结点
        return this.removeAt(position)
      }

      //九.实现isEmpty方法
      LinkList.prototype.isEmpty = () =&amp;gt; {
        return this.length == 0
      }

      //十.实现size方法
      LinkList.prototype.size = () =&amp;gt; {
        return this.length
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1x7411L7Q7?from=search&amp;amp;seid=3912456004602554239&#34;&gt;参考资料:JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现单向链表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/javascript-shi-xian-dui-lie-jie-gou-queue/"" data-c="
          &lt;h1 id=&#34;1队列简介&#34;&gt;1.队列简介&lt;/h1&gt;
&lt;p&gt;队列是是一种受限的线性表，特点为&lt;strong&gt;先进先出&lt;/strong&gt;（&lt;strong&gt;FIFO&lt;/strong&gt;：first in first out）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;受限之处在于它只允许在表的&lt;strong&gt;前端&lt;/strong&gt;（front）进行删除操作；&lt;/li&gt;
&lt;li&gt;在表的&lt;strong&gt;后端&lt;/strong&gt;（rear）进行插入操作；&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612359092282.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
相当于排队买票，先来的先买票，后来的后买票。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612359106480.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;队列的应用&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打印队列：计算机打印多个文件的时候，需要排队打印；&lt;/li&gt;
&lt;li&gt;线程队列：当开启多线程时，当新开启的线程所需的资源不足时就先放入线程队列，等待CPU处理；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;队列类的实现&lt;/strong&gt;：&lt;br&gt;
队列的实现和栈一样，有两种方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于数组实现；&lt;/li&gt;
&lt;li&gt;基于链表实现；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;队列的常见操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;enqueue（element）：向队列尾部添加一个（或多个）新的项；&lt;/li&gt;
&lt;li&gt;dequeue（）：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素；&lt;/li&gt;
&lt;li&gt;front（）：返回队列中的第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息与Stack类的peek方法非常类似）；&lt;/li&gt;
&lt;li&gt;isEmpty（）：如果队列中不包含任何元素，返回true，否则返回false；&lt;/li&gt;
&lt;li&gt;size（）：返回队列包含的元素个数，与数组的length属性类似；&lt;/li&gt;
&lt;li&gt;toString（）：将队列中的内容，转成字符串形式；&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2封装队列类&#34;&gt;2.封装队列类&lt;/h1&gt;
&lt;h2 id=&#34;21代码实现&#34;&gt;2.1.代码实现&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;    // 基于数组封装队列类
    function Queue() {
    // 属性
      this.items = []
      
    // 方法
    // 1.enqueue():将元素加入到队列中
    Queue.prototype.enqueue = element =&amp;gt; {
      this.items.push(element)
    }

    // 2.dequeue():从队列中删除前端元素
    Queue.prototype.dequeue = () =&amp;gt; {
      return this.items.shift()
    }

    // 3.front():查看前端的元素
    Queue.prototype.front = () =&amp;gt; {
      return this.items[0]
    }

    // 4.isEmpty:查看队列是否为空
    Queue.prototype.isEmpty = () =&amp;gt; {
      return this.items.length == 0;
    }

    // 5.size():查看队列中元素的个数
    Queue.prototype.size = () =&amp;gt; {
      return this.items.length
    }

    // 6.toString():将队列中元素以字符串形式输出
    Queue.prototype.toString = () =&amp;gt; {
      let resultString = &#39;&#39;
        for (let i of this.items){
          resultString += i + &#39; &#39;
        }
        return resultString
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;    // 创建队列
    let queue = new  Queue()

    // 将元素加入到队列中
    queue.enqueue(&#39;a&#39;)
    queue.enqueue(&#39;b&#39;)
    queue.enqueue(&#39;c&#39;)
    queue.enqueue(&#39;d&#39;)
    console.log(queue);												

    // 从队列中删除元素
    queue.dequeue()
    console.log(queue);											
    queue.dequeue()
    console.log(queue);											

    //front
    console.log(queue.front());								 		
    
    // 验证其他方法
    console.log(queue.isEmpty());								 	
    console.log(queue.size());								 	
    console.log(queue.toString());								 	
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612359291030.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;22队列的应用&#34;&gt;2.2.队列的应用&lt;/h2&gt;
&lt;p&gt;使用队列实现小游戏：击鼓传花，传入一组数据和设定的数字num，循环遍历数组内元素，遍历到的元素为指定数字num时将该元素删除，直至数组剩下一个元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;    // 队列应用：面试题：击鼓传花
    let passGame = (nameList, num) =&amp;gt; {
      //1.创建队列结构
      let queue = new Queue()

      //2.将所有人依次加入队列
      // 这是ES6的for循环写法，i相当于nameList[i]
      for(let i of nameList){
        queue.enqueue(i)
      }
      

      // 3.开始数数
     while(queue.size() &amp;gt; 1){//队列中只剩1个人就停止数数
      // 不是num的时候，重新加入队列末尾
      // 是num的时候，将其从队列中删除
      // 3.1.num数字之前的人重新放入队列的末尾(把队列前面删除的加到队列最后)
      for(let i = 0; i&amp;lt; num-1; i++ ){
        queue.enqueue(queue.dequeue())
      }
      // 3.2.num对应这个人，直接从队列中删除
      /*
        思路是这样的，由于队列没有像数组一样的下标值不能直接取到某一元素，所以采用，把num前面的num-1个元素先删除后添加到队列末尾，这样第num个元素就排到了队列的最前面，可以直接使用dequeue方法进行删除
      */
      queue.dequeue()
     }

      //4.获取剩下的那个人
      console.log(queue.size());									
      let endName = queue.front()
      console.log(&#39;最终剩下的人：&#39; + endName);						   	
      
      return nameList.indexOf(endName);
    }

    //5.测试击鼓传花
    let names = [&#39;lily&#39;, &#39;lucy&#39;, &#39;Tom&#39;, &#39;Lilei&#39;, &#39;Tony&#39;]
    console.log(passGame(names, 3));		
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612359343343.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3优先队列&#34;&gt;3.优先队列&lt;/h1&gt;
&lt;p&gt;优先级队列主要考虑的问题为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个元素不再只是一个数据，还包含数据的优先级；&lt;/li&gt;
&lt;li&gt;在添加数据过程中，根据优先级放入到正确位置；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;31优先级队列的实现&#34;&gt;3.1.优先级队列的实现&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;    // 封装优先级队列
    function PriorityQueue() {

      //内部类：在类里面再封装一个类;表示带优先级的数据
      function QueueElement(element, priority) {
        this.element = element;
        this.priority = priority;
      } 

      // 封装属性
      this.items = []

      // 1.实现按照优先级插入方法
      PriorityQueue.prototype.enqueue = (element, priority) =&amp;gt; {
        // 1.1.创建QueueElement对象
        let queueElement = new QueueElement(element, priority)

        // 1.2.判断队列是否为空
        if(this.items.length == 0){
          this.items.push(queueElement)
        }else{
          // 定义一个变量记录是否成功添加了新元素
          let added = false
          for(let i of this.items){
            // 让新插入的元素与原有元素进行优先级比较(priority越小，优先级越大)
            if(queueElement.priority &amp;lt; i.priority){
              this.items.splice(i, 0, queueElement)
              added = true
              // 新元素已经找到插入位置了可以使用break停止循环
              break
            }
          }
          // 新元素没有成功插入，就把它放在队列的最前面
          if(!added){
            this.items.push(queueElement)
          }
        }
      }

      // 2.dequeue():从队列中删除前端元素
      PriorityQueue.prototype.dequeue = () =&amp;gt; {
        return this.items.shift()
      }

      // 3.front():查看前端的元素
      PriorityQueue.prototype.front = () =&amp;gt; {
        return this.items[0]
      }

      // 4.isEmpty():查看队列是否为空
      PriorityQueue.prototype.isEmpty = () =&amp;gt; {
        return this.items.length == 0;
      }

      // 5.size():查看队列中元素的个数
      PriorityQueue.prototype.size = () =&amp;gt; {
        return this.items.length
      }

      // 6.toString():以字符串形式输出队列中的元素
      PriorityQueue.prototype.toString = () =&amp;gt; {
        let resultString = &#39;&#39;
          for (let i of this.items){
            resultString += i.element + &#39;-&#39; + i.priority + &#39; &#39;
          }
          return resultString
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;  // 测试代码
    let pq = new PriorityQueue();
    pq.enqueue(&#39;Tom&#39;,111);
    pq.enqueue(&#39;Hellen&#39;,200);
    pq.enqueue(&#39;Mary&#39;,30);
    pq.enqueue(&#39;Gogo&#39;,27);
    // 打印修改过后的优先队列对象
    console.log(pq);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612359507202.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;32注意点&#34;&gt;3.2.注意点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;关于数组方法splice用法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;splice（1，0，&#39;Tom&#39;）：表示在索引为1的元素前面插入元素’Tom‘（也可以理解为从索引为1的元素开始删除，删除0个元素，再在索引为1的元素前面添加元素&#39;Tom&#39;）；&lt;/li&gt;
&lt;li&gt;splice（1，1，&#39;Tom&#39;）：表示从索引为1的元素开始删除（包括索引为1的元素），共删除1个元素，并添加元素&#39;Tom&#39;。即把索引为1的元素替换为元素&#39;Tom&#39;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;数组的push方法在数组、栈和队列中的形式：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数组&lt;/strong&gt;：在数组[0，1，2]中，pop(3)，结果为[0，1，2，3]；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;栈&lt;/strong&gt;：执行pop(0)，pop(1)，pop(2)，pop(3)，从栈底到栈顶的元素分别为：0，1，2，3；如果看成数组，可写为[0，1，2，3]，但是索引为3的元素3其实是栈顶元素；所以说栈的push方法是向栈顶添加元素（但在数组的视角下为向数组尾部添加元素）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;队列&lt;/strong&gt;：enqueue方法可以由数组的push方法实现，与数组相同，相当于在数组尾部添加元素。&lt;br&gt;
可以这样想：栈结构是头朝下（索引值由下往上增大）的数组结构。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612359579513.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1x7411L7Q7?from=search&amp;amp;seid=3912456004602554239&#34;&gt;参考资料:JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现队列结构（Queue）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/javascript-shu-ju-jie-gou-yu-suan-fa-shi-xian-zhan-jie-gou-stack/"" data-c="
          &lt;h1 id=&#34;1前言&#34;&gt;1.前言&lt;/h1&gt;
&lt;h2 id=&#34;11-什么是数据结构&#34;&gt;1.1 什么是数据结构？&lt;/h2&gt;
&lt;p&gt;数据结构就是在计算机中，存储和组织数据的方式。&lt;br&gt;
例如：图书管理，怎样摆放图书才能既能放很多书，也方便取？&lt;/p&gt;
&lt;p&gt;主要需要考虑两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作一：新书怎么插入？&lt;/li&gt;
&lt;li&gt;操作二：怎么找到某本指定的书？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;常见的数据结构：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组（Aarray）&lt;/li&gt;
&lt;li&gt;栈（Stack）&lt;/li&gt;
&lt;li&gt;链表（Linked List）&lt;/li&gt;
&lt;li&gt;图（Graph）&lt;/li&gt;
&lt;li&gt;散列表（Hash）&lt;/li&gt;
&lt;li&gt;队列（Queue）&lt;/li&gt;
&lt;li&gt;树（Tree）&lt;/li&gt;
&lt;li&gt;堆（Heap）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：数据结构与算法与语言无关，常见的编程语言都有&lt;strong&gt;直接或间接&lt;/strong&gt;的使用上述常见的数据结构。&lt;/p&gt;
&lt;h2 id=&#34;12什么是算法&#34;&gt;1.2.什么是算法？&lt;/h2&gt;
&lt;p&gt;算法（Algorithm）的定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个有限指令集，每条指令的描述不依赖于语言；&lt;/li&gt;
&lt;li&gt;接收一些输入（有些情况下不需要输入）；&lt;/li&gt;
&lt;li&gt;产生输入；&lt;/li&gt;
&lt;li&gt;一定在有限步骤之后终止；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;算法通俗理解：解决问题的办法/步骤逻辑。数据结构的实现，离不开算法。&lt;/p&gt;
&lt;h1 id=&#34;2栈结构stack&#34;&gt;2.栈结构（Stack）&lt;/h1&gt;
&lt;h2 id=&#34;21简介&#34;&gt;2.1简介&lt;/h2&gt;
&lt;p&gt;数组是一个线性结构，并且可以在数组的&lt;strong&gt;任意位置&lt;/strong&gt;插入和删除元素。而&lt;strong&gt;栈和队列&lt;/strong&gt;就是比较常见的&lt;strong&gt;受限的线性结构&lt;/strong&gt;。如下图所示：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612336192859.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
栈的特点为&lt;strong&gt;先进后出，后进先出&lt;/strong&gt;（LIFO：last in first out）。&lt;/p&gt;
&lt;p&gt;程序中的栈结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;函数调用栈&lt;/strong&gt;：A（B（C（D（））））：即A函数中调用B，B调用C，C调用D；在A执行的过程中会将A压入栈，随后B执行时B也被压入栈，函数C和D执行时也会被压入栈。所以当前栈的顺序为：A-&amp;gt;B-&amp;gt;C-&amp;gt;D（栈顶）；函数D执行完之后，会弹出栈被释放，弹出栈的顺序为D-&amp;gt;C-&amp;gt;B-&amp;gt;A;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;递归&lt;/strong&gt;：为什么没有停止条件的递归会造成栈溢出？比如函数A为递归函数，不断地调用自己（因为函数还没有执行完，不会把函数弹出栈），不停地把相同的函数A压入栈，最后造成&lt;strong&gt;栈溢出&lt;/strong&gt;（Stack Overfloat）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.练习：题目：有6个元素6，5，4，3，2，1按顺序进栈，问下列哪一个不是合法的出栈顺序？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A：5	4	3	6	1	2	（√）&lt;/li&gt;
&lt;li&gt;B：4 5 3 2 1 6 （√）&lt;/li&gt;
&lt;li&gt;C：3 4 6 5 2 1 （×）&lt;/li&gt;
&lt;li&gt;D：2 3 4 1 5 6 （√）&lt;br&gt;
题目所说的按顺序进栈指的不是一次性全部进栈，而是有进有出，进栈顺序为6 -&amp;gt; 5 -&amp;gt; 4 -&amp;gt; 3 -&amp;gt; 2 -&amp;gt; 1。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A答案：65进栈，5出栈，4进栈出栈，3进栈出栈，6出栈，21进栈，1出栈，2出栈（整体入栈顺序符合654321）;&lt;/li&gt;
&lt;li&gt;B答案：654进栈，4出栈，5出栈，3进栈出栈，2进栈出栈，1进栈出栈，6出栈（整体的入栈顺序符合654321）;&lt;/li&gt;
&lt;li&gt;C答案：6543进栈，3出栈，4出栈，之后应该5出栈而不是6，所以错误；&lt;/li&gt;
&lt;li&gt;D答案：65432进栈，2出栈，3出栈，4出栈，1进栈出栈，5出栈，6出栈。符合入栈顺序；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;栈常见的操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;push（element）：添加一个新元素到栈顶位置；&lt;/li&gt;
&lt;li&gt;pop（）：移除栈顶的元素，同时返回被移除的元素；&lt;/li&gt;
&lt;li&gt;peek（）：返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）；&lt;/li&gt;
&lt;li&gt;isEmpty（）：如果栈里没有任何元素就返回true，否则返回false；&lt;/li&gt;
&lt;li&gt;size（）：返回栈里的元素个数。这个方法和数组的length属性类似；&lt;/li&gt;
&lt;li&gt;toString（）：将栈结构的内容以字符串的形式返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;22封装栈类&#34;&gt;2.2封装栈类&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    // 封装栈类
    function Stack(){
      // 栈中的属性
      this.items =[]

      // 栈的相关操作
      // 1.push():将元素压入栈
      //方式一(不推荐)：给对象添加方法，其他对象不能复用
      // this.push = () =&amp;gt; {
      // }
      
      //方式二(推荐)：给Stack类添加方法，能够多对象复用
      Stack.prototype.push = function(element) {
      // 利用数组item的push方法实现Stack类的pop方法
        this.items.push(element)
      }

      // 2.pop():从栈中取出元素
      Stack.prototype.pop = () =&amp;gt; {
      // 利用数组item的pop方法实现Stack类的pop方法
        return this.items.pop()
      }

      // 3.peek():查看一下栈顶元素
      Stack.prototype.peek = () =&amp;gt; {
        return this.items[this.items.length - 1]
      }

      // 4.isEmpty():判断栈是否为空
      Stack.prototype.isEmpty = () =&amp;gt; {
      // 两个小时的教训啊不是this.length(不是Stack对象的length，Stack类没有length属性啊)，而是			Stack类中定义的数组items才有length属性呀
        return this.items.length == 0 
      }

      // 5.size():获取栈中元素的个数
      Stack.prototype.size = () =&amp;gt; {
        return this.items.length
      }

      // 6.toString():以字符串形式输出栈内数据
      Stack.prototype.toString = () =&amp;gt; {
        //希望输出的形式：20 10 12 8 7
        let resultString = &#39;&#39;
        for (let i of this.items){
          resultString += i + &#39; &#39;
        }
        return resultString
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    // 栈的使用
    let  s = new Stack()
    s.push(20)
    s.push(10)
    s.push(100)
    s.push(77)
    console.log(s)													//65

    console.log(s.pop());											//68
    console.log(s.pop());											//69
    
    console.log(s.peek());											//71
	console.log(s.isEmpty());										//72
   
    console.log(s.size());											//74
    console.log(s.toString());			
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612336478157.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;栈结构的简单应用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;利用栈结构的特点封装十进至转换为二进至的函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;     //简单应用：
    //封装函数：将十进制转成二进制(十转二的运算最后倒叙取余的特点符合栈&#39;先进后出&#39;)
    let dec2bin = decNumber =&amp;gt; {
      //1.定义一个栈对象，保存余数
      var  stack = new Stack()

      // 2.循环操作
      while(decNumber &amp;gt; 0){
        // 2.1.获取余数并放入栈中
        stack.push(decNumber % 2)
        // 2.2.获取整除后的结果作为下一次运算的数字(floor:向下取整)
        decNumber = Math.floor(decNumber / 2)
      }

      // 3.从栈中取出0和1
      let  binaryString = &#39;&#39;;
      let a = stack.items.length
     while(stack.items.length != 0){
        binaryString += stack.pop();
      }
      return binaryString;
    }
    
    //测试代码
    console.log(dec2bin(10));										
    console.log(dec2bin(100));										
    console.log(dec2bin(1000));				
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612336555837.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV1x7411L7Q7?from=search&amp;amp;seid=3912456004602554239&#34;&gt;参考资料：JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现栈结构（Stack）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/ji-suan-ji-wang-luo-bi-ji-part6-ying-yong-ceng-application-layer/"" data-c="
          &lt;h1 id=&#34;1-概述&#34;&gt;1. 概述&lt;/h1&gt;
&lt;p&gt;因为不同的网络应用之间需要有一个确定的通信规则&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612273015782.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;11-两种常用的网络应用模型&#34;&gt;1.1 两种常用的网络应用模型&lt;/h2&gt;
&lt;h3 id=&#34;111-客户服务器模型clientserver&#34;&gt;1.1.1 客户/服务器模型（Client/Server）&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612273041065.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;112-p2p模型peer-to-peer&#34;&gt;1.1.2 P2P模型（Peer-to-Peer）&lt;/h3&gt;
&lt;p&gt;网络健壮性指的是P2P模型不容易坏掉，即使一个节点坏了也没问题，可以有其他节点代替&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612273076632.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;2-域名系统协议dns&#34;&gt;2. 域名系统协议（DNS）&lt;/h1&gt;
&lt;h2 id=&#34;21-概述&#34;&gt;2.1 概述&lt;/h2&gt;
&lt;p&gt;DNS就是将打在地址栏的域名转化为IP地址的东西&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612273105853.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;211-域名&#34;&gt;2.1.1 域名&lt;/h3&gt;
&lt;p&gt;域名就是www.xxx.com，当然这是最简单的一种&lt;br&gt;
.com之后还可以有东西，称之为根&lt;br&gt;
域名从左向右，级别逐渐增高&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612273137155.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612273140326.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;22-域名服务器dns服务器&#34;&gt;2.2 域名服务器（DNS服务器）&lt;/h2&gt;
&lt;p&gt;DNS服务器有很多台，根据层次结构分为三层，根域名服务器，顶级域名服务器，权限域名服务器&lt;br&gt;
本地域名服务器不算层次结构，特点是里主机比较近，当主机和另一台比较近的主机通信时，就不用走哪些更高级的服务器了&lt;br&gt;
根域名服务器并不是一个域名只有一台，而是一个域名对应多台域名服务器，全世界一共有13个这样的域名，分别是a.rootservers.net，b.rootservers.net，c.rootservers.net，~m.rootservers.net&lt;br&gt;
在权限域名服务器中，虽然看似abc.com比y.abc.com少了一位，但是他们的&lt;strong&gt;地位仍是对等的&lt;/strong&gt;，对应的两台权限域名服务器&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612273183064.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;23-域名解析过程&#34;&gt;2.3 域名解析过程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612273223655.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612273226529.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;231-递归查询&#34;&gt;2.3.1 递归查询&lt;/h3&gt;
&lt;p&gt;在上图中&lt;br&gt;
主机先是想本地域名服务器发送请求，如果查不到的话，&lt;br&gt;
&lt;code&gt;本地域名服务器&lt;/code&gt;向根域名服务器发送请求（找别人），如果还是查不到的话，&lt;br&gt;
&lt;code&gt;根域名域名服务器&lt;/code&gt;向顶级域名服务器发送请求（找别人），如果还是查不到的话，&lt;br&gt;
&lt;code&gt;顶级域名服务器&lt;/code&gt;向权限域名服务器发送请求（找别人）&lt;br&gt;
可以看到每一次向下一个查询的服务器都变了，不是主机一个个去问，而是&lt;code&gt;服务器自己一个个问下去&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;232-迭代查询&#34;&gt;2.3.2 迭代查询&lt;/h3&gt;
&lt;p&gt;在上图中&lt;br&gt;
主机先是想本地域名服务器发送请求，如果查不到的话，&lt;br&gt;
本地域名服务器就让&lt;code&gt;主机&lt;/code&gt;去向根域名服务器发送请求（主机去找，本地域名给目标根域名服务器的IP地址），如果还是查不到的话，&lt;br&gt;
根域名域名服务器让&lt;code&gt;主机&lt;/code&gt;去向对应的顶级域名服务器发送请求（主机去找，根域名给目标顶级域名服务器的IP地址），如果还是查不到的话，&lt;br&gt;
顶级域名服务器让&lt;code&gt;主机&lt;/code&gt;去向权限域名服务器发送请求（主机去找，顶级域名给目标权限域名服务器的IP地址）&lt;br&gt;
可以看到这里是&lt;code&gt;主机&lt;/code&gt;一个个挨个问的地址&lt;/p&gt;
&lt;h3 id=&#34;233-高速缓存&#34;&gt;2.3.3 高速缓存&lt;/h3&gt;
&lt;p&gt;为了减少多次查询同一个域名的资源浪费，&lt;code&gt;本地域名服务器&lt;/code&gt;会存储最近使用的ip地址解析，下次再访问同一个域名就不需要这么多查询步骤了。同时这个高速缓存&lt;code&gt;主机本身也有存储&lt;/code&gt;&lt;br&gt;
同时本地域名服务器还可以对顶级域名服务器，权限域名服务器的地址进行缓存，下一次即使是不知道的ip地址，查询也可以更快&lt;br&gt;
高速缓存为了保持正确性，需要定时更新&lt;/p&gt;
&lt;h1 id=&#34;3-文件传输协议ftptftp&#34;&gt;3. 文件传输协议（FTP，TFTP）&lt;/h1&gt;
&lt;h2 id=&#34;31-概述&#34;&gt;3.1 概述&lt;/h2&gt;
&lt;p&gt;TFTP是一个轻量的，比较容易实现的，面对小文件的，UDP的文件传输协议&lt;br&gt;
这里我们重点是FTP协议&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612273377105.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-ftp的服务端和客户端&#34;&gt;3.2 FTP的服务端和客户端&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612273399779.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;33-ftp的工作原理&#34;&gt;3.3 FTP的工作原理&lt;/h2&gt;
&lt;p&gt;为什么有匿名登陆：对于一些公共服务器来说，增加验证阶段就是增加资源开销，减少验证阶段就可以节省资源来更好地服务&lt;br&gt;
主进程和从属进程的区别：主进程是打开端口，让外部发送的数据可以进来，并且将这些数据逐个分配各从属进程。从属进程则是单独为这些数据服务&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612273431637.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612273434321.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
先注释一下这里的主进程被忽略掉了，只是没标在上面，不是没有啊&lt;br&gt;
这里客户端和服务器端先建立TCP连接，端口是21，称为控制连接&lt;br&gt;
然后看情况是主动建立连接还是被动建立连接&lt;br&gt;
主动建立连接是指服务器端主动发送请求和客户端进行连接，此时端口号固定是20&lt;br&gt;
被动连接是指客户端发送请求和服务器端建立数据传送连接，此时端口号是不确定，有两者协商得到&lt;br&gt;
数据传输完成之后，数据连接断开，控制连接继续保持，直至两边发送断开请求&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612273448354.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;FTP的两种传输模式了解即可&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612273464576.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;4-电子邮件&#34;&gt;4. 电子邮件&lt;/h1&gt;
&lt;h2 id=&#34;41-概述&#34;&gt;4.1 概述&lt;/h2&gt;
&lt;h3 id=&#34;411-电子邮件的格式&#34;&gt;4.1.1 电子邮件的格式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612273598681.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;412-电子邮件系统的组成结构&#34;&gt;4.1.2 电子邮件系统的组成结构&lt;/h3&gt;
&lt;p&gt;注释：&lt;br&gt;
用户代理的四个功能解释：&lt;br&gt;
撰写就是给用户编辑信件的环境&lt;br&gt;
显示就是可以看到自己写的和自己收的信件内容&lt;br&gt;
处理就是对信件进行操作，包括删除，打印，转发等等&lt;br&gt;
通信就是可以将邮件发送到&lt;strong&gt;邮件服务器当中&lt;/strong&gt;，同时可以从&lt;strong&gt;邮件服务器当中&lt;/strong&gt;读取邮件&lt;/p&gt;
&lt;p&gt;邮件服务器的功能注释&lt;br&gt;
邮件服务器端的发送和接受是指从自己的&lt;strong&gt;用户代理处接收邮件&lt;/strong&gt;，之后&lt;strong&gt;向对面的邮件服务器发送邮件&lt;/strong&gt;&lt;br&gt;
邮件服务器的报告邮件发送结果就是投递是否成功这种情况&lt;br&gt;
邮件服务器既可以作为客户端又可以作为服务器端，使用的是C/S方式&lt;/p&gt;
&lt;p&gt;协议的功能注释&lt;br&gt;
发邮件用的是SMTP&lt;br&gt;
收邮件的是POP3或者IMAP&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612273640637.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612273652798.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;42-几个邮件协议&#34;&gt;4.2 几个邮件协议&lt;/h2&gt;
&lt;h3 id=&#34;421-简单邮件传送协议smtp&#34;&gt;4.2.1 简单邮件传送协议SMTP&lt;/h3&gt;
&lt;p&gt;注意一下，这里STMP客户和服务器不是固定死的，可以也可以成为服务器，服务器也可以成为用户，由发送方和接收方决定，发送方就是客户，接收方就是服务器&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612273682225.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注释&lt;br&gt;
可以看见这里比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;220 service ready
250 OK
421 service not available
550 xxx
354 xxx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;都是应答信息&lt;/p&gt;
&lt;p&gt;这里RCPT能有多条命令的原因是，电子邮件可以有多个收件人，就是群发，所以允许多个RCPT&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;再强调一下，这里服务器和客户端可以互换，视具体情况而定，发送方是客户端，接收方是服务器端&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612273748438.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;422-改进smtp缺点的mime协议&#34;&gt;4.2.2 改进SMTP缺点的MIME协议&lt;/h3&gt;
&lt;p&gt;MIME改善SMTP发送数据的缺点，是SMTP的功能性扩展&lt;br&gt;
MIME协议已经逐渐开始应用到浏览器当中，通过对不同文件类型用不同的标识符标识，来让浏览器读取通过MIME的相关文件&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612273765867.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;423-邮局协议pop3&#34;&gt;4.2.3 邮局协议POP3&lt;/h3&gt;
&lt;p&gt;这里接收方是客户端，邮件服务器是服务器端&lt;br&gt;
POP3确实很简单，但是有不少缺点，比较难受的就是邮件一旦下载就自动删除了&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612273790716.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;424-比较复杂的读取邮件的协议imap协议&#34;&gt;4.2.4 比较复杂的读取邮件的协议——IMAP协议&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612273808897.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;43-基于万维网的电子邮件&#34;&gt;4.3 基于万维网的电子邮件&lt;/h2&gt;
&lt;p&gt;与之前的不同的地方就是，基于万维网的电子邮件的&lt;strong&gt;邮件服务器端可以不同&lt;/strong&gt;&lt;br&gt;
同时，发送邮件使用的SMTP/MIME和收邮件时的POP3/IMAP协议都&lt;strong&gt;换成了HTTP协议&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612273840716.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;5-万维网和http协议&#34;&gt;5. 万维网和HTTP协议&lt;/h1&gt;
&lt;h2 id=&#34;51-万维网概述&#34;&gt;5.1 万维网概述&lt;/h2&gt;
&lt;p&gt;URL用来标识整个互联网当中的某一个资源（文字，视屏，音频等）的位置&lt;/p&gt;
&lt;p&gt;HTTP用来将这些资源传送给用户&lt;/p&gt;
&lt;p&gt;HTML帮助设计者来设计页面，让不同设计者设计的页面都可以在界面上显示&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612273871245.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;52-http协议&#34;&gt;5.2 HTTP协议&lt;/h2&gt;
&lt;h3 id=&#34;521-http协议的过程&#34;&gt;5.2.1 HTTP协议的过程&lt;/h3&gt;
&lt;p&gt;这张图里讲了HTTP的具体过程&lt;/p&gt;
&lt;p&gt;服务器通过TCP 80端口来监听HTTP请求&lt;/p&gt;
&lt;p&gt;注意HTTP可以不一次性下载完页面的所有资源，可以只下载文本部分，其他音频视频等待用户下一步请求之后再传输&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612273896774.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;522-http协议的特点&#34;&gt;5.2.2 HTTP协议的特点&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612273916610.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;523-http的连接方式持久连接和非持久连接&#34;&gt;5.2.3 HTTP的连接方式——持久连接和非持久连接&lt;/h3&gt;
&lt;p&gt;非持久连接在TCP三次握手的第三次握手时发生，将HTTP请求作为第三次握手的数据部分发给服务器，服务器收到请求之后将HTTP相应报文传输给客户。耗时就是RTT*2+文档传输时间。&lt;br&gt;
缺点就是这样如果再想传输，那么就需要重新建立TCP连接从头开始&lt;/p&gt;
&lt;p&gt;持久连接和非持久连接类似，都是在第三次握手时发生，将HTTP请求作为第三次握手的数据部分发给服务器，服务器收到请求之后将HTTP相应报文传输给客户。但是持久连接再需要请资源的时候就不需要建立新的TCP连接了&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612273937976.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;持久连接的两种方式非流水线和流水线&#34;&gt;持久连接的两种方式——非流水线和流水线&lt;/h2&gt;
&lt;p&gt;非流水线就是发一个，确认一个，才能再发下一个&lt;br&gt;
流水线就是一个个连着发，然后多个确认&lt;br&gt;
和之前说过的停止等待协议，后退N帧协议和选择重传协议很像，忘了的话可以去复习一下&lt;br&gt;
开个传送门&lt;a href=&#34;https://ttarea.com/post/ji-suan-ji-wang-luo-bi-ji-part3-shu-ju-lian-lu-ceng-data-link-layer/&#34;&gt;计算机网络笔记Part3 数据链路层（Data Link Layer）&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;524-http的报文结构&#34;&gt;5.2.4 HTTP的报文结构&lt;/h3&gt;
&lt;p&gt;开始行用于区别请求报文和响应报文。可以明显的看到两者第一行的东西都不一样&lt;/p&gt;
&lt;p&gt;请求报文的方法是指命令，就是对所请求的对象进行什么操作，如获取/删除等等&lt;br&gt;
URL就是之间说的资源标识符&lt;br&gt;
版本是指使用的是什么版本的HTTP协议&lt;/p&gt;
&lt;p&gt;CRLF相当于我们程序里面的；，标识一行的结束。同时，在整个首部行结束时，为了区别首部行和实体主体还会有一行单独的CRLF&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612274029654.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里举了请求报文的例子，和一些常用的状态码&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612274047064.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;6-本章思维导图&#34;&gt;6. 本章思维导图&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612274078846.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;本章常用中英文对照&#34;&gt;本章常用中英文对照&lt;/h1&gt;
&lt;p&gt;Server farm 服务器集群&lt;br&gt;
Infrastructure 基础设施，或基础架构&lt;br&gt;
Self-scalability 自扩展性&lt;br&gt;
Timing 实时性&lt;br&gt;
Connection-oriented service 面向连接的服务&lt;br&gt;
Base HTML file 基本HTML文件&lt;br&gt;
Stateless protocol 无状态协议&lt;br&gt;
RTT (round-trip time ) 往返时间&lt;br&gt;
User agents 用户代理&lt;br&gt;
Mail servers 邮件服务器&lt;br&gt;
Top-level domain (TLD) servers 顶级域名服务器&lt;br&gt;
Authoritative DNS servers P161 权威域名服务器&lt;br&gt;
Iterative queries 迭代查询&lt;br&gt;
Resource records (RRs) 资源记录&lt;br&gt;
Nonpersistent HTTP 非持久HTTP，或非坚持HTTP&lt;br&gt;
Persistent HTTP 持久性HTTP，或坚持的HTTP&lt;br&gt;
Peer-to-Peer (P2P) Network 对等网络&lt;br&gt;
Socket programming 套接字编程&lt;/p&gt;
&lt;p&gt;参考资料&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV19E411D78Q?p=1&#34;&gt;2019 王道考研 计算机网络&lt;/a&gt;&lt;/p&gt;
">计算机网络笔记Part6 应用层（Application Layer）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/ji-suan-ji-wang-luo-bi-ji-part5-chuan-shu-ceng-transport-layer/"" data-c="
          &lt;h1 id=&#34;1-概述&#34;&gt;1. 概述&lt;/h1&gt;
&lt;h2 id=&#34;11-传输层的意义&#34;&gt;1.1 传输层的意义&lt;/h2&gt;
&lt;p&gt;网络层可以把数据从一个主机传送到另一个主机，但是没有和进程建立联系。&lt;br&gt;
传输层就是讲进程和收到的数据联系到一起，使数据能够为应用服务&lt;br&gt;
所以说传输层是主机才有的层次&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612264339876.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;12-传输层的两个协议&#34;&gt;1.2 传输层的两个协议&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612264374947.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;13-传输层的寻址和端口&#34;&gt;1.3 传输层的寻址和端口&lt;/h2&gt;
&lt;p&gt;端口号只用于计算机分辨本地进程，总共有2^16=65536种端口号，端口号有很多种，不能随便使用&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612264395717.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;131-常见的应用程序端口号&#34;&gt;1.3.1 常见的应用程序端口号&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612264419074.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;2-udp协议&#34;&gt;2. UDP协议&lt;/h1&gt;
&lt;h2 id=&#34;21-udp概述&#34;&gt;2.1 UDP概述&lt;/h2&gt;
&lt;p&gt;注释：&lt;br&gt;
因为UDP一次发送一个完整报文不会分片，所以需要应用层传输过来的数据不要太大，否则网络层分片任务就很重，但是也不能太小，不然效率较低&lt;br&gt;
UDP适合一些实时应用，因为实时应用延迟要求高，需要立即响应&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612264447032.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;22-udp首部格式&#34;&gt;2.2 UDP首部格式&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612264472057.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;221-udp的校验位构成&#34;&gt;2.2.1 UDP的校验位构成&lt;/h3&gt;
&lt;p&gt;这里的伪首部只是用来计算检验和的，计算完了就丢弃，可以见下UDP的校验方式&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612264492450.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;222-udp校验方式&#34;&gt;2.2.2 UDP校验方式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;总结一下步骤：&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;在发送端的时候：&lt;/strong&gt;&lt;br&gt;
1.就是将每一行（4字节）拆成两部分，左右平均2字节大小，将这两字节数据写成二进制，那么2字节一共就需要2*8=16位。此时检验和没有计算，默认填充0，同时如果数据字段不整齐，则用0补齐，这样就可以写出几十行二进制数，如图中方所示&lt;br&gt;
2.计算着几十行二进制数按&lt;strong&gt;二进制反码运算求和&lt;/strong&gt;，二进制反码运算可以参考&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/jcchan/p/10400504.html&#34;&gt;二进制反码求和运算&lt;/a&gt;&lt;br&gt;
得到的最后简介再反码，之后将&lt;strong&gt;反码之后&lt;/strong&gt;的放入原来的检验和字段&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在接收端的时候&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;与发送端的时候不同的是，此时检验和字段不是0了&lt;/strong&gt;&lt;br&gt;
按照发送端的步骤再将所有数据写成二进制进行二进制反码运算求和&lt;br&gt;
如果最后得到结果全1就是没问题，否则丢弃&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612264590178.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-tcp协议&#34;&gt;3. TCP协议&lt;/h1&gt;
&lt;h2 id=&#34;31-tcp协议的特点&#34;&gt;3.1 TCP协议的特点&lt;/h2&gt;
&lt;p&gt;TCP必须要建立连接之后才可以进行数据交换，所以TCP是面向连接的&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612271954885.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
TCP传输数据是随机切割数据的&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612271959573.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-tcp报文段的首部&#34;&gt;3.2 TCP报文段的首部&lt;/h2&gt;
&lt;p&gt;注释：&lt;br&gt;
见上图，可以看到TCP是将数据随机分割后加上TCP头传输的，所以序号就是为了标记这些随机分割之后的数据，这里把第一个字节的编号当成序号。&lt;br&gt;
确认号就是收到之后做一下标记，代表这之前的都收到了，希望收到的下一个编号的数据就是确认号打头的那个数据。&lt;br&gt;
偏移量就是为了标记一下距离TCP开始多少字节是数据，这里的单位是4B，这个偏移量就是TCP首部长度。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612271997941.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
窗口就是接收方告诉发送方，还有多少地方（缓存）可以放数据&lt;br&gt;
紧急指针就是告诉TCP从哪里到哪里是紧急数据&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612272021989.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;321-tcp的六个控制位&#34;&gt;3.2.1 TCP的六个控制位&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;紧急位URG&lt;/code&gt;&lt;br&gt;
URG的特点就是让数据&lt;strong&gt;插队&lt;/strong&gt;，URG=1的就会在缓存中被提前到第一个传输&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612272088545.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612272102301.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;确认位ACK&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612272129028.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;推送位PSH&lt;/code&gt;&lt;br&gt;
就是接收端的URG，将PSH=1的数据尽快接收&lt;br&gt;
注意一下，如果没有PSH，一般都是接收方缓存满了之后再将数据发送到主机&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612272160110.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;复位RST&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612272172344.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;同步位SYN&lt;/code&gt;&lt;br&gt;
A和B主机要建立连接，就A先发一个报文，其中SYN=1&lt;br&gt;
B收到之后也回复一个SYN=1的报文，代表接受连接&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612272207838.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;终止位FIN&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612272235086.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️&lt;/p&gt;
&lt;h2 id=&#34;33-tcp连接管理&#34;&gt;3.3 TCP连接管理&lt;/h2&gt;
&lt;h2 id=&#34;331-tcp三次握手建立连接&#34;&gt;3.3.1 TCP三次握手（建立连接）&lt;/h2&gt;
&lt;p&gt;注释：&lt;br&gt;
第一段的意思是&lt;br&gt;
SYN=1：(A)要建立连接了！&lt;br&gt;
seq=x（随机）：因为还没有数据，所以写什么都无所谓&lt;/p&gt;
&lt;p&gt;第二段的意思是&lt;br&gt;
SYN=1：我(B)同意你(A)建立连接！&lt;br&gt;
ACK=1：连接建立了，之后的ACK必须都置为1&lt;br&gt;
seq=y（随机）：因为还没有数据，所以写什么都无所谓&lt;br&gt;
ack=x+1：之前发送方(A)说发送的是第x位数据（虽然发送方是瞎说的），所以我(B)要的是x+1位数据&lt;/p&gt;
&lt;p&gt;第三段的意思是&lt;br&gt;
SYN=0：SYN只有在建立连接时才为1，其他时候均设为0&lt;br&gt;
ACK=1：连接建立了，之后的ACK必须都置为1&lt;br&gt;
seq=x+1：我(A)发送的报文段的第一个字节就是x+1&lt;br&gt;
ack=y+1：之前接收方(B)说发送的是第y位数据（虽然接收方是瞎说的），所以我(A)要的是y+1位数据&lt;/p&gt;
&lt;p&gt;注意一下，TCP是双向的，所以不存在绝对不变的发送方接收方，这里的两台主机都同时是发送方和接收方&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612272302854.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TCP三次握手特定导致的SYN洪泛攻击&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612272318640.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️&lt;/p&gt;
&lt;h3 id=&#34;332-tcp四次挥手连接释放&#34;&gt;3.3.2 TCP四次挥手（连接释放）&lt;/h3&gt;
&lt;p&gt;注释：&lt;br&gt;
第一段的意思是&lt;br&gt;
FIN=1：(A)要释放连接了！&lt;br&gt;
seq=u：发了好多数据，这里只是用u指代一下，这里u是有确定值的&lt;/p&gt;
&lt;p&gt;第二段的意思是&lt;br&gt;
ACK=1：连接建立了，之后的ACK必须都置为1&lt;br&gt;
seq=v：发了好多数据，这里只是用v指代一下，这里v是有确定值的&lt;br&gt;
ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（尽管此时A已经决定释放连接了）&lt;/p&gt;
&lt;p&gt;第三段的意思是&lt;br&gt;
FIN=1：(B)要释放连接了！&lt;br&gt;
ACK=1：连接建立了，之后的ACK必须都置为1&lt;br&gt;
seq=w：发了好多数据，这里只是用w指代一下，这里w是有确定值的&lt;br&gt;
ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（因为A直接不发数据了，所以第二段第三段的ack都是u+1）&lt;/p&gt;
&lt;p&gt;第四段的意思是&lt;br&gt;
ACK=1：连接建立了，之后的ACK必须都置为1&lt;br&gt;
seq=u+1：之前发的数据时第u位数据，B也要第u+1位数据，所以我发第u+1位数据&lt;br&gt;
ack=w+1：之前发送方(B)说发送的是第w位数据，所以我(A)要的是w+1位数据&lt;/p&gt;
&lt;p&gt;为什么需要等待计时2MSL？&lt;br&gt;
因为这样可以保证B可以收到A的终止报文段进而进入关闭状态&lt;br&gt;
比如说如果A的第四段报文丢失，那么等待一个MSL之后B就会重传第三段报文，花费小于1MSL之后A就会再收到第三段报文，之后就可以再次向B发送第四段报文提示B关闭连接&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612272433783.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;34-tcp可靠传输&#34;&gt;3.4 TCP可靠传输&lt;/h2&gt;
&lt;p&gt;TCP是提供可靠传输，UDP这种本身还是不可靠传输的就再靠应用层解决了&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612272456274.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;341-序号&#34;&gt;3.4.1 序号&lt;/h3&gt;
&lt;p&gt;就是TCP根据下方数据链路层的MTU（最大传输单元）来随即将数据切割成好几端并且进行编号&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612272493105.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;342-确认&#34;&gt;3.4.2 确认&lt;/h3&gt;
&lt;p&gt;发送方每一次发送数据之后都需要接收方进行确认。&lt;br&gt;
TCP使用的是累计确认机制，就是从第一个丢失的字节开始请求丢失的报文段。如图中456丢失，78到达，但仍然请求发送的数据序号是4&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612272519527.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;343-重传&#34;&gt;3.4.3 重传&lt;/h3&gt;
&lt;p&gt;为什么要使用自适应算法？网络环境太复杂，路径又长又短，RTT设置短了照顾不了距离远的，RTT设置长了又导致网络利用率降低，所以使用RTTs&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612272538461.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;35-tcp流量控制&#34;&gt;3.5 TCP流量控制&lt;/h2&gt;
&lt;p&gt;简单来说就是接收方可以动态的发送信息告诉发送方发送窗口的大小。&lt;br&gt;
接收方接受不过来了就让发送方发送窗口小点，这样发送方发送的速率就慢下来了，接收方就有时间处理它的数据了&lt;br&gt;
接受方处理完了也可以发送请求让发送方发送窗口大点，这样发送方发送的速率就快起来了，接收方就可以处理更多数据而不是空闲等着收数据了&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612272568911.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;351-计时器&#34;&gt;3.5.1 计时器&lt;/h3&gt;
&lt;p&gt;在本例子中，使用的累计确认机制（一次回复收到ack=201）和三次流量控制机制。&lt;br&gt;
但是有一个情况就是，如果最后B不允许A再发送数据了，B在处理完数据之后想要恢复窗口大小时发送的有rwnd大小的数据报丢了怎么办？此时A有B的指令在前，发送窗口为0无法发送数据，B也在等待A回复，造成了类似死锁的现象&lt;br&gt;
解决方法：使用计时器&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612272591905.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;36-tcp拥塞控制&#34;&gt;3.6 TCP拥塞控制&lt;/h2&gt;
&lt;p&gt;流量控制是对单独一个来说的，拥塞控制是一群&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612272745809.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;361-拥塞控制四种算法&#34;&gt;3.6.1 拥塞控制四种算法&lt;/h3&gt;
&lt;p&gt;这里虽然是四种算法，但是通常是两两结合进行使用&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612272768432.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;362-慢开始和拥塞避免&#34;&gt;3.6.2 慢开始和拥塞避免&lt;/h3&gt;
&lt;p&gt;这里开始时以&lt;strong&gt;指数形式增长&lt;/strong&gt;，ssthresh的意思是慢开始门限，代表从这个地方注入的报文段就比较多了，需要开始慢速增加了。&lt;br&gt;
之后一段都是&lt;strong&gt;线性增长&lt;/strong&gt;，每次增加1，直至达到网络拥塞状态&lt;br&gt;
瞬间将cwnd设置为1，同时调整原来的ssthresh的值到之前达到网络拥塞状态的1/2,（这里是24降到12）&lt;br&gt;
重复以上步骤，但是注意此时ssthresh变了之后线性增长的转折点也变了&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612272809278.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;363-快重传和快恢复&#34;&gt;3.6.3 快重传和快恢复&lt;/h3&gt;
&lt;p&gt;这里和上面的慢开始和拥塞避免的一开始步骤差不多，都是先指数增长再转变为线性增长。&lt;br&gt;
不同的点是快重传和快恢复算法是在收到连续的ack确认之后执行，这里的ack就是冗余ack，冗余ack的特点是如果多次对某一段请求的数据没有被收到，达到一定数目之后就会立即执行重传。但是此时只是降到现在cwnd的一半，再重新线性增长。而不是像慢开始和拥塞避免的从头开始&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612272834927.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;4-本章思维导图&#34;&gt;4. 本章思维导图&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612272877495.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;本文常用名词中英文对照&#34;&gt;本文常用名词中英文对照&lt;/h1&gt;
&lt;p&gt;Multiplexing and demultiplexing 复用与分用&lt;br&gt;
Positive acknowledgments 肯定确认&lt;br&gt;
Negative acknowledgments 否定确认&lt;br&gt;
Countdown timer （倒数）计时器&lt;br&gt;
Cumulative acknowledgment 累积确认&lt;br&gt;
Receive buffer 接收缓冲区，或接收缓存&lt;br&gt;
Resource-management cells 资源管理单元&lt;br&gt;
Source (port number) 源端口号&lt;br&gt;
Destination (port number) 目的端口号&lt;br&gt;
Checksum 校验和&lt;br&gt;
Pipelined protocols 流水线（型）协议&lt;br&gt;
Go-back-N 回退N&lt;br&gt;
Selective Repeat 选择重传&lt;br&gt;
Timeout （定时器）超时&lt;br&gt;
Fast Retransmit 快速重传&lt;br&gt;
Flow Control 流量控制&lt;br&gt;
Three way handshake 三次握手&lt;br&gt;
sequence number 序列号（简写为seq）&lt;br&gt;
acknowledgement number 确认号（简写为ack；注意与大小的ACK不同）&lt;br&gt;
Congestion Control 拥塞控制&lt;br&gt;
additive increase, multiplicative decrease 加性增乘性减&lt;br&gt;
Slow Start 慢启动&lt;br&gt;
congestion-avoidance 拥塞避免&lt;br&gt;
fast recovery 快速恢复&lt;br&gt;
duplicate (ACK) 冗余（ACK）&lt;br&gt;
Random Early Detection 随机早期检测&lt;/p&gt;
&lt;p&gt;参考资料&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV19E411D78Q?p=1&#34;&gt;2019 王道考研 计算机网络&lt;/a&gt;&lt;/p&gt;
">计算机网络笔记Part5 传输层（Transport Layer）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/22/"" data-c="
          &lt;h1 id=&#34;1tcp报文格式&#34;&gt;1.TCP报文格式&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1611559421318.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;1、端口号&lt;/strong&gt;：用来标识同一台计算机的不同的应用进程。&lt;br&gt;
&lt;strong&gt;1）源端口&lt;/strong&gt;：源端口和IP地址的作用是标识报文的返回地址。&lt;br&gt;
&lt;strong&gt;2）目的端口&lt;/strong&gt;：端口指明接收方计算机上的应用程序接口。&lt;br&gt;
&lt;code&gt;TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、序号和确认号&lt;/strong&gt;：是TCP可靠传输的关键部分。&lt;strong&gt;序号&lt;/strong&gt;是本报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节一个序号。e.g.一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性。&lt;strong&gt;确认号&lt;/strong&gt;，即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、数据偏移／首部长度&lt;/strong&gt;：4bits。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32/8 = 60，&lt;code&gt;故报头最大长度为60字节&lt;/code&gt;。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、保留&lt;/strong&gt;：为将来定义新的用途保留，现在一般置0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、控制位&lt;/strong&gt;：URG  ACK  PSH  RST  SYN  FIN，共6个，每一个标志位表示一个控制功能。&lt;br&gt;
&lt;strong&gt;1）URG&lt;/strong&gt;：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。&lt;br&gt;
&lt;strong&gt;2）ACK&lt;/strong&gt;：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。&lt;br&gt;
&lt;strong&gt;3）PSH&lt;/strong&gt;：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。&lt;br&gt;
&lt;strong&gt;4）RST&lt;/strong&gt;：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。&lt;br&gt;
&lt;strong&gt;5）SYN&lt;/strong&gt;：同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。&lt;br&gt;
&lt;strong&gt;6）FIN&lt;/strong&gt;：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、窗口&lt;/strong&gt;：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、校验和&lt;/strong&gt;：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8、紧急指针&lt;/strong&gt;：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9、选项和填充&lt;/strong&gt;：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10、数据部分&lt;/strong&gt;： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。&lt;/p&gt;
&lt;h1 id=&#34;2三次握手&#34;&gt;2.三次握手&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612076354558.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
TCP/IP 协议是传输层的一个面向连接的安全可靠的一个传输协议，三次握手的机制是为了保证能建立一个安全可靠的连接，那么第一次握手是由客户端发起，客户端会向服务端发送一个报文，在报文里面：SYN标志位置为1，表示发起新的连接。当服务端收到这个报文之后就知道客户端要和我建立一个新的连接，于是服务端就向客户端发送一个确认消息包，在这个消息包里面：ack标志位置为1，表示确认客户端发起的第一次连接请求。以上两次握手之后，对于客户端而言：已经明确了我既能给服务端成功发消息，也能成功收到服务端的响应。但是对于服务端而言：两次握手是不够的，因为到目前为止，服务端只知道一件事，客户端发给我的消息我能收到，但是我响应给客户端的消息，客户端能不能收到我是不知道的。所以，还需要进行第三次握手，第三次握手就是当客户端收到服务端发送的确认响应报文之后，还要继续去给服务端进行回应，也是一个ack标志位置1的确认消息。通过以上三次连接，不管是客户端还是服务端，都知道我既能给对方发送消息，也能收到对方的响应。那么，这个连接就被安全的建了。&lt;/p&gt;
&lt;h1 id=&#34;3-为什么两次握手不行&#34;&gt;3. 为什么两次握手不行？&lt;/h1&gt;
&lt;p&gt;谢希仁版《计算机网络》中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”&lt;/p&gt;
&lt;p&gt;这个例子很清晰的阐释了“三次握手”对于建立可靠连接的意义。&lt;/p&gt;
&lt;p&gt;在Google Groups的TopLanguage中看到一帖讨论TCP“三次握手”觉得很有意思。贴主提出“TCP建立连接为什么是三次握手？”的问题，在众多回复中，有一条回复写道：“&lt;code&gt;这个问题的本质是, 信道不可靠,&lt;/code&gt; 但是通信双发需要就某个问题达成一致. 而要解决这个问题,  无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足&amp;quot;&lt;code&gt;在不可靠信道上可靠地传输信息&lt;/code&gt;&amp;quot;这一需求所导致的. 请注意这里的本质需求,信道不可靠, 数据传输要可靠. 三次达到了, 那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了. 因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到, 或者你不关心是否要保证对方收到你的消息, 那就能像UDP那样直接发送消息就可以了.”。这可视为对“三次握手”目的的另一种解答思路。&lt;/p&gt;
&lt;p&gt;后面一段话意思就是如果想确定双通道通畅，必须使用三个包的发送接收，也就是三次握手&lt;/p&gt;
&lt;h1 id=&#34;4四次挥手&#34;&gt;4.四次挥手&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612076620053.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
四次握手机制也是由客户端去发起，客户端会发送一个报文，在报文里面FIN位标志位置一，当服务端收到这个报文之后，我就知道了客户端想要和我断开连接，但是此时服务端不一定能做好准备，因为当客户端发起断开连接的这个消息的时候，对于服务端而言，他和还有可能有未发送完的消息，他还要继续发送，所以呢，此时对于服务端而言，我只能进行一个消息确认，就是我先告诉服务端，我知道你要给我断开连接了，但是我这里边还可能没有做好准备，你需要等我一下，等会儿我会告诉你，于是呢，发完这个消息确认包之后，可能稍过片刻它就会继续发送一个断开连接的一个报文啊，也是一个FIN位置1的报文也是由服务端发给客户端的啊，这个报文表示服务端已经做好了断开连接的准备，那么当这个报文发给客户端的时候，客户端同样要给服务端继续发送一个消息确认的报文一共有四次，那么，通过这四次的相互沟通和连接，我就知道了，不管是服务端还是客户端都已经做好了断开连接的准备，于是连接就可以被断开啊，这是我对三次握手和四次挥手的一个理解。&lt;/p&gt;
">TCP报文——三次握手&四次挥手</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/ji-suan-ji-wang-luo-bi-ji-part4-wang-luo-ceng-network-layer/"" data-c="
          &lt;h1 id=&#34;1-概述&#34;&gt;1. 概述&lt;/h1&gt;
&lt;p&gt;注释：&lt;br&gt;
数据报和分组的关系：分组是一段比较长的数据，将它进行切割成一段段之后就得到数据报&lt;br&gt;
功能一就是让数据在路由器之间走最佳的路径&lt;br&gt;
功能二就是让不同的设备（手机，电脑，平板等）都能正常连接&lt;br&gt;
功能三见图中解释&lt;br&gt;
开环控制就是在拥塞之前就提前设计解决&lt;br&gt;
闭环控制就是在拥塞时自动调整解决问题&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612095965455.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;OSI参考模型&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;各层次的传输单元&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;应用层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;报文&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;传输层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;报文段&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;网络层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IP数据报，分组（如果IP数据报太大就切割成分组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据链路层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;帧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;物理层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;比特流&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;2-数据交换方式&#34;&gt;2. 数据交换方式&lt;/h1&gt;
&lt;p&gt;为什么要进行数据交换？因为每个节点之间都拉网线太麻烦了也不实际，所以通过大量交换设备互联进行数据交换&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612096463674.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;21-电路交换&#34;&gt;2.1 电路交换&lt;/h2&gt;
&lt;p&gt;常见的例子：打电话&lt;br&gt;
注释：&lt;br&gt;
链路支持多路复用（可参考数据链路层的TDM等）&lt;br&gt;
特点是独占资源，因为两者建立了连接&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612096503276.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;22-报文交换&#34;&gt;2.2 报文交换&lt;/h2&gt;
&lt;p&gt;注释：报文发送的过程&lt;br&gt;
1.源先根据报文加上ip地址，物理地址等，通过物理层发送&lt;br&gt;
2.交换机收到报文之后，先进行存储，等待链路空闲之后进行转发，但是转发的路径不是固定的，是比较随机的&lt;br&gt;
3.最后通过许多交换机最终到达目的地&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612096535503.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;23-分组交换&#34;&gt;2.3 分组交换&lt;/h2&gt;
&lt;p&gt;分组交换和报文交换基本相同，就是将报文切割之后再进行发送&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612096614492.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;24-分组交换和报文交换的具体计算对比&#34;&gt;2.4 分组交换和报文交换的具体计算对比&lt;/h2&gt;
&lt;p&gt;注释：是怎么计算的？&lt;br&gt;
报文交换：一共三段，每段都需要10000bit/1000bps=10s，三段就是3x10=30s&lt;br&gt;
分组交换：可以分为两段，一个是第一个数据开始发到最后一个数据从源发出，一段是最后一个数据到达目的地。第一段总时间是10000bit/1000bps=10s，第二段总时间是（10/1000）*2=0.02s，所以总时间是10.02s。&lt;br&gt;
理解一下，这里就是报文交换的时候，由于报文没有分割，所以即使先到的数据也不能先发走，只能等到最后一段报文全部到了之后才能一起走，相对于分组交换明显拖慢了前面数据的速度，所以导致报文交换明显慢于分组交换。&lt;br&gt;
可以看到分组交换明显快于报文交换，所以我们通常使用分组交换&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612096647245.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;241-分组传输的两种传输方式-数据报与虚电路&#34;&gt;2.4.1 分组传输的两种传输方式-数据报与虚电路&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;综述&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612096711651.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612096715380.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据报&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612096731409.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虚电路&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612096762230.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-路由算法和路由协议概述&#34;&gt;3. 路由算法和路由协议概述&lt;/h1&gt;
&lt;p&gt;路由算法就是让路由知道收到报文之后下一步怎么走&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612096787286.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
AS就是多个路由器之间构成的单独的小圈子，圈子内使用自己的协议，圈子和圈子之间用的是BGP协议&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612096806087.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;31-rip协议和距离向量算法&#34;&gt;3.1 RIP协议和距离向量算法&lt;/h2&gt;
&lt;h3 id=&#34;311-rip协议概述&#34;&gt;3.1.1 RIP协议概述&lt;/h3&gt;
&lt;p&gt;通过交换信息构建路由表&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612096856709.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;312-如何建立路由表&#34;&gt;3.1.2 如何建立路由表&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612096869111.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;313-rip协议报文格式&#34;&gt;3.1.3 RIP协议报文格式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612096886347.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;314-rip协议特点&#34;&gt;3.1.4 RIP协议特点&lt;/h3&gt;
&lt;p&gt;就是来回更新路由表，错误信息被覆盖，导致直至达到距离上限强制错误时才可以得知出错&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612096940327.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612096944098.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612096947518.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612096950613.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;315-距离向量算法&#34;&gt;3.1.5 距离向量算法&lt;/h3&gt;
&lt;p&gt;注释：&lt;br&gt;
为什么改地址？因为图中是从x得到的信息&lt;br&gt;
为什么距离固定+1？因为路由器只从相邻路由器之间获取RIP报文，举例只会是1&lt;br&gt;
为什么下一跳是x就要替换？因为网络环境不断变化，可能这次某个节点挂掉，所以保持最新的&lt;br&gt;
为什么下一跳不是x时有更新和不处理两种手段？因为这样可以提高效率，比原来快就换，比原来慢就保留原来的，也可以理解&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612097004430.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612097008383.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612097012997.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-ospf协议和链路状态算法&#34;&gt;3.2 OSPF协议和链路状态算法&lt;/h2&gt;
&lt;h3 id=&#34;321-ospf协议概述&#34;&gt;3.2.1 OSPF协议概述&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612097042017.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;322-ospf的其他特点&#34;&gt;3.2.2 OSPF的其他特点&lt;/h3&gt;
&lt;p&gt;为什么OSPF收敛速度快？因为它只是刷新一下链路状态，得知其是否连通，不需要和RIP一样进行对照，而是直接通过Dijilstra算法来自己算出路径&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612097062831.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;323-链路状态路由算法&#34;&gt;3.2.3 链路状态路由算法&lt;/h3&gt;
&lt;p&gt;了解即可&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612097087324.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;324-ospf区域&#34;&gt;3.2.4 OSPF区域&lt;/h3&gt;
&lt;p&gt;了解即可&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612097205918.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;325-ospf分组&#34;&gt;3.2.5 OSPF分组&lt;/h3&gt;
&lt;p&gt;了解即可&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612097230145.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;33-bgp协议&#34;&gt;3.3 BGP协议&lt;/h2&gt;
&lt;h3 id=&#34;331-bgp协议简介&#34;&gt;3.3.1 BGP协议简介&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612097260741.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;332-bgp协议交换信息的过程&#34;&gt;3.3.2 BGP协议交换信息的过程&lt;/h3&gt;
&lt;p&gt;了解即可，只需要知道BGP交换协议里面交换的是一组路径向量&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612097302736.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612097305652.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612097309001.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;333-bgp协议报文格式&#34;&gt;3.3.3 BGP协议报文格式&lt;/h3&gt;
&lt;p&gt;BGP是应用层协议&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612097339499.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;334-bgp协议特点&#34;&gt;3.3.4 BGP协议特点&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612097372931.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;335-bgp的四种报文&#34;&gt;3.3.5 BGP的四种报文&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612097376737.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;34-三种路由协议的比较&#34;&gt;3.4 三种路由协议的比较&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612097403721.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612097407772.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;4-ip数据报&#34;&gt;4. IP数据报&lt;/h1&gt;
&lt;h2 id=&#34;41-ip数据报格式&#34;&gt;4.1 IP数据报格式&lt;/h2&gt;
&lt;p&gt;注释：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;注释&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;大小&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;版本 Version&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ipv4或者ipv6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;首部长度 IHL&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;此处数值再乘以4才是真正大小，同时因为IP数据报固定长度为20字节，所以此处最小值为5，即二进制的0101&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;区分服务 DSCP + ECN&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;希望获得哪种服务，用的比较少&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;总长度 Total Length&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;首部+数据的长度，最大为2^16-1=65535&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;标识 Identification&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用来表示是哪一个数据报的分片，不同的分片标识各不相同&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;标志 Flags&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用来表示是否分片和分片是否结束&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3位，但实际有用的只有后两位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;片偏移 Fragment Offset&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用来标记分片之后，该分片在原来的数据报的位置，以8字节为单位&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;13位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;生存时间 Time To Live&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;即TTL，没经过一个路由器TTL-1,0时自动放弃，根据系统不同默认的TTL不同&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;协议 Protocol&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用来标记协议名的字段值，如TCP,UDP,ICMP等等&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;首部检验和 Header Checksum&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;检验首部的字段是否出错，出错就丢弃此数据报&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;源地址 Source IP Address&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;发送方ip地址&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;目的地址 Destination IP Address&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;接收方ip地址&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选字段 Options&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用来排错等安全检测&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;未知，可在0-40位之间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;填充&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将数据报对齐成4字节的整数倍，数值全部为0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;未知，根据可选字段来定&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612098474398.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612098477627.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
计算偏移量时记住是以0开始的就行，以每一篇最开始的除以8得到的数值就是偏移量&lt;br&gt;
MF和DF的定义见上图&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612098493784.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;5-ip&#34;&gt;5. IP&lt;/h1&gt;
&lt;h2 id=&#34;51-ipv4地址&#34;&gt;5.1 ipv4地址&lt;/h2&gt;
&lt;p&gt;全球唯一的表示某一个主机或者路由器接口的编码&lt;/p&gt;
&lt;h3 id=&#34;511-ip地址分类&#34;&gt;5.1.1 ip地址分类&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612098535241.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;512-特殊ip地址&#34;&gt;5.1.2 特殊ip地址&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612098614057.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;513-私有ip地址&#34;&gt;5.1.3 私有ip地址&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612098637063.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;解释一下&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;为什么A类最大是126.xxx.xxx.xxx？&lt;/code&gt;&lt;br&gt;
因为网络号最开始第一位是0，一共八位，所以二进制表示位0xxxxxxx，最大就是2^7-1=127，但是因为127.xxx.xxx.xxx是特殊ip地址，所以将其去掉&lt;br&gt;
&lt;code&gt;为什么B类最大是191.255.xxx.xxx？&lt;/code&gt;&lt;br&gt;
因为网络号最开始第一位是10，一共八位，所以二进制表示位10xxxxxx，最大就是10111111=191，最小就是10000000=128，无特殊ip地址&lt;br&gt;
&lt;code&gt;为什么C类最大是223.255.xxx.xxx？&lt;/code&gt;&lt;br&gt;
因为网络号最开始第一位是110，一共八位，所以二进制表示位110xxxxx，最大就是11011111=223，最小就是10000000=192，无特殊ip地址&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612098684254.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;52-网络地址转换nat&#34;&gt;5.2 网络地址转换NAT&lt;/h2&gt;
&lt;p&gt;注释：连接内网和外网，就是找个代理的用它的ip地址与外面收发数据&lt;br&gt;
NAT需要构建NAT转换表，既要存广域网（WAN，外网）也要存局域网（LAN，内网）的ip地址和端口号&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612098723762.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;53-子网划分和子网掩码&#34;&gt;5.3 子网划分和子网掩码&lt;/h2&gt;
&lt;h3 id=&#34;531-为什么需要子网划分&#34;&gt;5.3.1 为什么需要子网划分&lt;/h3&gt;
&lt;p&gt;总结一下，就是ip不够用，所以需要额外整个子网扩展ip&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612098876586.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注释：&lt;br&gt;
为什么子网好能全0或者全1：因为CIDR编址（可见下一段）&lt;br&gt;
为什么主机号不能全0或者全1：因为全0代表本网络，全1代表广播分组&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612098885794.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;532-子网掩码&#34;&gt;5.3.2 子网掩码&lt;/h3&gt;
&lt;p&gt;子网掩码就是用来和ip地址一起计算子网的地址的&lt;br&gt;
方法就是讲子网掩码逐位写成二进制然后而原来ip地址进行与运算，就可以得到子网ip地址&lt;br&gt;
因为255是11111111，所以如果写着255的话，ip地址和子网ip地址对应的地方的数值就相同&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612098919450.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这道题可以看出来，即使子网掩码不同，相同ip地址对应的子网ip地址也可能相同&lt;br&gt;
但是子网掩码不同，划分的&lt;strong&gt;子网数目不同&lt;/strong&gt;&lt;br&gt;
为什么划分的子网数目不同？或者说怎么算划分的子网位数目？&lt;br&gt;
以255.255.192.0为例，255是11111111即八个1,192是11000000即2个1，一共是82+2=18个1，一共有32位地址，所以剩余有32-18=14位&lt;br&gt;
以255.255.224.0为例，255是11111111即八个1,224是11100000即3个1，一共是82+3=19个1，一共有32位地址，所以剩余有32-19=13位&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612098940092.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这道题先将255.255.252.0计算出一共有8+8+6=22位网络号位&lt;br&gt;
所以就有32-22=10位主机号位&lt;br&gt;
将180.80.77.55解析，可以知道在77部分某部分开始会用来表示主机号位&lt;br&gt;
77的二进制是0100 1101，因为一共有22位网络号位，所以010011 （此处分开） 01，从这个01开始是主机号位。&lt;br&gt;
所以用来表示子网ip地址的应该是180.80.76（010011 00）.xxx PS注意76括号内后两位二进制00&lt;br&gt;
但是本体是发布广播地址，所以主机号全部都要是1&lt;br&gt;
所以应该是180.80.79（010011 11）.255（11111111）注意79括号内后两位二进制11&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612098960245.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注释：&lt;br&gt;
1.这里特定主机路由就是指找特定的处理这里这个ip地址的路由&lt;br&gt;
2.默认路由会将这个数据报发给另一个路由，直至找到对应的路由，或者TTL耗尽被丢弃&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612098976631.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;54-无分类编制cidr&#34;&gt;5.4 无分类编制CIDR&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612098994138.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
使用CIDR可以聚合网络&lt;br&gt;
如图，通过缩短前缀，R1和R2就可以合并在206.1.0.0/16的子网下&lt;br&gt;
但是这样转发表之中就会有多个匹配结果，所以我们使用&lt;strong&gt;最长前缀匹配&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612099099244.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
最长前缀匹配就是在计算后符合同一子网的时候，选前缀越长的&lt;br&gt;
这道题选B&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612099115616.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
因为本网络是192.168.5.0/24，就是192.168.5.（0000 0000）/24，将248写成二进制是11111 000，有五个1，所以前五位都可以作为子网的编号，剩下的三位就是用来分配子网内剩余的地址了，因为不能全0或者全1，所以还要减2&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612099128555.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;55-arp协议&#34;&gt;5.5 ARP协议&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612099442070.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612099446128.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;56-dhcp协议&#34;&gt;5.6 DHCP协议&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612099461816.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;57-icmp协议&#34;&gt;5.7 ICMP协议&lt;/h2&gt;
&lt;h3 id=&#34;571-icmp协议概述&#34;&gt;5.7.1 ICMP协议概述&lt;/h3&gt;
&lt;p&gt;ICMP，IGMP处于网络层和传输层之间，就是为了更好地转发ip数据报和提高交互成功的几率&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612099557198.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;572-icmp差错报告报文&#34;&gt;5.7.2 ICMP差错报告报文&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ICMP差错报告报文如何与IP数据报结合&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612099586573.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五种ICMP差错报文&lt;/strong&gt;&lt;br&gt;
其中源点抑制已废弃不用&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612099758130.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四种不发送ICMP差错报文的情况&lt;/strong&gt;&lt;br&gt;
注释：组播是指由一点到多点，但不是无脑发到所有点，无脑发到所有点的是广播，组播有筛选条件&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612099792458.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;573-icmp询问报文&#34;&gt;5.7.3 ICMP询问报文&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;四种ICMP询问报文&lt;/strong&gt;&lt;br&gt;
后两种是掩码地址请求和回答报文，路由器询问和通告报文，这两个已经废弃不再使用&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612099832338.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;574-icmp的应用&#34;&gt;5.7.4 ICMP的应用&lt;/h3&gt;
&lt;p&gt;1.ping命令：测试两个主机之间连通性，使用了ICMP回送请求和回答报文&lt;br&gt;
2.traceroute命令：跟踪一个分组从原点到终点的路径，使用了ICMP时间超过差错报告报文&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/llq_200/article/details/81034345&#34;&gt;traceroute命令讲解&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;6-ipv6&#34;&gt;6. IPV6&lt;/h1&gt;
&lt;h2 id=&#34;61-为什么会有ipv6&#34;&gt;6.1 为什么会有IPV6&lt;/h2&gt;
&lt;p&gt;就是IPV4地址用完了，从根本上增加ip地址数目，之前讲的NAT和CIDR也只是在IPV4的基础上扩展了IPV4地址数目，治标不治本&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612099968178.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;62-ipv6地址表示形式&#34;&gt;6.2 IPV6地址表示形式&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612099983088.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;63-ipv6数据报格式&#34;&gt;6.3 IPV6数据报格式&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;作用&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;位数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;版本 Version&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;知名协议版本，此处因为是ipv6所以总是6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;优先级 Traffic Class&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;又来区分数据报的类型和优先级&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;流标签 Flow Label&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;和ipv4标识某个数据报分片不同，这是对于一整个数据报流的标记&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;19位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有效载荷长度 Payload Length&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;指的是扩展首部+数据部分的大小，和ipv4的总长度和首部长度都不同，ipv6的首部长度是固定的40字节&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;下一个首部 Next Header&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;基本首部的下一个首部指的是有效载荷里标记的的扩展首部，有效载荷里的扩展首部再指向有效载荷里标记的的扩展首部，直至最后指向数据&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;跳数限制 Hop Limit&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;基本相当于ipv4当中的TTL，每到一个路由器-1.减到0时丢弃&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;源地址 Source Address&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;发送方ipv6地址&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;128位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;目标地址 Destination Address&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;接收方ipv6地址&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;128位&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612100298399.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;64-ipv4和ipv6的区别&#34;&gt;6.4 IPV4和IPV6的区别&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612100321103.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;65-ipv6基本地址类型&#34;&gt;6.5 IPV6基本地址类型&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;作用&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;要求&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一对一通信&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可做源地址，目的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;多播&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一对多通信，以前的广播地址当做覆盖所有主机的多播&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可做目的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;任播&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一对多当中的一个通信，看似一对多，实则一对一&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可做目的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;66-ipv4和ipv6之间的过渡&#34;&gt;6.6 IPV4和IPV6之间的过渡&lt;/h2&gt;
&lt;p&gt;如果是ipv6的数据报到了ipv4，就用ipv4重新封装，把ipv6数据报前面加上ipv4伪装成ipv4数据报继续传输，直至到了ipv6路由再解开ipv4伪装&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612100421431.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;7-ip组播多播&#34;&gt;7. IP组播（多播）&lt;/h1&gt;
&lt;h2 id=&#34;71-什么是组播&#34;&gt;7.1 什么是组播&lt;/h2&gt;
&lt;p&gt;单播只能一对一，广播必须一对全部，组播就可以是一对全部中的一部分&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612100449986.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
辅助理解：单播所占资源多&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612100580765.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
组播明显减轻了压力&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612100600765.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;72-ip组播地址&#34;&gt;7.2 IP组播地址&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612100630663.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;73-硬件组播&#34;&gt;7.3 硬件组播&lt;/h2&gt;
&lt;p&gt;就像全F的mac地址代表广播一样，00-10-5E打头的MAC地址就代表组播&lt;br&gt;
7为什么最大是00-10-5E-7F-FF-FF？因为只有最后23位决定&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612100653018.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;74-igmp协议与组播路由选择协议&#34;&gt;7.4 IGMP协议与组播路由选择协议&lt;/h2&gt;
&lt;h3 id=&#34;741-igmp协议&#34;&gt;7.4.1 IGMP协议&lt;/h3&gt;
&lt;p&gt;注释：IGMP只能知道有没有组播组成员，对有几个组播组成员，成员在哪个地方都不知道&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612100779176.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612100792527.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;742-组播路由选择协议&#34;&gt;7.4.2 组播路由选择协议&lt;/h3&gt;
&lt;p&gt;有了这个，成员可以自行找到转发组，自行决定参加哪个组播（就像电视机选台一样）&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612100819411.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612100823553.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;8-移动ip&#34;&gt;8. 移动IP&lt;/h1&gt;
&lt;p&gt;移动IP&lt;strong&gt;不等于&lt;/strong&gt;动态IP（DHCP获得的）&lt;br&gt;
移动IP的可以让用户因为地理原因等等，即使不在内网也可以访问内网的东西&lt;/p&gt;
&lt;h2 id=&#34;81-移动ip的相关术语&#34;&gt;8.1 移动IP的相关术语&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612100855884.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;82-移动ip通信过程&#34;&gt;8.2 移动IP通信过程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612100886983.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612100892321.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;9-网络层设备&#34;&gt;9. 网络层设备&lt;/h1&gt;
&lt;h2 id=&#34;91-路由器&#34;&gt;9.1 路由器&lt;/h2&gt;
&lt;h3 id=&#34;911-路由器的构造&#34;&gt;9.1.1 路由器的构造&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612100922364.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;912-路由器的输入输出端口构造&#34;&gt;9.1.2 路由器的输入输出端口构造&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612100934897.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612100957008.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;913-集线器网桥路由表几层设备比较&#34;&gt;9.1.3 集线器，网桥，路由表几层设备比较&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612100985820.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;914-路由器的路由表和转发表&#34;&gt;9.1.4 路由器的路由表和转发表&lt;/h3&gt;
&lt;p&gt;这里实际上就是对前面知识的复习了&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1612101019453.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;10-本章思维导图&#34;&gt;10. 本章思维导图&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1612101037645.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;本章常用名词中英文对照&#34;&gt;本章常用名词中英文对照&lt;/h1&gt;
&lt;p&gt;Forwarding table 转发表&lt;br&gt;
Virtual-circuit networks 虚电路网络&lt;br&gt;
Datagram networks 数据报网络&lt;br&gt;
Signaling message 信令报文&lt;br&gt;
Active queue management 主动队列管理&lt;br&gt;
Head-of-the-line 队头&lt;br&gt;
Classless interdomain routing (CIDR) 无类域间路由&lt;br&gt;
Plug-and-play 即插即用&lt;br&gt;
Anycast 任播&lt;br&gt;
Interior gateway protocols 内部网关协议&lt;br&gt;
Routing information Protocol 路由信息协议（RIP）&lt;br&gt;
Open shortest Path First OSPF 开放最短路径优先&lt;br&gt;
Area border routers 区域边界路由器&lt;br&gt;
Circuit Switching 电路转换&lt;br&gt;
Packet Switching 分组交换&lt;/p&gt;
&lt;p&gt;参考资料&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV19E411D78Q?p=1&#34;&gt;2019 王道考研 计算机网络&lt;/a&gt;&lt;/p&gt;
">计算机网络笔记Part4 网络层（Network Layer）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/ji-suan-ji-wang-luo-bi-ji-part3-shu-ju-lian-lu-ceng-data-link-layer/"" data-c="
          &lt;h1 id=&#34;1-基本概念&#34;&gt;1. 基本概念&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609390124988.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;2-封装成帧与透明传输&#34;&gt;2. 封装成帧与透明传输&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;封装成帧&lt;/strong&gt;就是加将数据加头加尾，相当于将数据打包&lt;br&gt;
&lt;strong&gt;透明传输&lt;/strong&gt;就是为了防止&lt;strong&gt;特殊的数据无法正常传输&lt;/strong&gt;的情况的发生，比如说在封装成帧的过程中出现数据中的某些标记符与开始/结束标记符恰巧重复等等情况&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609390179336.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609390192674.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;21-透明传输的应用&#34;&gt;2.1 透明传输的应用&lt;/h2&gt;
&lt;h3 id=&#34;211-字符计数法&#34;&gt;2.1.1 字符计数法&lt;/h3&gt;
&lt;p&gt;就是在帧的首部做&lt;strong&gt;计数&lt;/strong&gt;，看看数据是否错误&lt;br&gt;
缺点：如果在某一个帧内，标记位后面的某个字节的数据丢失，那么会影响后面的帧&lt;br&gt;
比如3 1 1 和 4 2 2 2，如果前面的帧丢失变成 3 1，那么后面的4就会被补到前面变成 3 1 4导致错误&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609568481663.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;212-字符填充法&#34;&gt;2.1.2 字符填充法&lt;/h3&gt;
&lt;p&gt;就是加头加尾分别标记开始结束，和零比特填充法（见下）对比，&lt;strong&gt;开始和结束的对应的字符不一样&lt;/strong&gt;&lt;br&gt;
但有可能出现数据内某段比特流数据正好&lt;strong&gt;与标记字段重复&lt;/strong&gt;，从而导致误判断的情况&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609568577190.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;解决方法：添加转义字符&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609568606048.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;213-零比特填充法&#34;&gt;2.1.3 零比特填充法&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609568630555.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;214-违规编码法&#34;&gt;2.1.4 违规编码法&lt;/h3&gt;
&lt;p&gt;因为曼彻斯特编码不使用高-高，低-低来表示，所以如果使用高-高，低-低来表示帧起始和终止就&lt;strong&gt;不会与数据冲突&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609568672962.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-差错控制&#34;&gt;3. 差错控制&lt;/h1&gt;
&lt;h2 id=&#34;31-差错是什么从哪来的&#34;&gt;3.1 差错是什么，从哪来的&lt;/h2&gt;
&lt;p&gt;数据链路层的差错检测的是&lt;strong&gt;比特&lt;/strong&gt;的错误&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609568711580.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-为什么要在数据链路层进行差错控制&#34;&gt;3.2 为什么要在数据链路层进行差错控制？&lt;/h2&gt;
&lt;p&gt;因为错误可以尽早发现，不会让一个错误的数据包发送了很长时间到达最终目的地之后才被发现，从而导致网络资源的浪费&lt;/p&gt;
&lt;h2 id=&#34;33-检错编码奇偶校验码循环冗余码crc&#34;&gt;3.3 检错编码（奇偶校验码，循环冗余码CRC）&lt;/h2&gt;
&lt;h3 id=&#34;331-奇偶校验码&#34;&gt;3.3.1 奇偶校验码&lt;/h3&gt;
&lt;p&gt;缺点：只能检测出1，3，5，7…等等奇位数错误，检测成功率位50%&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609568769474.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;332-循环冗余码crc&#34;&gt;3.3.2 循环冗余码CRC&lt;/h3&gt;
&lt;p&gt;就是用传输数据除以生成多项式得到冗余码&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609568796342.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
实际例子&lt;br&gt;
注释：&lt;br&gt;
1.阶数就是最高位是哪位，然后位数-1，如10011就是5-1=4,1011就是4-1=3&lt;br&gt;
2.异或运算就是相同得0，不同得1，比如100和101做异或，结果就是001&lt;br&gt;
3.出书和最后的余数添加到要发送的数据后面，称为&lt;strong&gt;帧检验序列FCS&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609568834916.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
接收方收到数据后进行检测&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609568859283.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
需要注意的地方&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609568878943.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;34-纠错编码海明码&#34;&gt;3.4 纠错编码（海明码）&lt;/h2&gt;
&lt;p&gt;分为四步&lt;/p&gt;
&lt;h2 id=&#34;第一步-确认校验码位数r&#34;&gt;第一步 确认校验码位数r&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609568956027.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;第二步-确定校验码和数据的位置&#34;&gt;第二步 确定校验码和数据的位置&lt;/h2&gt;
&lt;p&gt;注释：&lt;br&gt;
1.为什么是10为数据位？因为4位校验码+6位信息位=10位&lt;br&gt;
2.校验码放到2的几次方的位置，其他的地方按顺序放已知的信息位&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609568978597.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;第三步-求出校验码的值&#34;&gt;第三步 求出校验码的值&lt;/h2&gt;
&lt;p&gt;注释&lt;br&gt;
1.先是通过二进制位确定有几位。本题中因为最大位10的二进制是1010，所以是4为，将其标注&lt;br&gt;
2.然后从p1开始看，看p1的二进制位的数值和所有信息位的对应位置的数值是否相同，然后找出来这些位&lt;br&gt;
这里有点难理解，这里以p1为例辅助理解，这里找出来的就是P1,D1,D2,D4,D5&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609569004823.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
然后计算异或值，比如说这里D1=1,D2=0,D4=1,D5=0,就是p1要同时和0,1，0,1进行异或之后得到0，为了标识我加粗原始计算数据&lt;br&gt;
举例：0和1异或得1,1和0异或得1,1和1异或得0，那么p1和0异或得0，p1就是0了&lt;br&gt;
3.其他同理，按顺序计算出P2,P3,P4,然后填入表格&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609569018649.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;第四步-检测并纠错&#34;&gt;第四步 检测并纠错&lt;/h2&gt;
&lt;p&gt;就是和上面一样，将所有校验位进行运算，得出的结果的值就是错误的位&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609569067668.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;4-数据链路层的流量控制和可靠传输&#34;&gt;4. 数据链路层的流量控制和可靠传输&lt;/h1&gt;
&lt;h2 id=&#34;41-流量控制与可靠传输&#34;&gt;4.1 流量控制与可靠传输&lt;/h2&gt;
&lt;p&gt;流量控制是为了让传输过程中的发送速度和接受速度匹配，减少传输出错与资源浪费&lt;br&gt;
可靠传输是发送端发送什么，接收端就要受到什么&lt;/p&gt;
&lt;h3 id=&#34;411-停止等待协议stop-and-wait&#34;&gt;4.1.1 停止等待协议（Stop-and-Wait）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609569129958.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
停止等待协议的&lt;strong&gt;无差错&lt;/strong&gt;情况&lt;br&gt;
注释：因为一次就一个，所以用0和1标记ack就行&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609569160486.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
停止等待协议的&lt;strong&gt;有差错&lt;/strong&gt;情况&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609569192898.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609569221465.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609569225134.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
停止等待协议的特点&lt;br&gt;
1.简单&lt;br&gt;
2.信道利用率低。大部分时间数据都在路上，发送方很长时间闲置，资源浪费&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609569585809.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609569581900.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;412-后退n帧协议gbn&#34;&gt;4.1.2 后退N帧协议（GBN）&lt;/h3&gt;
&lt;p&gt;因为停止等待协议太浪费时间了，所以尝试采用GBN，发送连续多个数据帧，以增大信道利用率&lt;br&gt;
注释：&lt;br&gt;
累计确认：就是收到一个确认帧，那么&lt;strong&gt;它和它之前的所有帧&lt;/strong&gt;都默认已收到，反之，如果某个确认帧没收到，那么&lt;strong&gt;它和它之后的所有帧&lt;/strong&gt;都默认丢失（即使收到了也丢掉），进行重传&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609569637867.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
下图是一个实例&lt;br&gt;
注释：此图发送2帧时丢失，所以接收方几首收到后面的帧也是直接丢弃并且发送最晚收到的有效帧1的ACK，直至2帧的超时重传机制被触发进行重传并得到ACK之后，接收方才会接受2帧以及后面的帧&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609569648684.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发送窗口不能无限大，与使用的编号的比特数有关&lt;br&gt;
很简单，就是1比特编号0和1,同理2比特编号0-3，如果用1比特编号，却要4个窗口长度，那么窗口内数据编号都编不过来，直接乱套了&lt;br&gt;
GBN的优缺点也显而易见，优点是提高了信道利用率，缺点是因为重传机制的原因导致已经收到数据却需要强行丢弃而造成浪费&lt;/p&gt;
&lt;h3 id=&#34;413-选择重传协议sr&#34;&gt;4.1.3 选择重传协议（SR）&lt;/h3&gt;
&lt;p&gt;为了解决GBN的缺点，我们打算尝试只重传错误的帧，这样的话就不用浪费资源吧已经收到的帧再重传一次了。&lt;br&gt;
和GBN相比，两者都有窗口了，和GBN的区别其实就是做了一个数据缓存，已经收到的帧不用扔了，等待之前因意外丢失的帧收到的时候确认即可，但是只能缓存窗口尺寸内的包含的帧（PS，缓存咋可能无限大）&lt;br&gt;
&lt;code&gt;SR运行过程&lt;/code&gt;&lt;br&gt;
注释：2帧丢失之后仍然在发送，但是2帧丢失之后只是缓存，并没有移动窗口，直至最后2帧收到后一次性确认2-5帧&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609569746034.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
同样的，因为编号的问题，发送窗口不能无限大&lt;br&gt;
发送窗口最后和接受窗口&lt;strong&gt;大小相同&lt;/strong&gt;，这样利用率比较高&lt;/p&gt;
&lt;h1 id=&#34;5-介质访问控制技术&#34;&gt;5. 介质访问控制技术&lt;/h1&gt;
&lt;p&gt;就是让节点之间的通信不会进行相互干扰&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609569788475.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;51-信道划分介质访问控制&#34;&gt;5.1 信道划分介质访问控制&lt;/h2&gt;
&lt;p&gt;虽然使用一条共享信道，但是通过多路复用技术组合进行传输，提高了信道的利用率&lt;/p&gt;
&lt;h3 id=&#34;511-频分多路复用fdm&#34;&gt;5.1.1 频分多路复用FDM&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609569822950.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;512-时分多路复用tdm&#34;&gt;5.1.2 时分多路复用TDM&lt;/h3&gt;
&lt;p&gt;TDM的缺点就是利用率低，所以又衍生出了STDM&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609569854305.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;513-统计时分复用stdm&#34;&gt;5.1.3 统计时分复用STDM&lt;/h3&gt;
&lt;p&gt;STDM的原则是先到先走，满了就发，相对于TDM提高了利用率&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609569881696.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;514-码分多路复用cdm&#34;&gt;5.1.4 码分多路复用CDM&lt;/h3&gt;
&lt;p&gt;CDM只是做一下记录，暂时还用不到，有需要请自行查找资料&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609569908502.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;52-随机访问介质访问控制&#34;&gt;5.2 随机访问介质访问控制&lt;/h2&gt;
&lt;p&gt;所有用户都可以随机发送信息，发送时可以占用全部带宽，理论上个人使用时比静态分配信道的速度更快&lt;/p&gt;
&lt;h3 id=&#34;521-aloha协议&#34;&gt;5.2.1 ALOHA协议&lt;/h3&gt;
&lt;p&gt;纯ALOHA协议缺点：太随性，导致效率低&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609569957093.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
时隙ALOHA协议&lt;br&gt;
相对于纯ALOHA协议就是固定了发送的时间（只能在一个时间片的开始），提高了效率&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609569986799.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;522-csma协议&#34;&gt;5.2.2 CSMA协议&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609570006807.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;优点&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;缺点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1-坚持CSMA&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;发送信息时监听信道，一空闲下来就立即传输，信道忙也一直监听，如果发送时冲突就等待随机时长之后再监听&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;立即发送，利用率高&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;如果多台设备同时监听，那么会发生冲突&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;非坚持CSMA&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;发送信息时监听信道，如果空闲就立即传输，信道忙就随机等待一段时间后再监听&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;冲突发生的几率减少&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;因为需要等待，所以利用率不高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;p-坚持CSMA&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;发送信息时监听信道，空闲时以概率p进行传输，概率1-p不传输。信道忙就随机等待一段时间后再监听&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;冲突减少的同时效率也比较高&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;即使发生冲突也要坚持发送数据，资源被浪费&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;523-csmacd协议&#34;&gt;5.2.3 CSMA/CD协议&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;br&gt;
就是因为链路实际有长短，发送数据需要时间，这个时间内可能就被其他节点当成空闲状态导致发生碰撞&lt;br&gt;
知道自己发生碰撞的最长时间是2τ（两倍的&lt;strong&gt;传播时延&lt;/strong&gt;），就是一去一回&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609570559893.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
图示传播时延对载波监听的影响&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609570573007.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609570597526.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609570601177.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
由此我们可以想到最小帧长的问题，因为如果帧太短，帧都发送完了才检测到碰撞导致停止，导致无法停止碰撞&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609570623056.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;524-csmaca协议&#34;&gt;5.2.4 CSMA/CA协议&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609570763204.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609570766975.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;525-csmacd-与-csmaca的区别&#34;&gt;5.2.5 CSMA/CD 与 CSMA/CA的区别&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609570843437.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;53-轮询访问介质访问控制&#34;&gt;5.3 轮询访问介质访问控制&lt;/h2&gt;
&lt;p&gt;主要包括两大类，一个是&lt;strong&gt;轮询协议&lt;/strong&gt;，另一个是&lt;strong&gt;令牌传递协议&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;531-轮询协议&#34;&gt;5.3.1 轮询协议&lt;/h3&gt;
&lt;p&gt;就是选出一个代表，让他控制所有的传输&lt;br&gt;
注释：&lt;br&gt;
轮询开销在随着服务的节点越多，需要用于查询是否发送数据发送的数据帧也就越多，会造成一定开销&lt;br&gt;
等待延迟就是因为这是轮流“邀请”，所以难免某个节点需要发送数据，但是主节点还在较远的需要里有需求的节点那边，导致需求得不到立即响应&lt;br&gt;
单点故障很好理解，就是代表挂了&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609570905055.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;532-令牌传递协议&#34;&gt;5.3.2 令牌传递协议&lt;/h3&gt;
&lt;p&gt;注释：在节点之间没有收发数据的需求时，令牌在节点之间循环。&lt;br&gt;
发送数据的流程&lt;br&gt;
》当一个节点需要时就可以获得这个令牌。然后修改这个令牌的状态（空闲-&amp;gt;占用）&lt;br&gt;
》再将令牌与数据帧结合，让其在节点构成的环之间流动&lt;br&gt;
》不是目的地的节点收到令牌也不接受，直接略过，目标节点收到信息并复制一份到本地（传输完成），因为是个闭环，所以发送节点最后得到令牌&lt;br&gt;
》最后，发送令牌的节点对令牌的内容进行检查，如果发现数据出错还要重新发一遍&lt;br&gt;
问题基本和轮询协议相同&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609570949965.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;6局域网&#34;&gt;6.局域网&lt;/h1&gt;
&lt;h2 id=&#34;61-局域网的概念&#34;&gt;6.1 局域网的概念&lt;/h2&gt;
&lt;p&gt;概括：范围大小，速度快，延迟低，节点平等&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609570990208.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;611-局域网的网络拓扑结构&#34;&gt;6.1.1 局域网的网络拓扑结构&lt;/h3&gt;
&lt;p&gt;常用的是&lt;strong&gt;总线型拓扑&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609571010148.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;612-局域网的传播介质&#34;&gt;6.1.2 局域网的传播介质&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;局域网&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;常用介质&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有线局域网&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;双绞线，同轴电缆，光纤&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无线局域网&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;电磁波&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;613-局域网介质访问方法&#34;&gt;6.1.3 局域网介质访问方法&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609571141124.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;62-局域网的分类&#34;&gt;6.2 局域网的分类&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609571180089.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;63-ieee802标准&#34;&gt;6.3 IEEE802标准&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609571191251.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;631-ieee802描述的局域网参考模型&#34;&gt;6.3.1 IEEE802描述的局域网参考模型&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609571213929.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;64以太网&#34;&gt;6.4以太网&lt;/h2&gt;
&lt;h3 id=&#34;641-以太网概念&#34;&gt;6.4.1 以太网概念&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609571245741.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609571249735.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;642-以太网的发展&#34;&gt;6.4.2 以太网的发展&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609571279431.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;643-适配器和mac地址&#34;&gt;6.4.3 适配器和MAC地址&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609571294253.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;644-以太网mac帧&#34;&gt;6.4.4 以太网MAC帧&lt;/h3&gt;
&lt;p&gt;注释：&lt;br&gt;
1.这里的mac层指的是数据链路层&lt;br&gt;
2.之前说过数据链路层将上一层ip数据包加头加尾&lt;br&gt;
头就是目标地址（6字节），源地址（6字节），类型（2字节）&lt;br&gt;
尾就是FCS（帧检验序列），（4字节）&lt;br&gt;
3.前导码&lt;strong&gt;不是MAC帧的一部分&lt;/strong&gt;，目的是使时钟同步&lt;br&gt;
4.为什么数据长度时46~1500？&lt;br&gt;
因为有最小传输字节64字节，mac占用6+6+2+4=18，所以数据最小为64-18=46，1500则是规定的默认最大字节，没有理由&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609571340452.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;645-10base-t以太网&#34;&gt;6.4.5 10BASE-T以太网&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609571372027.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;646-高速以太网&#34;&gt;6.4.6 高速以太网&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609571385266.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;65-无线局域网&#34;&gt;6.5 无线局域网&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609571418731.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609571423009.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;651-两种无线局域网&#34;&gt;6.5.1 两种无线局域网&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609571452731.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609571457676.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;7广域网&#34;&gt;7.广域网&lt;/h1&gt;
&lt;h2 id=&#34;71-广域网的概述&#34;&gt;7.1 广域网的概述&lt;/h2&gt;
&lt;p&gt;概括一下，一个字大&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609572131515.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;72-ppp协议point-to-point-protocol&#34;&gt;7.2 PPP协议（Point-to-Point Protocol）&lt;/h2&gt;
&lt;p&gt;PPP协议是目前&lt;strong&gt;使用最广泛&lt;/strong&gt;的数据链路层协议，拨号基本都是PPP协议&lt;br&gt;
PPP协议&lt;strong&gt;仅支持全双工&lt;/strong&gt;链路&lt;/p&gt;
&lt;h3 id=&#34;721-ppp协议需要满足的要求&#34;&gt;7.2.1 PPP协议需要满足的要求&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609572186032.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;722-ppp协议不需要满足的要求&#34;&gt;7.2.2 PPP协议不需要满足的要求&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609572227622.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;723-ppp协议组成成分以及功能&#34;&gt;7.2.3 PPP协议组成成分以及功能&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609572247195.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;724-ppp协议的帧格式&#34;&gt;7.2.4 PPP协议的帧格式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609572272595.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;73-hdlc协议high-level-data-link-control&#34;&gt;7.3 HDLC协议（High-Level Data Link Control）&lt;/h2&gt;
&lt;h3 id=&#34;731-hdlc协议概述&#34;&gt;7.3.1 HDLC协议概述&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609572303168.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;732-hdlc的三种站&#34;&gt;7.3.2 HDLC的三种站&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609572325373.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;733-hdlc的帧格式&#34;&gt;7.3.3 HDLC的帧格式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609572351245.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;74-ppp协议和hdlc协议对比&#34;&gt;7.4 PPP协议和HDLC协议对比&lt;/h2&gt;
&lt;p&gt;为什么HDLC协议更可靠，但是我们使用PPP协议？&lt;br&gt;
因为现在网络要求高，数据链路层本来就是不可靠的尽力传输，差错控制这些复杂的交给了TCP等&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609572379651.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;8-链路层设备&#34;&gt;8. 链路层设备&lt;/h1&gt;
&lt;h2 id=&#34;81-集线器hub&#34;&gt;8.1 集线器（Hub）&lt;/h2&gt;
&lt;p&gt;可以扩展以太网，但是集线器会无脑将一个设备的所有消息转发到集线器所连的所有设备，故会将所连接的&lt;strong&gt;所有设备&lt;/strong&gt;变成一个大的冲突域，同时只能有两台设备进行通信，且设备越多，冲突越多。由此诞生了网桥&lt;/p&gt;
&lt;h2 id=&#34;82-网桥bridge&#34;&gt;8.2 网桥（Bridge）&lt;/h2&gt;
&lt;p&gt;使用网桥时，由于网桥会根据mac地址进行过滤，所以&lt;strong&gt;不会形成冲突域&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609572446383.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;821-两种网桥&#34;&gt;8.2.1 两种网桥&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;透明网桥&lt;/strong&gt;&lt;br&gt;
通过自学习来构建转发表。每一个通过网桥的数据包都会被记录下网桥收到数据时&lt;strong&gt;数据对应的地址&lt;/strong&gt;和&lt;strong&gt;网桥自己的接口&lt;/strong&gt;，通过许许多多的数据包的构造的缓存，网桥就可以知道哪个数据包在哪个接口，以后如果要穿数据包就知道要往哪个接口发送数据包了&lt;br&gt;
&lt;strong&gt;原路由网桥&lt;/strong&gt;&lt;br&gt;
在发送时，直接将最佳路径放到帧首部。那么网桥如何获得最佳路径？通过广播方式想目标地址发送广播，此时可能会经过不同路由产生不同的路径，目标地址收到后再将每一条路径都发一个响应帧给网桥，网桥经过对比就知道哪个接口最快了&lt;/p&gt;
&lt;h2 id=&#34;83-交换机&#34;&gt;8.3 交换机&lt;/h2&gt;
&lt;p&gt;网桥接口越来越多，网桥就变成了交换机&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609572535311.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;84-冲突域和广播域&#34;&gt;8.4 冲突域和广播域&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609572566320.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;9-本章总结思维导图&#34;&gt;9. 本章总结思维导图&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609572590789.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;本章常用中英文对照&#34;&gt;本章常用中英文对照&lt;/h1&gt;
&lt;p&gt;End system 端系统&lt;br&gt;
Modem 调制解调器（俗称：猫）&lt;br&gt;
Base station 基站&lt;br&gt;
Communication link 通信链路&lt;br&gt;
Physical media 物理介质&lt;br&gt;
Coaxial cable 同轴电缆&lt;br&gt;
Fiber optics 光纤&lt;br&gt;
Radio spectrum 射频频谱&lt;br&gt;
Transmission rate 传输速率&lt;br&gt;
Packets （数据）包，或分组&lt;br&gt;
Routers 路由器&lt;br&gt;
Path 路径&lt;br&gt;
ISP (Internet Service Provider) 网络服务提供商&lt;br&gt;
FDM (frequency-division multiplexing) 频分多路复用&lt;br&gt;
TDM (time-division multiplexing) 时分多路复用&lt;br&gt;
Statistical Multiplexing 统计复用&lt;br&gt;
Store-and-forward 存储转发&lt;br&gt;
Queuing delays 排队延迟&lt;br&gt;
Transmission delay 传输延迟，或发送延迟&lt;br&gt;
Propagation delay 传播延迟&lt;br&gt;
Throughput 吞吐量&lt;br&gt;
Internet backbone 骨干网&lt;br&gt;
Delay 延迟，或时延&lt;br&gt;
Loss 丢包&lt;br&gt;
Message 消息，或报文&lt;br&gt;
Segment （报文）段&lt;br&gt;
Datagram 数据报&lt;br&gt;
Frames 帧&lt;/p&gt;
&lt;p&gt;参考资料&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV19E411D78Q&#34;&gt;2019 王道考研 计算机网络&lt;/a&gt;&lt;/p&gt;
">计算机网络笔记Part3 数据链路层（Data Link Layer）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/ji-suan-ji-wang-luo-bi-ji-part2-wu-li-ceng-physical-layer/"" data-c="
          &lt;h1 id=&#34;1-基本概念&#34;&gt;1. 基本概念&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609332989754.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;2-数据通信基本知识&#34;&gt;2. 数据通信基本知识&lt;/h1&gt;
&lt;h2 id=&#34;21-一个数据通信例子&#34;&gt;2.1 一个数据通信例子&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609333260138.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;22-相关术语&#34;&gt;2.2 相关术语&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609333847379.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;23-三种通讯方式&#34;&gt;2.3 三种通讯方式&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;英文&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;定义&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;需要信道条数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;单工通信&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Simplex&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只能一个发一个收&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一条&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;半双工通信&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;half-duplex&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;都可以发或者收，但是同一时间只能进行一个&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;两条&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;全双工通信&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;duplex&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;都可以同时收发数据&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;两条&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;24-两种数据传输方式&#34;&gt;2.4 两种数据传输方式&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;传输方式&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;特点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;串行传输&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;速度慢，省钱，适合远距离&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;并行传输&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;速度快，耗钱，适合近距离&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609379006539.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;25-码元symbol&#34;&gt;2.5 码元（Symbol）&lt;/h2&gt;
&lt;p&gt;定义：码元是指用一个固定时长的信号波形（数字脉冲），代表离散数值的基本波形。当有多个离散状态时，成为M进制码元。一个码元可以携带多个比特的信息&lt;br&gt;
个人理解：码元就是在网线上传输的一个个信号段。码元的不同进制就是用来表示不同的数值的&lt;/p&gt;
&lt;h2 id=&#34;26-波特baud&#34;&gt;2.6 波特（Baud）&lt;/h2&gt;
&lt;p&gt;用来指一秒可以传输多少个码元&lt;/p&gt;
&lt;h2 id=&#34;27-速率&#34;&gt;2.7 速率&lt;/h2&gt;
&lt;p&gt;分为&lt;strong&gt;码元传输速率&lt;/strong&gt;和&lt;strong&gt;信息传输速率&lt;/strong&gt;&lt;br&gt;
信息传输速率就是b/s，就是我们平常说的&lt;strong&gt;网速&lt;/strong&gt;&lt;br&gt;
码元可以理解为几个比特的&lt;strong&gt;集合&lt;/strong&gt;，所以信息传输速率（网速）=码元传输速率x码元所带信息量（多少比特）&lt;br&gt;
码元所带信息量（比特数）=log2（码元进制数）&lt;/p&gt;
&lt;h2 id=&#34;28-带宽band-width&#34;&gt;2.8 带宽（Band Width）&lt;/h2&gt;
&lt;p&gt;用来表示最高数据速率&lt;/p&gt;
&lt;h2 id=&#34;29-奈式准则nyquist&#34;&gt;2.9 奈式准则（Nyquist）&lt;/h2&gt;
&lt;p&gt;是在&lt;strong&gt;理想状态下&lt;/strong&gt;得出的结论&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609379171027.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;210-香农公式shannon&#34;&gt;2.10 香农公式（Shannon）&lt;/h2&gt;
&lt;p&gt;是在&lt;strong&gt;有噪声的信道中&lt;/strong&gt;得出的结论&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609379224887.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609379228696.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;211-基带信号和宽带带通信号base-bandpass-band&#34;&gt;2.11 基带信号和宽带/带通信号（Base band，pass band）&lt;/h2&gt;
&lt;p&gt;计算机网络中用的基带信号是&lt;strong&gt;数字信号&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609379264723.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;212-编码&#34;&gt;2.12 编码&lt;/h2&gt;
&lt;p&gt;将数据转化为&lt;strong&gt;数字信号&lt;/strong&gt;&lt;br&gt;
数字数据(digtal data)通过 数字发送器(digit emitter) 转化为 数字信号(digtal signal)&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609379325314.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
模拟数据(analog data)通过 PCM编码器(PCM coder) 转化为 数字信号 (digtal signal)&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609379338474.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;单极性不归零编码：只使用一个电压值，高电平表示1，低电平表示0。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;双极性不归零编码：用幅值相等的正负电平表示二进制数1和0。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;单极性归零编码：发送码1时高电平在整个码元期间只持续一段时间，其余时间返回零电平。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;双极性归零编码：正负零三个电平，信号本身携带同步信息。
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609379405647.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;曼彻斯特编码：&lt;/code&gt;单极性编码的缺点是没有办法区分此时是没有信号，还是有信号，但是信号是0.&lt;br&gt;
这种编码方式是bit中间有信号，低-高跳转表示0，高-低跳转表示1，一个时钟周期只可以表示一个bit，并且必须通过两次采样才能得到一个bit。它能携带时钟信号，而且能区分此时是没有信号还是信号为0.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;差分曼彻斯特编码：&lt;/code&gt;抗干扰能力比曼彻斯特编码更强。bit与bit之间有信号跳变，表示下一个bit为0，bit与bit之间没有信号跳变，表示下一个bit为1。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609379572032.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;213-调制数据转化为模拟信号了解&#34;&gt;2.13 调制：数据转化为模拟信号（了解）&lt;/h2&gt;
&lt;p&gt;常用的调制方法：调频(AM)，调频(FM)，调相(PM)&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609379690610.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
模拟数据(analog data)通过 调制器(modulaotr) 转化为 模拟信号 (analog signal)&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609379708749.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
数字数据(digtal data)通过 调制器(modulaotr) 转化为 模拟信号 (analog signal)&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609379737643.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-物理层传输介质&#34;&gt;3. 物理层传输介质&lt;/h1&gt;
&lt;p&gt;传输介质分为&lt;strong&gt;导向性&lt;/strong&gt;传输介质和&lt;strong&gt;非导向性&lt;/strong&gt;传输介质&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;导向性传输介质&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;电磁波沿着固体媒介（铜线or光纤）被导向传播&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;非导向性传输介质&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;自由空间，如空气，水等等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;31-常见的导向性传输介质&#34;&gt;3.1 常见的导向性传输介质&lt;/h2&gt;
&lt;h3 id=&#34;311-双绞线&#34;&gt;3.1.1 双绞线&lt;/h3&gt;
&lt;p&gt;根据有无屏蔽层分为&lt;strong&gt;屏蔽双绞线（STP）和无屏蔽双绞线（UTP）&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609379878165.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;312-同轴电缆coaxial-cable&#34;&gt;3.1.2 同轴电缆（Coaxial Cable）&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609379892737.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;313-光纤optical-fiber&#34;&gt;3.1.3 光纤（Optical fiber）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609379932961.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
根据&lt;strong&gt;入射角&lt;/strong&gt;不同，又分为单模光纤和多模光纤&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609379946815.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-常见的非导向性传输介质&#34;&gt;3.2 常见的非导向性传输介质&lt;/h2&gt;
&lt;p&gt;包括&lt;strong&gt;无线电波&lt;/strong&gt;，&lt;strong&gt;微波&lt;/strong&gt;，&lt;strong&gt;红外线&lt;/strong&gt;和&lt;strong&gt;激光&lt;/strong&gt;等&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609379994768.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;4-物理层设备&#34;&gt;4. 物理层设备&lt;/h1&gt;
&lt;h2 id=&#34;41-中继器rp-repeater&#34;&gt;4.1 中继器（RP repeater）&lt;/h2&gt;
&lt;p&gt;注释：5-4-3规则是为了限制中继器使用次数的，理由可见图&lt;br&gt;
5是指不能超过5个网段&lt;br&gt;
4是指在这些网段中的物理层网络设备（中继器，集线器）最多不超过4个&lt;br&gt;
3是指这些网段中最多只有三个网段挂有计算机&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609380050132.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;42-集线器hub&#34;&gt;4.2 集线器（Hub）&lt;/h2&gt;
&lt;p&gt;集线器是个大的冲突域，同时&lt;strong&gt;只能有两个设备进行通讯&lt;/strong&gt;，只会传输信号，没有智能。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609380082969.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;5-本章思维导图&#34;&gt;5. 本章思维导图&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609380107652.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;br&gt;
&lt;br&gt;&lt;br&gt;
参考资料&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV19E411D78Q&#34;&gt;2019 王道考研 计算机网络&lt;/a&gt;&lt;/p&gt;
">计算机网络笔记Part2 物理层（Physical Layer）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/ji-suan-ji-wang-luo-bi-ji-part11/"" data-c="
          &lt;h1 id=&#34;1-速率相关性能指标&#34;&gt;1. 速率相关性能指标&lt;/h1&gt;
&lt;h2 id=&#34;11-速率&#34;&gt;1.1 速率&lt;/h2&gt;
&lt;p&gt;定义：连接在计算机网络上的主机在数字信道上传送数据位数的速率&lt;br&gt;
单位:b/s,Kb/s,Mb/s,Tb/s，&lt;br&gt;
如果用字节表示，则是B/s,KB/s,MB/s,TB/s&lt;br&gt;
1Byte=8Bit&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609227285065.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;12-带宽&#34;&gt;1.2 带宽&lt;/h2&gt;
&lt;p&gt;在计算机网络中，指的是网络设备所支持的最高速度，单位同速率，是&lt;strong&gt;理想条件下最高速率&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;13-吞吐量&#34;&gt;1.3 吞吐量&lt;/h2&gt;
&lt;p&gt;指的是单位时间内通过某个网络的数据&lt;strong&gt;总&lt;/strong&gt;量&lt;/p&gt;
&lt;h3 id=&#34;个人理解&#34;&gt;个人理解&lt;/h3&gt;
&lt;p&gt;速率就是实际网速，带宽是理论网速（长城宽带警告），吞吐量是一个或多个设备的综合速率，比如说1000m宽带的路由器连着三部手机，每部手机都是10mb/s看片，那么速率就是10mb/s，带宽是宽带的1000m，路由器吞吐量是30mb/s，即三者之和&lt;/p&gt;
&lt;h1 id=&#34;2时延相关指标&#34;&gt;2.时延相关指标&lt;/h1&gt;
&lt;h2 id=&#34;21-时延&#34;&gt;2.1 时延&lt;/h2&gt;
&lt;p&gt;时延包括四大类&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;计算公式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;发送时延&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据从主机到信道上所用的时间&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据从主机到信道上所用的时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;传播时延&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据在信道上传播所花费的时间&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;信道长度/电磁波在信道上传播的速率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;排队时延&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据在路由器前等待前面数据处理的时间&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无计算方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;处理时延&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据在路由器中处理需求的时间&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无计算方式&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;使用高速链路(提高网速)，只能减小发送时延，无法减少其他三个时延&lt;/p&gt;
&lt;h2 id=&#34;22-时延带宽积&#34;&gt;2.2 时延带宽积&lt;/h2&gt;
&lt;p&gt;公式：时延带宽积=传播时延x带宽&lt;br&gt;
意思是链路上有多少比特的数据&lt;/p&gt;
&lt;h2 id=&#34;23往返时延rtt&#34;&gt;2.3往返时延RTT&lt;/h2&gt;
&lt;p&gt;从发送方发送数据开始，到接收方确认收到为止所花费的时间&lt;br&gt;
RTT=传播时延x2+处理时间(有时可能直接忽略)&lt;/p&gt;
&lt;h2 id=&#34;24-利用率&#34;&gt;2.4 利用率&lt;/h2&gt;
&lt;h3 id=&#34;241-信道利用率&#34;&gt;2.4.1 信道利用率&lt;/h3&gt;
&lt;p&gt;信道利用率=有数据通过&lt;strong&gt;时间&lt;/strong&gt;/有+无数据通过&lt;strong&gt;时间&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;242-网络利用率&#34;&gt;2.4.2 网络利用率&lt;/h3&gt;
&lt;p&gt;网络利用率=所有信道利用率加权求平均值&lt;/p&gt;
&lt;h3 id=&#34;243-时延和利用率的关系图&#34;&gt;2.4.3 时延和利用率的关系图&lt;/h3&gt;
&lt;p&gt;利用率越高，延迟越大&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609228615004.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-分层结构&#34;&gt;3. 分层结构&lt;/h1&gt;
&lt;h2 id=&#34;31-为什么要分层分层要做什么&#34;&gt;3.1 为什么要分层，分层要做什么&lt;/h2&gt;
&lt;p&gt;（1）发起通信的计算机必须将数据通信的通路进行激活。&lt;br&gt;
（2）要告诉网络如何识别目的主机。&lt;br&gt;
（3）发起通信的计算机要查明目的主机是否开机，并且与网络连接正常。&lt;br&gt;
（4）发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作。&lt;br&gt;
（5）确保差错和意外可以解决。&lt;/p&gt;
&lt;h2 id=&#34;32-正式认识分层结构&#34;&gt;3.2 正式认识分层结构&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609229035668.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;4-参考模型&#34;&gt;4. 参考模型&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;英文&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;应用层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Application Layer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;直接为用户的应用进程（例如电子邮件、文件传输和终端仿真）提供服务。如HTTP、SMTP、FTP、DNS等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;表示层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Presentation Layer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;把数据转换为能与接收者的系统格式兼容并适合传输的格式，即让两个系统可以交换信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;会话层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Session Layer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;传输层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Transport Layer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;负责端到端通讯，可靠传输，不可靠传输 ，流量控制，复用分用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网络层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Network Layer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;负责选择路由最佳路径，规划IP地址(ipv4和ipv6变化只会影响网络层)，拥塞控制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据链路层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Data Link Layer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;帧的开始和结束，还有透明传输，差错校验(纠错由传输层解决)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;物理层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Physical Layer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;定义网络设备接口标准，电气标准(电压)，如何在物理链路上传输的更快&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;41-osi流程简介&#34;&gt;4.1 OSI流程简介&lt;/h2&gt;
&lt;p&gt;网络层及以上，每一层都要对上一层发送的数据进行处理（加个头部）&lt;br&gt;
数据链路层不仅需要加头部，还需要加尾部&lt;br&gt;
物理层什么都不加，只管发送数据（比特流）&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609229644091.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;42-tcpip参考模型&#34;&gt;4.2 TCP/IP参考模型&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609229668243.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;43-五层参考模型及其传输过程简介&#34;&gt;4.3 五层参考模型及其传输过程简介&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1609229701190.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1609229703634.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;参考资料&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV19E411D78Q&#34;&gt;2019 王道考研 计算机网络&lt;/a&gt;&lt;/p&gt;
">计算机网络笔记Part1 概述</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/vueandmock-mo-ni-shu-ju/"" data-c="
          &lt;h1 id=&#34;mock在vue里怎么用&#34;&gt;mock在vue里怎么用？&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/nuysoft/Mock/wiki/Getting-Started&#34;&gt;https://github.com/nuysoft/Mock/wiki/Getting-Started&lt;/a&gt;&lt;br&gt;
以上是官方文档，不知道mock是什么的自行查看&lt;/p&gt;
&lt;h1 id=&#34;一-下载nodejs-的npm-自行下载&#34;&gt;一、下载node.js 的npm 自行下载&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;+ npm install -g cnpm --registry=https://registry.npm.taobao.org
     //npm的镜像
	+ npm install -g @vue/cli    //安装全局脚手架  
	    自己新建一个文件夹，并在文件夹中打开  powershell 
	+ vue create mypro(文件名可随意换)   //创建并下载一个文件夹
	+ npm install vue-router --save //启路由的插件
		--save 代表局部
	+ cd mypro
	+ npm run serve //运行 
	+ 用local 地址打开
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;11-创建项目&#34;&gt;1.1 创建项目&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;vue create mock-demo 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1608807847530.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;12-安装依赖-不懂请看上面&#34;&gt;1.2 安装依赖 （不懂请看上面）&lt;/h2&gt;
&lt;p&gt;vue环境搭建好后，开始安装 mock依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     //使用axios发送  ajax
	  	cnpm install axios --save
	//使用mockjs产生随机数据
	  	cnpm install mockjs --save-dev
	//使用json5解决json文件,无法添加注释问题
	  	cnpm install json5 --save-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;二-学习mockjs&#34;&gt;二、学习MOCKJS&lt;/h1&gt;
&lt;p&gt;新建mock文件夹,新建testMockjs.js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const Mock = require(&#39;mockjs&#39;);//mockjs 导入依赖模块
var id = Mock.mock(&#39;@id&#39;)//得到随机的id,字符串
console.log(Mock.mock(&#39;@id&#39;), typeof id)

var obj = Mock.mock({
    id: &amp;quot;@id()&amp;quot;,//得到随机的id,对象
    username: &amp;quot;@cname()&amp;quot;,//随机生成中文名字
    date: &amp;quot;@date()&amp;quot;,//随机生成日期
    avatar: &amp;quot;@image(&#39;200x200&#39;,&#39;red&#39;,&#39;#fff&#39;,&#39;avatar&#39;)&amp;quot;,//生成图片,参数:size, background, foreground, text
    description: &amp;quot;@paragraph()&amp;quot;,//描述
    ip: &amp;quot;@ip()&amp;quot;,//IP地址
    email: &amp;quot;@email()&amp;quot;//email
})
console.log(obj)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;三-学习json5&#34;&gt;三、学习JSON5&lt;/h1&gt;
&lt;p&gt;json文件,中如果说存在注释文件和编辑器都会报错,我们采用json5格式来让json格式可以存在注释&lt;/p&gt;
&lt;h2 id=&#34;31编辑器安装json5扩展&#34;&gt;3.1编辑器安装JSON5扩展&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1608807967957.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;32引入json5库来解析json5格式&#34;&gt;3.2引入JSON5库来解析JSON5格式&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);
const JSON5 = require(&#39;json5&#39;);
//读取json文件
function getJsonFile(filePath) {
    //读取指定json文件
    var json = fs.readFileSync(path.resolve(__dirname,filePath), &#39;utf-8&#39;);
    //解析并返回
    return JSON5.parse(json);
}
var json = getJsonFile(&#39;./userInfo.json5&#39;);
console.log(&#39;json&#39;, json) 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;四-mock和vue-cli结合&#34;&gt;四、MOCK和VUE-CLI结合&lt;/h1&gt;
&lt;h2 id=&#34;41新建indexjs&#34;&gt;4.1新建INDEX.JS&lt;/h2&gt;
&lt;p&gt;在mock文件夹下,新建index.js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);
const Mock = require(&#39;mockjs&#39;);//mockjs 导入依赖模块
const JSON5 = require(&#39;json5&#39;);
//读取json文件
function getJsonFile(filePath) {
    //读取指定json文件
    var json = fs.readFileSync(path.resolve(__dirname,filePath), &#39;utf-8&#39;);
    //解析并返回
    return JSON5.parse(json);
}

//返回一个函数
module.exports = function(app){
    //监听http请求
    app.get(&#39;/user/userinfo&#39;, function (rep, res) {
        //每次响应请求时读取mock data的json文件
        //getJsonFile方法定义了如何读取json文件并解析成数据对象
        var json = getJsonFile(&#39;./userInfo.json5&#39;);
        //将json传入 Mock.mock 方法中，生成的数据返回给浏览器
        res.json(Mock.mock(json));
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;42-新建vueconfigjs&#34;&gt;4.2 新建VUE.CONFIG.JS&lt;/h2&gt;
&lt;p&gt;在项目根目录下,新建vue.config.js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module.exports = {
    devServer: {
        before: require(&#39;./mock/index.js&#39;)//引入mock/index.js
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;43-发送ajax请求&#34;&gt;4.3 发送AJAX请求&lt;/h2&gt;
&lt;p&gt;在src\components\HelloWorld.vue中发送ajax请求&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import axios from &#39;axios&#39;
	export default {
	  name: &#39;HelloWorld&#39;,
	  props: {
	    msg: String
	  },
	  mounted() {
	    axios.get(&#39;/user/userinfo&#39;)
	    .then(res =&amp;gt; {
	      console.log(res)
	    })
	    .catch(err =&amp;gt; {
	      console.error(err); 
	    })
	  }
	} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;五-移除mock-连接实际api&#34;&gt;五、移除MOCK （连接实际api）&lt;/h1&gt;
&lt;p&gt;在项目根路径新建.env.development&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MOCK=true 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完善mock\index.js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module.exports = function(app){
    if(process.env.MOCK == &#39;true&#39;){
        //监听http请求
        app.get(&#39;/user/userinfo&#39;, function (rep, res) {
            //每次响应请求时读取mock data的json文件
            //getJsonFile方法定义了如何读取json文件并解析成数据对象
            var json = getJsonFile(&#39;./userInfo.json5&#39;);
            //将json传入 Mock.mock 方法中，生成的数据返回给浏览器
            res.json(Mock.mock(json));
        });
    }
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;六-总结mock-json5-devserver-axios职责&#34;&gt;六、总结,MOCK-JSON5-DEVSERVER-AXIOS职责&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1608808179446.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;七-mockjs-中常用的函数&#34;&gt;七、mockjs 中常用的函数&lt;/h1&gt;
&lt;p&gt;&#39;Boolean&#39;: &#39;@boolean&#39;, // 随机生成布尔类型&lt;br&gt;
&#39;Natural&#39;: &#39;@natural(1, 100)&#39;, // 随机生成1到100之间自然数&lt;br&gt;
&#39;Integer&#39;: &#39;@integer(1, 100)&#39;, // 生成1到100之间的整数&lt;br&gt;
&#39;Float&#39;: &#39;@float(0, 100, 0, 5)&#39;, // 生成0到100之间的浮点数,小数点后尾数为0到5位&lt;br&gt;
&#39;Character&#39;: &#39;@character(&amp;quot;aeiou&amp;quot;)&#39;, // 在aeiou中，生成随机字符，不传参表示生成随机字符&lt;br&gt;
&#39;String&#39;: &#39;@string( 2, 10)&#39;, // 生成2到10个字符之间的字符串&lt;br&gt;
&#39;Range&#39;: &#39;@range(0, 10, 2)&#39;, // 生成一个数组，数组元素从0开始到10结束，间隔为2&lt;br&gt;
&#39;Date&#39;: &#39;@date(&amp;quot;yyyy yy y MM M dd d&amp;quot;)&#39;, // 生成一个随机日期,可加参数定义日期格式，默认yyyy-mm-dd&lt;br&gt;
&#39;Color1&#39;: &#39;@color&#39;, // 生成一个颜色16进制随机值&lt;br&gt;
&#39;Color2&#39;: &#39;@rgb&#39;, //生成一个颜色rgb随机值&lt;br&gt;
&#39;Paragraph&#39;:&#39;@paragraph(2, 5)&#39;, //生成2至5个句子的文本&lt;br&gt;
&#39;Sentence&#39;:&#39;@sentence(3, 5)&#39;, //生成3至5个单词组成的一个句子&lt;br&gt;
&#39;World&#39;:&#39;@word(3, 5)&#39;, //生成3-5个字母组成的单词&lt;br&gt;
&#39;title&#39;:&#39;@title(3,5)&#39;, //生成3-5个单词组成的标题&lt;br&gt;
&#39;cParagraph&#39;:&#39;@cparagraph(2, 5)&#39;, //生成2至5个句子的中文文本&lt;br&gt;
&#39;cSentence&#39;:&#39;@csentence(3, 5)&#39;, //生成3至5个词语组成的一个中文句子&lt;br&gt;
&#39;cWorld&#39;:&#39;@cword(3, 5)&#39;, //生成3-5个字组成的中文词语&lt;br&gt;
&#39;ctitle&#39;:&#39;@ctitle(3,5)&#39;, //生成3-5个词语组成的中文标题&lt;br&gt;
&#39;Name&#39;: &#39;@name&#39;, // 生成姓名&lt;br&gt;
&#39;cName&#39;: &#39;@cname&#39;, // 生成中文姓名&lt;br&gt;
&#39;Url&#39;: &#39;@url&#39;, // 生成url地址&lt;br&gt;
&#39;Email&#39;:&#39;@email&#39;,//生成邮箱&lt;br&gt;
&#39;Address&#39;: &#39;@county(true)&#39;， // 生成省 市 县组成的地址&lt;br&gt;
&#39;Guid&#39;:&#39;@guid()&#39;, //生成Guid值&lt;/p&gt;
">Vue&mock模拟数据</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/vueandmarkdown-bian-ji-qi-mavoneditor/"" data-c="
          &lt;h1 id=&#34;一-介绍&#34;&gt;一、介绍&lt;/h1&gt;
&lt;p&gt;Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。mavonEditor是国人开源的一款比较好用的markdown编辑器，GitHub地址：&lt;a href=&#34;https://github.com/hinesboy/mavonEditor&#34;&gt;https://github.com/hinesboy/mavonEditor&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;二-安装&#34;&gt;二、安装&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;npm install mavon-editor --save
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;三-使用&#34;&gt;三、使用&lt;/h1&gt;
&lt;h2 id=&#34;方法一&#34;&gt;方法一：&lt;/h2&gt;
&lt;p&gt;main.js:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; // 全局注册
    // import with ES6
    import Vue from &#39;vue&#39;
    import mavonEditor from &#39;mavon-editor&#39;
    import &#39;mavon-editor/dist/css/index.css&#39;
    // use
    Vue.use(mavonEditor)
    new Vue({
        &#39;el&#39;: &#39;#main&#39;,
        data() {
            return { value: &#39;&#39; }
        }
    })
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;index.html&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;main&amp;quot;&amp;gt;
    &amp;lt;mavon-editor v-model=&amp;quot;value&amp;quot;/&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;方法二&#34;&gt;方法二：&lt;/h2&gt;
&lt;p&gt;editor.vue:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;template&amp;gt;
        &amp;lt;div id=&amp;quot;editor&amp;quot;&amp;gt;
            &amp;lt;mavon-editor style=&amp;quot;height: 100%&amp;quot;&amp;gt;&amp;lt;/mavon-editor&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/template&amp;gt;
    &amp;lt;script&amp;gt;
    // Local Registration
    import { mavonEditor } from &#39;mavon-editor&#39;
    import &#39;mavon-editor/dist/css/index.css&#39;
    export default {
        name: &#39;editor&#39;,
        components: {
            mavonEditor
            // or &#39;mavon-editor&#39;: mavonEditor
        }
    }
    &amp;lt;/script&amp;gt;
    &amp;lt;style&amp;gt;
    #editor {
        margin: auto;
        width: 80%;
        height: 580px;
    }
    &amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;index.js:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 下同
    import Vue from &#39;vue&#39;;
    var editor = require(&#39;./editor.vue&#39;);
    new Vue({
        el: &#39;#main&#39;,
        render: h =&amp;gt; h(editor)
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;index.html:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 下同
&amp;lt;div id=&amp;quot;main&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;四-图片上传&#34;&gt;四、图片上传&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
    &amp;lt;mavon-editor ref=md @imgAdd=&amp;quot;$imgAdd&amp;quot; @imgDel=&amp;quot;$imgDel&amp;quot;&amp;gt;&amp;lt;/mavon-editor&amp;gt;
&amp;lt;/template&amp;gt;
exports default {
    methods: {
        // 绑定@imgAdd event
        $imgAdd(pos, $file){
            // 第一步.将图片上传到服务器.
           var formdata = new FormData();
           formdata.append(&#39;image&#39;, $file);
           axios({
               url: &#39;server url&#39;,
               method: &#39;post&#39;,
               data: formdata,
               headers: { &#39;Content-Type&#39;: &#39;multipart/form-data&#39; },
           }).then((url) =&amp;gt; {
               // 第二步.将返回的url替换到文本原位置![...](0) -&amp;gt; ![...](url)
               /**
               * $vm 指为mavonEditor实例，可以通过如下两种方式获取
               * 1. 通过引入对象获取: `import {mavonEditor} from ...` 等方式引入后，`$vm`为`mavonEditor`
               * 2. 通过$refs获取: html声明ref : `&amp;lt;mavon-editor ref=md &amp;gt;&amp;lt;/mavon-editor&amp;gt;，`$vm`为 `this.$refs.md`
               */
               $vm.$img2Url(pos, url);
           })
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注:&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;默认大小样式为 min-height: 300px , min-width: 300px 可自行覆盖&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;基础z-index: 1500&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;仅用作展示可以设置props: toolbarsFlag: false , subfield: false, defaultOpen: &amp;quot;preview&amp;quot;&lt;/strong&gt;&lt;/p&gt;
">Vue&markdown编辑器--mavonEditor</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/nodejs-cong-ling-dan-pai-6/"" data-c="
          &lt;h1 id=&#34;六-利用-http模块-url模块-path模块-创建静态web服务器&#34;&gt;六、利用 HTTP模块 Url模块 Path模块 创建静态WEB服务器&lt;/h1&gt;
&lt;h2 id=&#34;1-nodejs-创建的第一个应用&#34;&gt;1、Node.js 创建的第一个应用&lt;/h2&gt;
&lt;p&gt;1、引入 http 模块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var http = require(&amp;quot;http&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、创建服务器&lt;br&gt;
接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 3000 端口。 函数通过 request, response 参数来接收和响应数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const http =require(&#39;http&#39;); 
http.createServer((req,res)=&amp;gt;{ 
    //状态码是 200，文件类型是 html，字符集是 utf-8 
    res.writeHead(200,{&amp;quot;Content-type&amp;quot;:&amp;quot;text/html;charset=&#39;utf-8&#39;&amp;quot;}); 
    res.write(&amp;quot;&amp;lt;head&amp;gt; &amp;lt;meta charset=&#39;UTF-8&#39;&amp;gt;&amp;lt;/head&amp;gt;&amp;quot;); 
    res.write(&#39;你好 nodejs&#39;); 
    res.write(&#39;&amp;lt;h2&amp;gt;你好 nodejs&amp;lt;/h2&amp;gt;&#39;); 
    res.end(); //结束响应
}).listen(3000);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-web-服务器介绍&#34;&gt;2、WEB 服务器介绍&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Web 服务器一般指网站服务器&lt;/strong&gt;，是指驻留于因特网上某种类型计算机的程序，可以向 浏览器等 Web 客户端提供文档，也可以放置网站文件让全世界浏览，还可以放置数据文件， 让全世界下载。目前最主流的 Web 服务器有 Apache 、Nginx 、IIS 等。&lt;/p&gt;
&lt;h2 id=&#34;3-nodejs-创建一个-web-服务器&#34;&gt;3、Nodejs 创建一个 WEB 服务器。&lt;/h2&gt;
&lt;p&gt;1、可以让我们访问 web 服务器上面的网站&lt;br&gt;
2、可以让我们下载 web 服务器上面的文件&lt;/p&gt;
&lt;h1 id=&#34;七-nodejs-封装静态-web-服务-路由-ejs-模板引擎&#34;&gt;七、NodeJs 封装静态 WEB 服务、 路由、 EJS 模板引擎&lt;/h1&gt;
&lt;h2 id=&#34;1-nodejs-封装静态-web-服务&#34;&gt;1、 Nodejs 封装静态 web 服务&lt;/h2&gt;
&lt;p&gt;上一讲的静态 web 服务器封装&lt;/p&gt;
&lt;h2 id=&#34;2-路由&#34;&gt;2、 路由&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;官方解释：&lt;/strong&gt;&lt;br&gt;
路由（Routing）是由一个 URI（或者叫路径）和一个特定的 HTTP 方法（GET、POST 等）组成的，涉及到应用如何响应客户端对某个网站节点的访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通俗的说：&lt;/strong&gt;&lt;br&gt;
路由指的就是针对不同请求的 URL，处理不同的业务逻辑。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1608781577104.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-初识-ejs-模块引擎&#34;&gt;3、 初识 EJS 模块引擎&lt;/h2&gt;
&lt;p&gt;我们学的 EJS 是后台模板，可以把我们数据库和文件读取的数据显示到 Html 页面上面。它是一个第三方模块，需要通过 npm 安装&lt;br&gt;
&lt;a href=&#34;https://www.npmjs.com/package/ejs&#34;&gt;https://www.npmjs.com/package/ejs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install ejs –save / cnpm install ejs --save
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nodejs 中使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ejs.renderFile(filename, data, options, function(err, str){ 
    // str =&amp;gt;  Rendered HTML string 
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;EJS 常用标签&lt;br&gt;
 &amp;lt;% %&amp;gt;流程控制标签&lt;br&gt;
 &amp;lt;%= %&amp;gt;输出标签（原文输出 HTML 标签）&lt;br&gt;
 &amp;lt;%- %&amp;gt;输出标签（HTML 会被浏览器解析）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;&amp;lt;%= url %&amp;gt;&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;&amp;lt;%= imageURL %&amp;gt;&amp;quot; alt=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt; 
    &amp;lt;% for(var i = 0 ; i &amp;lt; news.length ; i++){ %&amp;gt; 
         &amp;lt;li&amp;gt;&amp;lt;%= news[i] %&amp;gt;&amp;lt;/li&amp;gt; 
    &amp;lt;% } %&amp;gt; 
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-get-post&#34;&gt;4、 Get、Post&lt;/h2&gt;
&lt;p&gt;超文本传输协议（HTTP）的设计目的是保证客户端机器与服务器之间的通信。&lt;br&gt;
在客户端和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。&lt;/p&gt;
&lt;p&gt;GET - 从指定的资源请求数据。（一般用于获取数据）&lt;br&gt;
POST - 向指定的资源提交要被处理的数据。（一般用于提交数据）&lt;/p&gt;
&lt;p&gt;获取 GET 传值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var urlinfo=url.parse(req.url,true); 
urlinfo.query;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取 POST 传值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var postData = &#39;&#39;; 
// 数据块接收中 
req.on(&#39;data&#39;, function (postDataChunk) { 
    postData += postDataChunk; 
}); 
// 数据接收完毕，执行回调函数 
req.on(&#39;end&#39;, function () { 
    try {postData = JSON.parse(postData); 
    } catch (e) { } 
    req.query = postData; 
    console.log(querystring.parse(postData)); 
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;八-nodejs路由封装-仿照express&#34;&gt;八、Nodejs路由封装 仿照express&lt;/h1&gt;
&lt;h2 id=&#34;1-模块化的方式封装&#34;&gt;1、模块化的方式封装&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var app={ 
    static:function (req, res, staticPath) { 
        //处理静态资源 
    },
    login:function(req,res){ 
        console.log(&#39;login&#39;); 
        res.end(&#39;login&#39;); 
    },
    dologin:function(req,res){ 
        res.end(&#39;doLogin&#39;); 
    }, 
    register:function(req,res){ 
        res.end(&#39;register&#39;); 
    },error:function(req,res){ 
        res.end(&#39;error&#39;); 
    } 
}
module.exports=app;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;http.createServer(function (req, res) { 
    //创建静态 web 服务 
    routes.static(req,res,&#39;static&#39;); 
    //路由 
    let pathname=url.parse(req.url).pathname.replace(&#39;/&#39;,&#39;&#39;); 
    try { 
        routes[pathname](req, res); 
    } catch (err) { 
        routes[&#39;error&#39;](req, res); 
        }
}).listen(3000);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-封装仿照-express-的路由&#34;&gt;2、封装仿照 express 的路由&lt;/h2&gt;
&lt;p&gt;Express 官网：&lt;a href=&#34;https://www.expressjs.com.cn/&#34;&gt;https://www.expressjs.com.cn/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var express = require(&#39;express&#39;) 
var app = express() 
app.get(&amp;quot;/&amp;quot;, function (req, res) { 
    res.send(&#39;hello world&#39;) 
})
app.get(&amp;quot;/login&amp;quot;, function (req, res) {
    res.send(&#39;hello world&#39;) 
})
app.post(&amp;quot;/doLogin&amp;quot;, function (req, res) { 
    res.send(&#39;POST request to the homepage&#39;) 
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;九-nodejs调用mongodb驱动&#34;&gt;九、Nodejs调用Mongodb驱动&lt;/h1&gt;
&lt;h2 id=&#34;1-在-nodejs-中使用-mongodb&#34;&gt;1、在 Nodejs 中使用 Mongodb&lt;/h2&gt;
&lt;p&gt;在前面的课程我们给大家讲了如何使用命令操作 Mongodb，这一讲开始我们给大家讲解一 下如何使用 Nodejs 来操作 Mongodb 数据库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Nodejs 操作 mongodb 数据库官方文档：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://mongodb.github.io/node-mongodb-native/&#34;&gt;http://mongodb.github.io/node-mongodb-native/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install mongodb --save 
或者
cnpm install mongodb --save 
或者
yarn add mongodb
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-nodejs-连接-mongodb-数据库&#34;&gt;2、Nodejs 连接 MongoDb 数据库&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const MongoClient = require(&#39;mongodb&#39;).MongoClient;
const url = &#39;mongodb://localhost:27017&#39;; 
// const url = &#39;mongodb://admin:123456@localhost:27017/&#39;; 有密码连接方式 
const dbName = &#39;itying&#39;; 
const client = new MongoClient(url,{ useUnifiedTopology: true }); client.connect(function(err) { 
    if(err){
        console.log(err); 
        return;
     }
     console.log(&amp;quot;连接成功&amp;quot;); 
     //获取 db 对象 
     const db = client.db(dbName); 
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span style=&#34;color:red&#34;&gt;注意：如果数据库开启了权限验证的话需要使用下面方式连接数据库&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const url = &#39;mongodb://admin:123456@localhost:27017/&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span style=&#34;color:red&#34;&gt;其中：&lt;/span&gt;admin 表示用户名，123456 表示密码&lt;/p&gt;
&lt;h2 id=&#34;3-nodejs-查找-mongodb-数据库的数据&#34;&gt;3、Nodejs 查找 MongoDb 数据库的数据&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const MongoClient = require(&#39;mongodb&#39;).MongoClient; 
const url = &#39;mongodb://localhost:27017&#39;; 
const dbName = &#39;itying&#39;; 
const client = new MongoClient(url,{ useUnifiedTopology: true }); client.connect(function(err) { 
    if(err){
        console.log(err); 
        return; 
    }
    const db = client.db(dbName); //获取 db 对象 
    db.collection(&amp;quot;user&amp;quot;).find({}).toArray(function(err,data){ //查找 
        if(err){
            console.log(err); 
            return; 
        }
        console.log(data); 
        client.close(); 
        })
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-nodejs-给-mongodb-增加数据&#34;&gt;4、Nodejs 给 MongoDb 增加数据&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const MongoClient = require(&#39;mongodb&#39;).MongoClient; 
const url = &#39;mongodb://localhost:27017&#39;; 
const dbName = &#39;itying&#39;; 
const client = new MongoClient(url,{ useUnifiedTopology: true }); client.connect(function(err) { 
    if(err){
        console.log(err); 
        return; 
    }
    //获取 db 对象 
    const db = client.db(dbName); 
    //新增数据 
    db.collection(&amp;quot;user&amp;quot;).insertOne({&amp;quot;username&amp;quot;:&amp;quot;nodejs&amp;quot;,&amp;quot;age&amp;quot;:10},(err,result)=&amp;gt;{ 
        if(err){
            console.log(err); 
            return; 
        }
        console.log(result); 
        client.close(); 
     }) 
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-nodejs-修改-mongodb-数据&#34;&gt;5、Nodejs 修改 MongoDb 数据&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const MongoClient = require(&#39;mongodb&#39;).MongoClient; 
const url = &#39;mongodb://localhost:27017&#39;; 
// const url = &#39;mongodb://admin:123456@localhost:27017/&#39;; 有密码连接方式 
const dbName = &#39;itying&#39;; 
const client = new MongoClient(url,{ useUnifiedTopology: true }); client.connect(function(err) {
     if(err){
         console.log(err); 
         return; 
    }
    const db = client.db(dbName); 
    //获取 db 对象 
    db.collection(&amp;quot;user&amp;quot;).updateOne({&amp;quot;name&amp;quot;:&amp;quot;zhangsan&amp;quot;},{$set:{&amp;quot;age&amp;quot;:50}},(err,result)=&amp;gt;{ 
        if(err){
         console.log(err); 
         return; 
        }
        console.log(result); 
        client.close(); 
    })
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-nodejs-删除-mongodb-数据&#34;&gt;6、Nodejs 删除 MongoDb 数据&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const {MongoClient,ObjectID} = require(&#39;mongodb&#39;); 
const url = &#39;mongodb://localhost:27017&#39;; 
const dbName = &#39;itying&#39;; 
const client = new MongoClient(url,{ useUnifiedTopology: true }); client.connect(function(err) { 
    if(err){
        console.log(err); 
        return; 
        }
        //获取 db 对象 
        const db = client.db(dbName); 
        //删除数据 
        db.collection(&amp;quot;user&amp;quot;).deleteOne({ &amp;quot;username&amp;quot; : &amp;quot;nodejs&amp;quot; }, function(err, result) { 
            if(err){ 
                console.log(err); 
                return; 
            }
            console.log(result); 
            client.close(); 
        }); 
});
&lt;/code&gt;&lt;/pre&gt;
">NodeJs从零单排（下）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/nodejs-cong-ling-dan-pai/"" data-c="
          &lt;h1 id=&#34;一-nodejs-环境搭建&#34;&gt;一、NodeJs 环境搭建&lt;/h1&gt;
&lt;p&gt;官网：&lt;a href=&#34;https://nodejs.org/en/&#34;&gt;https://nodejs.org/en/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&#34;https://nodejs.org/en/download/&#34;&gt;https://nodejs.org/en/download/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载稳定版本、双击下一步下一步安装。&lt;/p&gt;
&lt;p&gt;安装完成重新打开 CMD。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1608729555271.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;二-nodejs-http-模块-url-模块-supervisor-工具&#34;&gt;二、NodeJs HTTP 模块、URL 模块、 supervisor 工具&lt;/h1&gt;
&lt;h2 id=&#34;1-nodejs-创建第一个应用&#34;&gt;1、Node.js 创建第一个应用&lt;/h2&gt;
&lt;h3 id=&#34;11-引入-http-模块&#34;&gt;1.1、引入 http 模块&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;var http = require(&amp;quot;http&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;12-创建服务器&#34;&gt;1.2、创建服务器&lt;/h3&gt;
&lt;p&gt;接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var http = require(&#39;http&#39;);
 http.createServer(function (request, response) {
    // 发送 HTTP 头部
    // HTTP 状态值: 200 : OK
    //设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf8 
    response.writeHead(200,{&amp;quot;Content-Type&amp;quot;:&amp;quot;text/html;charset=UTF-8&amp;quot;}); 
    // 发送响应数据 &amp;quot;Hello World&amp;quot; 
    res.end(&amp;quot;哈哈哈哈，我买了一个 iPhone&amp;quot; + (1+2+3) + &amp;quot;s&amp;quot;); 
    }).listen(8888); 
    // 终端打印如下信息 
    console.log(&#39;Server running at http://127.0.0.1:8888/&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;13-运行程序&#34;&gt;1.3、运行程序&lt;/h3&gt;
&lt;p&gt;用命令行切换到程序对应目录。通过 node 命令运行程序。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1608771582393.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
浏览器运行&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1608771633470.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
你会发现，我们本地写一个 js，打死都不能直接拖入浏览器运行，但是有了 node，我们任何一个 js 文件，都可以通过 node 来运行。&lt;span style=&#34;color:red&#34;&gt;也就是说，node 就是一个 js 的执行环境。&lt;/span&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-http-模块-url-模块&#34;&gt;2、HTTP 模块、URL 模块&lt;/h2&gt;
&lt;p&gt;Node.js 中，将很多的功能，划分为了一个个 module（模块）。 Node.js 中的很多功能都 是通过模块实现。&lt;/p&gt;
&lt;h3 id=&#34;21-http-模块的使用&#34;&gt;2.1、HTTP 模块的使用&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;//引用模块 
var http = require(&amp;quot;http&amp;quot;); 

//创建一个服务器，回调函数表示接收到请求之后做的事情 
var server = http.createServer(function(req,res){ 
    //req 参数表示请求，res 表示响应 
    console.log(&amp;quot;服务器接收到了请求&amp;quot; + req.url); 
    res.end(); // End 方法使 Web 服务器停止处理脚本并返回当前结果
 }); 
 //监听端口
server.listen(3000,&amp;quot;127.0.0.1&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置一个响应头：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;res.writeHead(200,{&amp;quot;Content-Type&amp;quot;:&amp;quot;text/html;charset=UTF8&amp;quot;});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1608772545739.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
我们现在来看一下 req 里面能够使用的东西。&lt;br&gt;
&lt;code&gt;最关键的就是 req.url 属性&lt;/code&gt;，表示用户的请求 URL 地址。所有的路由设计，都是通过 req.url 来实现的。&lt;br&gt;
我们比较关心的不是拿到 URL，而是识别这个 URL。&lt;br&gt;
&lt;span style=&#34;color:green&#34;&gt;识别 URL，用到了下面的&lt;code&gt;url 模块&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;22-url-模块的使用&#34;&gt;2.2、URL 模块的使用&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;url.parse() 解析 URL
url.format(urlObject) //是上面 url.parse() 操作的逆向操作 
url.resolve(from, to) 添加或者替换地址
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1、url.parse()&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1608772888877.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1608772910458.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1608772947330.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1608772951314.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;2、url.format()&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1608772985827.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;3、url.resolve()&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1608773020569.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-nodejs-自启动工具-supervisor&#34;&gt;3、Nodejs 自启动工具 supervisor&lt;/h2&gt;
&lt;p&gt;supervisor 会不停的 watch 你应用下面的所有文件，发现有文件被修改，就重新载入程序文件这样就实现了部署，修 改了程序文件后马上就能看到变更后的结果。麻麻再也不用担心我的重启 nodejs 了！&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先安装 supervisor&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g supervisor
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 supervisor 代替 node 命令启动应用&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1608773581099.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;三-commonjs-和-nodejs-模块-自定义模块&#34;&gt;三、CommonJs 和 Nodejs 模块、自定义模块&lt;/h1&gt;
&lt;h2 id=&#34;1-什么是-commonjs&#34;&gt;1. 什么是 CommonJs？&lt;/h2&gt;
&lt;p&gt;JavaScript 是一个强大面向对象语言，它有很多快速高效的解释器。然而， JavaScript 标准定义的 API 是为了构建基于浏览器的应用程序。并没有制定一个用于更广泛的应用程序 的标准库。&lt;code&gt;CommonJS 规范的提出,主要是为了弥补当前 JavaScript 没有标准库的缺陷。它的 终极目标就是：提供一个类似 Python，Ruby 和 Java 语言的标准库&lt;/code&gt;，而不只是让 JavaScript 停 留在小脚本程序的阶段。用 CommonJS API 编写出的应用，不仅可以利用 JavaScript 开发客户端应用，&lt;strong&gt;而且还可以编写以下应用。&lt;/strong&gt;&lt;br&gt;
     •服务器端 JavaScript 应用程序。（nodejs）&lt;br&gt;
     •命令行工具。&lt;br&gt;
     •桌面图形界面应用程序。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CommonJS 就是模块化的标准，nodejs 就是 CommonJS（模块化）的实现。&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-nodejs-中的模块化&#34;&gt;2、Nodejs 中的模块化&lt;/h2&gt;
&lt;p&gt;Node 应用由模块组成，采用 CommonJS 模块规范。&lt;/p&gt;
&lt;h3 id=&#34;21-在-node-中模块分为两类&#34;&gt;2.1 在 Node 中，模块分为两类:&lt;/h3&gt;
&lt;p&gt;一类是 Node 提供的模块,称为&lt;strong&gt;核心模块&lt;/strong&gt;；另一类是用户编写的模块，称为&lt;strong&gt;文件模块&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;    • 核心模块部分在 Node 源代码的编译过程中，编译进了二进制执行文件。在 Node 进 程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和 编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。 &lt;strong&gt;如：HTTP 模块 、URL 模块、Fs 模块都是 nodejs 内置的核心模块，可以直接引入使用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    • 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程、 速度相比核心模块稍微慢一些，但是用的非常多。&lt;strong&gt;这些模块需要我们自己定义。接下来我 们看一下 nodejs 中的自定义模块。&lt;/strong&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;22-commonjsnodejs中自定义模块的规定&#34;&gt;2.2 CommonJS（Nodejs）中自定义模块的规定：&lt;/h3&gt;
&lt;p&gt;1.我们可以把公共的功能&lt;strong&gt;抽离成为一个单独的 js 文件作为&lt;/strong&gt;一个模块，默认情况下面这 个模块里面的方法或者属性，外面是没法访问的。如果要让外部可以访问模块里面的方法或 者属性，就必须在模块里面通过 exports 或者 module.exports 暴露属性或者方法。&lt;/p&gt;
&lt;p&gt;2.在需要使用这些模块的文件中，通过 require 的方式引入这个模块。这个时候就可 以使用模块里面暴露的属性和方法。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1608774648876.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;23-定义使用模块&#34;&gt;2.3 定义使用模块：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// 定义一个 tools.js 的模块 
//模块定义
var tools = {
     sayHello: function() {
        return &#39;hello NodeJS&#39;;
        },
        add: function(x, y) {
            return x + y; 
            } 
 };// 模块接口的暴露 
// module.exports = tools; 
    exports.sayHello = tools.sayHello; 
    exports.add = tools.add;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var http = require(&#39;http&#39;); 
// 引入自定义的 tools.js 模块
var tools= require(&#39;./tools&#39;); 
tools.sayHello(); //使用模块
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-npm-init-生成-packagejson&#34;&gt;3、npm init 生成 package.json&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;npm init --yes
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;四-nodejs-中的包-npm-第三方模块&#34;&gt;四、Nodejs 中的包、npm 、第三方模块&lt;/h1&gt;
&lt;h2 id=&#34;1-包与npm&#34;&gt;1. 包与npm&lt;/h2&gt;
&lt;h3 id=&#34;11-包&#34;&gt;1.1. 包&lt;/h3&gt;
&lt;p&gt;Nodejs 中除了它自己提供的&lt;span style=&#34;color:red&#34;&gt;核心模块&lt;/span&gt;外，我们可以&lt;span style=&#34;color:red&#34;&gt;自定义模块&lt;/span&gt;，也可以使用&lt;span style=&#34;color:red&#34;&gt;第三方的模块&lt;/span&gt;。Nodejs 中第三方模块由包组成，可以通过包来对一组具有相互依赖关系的模块进行统一管理。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1608777425715.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;完全符合CommonJs规范的&lt;span style=&#34;color:red&#34;&gt;包目录&lt;/span&gt;一般包含如下这些文件。&lt;br&gt;
• package.json :包描述文件。&lt;br&gt;
• bin :用于存放可执行二进制文件的目录。&lt;br&gt;
• lib :用于存放 JavaScript 代码的目录。&lt;br&gt;
• doc :用于存放文档的目录。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;在 NodeJs 中通过 NPM 命令来下载第三方的模块（包）。&lt;/code&gt;&lt;br&gt;
&lt;a href=&#34;https://www.npmjs.com/package/silly-datetime&#34;&gt;https://www.npmjs.com/package/silly-datetime&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm i silly-datetime –save 
var sd = require(&#39;silly-datetime&#39;); 
sd.format(new Date(), &#39;YYYY-MM-DD HH:mm&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;12-npm-介绍&#34;&gt;1.2. NPM 介绍&lt;/h3&gt;
&lt;p&gt;npm 是&lt;code&gt;世界上最大的开放源代码&lt;/code&gt;的生态系统。我们可以通过 npm 下载各种各样的包， 这些源代码（包）我们可以在&lt;a href=&#34;https://www.npmjs.com&#34;&gt;https://www.npmjs.com&lt;/a&gt;找到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;npm 是随同 NodeJS 一起安装的包管理工具，能解决 NodeJS 代码部署上的很多问题， 常见的使用场景有以下几种：&lt;/strong&gt;&lt;br&gt;
 允许用户从 NPM 服务器下载别人编写的第三方包到本地使用。(silly-datetime)&lt;br&gt;
 允许用户从 NPM 服务器下载并安装别人编写的命令行程序(工具)到本地使用。 （supervisor）&lt;br&gt;
 允许用户将自己编写的包或命令行程序上传到 NPM 服务器供别人使用。&lt;/p&gt;
&lt;h2 id=&#34;2-npm-命令详解&#34;&gt;2、NPM 命令详解。&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;npm -v 查看 npm 版本&lt;/li&gt;
&lt;li&gt;使用 npm 命令安装模块&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;npm install Module Name 
如安装 jq 模块：
npm install jquery
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;npm uninstall moudleName &lt;strong&gt;卸载模块&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;npm uninstall ModuleName
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;npm list 查看当前目录下已安装的 node 包&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;npm list
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;npm info jquery 查看 jquery 的版本&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;npm info 模块 //查看模块的版本
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;code&gt;指定版本安装 npm install jquery@1.8.0&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-packagejson&#34;&gt;3、package.json&lt;/h2&gt;
&lt;p&gt;package.json定义了这个项目所需要的各种模块,以及项目的配置信息(比如名称、版本、 许可证等元数据)&lt;br&gt;
1、&lt;code&gt;创建 package.json&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm init 或者 npm init –yes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、&lt;code&gt;package.json 文件&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
     &amp;quot;name&amp;quot;: &amp;quot;test&amp;quot;, 
     &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;, 
     &amp;quot;description&amp;quot;: &amp;quot;test&amp;quot;, 
     &amp;quot;main&amp;quot;: &amp;quot;main.js&amp;quot;, 
     &amp;quot;keywords&amp;quot;: [ &amp;quot;test&amp;quot; ],
     &amp;quot;author&amp;quot;: &amp;quot;wade&amp;quot;,
     &amp;quot;license&amp;quot;: &amp;quot;MIT&amp;quot;, 
     &amp;quot;dependencies&amp;quot;: { 
        &amp;quot;express&amp;quot;: &amp;quot;^4.10.1&amp;quot;
        },
        &amp;quot;devDependencies&amp;quot;: {
        &amp;quot;jslint&amp;quot;: &amp;quot;^0.6.5&amp;quot; 
     }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、安装模块并把模块写入 package.json(依赖)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install babel-cli --save-dev 
npm install 模块 --save 
npm install 模块 --save-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、&lt;code&gt;dependencies 与 devDependencies 之间的区别?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用 npm install node_module –save 自动更新 dependencies 字段值;&lt;br&gt;
使用 npm install node_module –save-dev 自动更新 devDependencies 字段值;&lt;/p&gt;
&lt;p&gt;dependencie 配置当前程序所依赖的其他包。&lt;br&gt;
devDependencie 配置当前程序所依赖的其他包，比如一些工具之类的配置在这里&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;dependencies&amp;quot;: { 
    &amp;quot;ejs&amp;quot;: &amp;quot;^2.3.4&amp;quot;, 
    &amp;quot;express&amp;quot;: &amp;quot;^4.13.3&amp;quot;,
     &amp;quot;formidable&amp;quot;: &amp;quot;^1.0.17&amp;quot;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;div style=&#34;color:red&#34;&gt;
^表示第一位版本号不变，后面两位取最新的&lt;br&gt;
~表示前两位不变，最后一个取最新&lt;br&gt;
*表示全部取最新
&lt;/div&gt;
&lt;h2 id=&#34;4-安装淘宝镜像&#34;&gt;4、安装淘宝镜像&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.npmjs.org&#34;&gt;http://www.npmjs.org&lt;/a&gt;  npm 包官网&lt;br&gt;
&lt;a href=&#34;https://npm.taobao.org/&#34;&gt;https://npm.taobao.org/&lt;/a&gt; 淘宝 npm 镜像官网&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;淘宝 NPM 镜像&lt;/strong&gt;是一个完整 &lt;strong&gt;npmjs.org&lt;/strong&gt; 镜像，你可以用此代替官方版本(只读)，同步频 率目前为 10 分钟 一次以保证尽量与官方服务同步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们可以使用我们定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g cnpm --registry=https://registry.npm.taobao.org
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;五-nodejs-中的-fs-模块的使用&#34;&gt;五、Nodejs 中的 fs 模块的使用&lt;/h1&gt;
&lt;h2 id=&#34;1-fsstat-检测是文件还是目录&#34;&gt;1. fs.stat 检测是文件还是目录&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;) 
fs.stat(&#39;hello.js&#39;, (error, stats) =&amp;gt;{ 
    if(error){
         console.log(error) 
         } else {
        console.log(stats) 
        console.log(`文件：${stats.isFile()}`) 
        console.log(`目录：${stats.isDirectory()}`) 
        } 
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-fsmkdir-创建目录&#34;&gt;2. fs.mkdir 创建目录&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;)
fs.mkdir(&#39;logs&#39;, (error) =&amp;gt; { 
    if(error){ 
       console.log(error) 
   } else { 
    console.log(&#39;成功创建目录：logs&#39;) 
     } 
 })
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-fswritefile-创建写入文件&#34;&gt;3. fs.writeFile 创建写入文件&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;fs.writeFile(&#39;logs/hello.log&#39;, &#39;您好 ~ \n&#39;, (error) =&amp;gt; { 
    if(error) { 
        console.log(error) 
   } else { 
        console.log(&#39;成功写入文件&#39;) 
    } 
 })
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-fsappendfile-追加文件&#34;&gt;4. fs.appendFile 追加文件&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;) 
fs.appendFile(&#39;logs/hello.log&#39;, &#39;hello ~ \n&#39;, (error) =&amp;gt; { 
    if(error) { 
    console.log(error) 
    } else { 
        console.log(&#39;成功写入文件&#39;) 
    } 
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5fsreadfile-读取文件&#34;&gt;5.fs.readFile 读取文件&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;) 
fs.readFile(&#39;logs/hello.log&#39;, &#39;utf8&#39;, (error, data) =&amp;gt;{ 
    if (error) { 
     console.log(error) 
} else { 
    console.log(data) 
    } 
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6fsreaddir-读取目录&#34;&gt;6.fs.readdir 读取目录&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;) 
fs.readdir(&#39;logs&#39;, (error, files) =&amp;gt; { 
   if (error) { 
     console.log(error) 
  } else { 
    console.log(files) 
    }
 })
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7fsrename-重命名&#34;&gt;7.fs.rename 重命名&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;) 
fs.rename(&#39;js/hello.log&#39;, &#39;js/greeting.log&#39;, (error) =&amp;gt;{ 
 if (error) { 
     console.log(error) 
  } else { 
console.log(&#39;重命名成功&#39;) 
    }
 })
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8-fsrmdir-删除目录&#34;&gt;8. fs.rmdir 删除目录&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;) 
fs.rmdir(&#39;logs&#39;, (error) =&amp;gt;{ 
 if (error) { 
    console.log(error) 
    } else { 
    console.log(&#39;成功的删除了目录：logs&#39;) 
     } 
 })
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;9-fsunlink-删除文件&#34;&gt;9. fs.unlink 删除文件&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;) 
fs.unlink(`logs/${file}`, (error) =&amp;gt; { 
  if (error) { 
    console.log(error) 
    } else { 
    console.log(`成功的删除了文件: ${file}`) 
    } 
 })
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;10-fscreatereadstream-从文件流中读取数据&#34;&gt;10. fs.createReadStream 从文件流中读取数据&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;) 
var fileReadStream = fs.createReadStream(&#39;data.json&#39;) 
let count=0; 
var str=&#39;&#39;; 
fileReadStream.on(&#39;data&#39;, (chunk) =&amp;gt; { 
    console.log(`${ ++count } 接收到：${chunk.length}`);
     str+=chunk
     })
fileReadStream.on(&#39;end&#39;, () =&amp;gt; { 
    console.log(&#39;--- 结束 ---&#39;); 
    console.log(count); 
    console.log(str); 
})
fileReadStream.on(&#39;error&#39;, (error) =&amp;gt; { 
    console.log(error)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;11-fscreatewritestream-写入文件&#34;&gt;11. fs.createWriteStream 写入文件&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var fs = require(&amp;quot;fs&amp;quot;); 
var data = &#39;我是从数据库获取的数据，我要保存起来&#39;; 
// 创建一个可以写入的流，写入到文件 output.txt 中
var writerStream = fs.createWriteStream(&#39;output.txt&#39;); 
// 使用 utf8 编码写入数据 
writerStream.write(data,&#39;UTF8&#39;); 
// 标记文件末尾 
writerStream.end();
// 处理流事件 --&amp;gt; finish 事件
writerStream.on(&#39;finish&#39;, function() { 
    /*finish - 所有数据已被写入到底层系统时触发。*/
console.log(&amp;quot;写入完成。&amp;quot;); 
}); 
writerStream.on(&#39;error&#39;, function(err){ 
    console.log(err.stack); 
}); 
console.log(&amp;quot;程序执行完毕&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;12-管道流&#34;&gt;12. 管道流&lt;/h2&gt;
&lt;p&gt;管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传 递到另外一个流中。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1608779085554.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如上面的图片所示，我们把文件比作装水的桶，而水就是文件里的内容，我们用一根管子(pipe)连接两个桶使得水从一个桶流入另一个桶，这样就慢慢的实现了大文件的复制过程。 以下实例我们通过读取一个文件内容并将内容写入到另外一个文件中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var fs = require(&amp;quot;fs&amp;quot;); 
// 创建一个可读流 
var readerStream = fs.createReadStream(&#39;input.txt&#39;); 
// 创建一个可写流 
var writerStream = fs.createWriteStream(&#39;output.txt&#39;); 
// 管道读写操作 
// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中 
readerStream.pipe(writerStream);
console.log(&amp;quot;程序执行完毕&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
">NodeJs从零单排（上）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/ecmascript-6-11/"" data-c="
          &lt;h1 id=&#34;第-1-章-ecmasript-相关介绍&#34;&gt;第 1 章 ECMASript 相关介绍&lt;/h1&gt;
&lt;h2 id=&#34;11什么是-ecma&#34;&gt;1.1.什么是 ECMA&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1607764166027.png&#34; alt=&#34;ECMA&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;ECMA（European Computer Manufacturers Association）中文名称为欧洲计算机制造商协会，这个组织的目标是评估、开发和认可电信和计算机标准。1994 年后该组织改名为 Ecma 国际。&lt;/p&gt;
&lt;h2 id=&#34;12什么是-ecmascript&#34;&gt;1.2.什么是 ECMAScript&lt;/h2&gt;
&lt;p&gt;ECMAScript 是由 Ecma 国际通过 ECMA-262 标准化的脚本程序设计语言。&lt;/p&gt;
&lt;h2 id=&#34;13什么是-ecma-262&#34;&gt;1.3.什么是 ECMA-262&lt;/h2&gt;
&lt;p&gt;Ecma 国际制定了许多标准，而 ECMA-262 只是其中的一个，所有标准列表查看&lt;br&gt;
&lt;a href=&#34;http://www.ecma-international.org/publications/standards/Standard.htm&#34;&gt;http://www.ecma-international.org/publications/standards/Standard.htm&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;14ecma-262-历史&#34;&gt;1.4.ECMA-262 历史&lt;/h2&gt;
&lt;p&gt;ECMA-262（ECMAScript）历史版本查看网址&lt;br&gt;
&lt;a href=&#34;http://www.ecma-international.org/publications/standards/Ecma-262-arch.htm&#34;&gt;http://www.ecma-international.org/publications/standards/Ecma-262-arch.htm&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1607764588998.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;div style=&#34;color:red&#34;&gt; 注：从 ES6 开始，每年发布一个版本，版本号比年份最后一位大 1&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;15谁在维护-ecma-262&#34;&gt;1.5.谁在维护 ECMA-262&lt;/h2&gt;
&lt;p&gt;TC39（Technical Committee 39）是推进 ECMAScript 发展的委员会。其会员都是公司（其中主要是浏览器厂商，有苹果、谷歌、微软、因特尔等）。TC39 定期召开会议，会议由会员公司的代表与特邀专家出席。&lt;/p&gt;
&lt;h2 id=&#34;16为什么要学习-es6&#34;&gt;1.6.为什么要学习 ES6&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ES6 的版本变动内容最多，具有里程碑意义&lt;/li&gt;
&lt;li&gt;ES6 加入许多新的语法特性，编程实现更简单、高效&lt;/li&gt;
&lt;li&gt;ES6 是前端发展趋势，就业必备技能&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;17es6-兼容性&#34;&gt;1.7.ES6 兼容性&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://kangax.github.io/compat-table/es6/&#34;&gt;可查看兼容性&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;第-2-章-ecmasript-6-新特性&#34;&gt;第 2 章 ECMASript 6 新特性&lt;/h1&gt;
&lt;h2 id=&#34;21let-关键字&#34;&gt;2.1.let 关键字&lt;/h2&gt;
&lt;p&gt;let 关键字用来声明变量，使用 let 声明的变量有几个特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不允许重复声明&lt;/li&gt;
&lt;li&gt;块儿级作用域&lt;/li&gt;
&lt;li&gt;不存在变量提升&lt;/li&gt;
&lt;li&gt;不影响作用域链&lt;/li&gt;
&lt;/ol&gt;
&lt;div style=&#34;color:red&#34;&gt; 应用场景：以后声明变量使用 let 就对了&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;22-const-关键字&#34;&gt;2.2. const 关键字&lt;/h2&gt;
&lt;p&gt;const 关键字用来声明常量，const 声明有以下特点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;声明必须赋初始值&lt;/li&gt;
&lt;li&gt;标识符一般为大写&lt;/li&gt;
&lt;li&gt;不允许重复声明&lt;/li&gt;
&lt;li&gt;值不允许修改&lt;/li&gt;
&lt;li&gt;块儿级作用域&lt;/li&gt;
&lt;/ol&gt;
&lt;div style=&#34;color:red&#34;&gt; 注意: 对象属性修改和数组元素变化不会出发 const 错误&lt;/div&gt;
&lt;div style=&#34;color:red&#34;&gt; 应用场景：声明对象类型使用 const，非对象类型声明选择 let&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;23变量的解构赋值&#34;&gt;2.3.变量的解构赋值&lt;/h2&gt;
&lt;p&gt;ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//数组的解构赋值
const arr = [&#39;张学友&#39;, &#39;刘德华&#39;, &#39;黎明&#39;, &#39;郭富城&#39;];
let [zhang, liu, li, guo] = arr;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;//对象的解构赋值
const lin = {
 name: &#39;林志颖&#39;,
 tags: [&#39;车手&#39;, &#39;歌手&#39;, &#39;小旋风&#39;, &#39;演员&#39;]
};
let {name, tags} = lin;
//复杂解构
let wangfei = {
 name: &#39;王菲&#39;,
 age: 18,
 songs: [&#39;红豆&#39;, &#39;流年&#39;, &#39;暧昧&#39;, &#39;传奇&#39;],
 history: [
 {name: &#39;窦唯&#39;},
 {name: &#39;李亚鹏&#39;},
 {name: &#39;谢霆锋&#39;}
 ]
};
let {songs: [one, two, three], history: [first, second, third]} = 
wangfei;
&lt;/code&gt;&lt;/pre&gt;
&lt;div style=&#34;color:red&#34;&gt;注意：频繁使用对象方法、数组元素，就可以使用解构赋值形式&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;24模板字符串&#34;&gt;2.4.模板字符串&lt;/h2&gt;
&lt;p&gt;模板字符串（template string）是增强版的字符串，用反引号（`）标识，特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;字符串中可以出现换行符&lt;/li&gt;
&lt;li&gt;可以使用 ${xxx} 形式输出变量&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;// 定义字符串
let str = `&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;沈腾&amp;lt;/li&amp;gt;
 &amp;lt;li&amp;gt;玛丽&amp;lt;/li&amp;gt;
 &amp;lt;li&amp;gt;魏翔&amp;lt;/li&amp;gt;
 &amp;lt;li&amp;gt;艾伦&amp;lt;/li&amp;gt;
 &amp;lt;/ul&amp;gt;`;
// 变量拼接
let star = &#39;王宁&#39;;
let result = `${star}在前几年离开了开心麻花`;
&lt;/code&gt;&lt;/pre&gt;
&lt;div style=&#34;color:red&#34;&gt;注意：当遇到字符串与变量拼接的情况使用模板字符串&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;25简化对象写法&#34;&gt;2.5.简化对象写法&lt;/h2&gt;
&lt;p&gt;ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let name = &#39;尚硅谷&#39;;
let slogon = &#39;永远追求行业更高标准&#39;;
let improve = function () {
 console.log(&#39;可以提高你的技能&#39;);
}
//属性和方法简写
let atguigu = {
 name,
 slogon,
 improve,
 change() {
 console.log(&#39;可以改变你&#39;)
 }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;div style=&#34;color:red&#34;&gt;注意：对象简写形式简化了代码，所以以后用简写就对了&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;26箭头函数&#34;&gt;2.6.箭头函数&lt;/h2&gt;
&lt;p&gt;ES6 允许使用「箭头」（=&amp;gt;）定义函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
* 1. 通用写法
*/
let fn = (arg1, arg2, arg3) =&amp;gt; {
 return arg1 + arg2 + arg3;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;箭头函数的注意点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果形参只有一个，则小括号可以省略&lt;/li&gt;
&lt;li&gt;函数体如果只有一条语句，则花括号可以省略，函数的返回值为该条语句的&lt;br&gt;
执行结果&lt;/li&gt;
&lt;li&gt;箭头函数 this 指向声明时所在作用域下 this 的值&lt;/li&gt;
&lt;li&gt;箭头函数不能作为构造函数实例化&lt;/li&gt;
&lt;li&gt;不能使用 arguments&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;/**
* 2. 省略小括号的情况
*/
let fn2 = num =&amp;gt; {
 return num * 10;
};
/**
* 3. 省略花括号的情况
*/
let fn3 = score =&amp;gt; score * 20;
/**
* 4. this 指向声明时所在作用域中 this 的值
*/
let fn4 = () =&amp;gt; {
 console.log(this);
}
let school = {
 name: &#39;尚硅谷&#39;,
 getName(){
 let fn5 = () =&amp;gt; {
 console.log(this);
 }
 fn5();
 }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;div style=&#34;color:red&#34;&gt;注意：箭头函数不会更改 this 指向，用来指定回调函数会非常合适&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;27-rest-参数&#34;&gt;2.7. rest 参数&lt;/h2&gt;
&lt;p&gt;ES6 引入 rest 参数，用于获取函数的实参，用来代替 arguments&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
* 作用与 arguments 类似
*/
function add(...args){
 console.log(args);
}
add(1,2,3,4,5);
/**
* rest 参数必须是最后一个形参
*/
function minus(a,b,...args){
 console.log(a,b,args);
}
minus(100,1,2,3,4,5,19);
&lt;/code&gt;&lt;/pre&gt;
&lt;div style=&#34;color:red&#34;&gt;注意：rest 参数非常适合不定个数参数函数的场景&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;28-spread-扩展运算符&#34;&gt;2.8. spread 扩展运算符&lt;/h2&gt;
&lt;p&gt;扩展运算符（spread）也是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列，对数组进行解包。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
* 展开数组
*/ 
let tfboys = [&#39;德玛西亚之力&#39;,&#39;德玛西亚之翼&#39;,&#39;德玛西亚皇子&#39;];
function fn(){
 console.log(arguments);
}
fn(...tfboys)
/**
* 展开对象
*/
let skillOne = {
 q: &#39;致命打击&#39;,
};
let skillTwo = {
 w: &#39;勇气&#39;
};
let skillThree = {
 e: &#39;审判&#39;
};
let skillFour = {
 r: &#39;德玛西亚正义&#39;
};
let gailun = {...skillOne, ...skillTwo,...skillThree,...skillFour};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;29symbol&#34;&gt;2.9.Symbol&lt;/h2&gt;
&lt;h3 id=&#34;291symbol-基本使用&#34;&gt;2.9.1.Symbol 基本使用&lt;/h3&gt;
&lt;p&gt;ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是JavaScript 语言的第七种数据类型，是一种类似于字符串的数据类型。&lt;/p&gt;
&lt;p&gt;Symbol 特点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Symbol 的值是唯一的，用来解决命名冲突的问题&lt;/li&gt;
&lt;li&gt;Symbol 值不能与其他数据进行运算&lt;/li&gt;
&lt;li&gt;Symbol 定义 的 对象属 性 不能 使 用 for…in 循 环遍 历 ，但 是可 以 使 用&lt;br&gt;
Reflect.ownKeys 来获取对象的所有键名&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;//创建 Symbol
let s1 = Symbol();
console.log(s1, typeof s1);
//添加标识的 Symbol
let s2 = Symbol(&#39;尚硅谷&#39;);
let s2_2 = Symbol(&#39;尚硅谷&#39;);
console.log(s2 === s2_2);
//使用 Symbol for 定义
let s3 = Symbol.for(&#39;尚硅谷&#39;);
let s3_2 = Symbol.for(&#39;尚硅谷&#39;);
console.log(s3 === s3_2);
&lt;/code&gt;&lt;/pre&gt;
&lt;div style=&#34;color:red&#34;&gt;注: 遇到唯一性的场景时要想到 Symbol&lt;/div&gt;
&lt;br&gt;
&lt;h3 id=&#34;292symbol-内置值&#34;&gt;2.9.2.Symbol 内置值&lt;/h3&gt;
&lt;p&gt;除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。可以称这些方法为魔术方法，因为它们会在特定的场景下自动执行。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1607828563219.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;210-迭代器&#34;&gt;2.10. 迭代器&lt;/h2&gt;
&lt;p&gt;遍历器（Iterator）就是一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ES6 创造了一种新的遍历命令 for...of 循环，Iterator 接口主要供 for...of 消费&lt;/li&gt;
&lt;li&gt;原生具备 iterator 接口的数据(可用 for of 遍历)&lt;br&gt;
a) Array&lt;br&gt;
b) Arguments&lt;br&gt;
c) Set&lt;br&gt;
d) Map&lt;br&gt;
e) String&lt;br&gt;
f) TypedArray&lt;br&gt;
g) NodeList&lt;/li&gt;
&lt;li&gt;工作原理&lt;br&gt;
a) 创建一个指针对象，指向当前数据结构的起始位置&lt;br&gt;
b) 第一次调用对象的 next 方法，指针自动指向数据结构的第一个成员&lt;br&gt;
c) 接下来不断调用 next 方法，指针一直往后移动，直到指向最后一个成员&lt;br&gt;
d) 每调用 next 方法返回一个包含 value 和 done 属性的对象&lt;/li&gt;
&lt;/ol&gt;
&lt;div style=&#34;color:red&#34;&gt;注: 需要自定义遍历数据的时候，要想到迭代器。&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;211-生成器&#34;&gt;2.11. 生成器&lt;/h2&gt;
&lt;p&gt;生成器函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function * gen(){
 yield &#39;一只没有耳朵&#39;;
 yield &#39;一只没有尾巴&#39;;
 return &#39;真奇怪&#39;; }
let iterator = gen();
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;* 的位置没有限制&lt;/li&gt;
&lt;li&gt;生成器函数返回的结果是迭代器对象，调用迭代器对象的 next 方法可以得到yield 语句后的值&lt;/li&gt;
&lt;li&gt;yield 相当于函数的暂停标记，也可以认为是函数的分隔符，每调用一次 next方法，执行一段代码&lt;/li&gt;
&lt;li&gt;next 方法可以传递实参，作为 yield 语句的返回值&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;212-promise&#34;&gt;2.12. Promise&lt;/h2&gt;
&lt;p&gt;Promise 是 ES6 引入的异步编程的新解决方案。语法上 Promise 是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Promise 构造函数: Promise (excutor) {}&lt;/li&gt;
&lt;li&gt;Promise.prototype.then 方法&lt;/li&gt;
&lt;li&gt;Promise.prototype.catch 方法&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;213-set&#34;&gt;2.13. Set&lt;/h2&gt;
&lt;p&gt;ES6 提供了新的数据结构 Set（集合）。它类似于数组，但成员的值都是唯一的，集合实现了 iterator 接口，所以可以使用『扩展运算符』和『for…of…』进行遍历，集合的属性和方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;size 返回集合的元素个数&lt;/li&gt;
&lt;li&gt;add 增加一个新元素，返回当前集合&lt;/li&gt;
&lt;li&gt;delete 删除元素，返回 boolean 值&lt;/li&gt;
&lt;li&gt;has 检测集合中是否包含某个元素，返回 boolean 值&lt;/li&gt;
&lt;li&gt;clear 清空集合，返回 undefined&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;//创建一个空集合
let s = new Set();
//创建一个非空集合
let s1 = new Set([1,2,3,1,2,3]);
//集合属性与方法
//返回集合的元素个数
console.log(s1.size);
//添加新元素
console.log(s1.add(4));
//删除元素
console.log(s1.delete(1));
//检测是否存在某个值
console.log(s1.has(2));
//清空集合
console.log(s1.clear());
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;214-map&#34;&gt;2.14. Map&lt;/h2&gt;
&lt;p&gt;ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合。但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map 也实现了iterator 接口，所以可以使用『扩展运算符』和『for…of…』进行遍历。Map 的属性和方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;size 返回 Map 的元素个数&lt;/li&gt;
&lt;li&gt;set 增加一个新元素，返回当前 Map&lt;/li&gt;
&lt;li&gt;get 返回键名对象的键值&lt;/li&gt;
&lt;li&gt;has 检测 Map 中是否包含某个元素，返回 boolean 值&lt;/li&gt;
&lt;li&gt;clear 清空集合，返回 undefined&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;//创建一个空 map
let m = new Map();
//创建一个非空 map
let m2 = new Map([
 [&#39;name&#39;,&#39;尚硅谷&#39;],
 [&#39;slogon&#39;,&#39;不断提高行业标准&#39;]
]);
//属性和方法
//获取映射元素的个数
console.log(m2.size);
//添加映射值
console.log(m2.set(&#39;age&#39;, 6));
//获取映射值
console.log(m2.get(&#39;age&#39;));
//检测是否有该映射
console.log(m2.has(&#39;age&#39;));
//清除
console.log(m2.clear());
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;215-class-类&#34;&gt;2.15. class 类&lt;/h2&gt;
&lt;p&gt;ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过 class 关键字，可以定义类。基本上，ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。&lt;br&gt;
知识点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;class 声明类&lt;/li&gt;
&lt;li&gt;constructor 定义构造函数初始化&lt;/li&gt;
&lt;li&gt;extends 继承父类&lt;/li&gt;
&lt;li&gt;super 调用父级构造方法&lt;/li&gt;
&lt;li&gt;static 定义静态方法和属性&lt;/li&gt;
&lt;li&gt;父类方法可以重写&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;//父类
class Phone {
 //构造方法
 constructor(brand, color, price) {
 this.brand = brand;
 this.color = color;
 this.price = price;
 }
 //对象方法
 call() {
     console.log(&#39;我可以打电话!!!&#39;)
 } }
//子类
class SmartPhone extends Phone {
 constructor(brand, color, price, screen, pixel) {
 super(brand, color, price);
 this.screen = screen;
 this.pixel = pixel;
 }
 //子类方法
 photo(){
 console.log(&#39;我可以拍照!!&#39;);
 }
 playGame(){
 console.log(&#39;我可以玩游戏!!&#39;);
 }
 //方法重写
 call(){
 console.log(&#39;我可以进行视频通话!!&#39;);
 }
 //静态方法
 static run(){
 console.log(&#39;我可以运行程序&#39;)
 }
 static connect(){
 console.log(&#39;我可以建立连接&#39;)
 } }
 //实例化对象
const Nokia = new Phone(&#39;诺基亚&#39;, &#39;灰色&#39;, 230);
const iPhone6s = new SmartPhone(&#39;苹果&#39;, &#39;白色&#39;, 6088, 
&#39;4.7inch&#39;,&#39;500w&#39;);
//调用子类方法
iPhone6s.playGame();
//调用重写方法
iPhone6s.call();
//调用静态方法
SmartPhone.run();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;216-数值扩展&#34;&gt;2.16. 数值扩展&lt;/h2&gt;
&lt;h3 id=&#34;2161-二进制和八进制&#34;&gt;2.16.1. 二进制和八进制&lt;/h3&gt;
&lt;p&gt;ES6 提供了二进制和八进制数值的新的写法，分别用前缀 0b 和 0o 表示。&lt;/p&gt;
&lt;h3 id=&#34;2162-numberisfinite-与-numberisnan&#34;&gt;2.16.2. Number.isFinite() 与 Number.isNaN()&lt;/h3&gt;
&lt;p&gt;Number.isFinite() 用来检查一个数值是否为有限的&lt;br&gt;
Number.isNaN() 用来检查一个值是否为 NaN&lt;/p&gt;
&lt;h3 id=&#34;2163-numberparseint-与-numberparsefloat&#34;&gt;2.16.3. Number.parseInt() 与 Number.parseFloat()&lt;/h3&gt;
&lt;p&gt;ES6 将全局方法 parseInt 和 parseFloat，移植到 Number 对象上面，使用不变。&lt;/p&gt;
&lt;h3 id=&#34;2164-mathtrunc&#34;&gt;2.16.4. Math.trunc&lt;/h3&gt;
&lt;p&gt;用于去除一个数的小数部分，返回整数部分。&lt;/p&gt;
&lt;h3 id=&#34;2165-numberisinteger&#34;&gt;2.16.5. Number.isInteger&lt;/h3&gt;
&lt;p&gt;Number.isInteger() 用来判断一个数值是否为整数&lt;/p&gt;
&lt;h2 id=&#34;217-对象扩展&#34;&gt;2.17. 对象扩展&lt;/h2&gt;
&lt;p&gt;ES6 新增了一些 Object 对象的方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Object.is 比较两个值是否严格相等，与『===』行为基本一致（+0 与 NaN）&lt;/li&gt;
&lt;li&gt;Object.assign 对象的合并，将源对象的所有可枚举属性，复制到目标对象&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;proto&lt;/strong&gt;、setPrototypeOf、 setPrototypeOf 可以直接设置对象的原型&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;218-模块化&#34;&gt;2.18. 模块化&lt;/h2&gt;
&lt;p&gt;模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来。&lt;/p&gt;
&lt;h3 id=&#34;2181-模块化的好处&#34;&gt;2.18.1. 模块化的好处&lt;/h3&gt;
&lt;p&gt;模块化的优势有以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;防止命名冲突&lt;/li&gt;
&lt;li&gt;代码复用&lt;/li&gt;
&lt;li&gt;高维护性&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2182-模块化规范产品&#34;&gt;2.18.2. 模块化规范产品&lt;/h3&gt;
&lt;p&gt;ES6 之前的模块化规范有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CommonJS =&amp;gt; NodeJS、Browserify&lt;/li&gt;
&lt;li&gt;AMD =&amp;gt; requireJS&lt;/li&gt;
&lt;li&gt;CMD =&amp;gt; seaJS&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2183-es6-模块化语法&#34;&gt;2.18.3. ES6 模块化语法&lt;/h3&gt;
&lt;p&gt;模块功能主要由两个命令构成：export 和 import。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;export 命令用于规定模块的对外接口&lt;/li&gt;
&lt;li&gt;import 命令用于输入其他模块提供的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;第-3-章-ecmasript-7-新特性&#34;&gt;第 3 章 ECMASript 7 新特性&lt;/h1&gt;
&lt;h2 id=&#34;31arrayprototypeincludes&#34;&gt;3.1.Array.prototype.includes&lt;/h2&gt;
&lt;p&gt;Includes 方法用来检测数组中是否包含某个元素，返回布尔类型值&lt;/p&gt;
&lt;h2 id=&#34;32指数操作符&#34;&gt;3.2.指数操作符&lt;/h2&gt;
&lt;p&gt;在 ES7 中引入指数运算符「**」，用来实现幂运算，功能与 Math.pow 结果相同&lt;/p&gt;
&lt;h1 id=&#34;第-4-章-ecmasript-8-新特性&#34;&gt;第 4 章 ECMASript 8 新特性&lt;/h1&gt;
&lt;h2 id=&#34;41async-和-await&#34;&gt;4.1.async 和 await&lt;/h2&gt;
&lt;p&gt;async 和 await 两种语法结合可以让异步代码像同步代码一样&lt;/p&gt;
&lt;h3 id=&#34;411async-函数&#34;&gt;4.1.1.async 函数&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;async 函数的返回值为 promise 对象，&lt;/li&gt;
&lt;li&gt;promise 对象的结果由 async 函数执行的返回值决定&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;412await-表达式&#34;&gt;4.1.2.await 表达式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;await 必须写在 async 函数中&lt;/li&gt;
&lt;li&gt;await 右侧的表达式一般为 promise 对象&lt;/li&gt;
&lt;li&gt;await 返回的是 promise 成功的值&lt;/li&gt;
&lt;li&gt;await 的 promise 失败了, 就会抛出异常, 需要通过 try...catch 捕获处理&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;42objectvalues-和-objectentries&#34;&gt;4.2.Object.values 和 Object.entries&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Object.values()方法返回一个给定对象的所有可枚举属性值的数组&lt;/li&gt;
&lt;li&gt;Object.entries()方法返回一个给定对象自身可遍历属性 [key,value] 的数组&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;43objectgetownpropertydescriptors&#34;&gt;4.3.Object.getOwnPropertyDescriptors&lt;/h2&gt;
&lt;p&gt;该方法返回指定对象所有自身属性的描述对象&lt;/p&gt;
&lt;h1 id=&#34;第-5-章-ecmasript-9-新特性&#34;&gt;第 5 章 ECMASript 9 新特性&lt;/h1&gt;
&lt;h2 id=&#34;51restspread-属性&#34;&gt;5.1.Rest/Spread 属性&lt;/h2&gt;
&lt;p&gt;Rest 参数与 spread 扩展运算符在 ES6 中已经引入，不过 ES6 中只针对于数组，在 ES9 中为对象提供了像数组一样的 rest 参数和扩展运算符。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function connect({host, port, ...user}) {
 console.log(host);
 console.log(port);
 console.log(user);
}
connect({
 host: &#39;127.0.0.1&#39;,
 port: 3306,
 username: &#39;root&#39;,
 password: &#39;root&#39;,
 type: &#39;master&#39;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;52正则表达式命名捕获组&#34;&gt;5.2.正则表达式命名捕获组&lt;/h2&gt;
&lt;p&gt;ES9 允许命名捕获组使用符号『?&lt;name&gt;』,这样获取捕获结果可读性更强&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let str = &#39;&amp;lt;a href=&amp;quot;http://www.atguigu.com&amp;quot;&amp;gt;尚硅谷&amp;lt;/a&amp;gt;&#39;;
const reg = /&amp;lt;a href=&amp;quot;(?&amp;lt;url&amp;gt;.*)&amp;quot;&amp;gt;(?&amp;lt;text&amp;gt;.*)&amp;lt;\/a&amp;gt;/;
const result = reg.exec(str);
console.log(result.groups.url);
console.log(result.groups.text);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;53正则表达式反向断言&#34;&gt;5.3.正则表达式反向断言&lt;/h2&gt;
&lt;p&gt;ES9 支持反向断言，通过对匹配结果前面的内容进行判断，对匹配进行筛选。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//声明字符串
let str = &#39;JS5211314 你知道么 555 啦啦啦&#39;;
//正向断言
const reg = /\d+(?=啦)/;
const result = reg.exec(str);
//反向断言
const reg = /(?&amp;lt;=么)\d+/;
const result = reg.exec(str);
console.log(result);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;54正则表达式-dotall-模式&#34;&gt;5.4.正则表达式 dotAll 模式&lt;/h2&gt;
&lt;p&gt;正则表达式中点.匹配除回车外的任何单字符，标记『s』改变这种行为，允许行终止符出现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let str = `
&amp;lt;ul&amp;gt;
 &amp;lt;li&amp;gt;
 &amp;lt;a&amp;gt;肖生克的救赎&amp;lt;/a&amp;gt;
 &amp;lt;p&amp;gt;上映日期: 1994-09-10&amp;lt;/p&amp;gt;
 &amp;lt;/li&amp;gt;
 &amp;lt;li&amp;gt;
 &amp;lt;a&amp;gt;阿甘正传&amp;lt;/a&amp;gt;
 &amp;lt;p&amp;gt;上映日期: 1994-07-06&amp;lt;/p&amp;gt;
 &amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;`;
//声明正则
const reg = /&amp;lt;li&amp;gt;.*?&amp;lt;a&amp;gt;(.*?)&amp;lt;\/a&amp;gt;.*?&amp;lt;p&amp;gt;(.*?)&amp;lt;\/p&amp;gt;/gs;
//执行匹配
const result = reg.exec(str);
let result;
let data = [];
while(result = reg.exec(str)){
 data.push({title: result[1], time: result[2]});
}
//输出结果
console.log(data);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第-6-章-ecmasript-10-新特性&#34;&gt;第 6 章 ECMASript 10 新特性&lt;/h1&gt;
&lt;h2 id=&#34;61objectfromentries&#34;&gt;6.1.Object.fromEntries&lt;/h2&gt;
&lt;h2 id=&#34;62trimstart-和-trimend&#34;&gt;6.2.trimStart 和 trimEnd&lt;/h2&gt;
&lt;h2 id=&#34;63arrayprototypeflat-与-flatmap&#34;&gt;6.3.Array.prototype.flat 与 flatMap&lt;/h2&gt;
&lt;h2 id=&#34;64symbolprototypedescription&#34;&gt;6.4.Symbol.prototype.description&lt;/h2&gt;
&lt;h1 id=&#34;第-7-章-ecmasript-11-新特性&#34;&gt;第 7 章 ECMASript 11 新特性&lt;/h1&gt;
&lt;h2 id=&#34;71stringprototypematchall&#34;&gt;7.1.String.prototype.matchAll&lt;/h2&gt;
&lt;h2 id=&#34;72类的私有属性&#34;&gt;7.2.类的私有属性&lt;/h2&gt;
&lt;h2 id=&#34;73promiseallsettled&#34;&gt;7.3.Promise.allSettled&lt;/h2&gt;
&lt;h2 id=&#34;74可选链操作符&#34;&gt;7.4.可选链操作符&lt;/h2&gt;
&lt;h2 id=&#34;75动态-import-导入&#34;&gt;7.5.动态 import 导入&lt;/h2&gt;
&lt;h2 id=&#34;76globalthis-对象&#34;&gt;7.6.globalThis 对象&lt;/h2&gt;
&lt;p&gt;鸣谢：源自&lt;a href=&#34;https://www.bilibili.com/video/BV1uK411H7on&#34;&gt;视频教程-尚硅谷&lt;/a&gt;&lt;/p&gt;
">ECMAScript 6-11</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/ce-shi/"" data-c="
          &lt;h2 id=&#34;1element-ui-引言&#34;&gt;1.Element UI 引言&lt;/h2&gt;
&lt;p&gt;官网: &lt;a href=&#34;https://element.eleme.cn/#/zh-CN&#34;&gt;Element，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;11-官方定义&#34;&gt;1.1 官方定义&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;网站快速成型工具&lt;/code&gt; 和 &lt;code&gt;桌面端组件库&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;12-定义&#34;&gt;1.2 定义&lt;/h3&gt;
&lt;p&gt;element ui 就是基于vue的一个ui框架,该框架基于vue开发了很多相关组件,方便我们快速开发页面。&lt;/p&gt;
&lt;h3 id=&#34;13-由来&#34;&gt;1.3 由来&lt;/h3&gt;
&lt;p&gt;饿了么前端团队 基于vue进行开发并且进行了开源  element ui 中提供全部都是封装好组件。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2安装element-ui&#34;&gt;2.安装Element UI&lt;/h2&gt;
&lt;h3 id=&#34;21通过vue脚手架创建项目&#34;&gt;2.1通过vue脚手架创建项目&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;vue init webpack element(项目名)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;22在vue脚手架项目中安装elementui&#34;&gt;2.2在vue脚手架项目中安装elementui&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# 1.下载elementui的依赖
	npm i element-ui -S

# 2.指定当前项目中使用elementui
	import ElementUI from &#39;element-ui&#39;;
	import &#39;element-ui/lib/theme-chalk/index.css&#39;;

  //在vue脚手架中使用elementui
	Vue.use(ElementUI);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;3按钮组件示例&#34;&gt;3.按钮组件(示例)&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1606975701437.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;31-默认样式按钮&#34;&gt;3.1 默认样式按钮&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-row&amp;gt;
  &amp;lt;el-button&amp;gt;默认按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;primary&amp;quot;&amp;gt;主要按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;success&amp;quot;&amp;gt;成功按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;info&amp;quot;&amp;gt;信息按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;warning&amp;quot;&amp;gt;警告按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;danger&amp;quot;&amp;gt;危险按钮&amp;lt;/el-button&amp;gt;
&amp;lt;/el-row&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;32-简洁按钮&#34;&gt;3.2 简洁按钮&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-row&amp;gt;
  &amp;lt;el-button plain&amp;gt;朴素按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;primary&amp;quot; plain&amp;gt;主要按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;success&amp;quot; plain&amp;gt;成功按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;info&amp;quot; plain&amp;gt;信息按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;warning&amp;quot; plain&amp;gt;警告按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;danger&amp;quot; plain&amp;gt;危险按钮&amp;lt;/el-button&amp;gt;
&amp;lt;/el-row&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;33-圆角按钮&#34;&gt;3.3 圆角按钮&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-row&amp;gt;
  &amp;lt;el-button round&amp;gt;圆角按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;primary&amp;quot; round&amp;gt;主要按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;success&amp;quot; round&amp;gt;成功按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;info&amp;quot; round&amp;gt;信息按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;warning&amp;quot; round&amp;gt;警告按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;danger&amp;quot; round&amp;gt;危险按钮&amp;lt;/el-button&amp;gt;
&amp;lt;/el-row&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;34-图标按钮&#34;&gt;3.4 图标按钮&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-row&amp;gt;
  &amp;lt;el-button icon=&amp;quot;el-icon-search&amp;quot; circle&amp;gt;&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;primary&amp;quot; icon=&amp;quot;el-icon-edit&amp;quot; circle&amp;gt;&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;success&amp;quot; icon=&amp;quot;el-icon-check&amp;quot; circle&amp;gt;&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;info&amp;quot; icon=&amp;quot;el-icon-message&amp;quot; circle&amp;gt;&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;warning&amp;quot; icon=&amp;quot;el-icon-star-off&amp;quot; circle&amp;gt;&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;danger&amp;quot; icon=&amp;quot;el-icon-delete&amp;quot; circle&amp;gt;&amp;lt;/el-button&amp;gt;
&amp;lt;/el-row&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;4按钮组件的详细使用&#34;&gt;4.按钮组件的详细使用&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;总结:日后使用element ui的相关组件时需要注意的是 所有组件都是el-组件名称开头&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;41创建按钮&#34;&gt;4.1创建按钮&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-button&amp;gt;默认按钮&amp;lt;/el-button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;42-按钮属性使用&#34;&gt;4.2 按钮属性使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-button type=&amp;quot;primary&amp;quot; 属性名=属性值&amp;gt;默认按钮&amp;lt;/el-button&amp;gt;
&amp;lt;el-button type=&amp;quot;success&amp;quot; size=&amp;quot;medium&amp;quot; plain=true round circle icon=&amp;quot;el-icon-loading&amp;quot;&amp;gt;&amp;lt;/el-button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;总结:在elementui中所有组件的属性全部写在组件标签上&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;43-按钮组使用&#34;&gt;4.3 按钮组使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-button-group&amp;gt;
  &amp;lt;el-button type=&amp;quot;primary&amp;quot; icon=&amp;quot;el-icon-back&amp;quot;&amp;gt;上一页&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;primary&amp;quot; icon=&amp;quot;el-icon-right&amp;quot;&amp;gt;下一页&amp;lt;/el-button&amp;gt;
&amp;lt;/el-button-group&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在element ui中所有组件都是 &lt;code&gt;el-组件名称&lt;/code&gt; 方式进行命名&lt;/li&gt;
&lt;li&gt;在element ui中组件的属性使用&lt;code&gt;都是直接将属性名=属性值方式写在对应的组件标签上&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;5link-文字链接组件&#34;&gt;5.Link 文字链接组件&lt;/h2&gt;
&lt;h3 id=&#34;51-文字链接组件的创建&#34;&gt;5.1 文字链接组件的创建&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-link&amp;gt;默认链接&amp;lt;/el-link&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;52-文字链接组件的属性的使用&#34;&gt;5.2 文字链接组件的属性的使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-link  target=&amp;quot;_blank&amp;quot; href=&amp;quot;http://www.baidu.com&amp;quot; &amp;gt;默认链接&amp;lt;/el-link&amp;gt;
&amp;lt;el-link type=&amp;quot;primary&amp;quot;:underline=&amp;quot;false&amp;quot;&amp;gt;默认链接&amp;lt;/el-link&amp;gt;
&amp;lt;el-link type=&amp;quot;success&amp;quot; disabled&amp;gt;默认链接&amp;lt;/el-link&amp;gt;
&amp;lt;el-link type=&amp;quot;info&amp;quot; icon=&amp;quot;el-icon-platform-eleme&amp;quot;&amp;gt;默认链接&amp;lt;/el-link&amp;gt;
&amp;lt;el-link type=&amp;quot;warning&amp;quot;&amp;gt;默认链接&amp;lt;/el-link&amp;gt;
&amp;lt;el-link type=&amp;quot;danger&amp;quot;&amp;gt;默认链接&amp;lt;/el-link&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;6layout-栅格布局组件的使用&#34;&gt;6.Layout (栅格)布局组件的使用&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;通过基础的 24 分栏，迅速简便地创建布局&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;在element ui中布局组件将页面划分为多个行row,每行最多分为24栏(列)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;61-使用layout组件&#34;&gt;6.1 使用Layout组件&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-row&amp;gt;
	&amp;lt;el-col :span=&amp;quot;8&amp;quot;&amp;gt;占用8份&amp;lt;/el-col&amp;gt;
  &amp;lt;el-col :span=&amp;quot;8&amp;quot;&amp;gt;占用8份&amp;lt;/el-col&amp;gt;
  &amp;lt;el-col :span=&amp;quot;8&amp;quot;&amp;gt;占用8份&amp;lt;/el-col&amp;gt;
&amp;lt;/el-row&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在一个布局组件中 是由 &lt;code&gt;row&lt;/code&gt; 和 &lt;code&gt;col&lt;/code&gt; 组合而成&lt;/li&gt;
&lt;li&gt;在使用时要区分 &lt;code&gt;row属性&lt;/code&gt; 和 &lt;code&gt;col属性&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;62-属性的使用&#34;&gt;6.2 属性的使用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;行属性使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-row :gutter=&amp;quot;50&amp;quot; tag=&amp;quot;span&amp;quot;&amp;gt;
  &amp;lt;el-col :span=&amp;quot;4&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;border: 1px red solid;&amp;quot;&amp;gt;占用4份&amp;lt;/div&amp;gt;&amp;lt;/el-col&amp;gt;
  &amp;lt;el-col :span=&amp;quot;8&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;border: 1px red solid;&amp;quot;&amp;gt;占用8份&amp;lt;/div&amp;gt;&amp;lt;/el-col&amp;gt;
  &amp;lt;el-col :span=&amp;quot;3&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;border: 1px red solid;&amp;quot;&amp;gt;占用3份&amp;lt;/div&amp;gt;&amp;lt;/el-col&amp;gt;
  &amp;lt;el-col :span=&amp;quot;9&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;border: 1px red solid;&amp;quot;&amp;gt;占用9份&amp;lt;/div&amp;gt;&amp;lt;/el-col&amp;gt;
&amp;lt;/el-row&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列属性的使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-row&amp;gt;
  &amp;lt;el-col :span=&amp;quot;12&amp;quot; :offset=&amp;quot;9&amp;quot; :psuh=&amp;quot;3&amp;quot; xs&amp;gt;&amp;lt;div style=&amp;quot;border: 1px blue solid;&amp;quot;&amp;gt;我是占用12分&amp;lt;/div&amp;gt;&amp;lt;/el-col&amp;gt;
  &amp;lt;el-col :span=&amp;quot;6&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;border: 1px blue solid;&amp;quot;&amp;gt;我是占用6分&amp;lt;/div&amp;gt;&amp;lt;/el-col&amp;gt;
&amp;lt;/el-row&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;7container-布局容器组件&#34;&gt;7.Container 布局容器组件&lt;/h2&gt;
&lt;h3 id=&#34;71-创建布局容器&#34;&gt;7.1 创建布局容器&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-container&amp;gt;
	
&amp;lt;/el-container&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;72-容器中包含的子元素&#34;&gt;7.2 容器中包含的子元素&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-header&amp;gt;：顶栏容器。
&amp;lt;el-aside&amp;gt;：侧边栏容器。
&amp;lt;el-main&amp;gt;：主要区域容器。
&amp;lt;el-footer&amp;gt;：底栏容器。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;73-容器的嵌套使用&#34;&gt;7.3 容器的嵌套使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!--创建容器--&amp;gt;
&amp;lt;el-container&amp;gt;
  &amp;lt;!--header--&amp;gt;
  &amp;lt;el-header&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是标题&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-header&amp;gt;
  &amp;lt;!--容器嵌套使用--&amp;gt;
  &amp;lt;el-container&amp;gt;
    &amp;lt;!--aside--&amp;gt;
    &amp;lt;el-aside&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是菜单&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-aside&amp;gt;
    &amp;lt;!--main--&amp;gt;
    &amp;lt;el-main&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是中心内容&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-main&amp;gt;
  &amp;lt;/el-container&amp;gt;
  &amp;lt;el-footer&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是页脚&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-footer&amp;gt;
&amp;lt;/el-container&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;74-水平容器&#34;&gt;7.4 水平容器&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-container direction=&amp;quot;horizontal&amp;quot;&amp;gt;
  &amp;lt;!--header--&amp;gt;
  &amp;lt;el-header&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是标题&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-header&amp;gt;
  &amp;lt;el-container&amp;gt;
    &amp;lt;!--aside--&amp;gt;
    &amp;lt;el-aside&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是菜单&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-aside&amp;gt;
    &amp;lt;!--main--&amp;gt;
    &amp;lt;el-main&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是中心内容&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-main&amp;gt;
  &amp;lt;/el-container&amp;gt;
  &amp;lt;el-footer&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是页脚&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-footer&amp;gt;
&amp;lt;/el-container&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意:当子元素中没有有 el-header 或 el-footer 时容器排列为水平&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;75-垂直容器&#34;&gt;7.5 垂直容器&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-container direction=&amp;quot;vertical&amp;quot;&amp;gt;
  &amp;lt;!--header--&amp;gt;
  &amp;lt;el-header&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是标题&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-header&amp;gt;
  &amp;lt;el-container&amp;gt;
    &amp;lt;!--aside--&amp;gt;
    &amp;lt;el-aside&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是菜单&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-aside&amp;gt;
    &amp;lt;!--main--&amp;gt;
    &amp;lt;el-main&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是中心内容&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-main&amp;gt;
  &amp;lt;/el-container&amp;gt;
  &amp;lt;!--footer--&amp;gt;
  &amp;lt;el-footer&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是页脚&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-footer&amp;gt;
&amp;lt;/el-container&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;8form相关组件&#34;&gt;8.Form相关组件&lt;/h2&gt;
&lt;h3 id=&#34;81-radio单选按钮&#34;&gt;8.1 Radio单选按钮&lt;/h3&gt;
&lt;h4 id=&#34;1创建radio按钮&#34;&gt;1.创建Radio按钮&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!--组件创建--&amp;gt;
&amp;lt;el-radio v-model=&amp;quot;label&amp;quot; label=&amp;quot;男&amp;quot;&amp;gt;男&amp;lt;/el-radio&amp;gt;
&amp;lt;el-radio v-model=&amp;quot;label&amp;quot; label=&amp;quot;女&amp;quot;&amp;gt;女&amp;lt;/el-radio&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Radio&amp;quot;,
        data(){
            return{
                label:&#39;男&#39;
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意:在使用radio单选按钮是至少加入v-model和label两个属性&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;2radio按钮属性的使用&#34;&gt;2.Radio按钮属性的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-radio v-model=&amp;quot;label&amp;quot; name=&amp;quot;sex&amp;quot; disabled label=&amp;quot;男&amp;quot;&amp;gt;男&amp;lt;/el-radio&amp;gt;
&amp;lt;el-radio v-model=&amp;quot;label&amp;quot; name=&amp;quot;sex&amp;quot; border size=&amp;quot;small&amp;quot; label=&amp;quot;女&amp;quot;&amp;gt;女&amp;lt;/el-radio&amp;gt;
&amp;lt;el-radio v-model=&amp;quot;label&amp;quot; border size=&amp;quot;mini&amp;quot; label=&amp;quot;女&amp;quot;&amp;gt;女&amp;lt;/el-radio&amp;gt;
&amp;lt;el-radio v-model=&amp;quot;label&amp;quot; border size=&amp;quot;medium&amp;quot; label=&amp;quot;女&amp;quot;&amp;gt;女&amp;lt;/el-radio&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;总结:属性使用还是直接卸载对应的组件标签上以 属性名=属性值 方式使用&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;3radio事件的使用&#34;&gt;3.Radio事件的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-radio v-model=&amp;quot;label&amp;quot; @change=&amp;quot;aa&amp;quot; name=&amp;quot;sex&amp;quot; label=&amp;quot;男&amp;quot;&amp;gt;男&amp;lt;/el-radio&amp;gt;
&amp;lt;el-radio v-model=&amp;quot;label&amp;quot; @change=&amp;quot;aa&amp;quot; name=&amp;quot;sex&amp;quot; border size=&amp;quot;small&amp;quot; label=&amp;quot;女&amp;quot;&amp;gt;女&amp;lt;/el-radio&amp;gt;



&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Radio&amp;quot;,
        data(){
            return{
                label:&#39;男&#39;
            }
        },
        methods:{
            aa(){ //定义的事件处理函数
                console.log(this.label);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;总结:&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;​	事件的使用也是和属性使用是一致都是直接写在对应的组件标签上&lt;/li&gt;
&lt;li&gt;事件在使用时必须使用Vue中绑定时间方式进行使用如 @事件名=事件处理函数(绑在在vue组件中对应函数)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;4radio按钮组&#34;&gt;4.radio按钮组&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-radio-group v-model=&amp;quot;radio&amp;quot;&amp;gt;
  &amp;lt;el-radio :label=&amp;quot;3&amp;quot;&amp;gt;备选项3&amp;lt;/el-radio&amp;gt;
  &amp;lt;el-radio :label=&amp;quot;6&amp;quot;&amp;gt;备选项6&amp;lt;/el-radio&amp;gt;
  &amp;lt;el-radio :label=&amp;quot;9&amp;quot;&amp;gt;备选项9&amp;lt;/el-radio&amp;gt;
&amp;lt;/el-radio-group&amp;gt;
&amp;lt;script&amp;gt;
  export default {
    name: &amp;quot;Radio&amp;quot;,
    data() {
      return {
        radio: 6
      }
    }
  }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;82-checkbox组件&#34;&gt;8.2 checkbox组件&lt;/h3&gt;
&lt;h4 id=&#34;1创建checkbox组件&#34;&gt;1.创建checkbox组件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-checkbox v-model=&amp;quot;checked&amp;quot;&amp;gt;北京&amp;lt;/el-checkbox&amp;gt;
&amp;lt;el-checkbox v-model=&amp;quot;checked&amp;quot;&amp;gt;上海&amp;lt;/el-checkbox&amp;gt;
&amp;lt;el-checkbox v-model=&amp;quot;checked&amp;quot;&amp;gt;天津&amp;lt;/el-checkbox&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2属性使用&#34;&gt;2.属性使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-checkbox v-model=&amp;quot;checked&amp;quot;  disabled true-label=&amp;quot;北京&amp;quot;&amp;gt;北京&amp;lt;/el-checkbox&amp;gt;
&amp;lt;el-checkbox checked border true-label=&amp;quot;上海&amp;quot;&amp;gt;上海&amp;lt;/el-checkbox&amp;gt;
&amp;lt;el-checkbox v-model=&amp;quot;checked&amp;quot; true-label=&amp;quot;天津&amp;quot;&amp;gt;天津&amp;lt;/el-checkbox&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3事件使用&#34;&gt;3.事件使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-checkbox @change=&amp;quot;aa&amp;quot;v-model=&amp;quot;checked&amp;quot;  true-label=&amp;quot;上海&amp;quot;&amp;gt;上海&amp;lt;/el-checkbox&amp;gt;
&amp;lt;el-checkbox v-model=&amp;quot;checked&amp;quot; @change=&amp;quot;aa&amp;quot; true-label=&amp;quot;天津&amp;quot;&amp;gt;天津&amp;lt;/el-checkbox&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Checkbox&amp;quot;,
        data(){
            return{
                checked:true
            }
        },
        methods:{
            aa(){
                console.log(this.checked);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4复选框组的使用&#34;&gt;4.复选框组的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-checkbox-group @change=&amp;quot;bb&amp;quot; :min=&amp;quot;1&amp;quot; v-model=&amp;quot;checkList&amp;quot;&amp;gt;
  &amp;lt;el-checkbox label=&amp;quot;复选框 A&amp;quot;&amp;gt;&amp;lt;/el-checkbox&amp;gt;
  &amp;lt;el-checkbox label=&amp;quot;复选框 B&amp;quot;&amp;gt;&amp;lt;/el-checkbox&amp;gt;
  &amp;lt;el-checkbox label=&amp;quot;复选框 C&amp;quot;&amp;gt;&amp;lt;/el-checkbox&amp;gt;
  &amp;lt;el-checkbox label=&amp;quot;禁用&amp;quot; disabled&amp;gt;&amp;lt;/el-checkbox&amp;gt;
  &amp;lt;el-checkbox label=&amp;quot;选中且禁用&amp;quot; disabled&amp;gt;&amp;lt;/el-checkbox&amp;gt;
&amp;lt;/el-checkbox-group&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Checkbox&amp;quot;,
        data(){
            return{
                checked:true,
                checkList:[],
            }
        },
        methods:{
            aa(){
                console.log(this.checked);
            },
            bb(){
                console.log(this.checkList);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;83-input-输入框组件&#34;&gt;8.3 Input 输入框组件&lt;/h3&gt;
&lt;h4 id=&#34;1创建input组件&#34;&gt;1.创建Input组件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-input v-model=&amp;quot;name&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Input&amp;quot;,
        data(){
            return {
                name:&#39;xiaochen&#39;
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2常用属性&#34;&gt;2.常用属性&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-input v-model=&amp;quot;name&amp;quot; disabled type=&amp;quot;textarea&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
&amp;lt;el-input v-model=&amp;quot;price&amp;quot; :maxlength=&amp;quot;10&amp;quot; show-word-limit :minlength=&amp;quot;5&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
&amp;lt;el-input prefix-icon=&amp;quot;el-icon-user-solid&amp;quot; placeholder=&amp;quot;请输入用户名&amp;quot; clearable v-model=&amp;quot;username&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
&amp;lt;el-input suffix-icon=&amp;quot;el-icon-star-off&amp;quot; placeholder=&amp;quot;请输入密码&amp;quot; show-password type=&amp;quot;password&amp;quot; clearable v-model=&amp;quot;password&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Input&amp;quot;,
        data() {
            return {
                restaurants: [],
                state1: &#39;&#39;,
                state2: &#39;&#39;,
                name:&#39;xiaochen&#39;,
                price:0.0,
                username:&amp;quot;&amp;quot;,
                password:&amp;quot;&amp;quot;,
            };
        },
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3事件使用-2&#34;&gt;3.事件使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-input v-model=&amp;quot;username&amp;quot; @blur=&amp;quot;aaa&amp;quot; @focus=&amp;quot;bbb&amp;quot; @clear=&amp;quot;clears&amp;quot; clearable @input=&amp;quot;ccc&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Input&amp;quot;,
        data() {
            return {
                restaurants: [],
                state1: &#39;&#39;,
                state2: &#39;&#39;,
                name:&#39;xiaochen&#39;,
                price:0.0,
                username:&amp;quot;&amp;quot;,
                password:&amp;quot;&amp;quot;,
            };
        },
        methods:{
            aaa(){
                console.log(&#39;失去焦点&#39;);
                ;
            },
            bbb(){
                console.log(&amp;quot;获取焦点&amp;quot;);
            },
            ccc(value){
                console.log(&amp;quot;改变:&amp;quot;+value);
            },
            clears(){
                console.log(&amp;quot;清楚&amp;quot;);
            }


        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4方法的使用&#34;&gt;4.方法的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;h1&amp;gt;方法的使用&amp;lt;/h1&amp;gt;
&amp;lt;el-input v-model=&amp;quot;username&amp;quot; ref=&amp;quot;inputs&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;

&amp;lt;el-button @click=&amp;quot;focusInputs&amp;quot;&amp;gt;focus方法&amp;lt;/el-button&amp;gt;
&amp;lt;el-button @click=&amp;quot;blurInputs&amp;quot;&amp;gt;blur方法&amp;lt;/el-button&amp;gt;

&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Input&amp;quot;,
        data() {
            return{}
        },
        methods:{
            //调用focus方法
            focusInputs(){
                this.$refs.inputs.focus();
            },
           //调用失去焦点方法
            blurInputs(){
                this.$refs.inputs.blur();
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;总结&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;​	在使用组件的方法时需要在对应的组件中加入 &lt;code&gt;ref=&amp;quot;组件别名&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在调用方法时直接使用 &lt;code&gt;this.$refs.组件别名.方法名()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;注意:在elementui中所有组件 都存在 属性 事件 和方法&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;属性:&lt;/code&gt;直接写在对应的组件标签上 使用方式:&lt;code&gt;属性名=属性值&lt;/code&gt;方式&lt;/p&gt;
&lt;p&gt;&lt;code&gt;事件&lt;/code&gt;: 直接使用vue绑定事件方式写在对应的组件标签上 使用方式:&lt;code&gt;@事件名=vue中事件处理函数&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;方法&lt;/code&gt;: 1.在对应组件标签上使用&lt;code&gt;ref=组件别名&lt;/code&gt; 2.&lt;code&gt;通过使用this.$refs.组件别名.方法名()&lt;/code&gt;进行调用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;84-select选择器组件的使用&#34;&gt;8.4 Select选择器组件的使用&lt;/h3&gt;
&lt;h4 id=&#34;1组件创建&#34;&gt;1.组件创建&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# 1.数据写死在页面上
&amp;lt;el-select v-model=&amp;quot;cityName&amp;quot;&amp;gt;
  &amp;lt;el-option value=&amp;quot;北京&amp;quot;&amp;gt;北京&amp;lt;/el-option&amp;gt;
  &amp;lt;el-option value=&amp;quot;天津&amp;quot;&amp;gt;天津&amp;lt;/el-option&amp;gt;
&amp;lt;/el-select&amp;gt;
	注意:1.要求下拉列表中必须存在option的value属性值 2.要求select中必须使用v-model进行数据绑定

# 2.如何动态获取数据
 &amp;lt;el-select&amp;gt;
 		&amp;lt;el-option v-for=&amp;quot;option in options&amp;quot; :label=&amp;quot;option.name&amp;quot; :value=&amp;quot;option.id&amp;quot; :key=&amp;quot;option.id&amp;quot;&amp;gt;
 		&amp;lt;/el-option&amp;gt;
 &amp;lt;/el-select&amp;gt;

  &amp;lt;script&amp;gt;
      export default {
          name: &amp;quot;Select&amp;quot;,
          data(){
              return{
                  options:[
                      {id:&#39;1&#39;,name:&amp;quot;研发部&amp;quot;},
                      {id:&#39;2&#39;,name:&amp;quot;小卖部&amp;quot;},
                      {id:&#39;3&#39;,name:&amp;quot;小米部&amp;quot;},
                  ]
              }
          },
      }
  &amp;lt;/script&amp;gt;
  
# 3.获取下拉列表选中数据
 &amp;lt;el-select v-model=&amp;quot;cityId&amp;quot; multiple clearable&amp;gt;
        &amp;lt;el-option v-for=&amp;quot;option in options&amp;quot; :label=&amp;quot;option.name&amp;quot; :value=&amp;quot;option.id&amp;quot; :key=&amp;quot;option.id&amp;quot;&amp;gt;&amp;lt;/el-option&amp;gt;
&amp;lt;/el-select&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Select&amp;quot;,
        data(){
            return{
                options:[
                    {id:&#39;1&#39;,name:&amp;quot;研发部&amp;quot;},
                    {id:&#39;2&#39;,name:&amp;quot;小卖部&amp;quot;},
                    {id:&#39;3&#39;,name:&amp;quot;小米部&amp;quot;},
                ],
                cityId:&#39;&#39;
            }
        },
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2属性使用-2&#34;&gt;2.属性使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-select v-model=&amp;quot;cityId&amp;quot; multiple clearable&amp;gt;
  ......
&amp;lt;/el-select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3事件的使用&#34;&gt;3.事件的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-select v-model=&amp;quot;cityId&amp;quot; @change=&amp;quot;aaa&amp;quot; multiple clearable&amp;gt;
  &amp;lt;el-option v-for=&amp;quot;option in options&amp;quot; :label=&amp;quot;option.name&amp;quot; :value=&amp;quot;option.id&amp;quot; :key=&amp;quot;option.id&amp;quot;&amp;gt;
  &amp;lt;/el-option&amp;gt;
&amp;lt;/el-select&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Select&amp;quot;,
        data(){
            return{
                options:[
                    {id:&#39;1&#39;,name:&amp;quot;研发部&amp;quot;},
                    {id:&#39;2&#39;,name:&amp;quot;小卖部&amp;quot;},
                    {id:&#39;3&#39;,name:&amp;quot;小米部&amp;quot;},
                ],
                cityId:&#39;&#39;,
                cityName:&#39;&#39;
            }
        },
        methods:{
            aaa(value){
                console.log(value);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4方法的使用-2&#34;&gt;4.方法的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;1.给组件通过ref起别名并绑定到vue实例中
 &amp;lt;el-select ref=&amp;quot;selects&amp;quot; v-model=&amp;quot;cityId&amp;quot; @change=&amp;quot;aaa&amp;quot; multiple clearable&amp;gt;
       ....
 &amp;lt;/el-select&amp;gt;
2.调用方法
 this.$refs.selects.focus();//方法调用
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;85-switch-开关组件&#34;&gt;8.5 Switch 开关组件&lt;/h3&gt;
&lt;h4 id=&#34;1switch组件的创建&#34;&gt;1.Switch组件的创建&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-switch v-model=&amp;quot;value&amp;quot;&amp;gt;&amp;lt;/el-switch&amp;gt;
&amp;lt;script&amp;gt;
  export default {
    name: &amp;quot;Switchs&amp;quot;,
    data(){
      return{
        value:true
      }
    }
  }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2属性使用-3&#34;&gt;2.属性使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-switch v-model=&amp;quot;value&amp;quot; active-text=&amp;quot;打开&amp;quot; active-color=&amp;quot;#13ce66&amp;quot; inactive-color=&amp;quot;#ff4949&amp;quot; :active-
           value=&amp;quot;true&amp;quot; :inactive-value=&amp;quot;false&amp;quot; inactive-text=&amp;quot;关闭&amp;quot; :width=&amp;quot;200&amp;quot;&amp;gt;
&amp;lt;/el-switch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3事件使用-3&#34;&gt;3.事件使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-switch v-model=&amp;quot;value&amp;quot; @change=&amp;quot;aaa&amp;quot;&amp;gt;&amp;lt;/el-switch&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Switchs&amp;quot;,
        data(){
            return{
                value:true
            }
        },
        methods:{
            aaa(value){
                console.log(value);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4方法使用&#34;&gt;4.方法使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-switch ref=&amp;quot;sw&amp;quot; v-model=&amp;quot;value&amp;quot; @change=&amp;quot;aaa&amp;quot; active-text=&amp;quot;打开&amp;quot; active-color=&amp;quot;#13ce66&amp;quot; inactive-color=&amp;quot;#ff4949&amp;quot; :active-value=&amp;quot;true&amp;quot; :inactive-value=&amp;quot;false&amp;quot; inactive-text=&amp;quot;关闭&amp;quot; :width=&amp;quot;200&amp;quot;&amp;gt;&amp;lt;/el-switch&amp;gt;
&amp;lt;el-button @click=&amp;quot;bbb&amp;quot;&amp;gt;调用方法&amp;lt;/el-button&amp;gt;

&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Switchs&amp;quot;,
        data(){
            return{
                value:true
            }
        }
        ,
        methods:{
            aaa(value){
                console.log(value);
            },
            bbb(){
                alert();
                this.$refs.sw.focus();//方法调用
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;86-datepicker组件&#34;&gt;8.6 DatePicker组件&lt;/h3&gt;
&lt;h4 id=&#34;1创建&#34;&gt;1.创建&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-date-picker v-model=&amp;quot;createDate&amp;quot; &amp;gt;&amp;lt;/el-date-picker&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2属性的使用&#34;&gt;2.属性的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-date-picker
        v-model=&amp;quot;createDate&amp;quot;
        :editable=&amp;quot;false&amp;quot;
        :clearable=&amp;quot;false&amp;quot;
        placeholder=&amp;quot;请输入创建时间&amp;quot;
        type=&amp;quot;daterange&amp;quot;
        start-placeholder=&amp;quot;生产时间&amp;quot;
        end-placeholder=&amp;quot;过期时间&amp;quot;
        format=&amp;quot;yyyy/MM/dd&amp;quot;
      &amp;gt;
&amp;lt;/el-date-picker&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3picker-options-和-shortcuts使用&#34;&gt;3.Picker Options 和 Shortcuts使用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Shortcuts:&lt;/strong&gt; 用来增加日期组件的快捷面板&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Picker Options:&lt;/strong&gt; 用来对日期控件做自定义配置&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;31-shortcuts使用&#34;&gt;3.1 Shortcuts使用&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;/el-date-picker&amp;gt;
&amp;lt;h1&amp;gt;日期配置&amp;lt;/h1&amp;gt;
&amp;lt;el-date-picker
                v-model=&amp;quot;createDate&amp;quot;
                type=&amp;quot;date&amp;quot;
                placeholder=&amp;quot;请输入时间&amp;quot;
                :picker-options=&amp;quot;pickerOptions&amp;quot;
                &amp;gt;
&amp;lt;/el-date-picker&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;DatePrickers&amp;quot;,
        data(){
            return{
                createDate:&amp;quot;&amp;quot;,
                pickerOptions: {
                    disabledDate(time) {
                        return time.getTime() &amp;gt; Date.now();
                    },
                    shortcuts: [{  //定义的shortucts
                        text: &#39;今天&#39;,
                        onClick(picker) {
                            picker.$emit(&#39;pick&#39;, new Date());
                        }
                    }, {
                        text: &#39;昨天&#39;,
                        onClick(picker) {
                            const date = new Date();
                            date.setTime(date.getTime() - 3600 * 1000 * 24);
                            picker.$emit(&#39;pick&#39;, date);
                        }
                    }, {
                        text: &#39;一周前&#39;,
                        onClick(picker) {
                            const date = new Date();
                            date.setTime(date.getTime() - 3600 * 1000 * 24 * 7);
                            picker.$emit(&#39;pick&#39;, date);
                        }
                    }]
                },
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1606975735552.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;32-picker-options&#34;&gt;3.2 Picker Options&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-date-picker
                v-model=&amp;quot;createDate&amp;quot;
                type=&amp;quot;date&amp;quot;
                placeholder=&amp;quot;请输入时间&amp;quot;
                :picker-options=&amp;quot;pickerOptions&amp;quot;
                &amp;gt;
&amp;lt;/el-date-picker&amp;gt;

&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;DatePrickers&amp;quot;,
        data(){
            return{
                createDate:&amp;quot;&amp;quot;,
                pickerOptions: {
                    disabledDate(time) { //用来对日期进行的控制
                        return time.getTime() &amp;lt; Date.now();
                    }
                },
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1606975746134.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;4事件使用&#34;&gt;4.事件使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-date-picker
                .....
                :picker-options=&amp;quot;pickerOptions&amp;quot;
                @change=&amp;quot;aaa&amp;quot;
                &amp;gt;
&amp;lt;/el-date-picker&amp;gt;

&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;DatePrickers&amp;quot;,
        data(){
            return{
                createDate:&amp;quot;&amp;quot;,
            }
        },
        methods:{
            aaa(value){  //发生change事件的函数
                console.log(value);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;87-upload组件&#34;&gt;8.7 Upload组件&lt;/h3&gt;
&lt;h4 id=&#34;1组件创建-2&#34;&gt;1.组件创建&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-upload action=&amp;quot;https://jsonplaceholder.typicode.com/posts/&amp;quot; :file-list=&amp;quot;fileList&amp;quot;&amp;gt;
  &amp;lt;el-button size=&amp;quot;small&amp;quot; type=&amp;quot;primary&amp;quot;&amp;gt;点击上传&amp;lt;/el-button&amp;gt;
  &amp;lt;div slot=&amp;quot;tip&amp;quot; class=&amp;quot;el-upload__tip&amp;quot;&amp;gt;只能上传jpg/png文件，且不超过500kb&amp;lt;/div&amp;gt;
&amp;lt;/el-upload&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意:在使用upload组件时必须设置action属性 action属性为必要参数不能省略&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;2属性和事件的使用&#34;&gt;2.属性和事件的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-upload :limit=&amp;quot;3&amp;quot; :on-exceed=&amp;quot;exceed&amp;quot; :multiple=&amp;quot;false&amp;quot; :before-remove=&amp;quot;beforeRemove&amp;quot; :on-remove=&amp;quot;remove&amp;quot; :on-preview=&amp;quot;show&amp;quot; :drag=&amp;quot;true&amp;quot; accept=&amp;quot;.txt,.png&amp;quot; :show-file-list=&amp;quot;true&amp;quot; name=&amp;quot;aaa&amp;quot; :data=&amp;quot;info&amp;quot; action=&amp;quot;https://jsonplaceholder.typicode.com/posts/&amp;quot;
               :file-list=&amp;quot;fileList&amp;quot;&amp;gt;
  &amp;lt;i class=&amp;quot;el-icon-upload&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;
  &amp;lt;div class=&amp;quot;el-upload__text&amp;quot;&amp;gt;将文件拖到此处，或&amp;lt;em&amp;gt;点击上传&amp;lt;/em&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;el-upload__tip&amp;quot; slot=&amp;quot;tip&amp;quot;&amp;gt;只能上传jpg/png文件，且不超过500kb&amp;lt;/div&amp;gt;
&amp;lt;/el-upload&amp;gt;

&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Uploads&amp;quot;,
        data() {
            return {
                fileList: [{
                    name: &#39;food.jpeg&#39;,
                    url: &#39;https://fuss10.elemecdn.com/3/63/4e7f3a15429bfda99bce42a18cdd1jpeg.jpeg?imageMogr2/thumbnail/360x360/format/webp/quality/100&#39;
                }, {
                    name: &#39;food2.jpeg&#39;,
                    url: &#39;https://fuss10.elemecdn.com/3/63/4e7f3a15429bfda99bce42a18cdd1jpeg.jpeg?imageMogr2/thumbnail/360x360/format/webp/quality/100&#39;
                }],
                info: {id:&amp;quot;21&amp;quot;}
            }
        },
        methods:{
            show(file){
                console.log(file);
            },
            remove(file,fileList){
                console.log(file);
                console.log(fileList);
                //alert(fileList.length)
            },
            beforeRemove(file,fileList){
                if(fileList.length&amp;lt;3){
                    alert(&amp;quot;上传文件不能少于3个&amp;quot;)
                    return false;
                }
            },
            exceed(file,fileList){
                alert(&amp;quot;文件超出上传的个数限制&amp;quot;)
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;注意:在使用upload组件时没有event事件,所有事件都是属性事件&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3方法的使用&#34;&gt;3.方法的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-upload ref=&amp;quot;uploads&amp;quot; ....&amp;gt;........&amp;lt;/el-upload&amp;gt;

方法调用:
	this.$refs.uploads.clearFiles();
	this.$refs.uploads.abort();
	this.$refs.uploads.submit();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;88-form组件&#34;&gt;8.8 Form组件&lt;/h3&gt;
&lt;h4 id=&#34;1组件的创建&#34;&gt;1.组件的创建&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-form ref=&amp;quot;form&amp;quot; :model=&amp;quot;form&amp;quot; label-width=&amp;quot;80px&amp;quot;&amp;gt;
  &amp;lt;el-form-item label=&amp;quot;活动名称&amp;quot;&amp;gt;
    &amp;lt;el-input v-model=&amp;quot;form.name&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
  &amp;lt;/el-form-item&amp;gt;
  ......
  &amp;lt;el-form-item&amp;gt;
    &amp;lt;el-button type=&amp;quot;primary&amp;quot; @click=&amp;quot;onSubmit&amp;quot;&amp;gt;立即创建&amp;lt;/el-button&amp;gt;
    &amp;lt;el-button&amp;gt;取消&amp;lt;/el-button&amp;gt;
  &amp;lt;/el-form-item&amp;gt;
&amp;lt;/el-form&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Form&amp;quot;,
        data() {
            return {
                form: {
                    name: &#39;&#39;,
                    region: &#39;&#39;,
                    date1: &#39;&#39;,
                    date2: &#39;&#39;,
                    delivery: false,
                    type: [],
                    resource: &#39;&#39;,
                    desc: &#39;&#39;
                }
            }
        },
        methods: {
            onSubmit() {
                console.log(&#39;submit!&#39;);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2内联表单&#34;&gt;2.内联表单&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-form :inline=&amp;quot;true&amp;quot; :model=&amp;quot;formInline&amp;quot; class=&amp;quot;demo-form-inline&amp;quot;&amp;gt;
		.......
&amp;lt;/el-form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;通过设置 inline=true方式将表单作为内联表单处理&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;3表单验证&#34;&gt;3.表单验证&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用说明:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Form 组件提供了表单验证的功能，只需要通过 &lt;code&gt;rules&lt;/code&gt; 属性传入约定的验证规则，并将 Form-Item 的 &lt;code&gt;prop&lt;/code&gt; 属性设置为需校验的字段名即可。校验规则参见 &lt;a href=&#34;https://github.com/yiminghe/async-validator&#34;&gt;async-validator&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;31-失去焦点自动验证&#34;&gt;3.1 失去焦点自动验证&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-form :rules=&amp;quot;rules&amp;quot; ...&amp;gt;
  &amp;lt;el-form-item label=&amp;quot;活动名称&amp;quot; prop=&amp;quot;name&amp;quot;&amp;gt;
      &amp;lt;el-input v-model=&amp;quot;form.name&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
  &amp;lt;/el-form-item&amp;gt;
  ....
&amp;lt;/el-form&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Form&amp;quot;,
        data() {
            return {
                form: {
                    name: &#39;&#39;,
                    region: &#39;&#39;,
                    date1: &#39;&#39;,
                    date2: &#39;&#39;,
                    delivery: false,
                    type: [],
                    resource: &#39;&#39;,
                    desc: &#39;&#39;
                },
                rules: {
                    name: [
                        {required: true, message: &#39;请输入活动名称&#39;, trigger: &#39;blur&#39;},
                        {min: 3, max: 5, message: &#39;长度在 3 到 5 个字符&#39;, trigger: &#39;blur&#39;}
                    ],
                }
            }
        },
        methods: {
            onSubmit() {
                console.log(&#39;submit!&#39;);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;32-表单提交调用表单组件的验证方法验证&#34;&gt;3.2 表单提交调用表单组件的验证方法验证&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-form :rules=&amp;quot;rules&amp;quot;.... ref=&amp;quot;form&amp;quot; &amp;gt;
    &amp;lt;el-form-item label=&amp;quot;活动名称&amp;quot; prop=&amp;quot;name&amp;quot;&amp;gt;
      &amp;lt;el-input v-model=&amp;quot;form.name&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
  	&amp;lt;/el-form-item&amp;gt;
  	&amp;lt;el-form-item&amp;gt;
      &amp;lt;el-button type=&amp;quot;primary&amp;quot; @click=&amp;quot;onSubmit(&#39;form&#39;)&amp;quot;&amp;gt;立即创建&amp;lt;/el-button&amp;gt;
      &amp;lt;el-button&amp;gt;取消&amp;lt;/el-button&amp;gt;
  	&amp;lt;/el-form-item&amp;gt;
&amp;lt;/el-form&amp;gt;
...
methods: {
            onSubmit(formName) {
                this.$refs[formName].validate((valid) =&amp;gt; {
                    if (valid) {
                        alert(&#39;submit!&#39;);
                        //发送异步请求 到 springboot项目
                    } else {
                        console.log(&#39;error submit!!&#39;);
                        return false;
                    }
                });
            }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4自定义表单的验证规则&#34;&gt;4.自定义表单的验证规则&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-form :model=&amp;quot;ruleForm&amp;quot; :rules=&amp;quot;rules&amp;quot; ref=&amp;quot;ruleForm&amp;quot; label-width=&amp;quot;100px&amp;quot;&amp;gt;
  &amp;lt;el-form-item label=&amp;quot;手机号&amp;quot; prop=&amp;quot;phone&amp;quot;&amp;gt;
    &amp;lt;el-input type=&amp;quot;password&amp;quot; v-model=&amp;quot;ruleForm.phone&amp;quot; &amp;gt;&amp;lt;/el-input&amp;gt;
  &amp;lt;/el-form-item&amp;gt;
  &amp;lt;el-form-item&amp;gt;
    &amp;lt;el-button type=&amp;quot;primary&amp;quot; @click=&amp;quot;submitForm(&#39;ruleForm&#39;)&amp;quot;&amp;gt;提交&amp;lt;/el-button&amp;gt;
    &amp;lt;el-button @click=&amp;quot;resetForm(&#39;ruleForm&#39;)&amp;quot;&amp;gt;重置&amp;lt;/el-button&amp;gt;
  &amp;lt;/el-form-item&amp;gt;
&amp;lt;/el-form&amp;gt;

&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Form&amp;quot;,
        data() {
            let validatePhone = (rule,value,callback)=&amp;gt;{ //定义自定义的验证规则
                console.log(rule);
                console.log(value);
                console.log(callback);
                if(!value){
                    callback(new Error(&amp;quot;手机号不能为空!&amp;quot;));
                }
                if(!/^1[3456789]\d{9}$/.test(value)){
                    callback(new Error(&amp;quot;手机号码不正确!!&amp;quot;))
                }
            }
            return {
                form: {
                    name: &#39;&#39;,
                    region: &#39;&#39;,
                    date1: &#39;&#39;,
                    date2: &#39;&#39;,
                    delivery: false,
                    type: [],
                    resource: &#39;&#39;,
                    desc: &#39;&#39;
                },
                rules: { //验证规则
                    name: [ //使用默认规则
                        {required: true, message: &#39;请输入活动名称&#39;, trigger: &#39;blur&#39;},
                        {min: 3, max: 5, message: &#39;长度在 3 到 5 个字符&#39;, trigger: &#39;blur&#39;}
                    ],
                    phone:[  //使用自定义规则
                        {validator:validatePhone,trigger: &#39;blur&#39;}
                    ]
                },
                ruleForm:{
                    phone:&#39;&#39;,
                },
            }
        },
        methods: {
           
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;9消息提示&#34;&gt;9.消息提示&lt;/h2&gt;
&lt;h3 id=&#34;91警告提示&#34;&gt;9.1警告提示&lt;/h3&gt;
&lt;h4 id=&#34;11-创建警告提示&#34;&gt;1.1 创建警告提示&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-alert title=&amp;quot;成功信息提示&amp;quot; :closable=&amp;quot;false&amp;quot; type=&amp;quot;success&amp;quot;&amp;gt;
  &amp;lt;div slot&amp;gt;我是辅助信息&amp;lt;/div&amp;gt;
&amp;lt;/el-alert&amp;gt;
&amp;lt;el-alert title=&amp;quot;成功信息提示&amp;quot; type=&amp;quot;info&amp;quot;&amp;gt;&amp;lt;/el-alert&amp;gt;
&amp;lt;el-alert title=&amp;quot;成功信息提示&amp;quot; type=&amp;quot;warning&amp;quot;&amp;gt;&amp;lt;/el-alert&amp;gt;
&amp;lt;el-alert title=&amp;quot;成功信息提示&amp;quot; type=&amp;quot;error&amp;quot;&amp;gt;&amp;lt;/el-alert&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;12属性的使用&#34;&gt;1.2属性的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-alert title=&amp;quot;成功信息提示&amp;quot; effect=&amp;quot;dark&amp;quot; :show-icon=&amp;quot;true&amp;quot; center :closable=&amp;quot;false&amp;quot; type=&amp;quot;success&amp;quot;&amp;gt;
  &amp;lt;div slot&amp;gt;我是辅助信息&amp;lt;/div&amp;gt;
&amp;lt;/el-alert&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;92-message消息提示&#34;&gt;9.2 Message消息提示&lt;/h3&gt;
&lt;h4 id=&#34;21-创建组件&#34;&gt;2.1 创建组件&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;注意:这个组件的创建无须在页面中书写任何标签,他是一个js插件,在需要展示消息提示的位置直接调用提供的js插件方法即可&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;# 1.创建最简单的消息
	this.$message(&#39;这是一个消息提示!!&#39;)

# 2.自定义消息内容
	this.$message({
    message: h(&#39;p&#39;, null, [
      h(&#39;span&#39;, null, &#39;订单创建成功,您的订单编号为: &#39;),
      h(&#39;i&#39;, { style: &#39;color: teal&#39; }, &#39;87&#39;)
    ])
  });

# 3.不同主题的消息提示
	 this.$message({
     message:&#39;这是信息提示&#39;,
     type:&amp;quot;success&amp;quot;,
   })
		//主题样式:  success  info  warning  error

# 4.属性使用
	this.$message({
    message:&#39;这是信息提示&#39;,
    type:&amp;quot;success&amp;quot;,
    showClose:true,
    center:true,
    iconClass:&#39;el-icon-user-solid&#39;,
    duration:0
  })
# 5.方法的使用
	this.$message.closeAll();

&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;10table表格组件&#34;&gt;10.table表格组件&lt;/h2&gt;
&lt;h3 id=&#34;1组件的创建-2&#34;&gt;1.组件的创建&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-table :data=&amp;quot;tableData&amp;quot;&amp;gt;
  &amp;lt;el-table-column prop=&amp;quot;id&amp;quot; label=&amp;quot;编号&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
  &amp;lt;el-table-column prop=&amp;quot;name&amp;quot; label=&amp;quot;姓名&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
  &amp;lt;el-table-column prop=&amp;quot;age&amp;quot; label=&amp;quot;年龄&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
  &amp;lt;el-table-column prop=&amp;quot;email&amp;quot; label=&amp;quot;邮箱&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
&amp;lt;/el-table&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Tables&amp;quot;,
        data(){
            return {
                tableData:[
                    {id:21,name:&amp;quot;小陈&amp;quot;,age:23,email:&amp;quot;60037647@qq.com&amp;quot;},
                    {id:22,name:&amp;quot;小张&amp;quot;,age:25,email:&amp;quot;60038647@qq.com&amp;quot;},
                ]
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2表格中列属性&#34;&gt;2.表格中列属性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;el-table-column属性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-table-column prop=&amp;quot;id&amp;quot; :resizable=&amp;quot;false&amp;quot; header-align=&amp;quot;left&amp;quot; align=&amp;quot;center&amp;quot; fixed=&amp;quot;left&amp;quot; width=&amp;quot;200px;&amp;quot; label=&amp;quot;编号&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
&amp;lt;el-table-column prop=&amp;quot;name&amp;quot; label=&amp;quot;姓名&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
&amp;lt;el-table-column prop=&amp;quot;age&amp;quot; :sort-method=&amp;quot;sorts&amp;quot; sortable label=&amp;quot;年龄&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
&amp;lt;el-table-column prop=&amp;quot;email&amp;quot; label=&amp;quot;邮箱&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
&amp;lt;el-table-column prop=&amp;quot;dept.name&amp;quot; :formatter=&amp;quot;showDept&amp;quot; label=&amp;quot;部门&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Tables&amp;quot;,
        data() {
            return {
                tableData: [
                    {
                        id: 21, name: &amp;quot;小陈&amp;quot;, age: 23, email: &amp;quot;60037647@qq.com&amp;quot;,
                        dept: {id: 1, name: &amp;quot;研发部&amp;quot;}
                    },
                    {
                        id: 22, name: &amp;quot;小张&amp;quot;, age: 25, email: &amp;quot;60038647@qq.com&amp;quot;,
                        dept: {id: 1, name: &amp;quot;小卖部&amp;quot;}
                    },
                    {
                        id: 23, name: &amp;quot;小李&amp;quot;, age: 25, email: &amp;quot;60038657@qq.com&amp;quot;,
                        dept:{}
                    },
                ]
            }
        },
        methods: {
            sorts(a, b) {
                return a.age - b.age;
            },
            showDept(row, column, cellValue, index){
                console.log(row);
                console.log(column);
                console.log(cellValue);
                console.log(index);
                if(cellValue){
                    return cellValue
                }
                return &amp;quot;暂无部门&amp;quot;;
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3表格属性&#34;&gt;3.表格属性&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-table :data=&amp;quot;tableData&amp;quot; empty-text=&amp;quot;暂无数据&amp;quot; :row-class-name=&amp;quot;showCss&amp;quot; highlight-current-row :show-header=&amp;quot;true&amp;quot; :fit=&amp;quot;true&amp;quot;
              size=&amp;quot;mini&amp;quot; :height=&amp;quot;600&amp;quot; border&amp;gt;

&amp;lt;/el-table&amp;gt;
&amp;lt;script&amp;gt;
  .....
	methods: {
            showCss({row, rowIndex}) {
                if (rowIndex % 2 == 0) {
                    return &amp;quot;warning-row&amp;quot;;
                }
                return &amp;quot;success-row&amp;quot;;
            }
        }
 &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4组件事件使用&#34;&gt;4.组件事件使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-table @事件名=&amp;quot;事件处理函数名&amp;quot;&amp;gt;&amp;lt;el-table&amp;gt;

&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Tables&amp;quot;,
        data() {
            //....
        },
        methods: {
            //...事件处理函数
            selectRow(selection, row){
                console.log(selection);
                console.log(row);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5组件方法的使用&#34;&gt;5.组件方法的使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-table  ref=&amp;quot;mytable&amp;quot;&amp;gt;........&amp;lt;/el-table&amp;gt;
//调用方法
	this.$refs.mytable.方法名  
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6表格中定义操作列&#34;&gt;6.表格中定义操作列&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-table&amp;gt;
  ....
	 &amp;lt;el-table-column label=&amp;quot;操作&amp;quot;&amp;gt;
      &amp;lt;template slot-scope=&amp;quot;scope&amp;quot;&amp;gt;
        &amp;lt;el-button
          size=&amp;quot;mini&amp;quot;
          @click=&amp;quot;handleEdit(scope.$index, scope.row)&amp;quot;&amp;gt;编辑&amp;lt;/el-button&amp;gt;
        &amp;lt;el-button
          size=&amp;quot;mini&amp;quot;
          type=&amp;quot;danger&amp;quot;
          @click=&amp;quot;handleDelete(scope.$index, scope.row)&amp;quot;&amp;gt;删除&amp;lt;/el-button&amp;gt;
      &amp;lt;/template&amp;gt;
    &amp;lt;/el-table-column&amp;gt;
&amp;lt;/el-table&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Tables&amp;quot;,
        data() {
            .....
        },
        methods: {
						//用来处理编辑和删除的事件函数
            handleEdit(index,row){
                console.log(index);
                console.log(row);
            },
            handleDelete(index,row){
                console.log(index);
                console.log(row);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1606975770913.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/h2&gt;
&lt;h3 id=&#34;7自定义表头&#34;&gt;7.自定义表头&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt; &amp;lt;el-table :data=&amp;quot;tableData.filter(data =&amp;gt; !search || data.name.toLowerCase().includes(search.toLowerCase()))&amp;quot; &amp;gt;
   .....
   &amp;lt;!--展示搜索和操作--&amp;gt;
   &amp;lt;el-table-column&amp;gt;
        &amp;lt;template slot=&amp;quot;header&amp;quot; slot-scope=&amp;quot;scope&amp;quot;&amp;gt;
          &amp;lt;el-input
            v-model=&amp;quot;search&amp;quot;
            size=&amp;quot;mini&amp;quot;
            placeholder=&amp;quot;输入关键字搜索&amp;quot;/&amp;gt;
        &amp;lt;/template&amp;gt;
        &amp;lt;template slot-scope=&amp;quot;scope&amp;quot;&amp;gt;
          &amp;lt;el-button
            size=&amp;quot;mini&amp;quot;
            @click=&amp;quot;handleEdit(scope.$index, scope.row)&amp;quot;&amp;gt;编辑&amp;lt;/el-button&amp;gt;
          &amp;lt;el-button
            size=&amp;quot;mini&amp;quot;
            type=&amp;quot;danger&amp;quot;
            @click=&amp;quot;handleDelete(scope.$index, scope.row)&amp;quot;&amp;gt;删除&amp;lt;/el-button&amp;gt;
        &amp;lt;/template&amp;gt;
      &amp;lt;/el-table-column&amp;gt;
&amp;lt;/el-table&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Tables&amp;quot;,
        data() {
            return {
                tableData: [
                    {
                        id: 21, name: &amp;quot;小陈&amp;quot;, age: 23, email: &amp;quot;60037647@qq.com&amp;quot;,
                        dept: {id: 1, name: &amp;quot;研发部&amp;quot;}
                    },
                    {
                        id: 22, name: &amp;quot;小张&amp;quot;, age: 25, email: &amp;quot;60038647@qq.com&amp;quot;,
                        dept: {id: 1, name: &amp;quot;小卖部&amp;quot;}
                    },
                    {
                        id: 23, name: &amp;quot;小李&amp;quot;, age: 25, email: &amp;quot;60038657@qq.com&amp;quot;,
                        dept: {}
                    },
                    {
                        id: 24, name: &amp;quot;小四&amp;quot;, age: 25, email: &amp;quot;60038657@qq.com&amp;quot;,
                        dept: {}
                    },
                ],
                search: &#39;&#39;
            }
        },
        methods: {
            sorts(a, b) {
                return a.age - b.age;
            },
            showDept(row, column, cellValue, index) {
                if (cellValue) {
                    return cellValue
                }
                return &amp;quot;暂无部门&amp;quot;;
            },
            showCss({row, rowIndex}) {
                if (rowIndex % 2 == 0) {
                    return &amp;quot;warning-row&amp;quot;;
                }
                return &amp;quot;success-row&amp;quot;;
            },
            selectRow(selection, row){
                console.log(selection);
                console.log(row);
            },
            clearSelect(){
                this.$refs.mytable.clearSelection();
            },
            handleEdit(index,row){
                console.log(index);
                console.log(row);
            },
            handleDelete(index,row){
                console.log(index);
                console.log(row);
            }
        }
    }
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:4000/post-images/1606975779180.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;鸣谢：源自&lt;a href=&#34;https://www.bilibili.com/video/BV1NK4y187XH&#34;&gt;视频教程-陈老师&lt;/a&gt;&lt;/p&gt;
">Element UI 实战教程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/can-ting-lian-xi-css-xuan-ze-qi/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://github.com/Tyloo-code/Restaurant&#34;&gt;点此下载&lt;/a&gt;&lt;br&gt;
第一关&lt;br&gt;
plate&lt;br&gt;
plate元素&lt;/p&gt;
&lt;p&gt;第二关&lt;br&gt;
bento&lt;br&gt;
bento元素&lt;/p&gt;
&lt;p&gt;第三关&lt;br&gt;
#fancy&lt;br&gt;
id为fancy的元素&lt;/p&gt;
&lt;p&gt;第四关&lt;br&gt;
plate apple&lt;br&gt;
plate祖先元素下的apple后代元素&lt;/p&gt;
&lt;p&gt;第五关&lt;br&gt;
#fancy pickle&lt;br&gt;
id为#fancy的祖先元素下的pickle后代元素&lt;/p&gt;
&lt;p&gt;第六关&lt;br&gt;
.small&lt;br&gt;
组为small的元素&lt;/p&gt;
&lt;p&gt;第七关&lt;br&gt;
orange.small&lt;br&gt;
组为small的orange元素&lt;/p&gt;
&lt;p&gt;第八关&lt;br&gt;
bento&amp;gt;orange.small&lt;br&gt;
bento父元素下的组为small的orange子元素&lt;/p&gt;
&lt;p&gt;第九关&lt;br&gt;
plate,bento,div&lt;br&gt;
plate,bento兄弟元素在div元素中&lt;/p&gt;
&lt;p&gt;第十关&lt;br&gt;
*&lt;br&gt;
*代表所有元素&lt;/p&gt;
&lt;p&gt;第十一关&lt;br&gt;
plate&amp;gt;*&lt;br&gt;
plate父元素的所有子元素&lt;/p&gt;
&lt;p&gt;第十二关&lt;br&gt;
plate + apple&lt;br&gt;
兄弟元素选择器，plate元素的后一个元素&lt;/p&gt;
&lt;p&gt;第十三关&lt;br&gt;
bento~pickle&lt;br&gt;
兄弟元素选择器,bento元素后的多个pickle元素&lt;/p&gt;
&lt;p&gt;第十四关&lt;br&gt;
plate&amp;gt;apple&lt;br&gt;
plate父元素下的apple子元素&lt;/p&gt;
&lt;p&gt;第十五关&lt;br&gt;
plate orange:first-child&lt;br&gt;
子元素选择器，plate元素下的第一个orange元素&lt;/p&gt;
&lt;p&gt;第十六关&lt;br&gt;
plate :only-child&lt;br&gt;
所有plate元素下的元素&lt;/p&gt;
&lt;p&gt;第十七关&lt;br&gt;
.small:last-child&lt;br&gt;
id为fancy的元素的最后一个和pickle元素的最后一个&lt;/p&gt;
&lt;p&gt;第十八关&lt;br&gt;
plate:nth-child(3)&lt;br&gt;
div元素中的第三个plate元素&lt;/p&gt;
&lt;p&gt;第十九关&lt;br&gt;
bento:nth-of-type(1)&lt;br&gt;
第N个最后一个孩子选择器&lt;/p&gt;
&lt;p&gt;第二十关&lt;br&gt;
apple:first-of-type&lt;br&gt;
第一个apple元素&lt;/p&gt;
&lt;p&gt;第二十一关&lt;br&gt;
plate:nth-of-type(even)&lt;br&gt;
所有偶数个的plate元素&lt;/p&gt;
&lt;p&gt;第二十二关&lt;br&gt;
plate:nth-of-type(2n+3)&lt;br&gt;
同类型的，每2个选择一个plate，从第3 个开始，包括第3个&lt;/p&gt;
&lt;p&gt;第二十三关&lt;br&gt;
plate apple.small:only-of-type&lt;br&gt;
plate元素下满足apple.small元素的唯一一个元素&lt;/p&gt;
&lt;p&gt;第二十四关&lt;br&gt;
orange.small:last-of-type,apple.small:last-of-type&lt;br&gt;
是orange.samll和apple.small元素的最后一个元素&lt;/p&gt;
&lt;p&gt;第二十五关&lt;br&gt;
bento:empty&lt;br&gt;
bento元素里没有包括额外元素&lt;/p&gt;
&lt;p&gt;第二十六关&lt;br&gt;
apple:not(.small)&lt;br&gt;
apple里没有组是.small的元素&lt;/p&gt;
">餐厅练习-Css选择器</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/vue-cong-ru-men-dao-wei-wan-dai-xu/"" data-c="
          &lt;h1 id=&#34;vue-day-01&#34;&gt;Vue Day 01&lt;/h1&gt;
&lt;h3 id=&#34;一-邂逅vuejs&#34;&gt;一. 邂逅Vuejs&lt;/h3&gt;
&lt;h4 id=&#34;11-认识vuejs&#34;&gt;1.1. 认识Vuejs&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;为什么学习Vuejs&lt;/li&gt;
&lt;li&gt;Vue的读音&lt;/li&gt;
&lt;li&gt;Vue的渐进式&lt;/li&gt;
&lt;li&gt;Vue的特点&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;12-安装vue&#34;&gt;1.2. 安装Vue&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;CDN引入&lt;/li&gt;
&lt;li&gt;下载引入&lt;/li&gt;
&lt;li&gt;npm安装&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;13-vue的初体验&#34;&gt;1.3. Vue的初体验&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Hello Vuejs
&lt;ul&gt;
&lt;li&gt;mustache -&amp;gt; 体验vue响应式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Vue列表展示
&lt;ul&gt;
&lt;li&gt;v-for&lt;/li&gt;
&lt;li&gt;后面给数组追加元素的时候, 新的元素也可以在界面中渲染出来&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Vue计数器小案例
&lt;ul&gt;
&lt;li&gt;事件监听: click -&amp;gt; methods&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;14-vue中的mvvm&#34;&gt;1.4. Vue中的MVVM&lt;/h4&gt;
&lt;h4 id=&#34;15-创建vue时-options可以放那些东西&#34;&gt;1.5. 创建Vue时, options可以放那些东西&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;el:&lt;/li&gt;
&lt;li&gt;data:&lt;/li&gt;
&lt;li&gt;methods:&lt;/li&gt;
&lt;li&gt;生命周期函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二插值语法&#34;&gt;二.插值语法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;mustache语法&lt;/li&gt;
&lt;li&gt;v-once&lt;/li&gt;
&lt;li&gt;v-html&lt;/li&gt;
&lt;li&gt;v-text&lt;/li&gt;
&lt;li&gt;v-pre: {{}}&lt;/li&gt;
&lt;li&gt;v-cloak: 斗篷&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三-v-bind&#34;&gt;三. v-bind&lt;/h3&gt;
&lt;h4 id=&#34;31-v-bind绑定基本属性&#34;&gt;3.1. v-bind绑定基本属性&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;v-bind:sr&lt;/li&gt;
&lt;li&gt;:href&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;32-v-bind动态绑定class&#34;&gt;3.2. v-bind动态绑定class&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;对象语法: 作业 :class=&#39;{类名: boolean}&#39;&lt;/li&gt;
&lt;li&gt;数组语法:&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;33-v-bind动态绑定style&#34;&gt;3.3. v-bind动态绑定style&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;对象语法:&lt;/li&gt;
&lt;li&gt;数组语法:&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;四-计算属性&#34;&gt;四. 计算属性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;案例一: firstName+lastName&lt;/li&gt;
&lt;li&gt;案例二: books -&amp;gt; price&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;vue-day-02&#34;&gt;Vue Day 02&lt;/h1&gt;
&lt;h3 id=&#34;一-计算属性&#34;&gt;一. 计算属性&lt;/h3&gt;
&lt;h4 id=&#34;11-计算属性的本质&#34;&gt;1.1. 计算属性的本质&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;fullname: {set(), get()}&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;12-计算属性和methods对比&#34;&gt;1.2. 计算属性和methods对比&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;计算属性在多次使用时, 只会调用一次.&lt;/li&gt;
&lt;li&gt;它是由缓存的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二-事件监听&#34;&gt;二. 事件监听&lt;/h3&gt;
&lt;h4 id=&#34;21-事件监听基本使用&#34;&gt;2.1. 事件监听基本使用&lt;/h4&gt;
&lt;h4 id=&#34;22-参数问题&#34;&gt;2.2. 参数问题&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;btnClick&lt;/li&gt;
&lt;li&gt;btnClick(event)&lt;/li&gt;
&lt;li&gt;btnClick(abc, event) -&amp;gt; $event&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;23-修饰符&#34;&gt;2.3. 修饰符&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;stop&lt;/li&gt;
&lt;li&gt;prevent&lt;/li&gt;
&lt;li&gt;.enter&lt;/li&gt;
&lt;li&gt;.once&lt;/li&gt;
&lt;li&gt;.native&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三-条件判断&#34;&gt;三. 条件判断&lt;/h3&gt;
&lt;h4 id=&#34;31-v-ifv-else-ifv-else&#34;&gt;3.1. v-if/v-else-if/v-else&lt;/h4&gt;
&lt;h4 id=&#34;32-登录小案例&#34;&gt;3.2. 登录小案例&lt;/h4&gt;
&lt;h4 id=&#34;33-v-show&#34;&gt;3.3. v-show&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;v-show和v-if区别&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;四-循环遍历&#34;&gt;四. 循环遍历&lt;/h3&gt;
&lt;h4 id=&#34;41-遍历数组&#34;&gt;4.1. 遍历数组&lt;/h4&gt;
&lt;h4 id=&#34;42-遍历对象&#34;&gt;4.2. 遍历对象&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;value&lt;/li&gt;
&lt;li&gt;value, key&lt;/li&gt;
&lt;li&gt;value, key, index&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;43-数组哪些方法是响应式的&#34;&gt;4.3. 数组哪些方法是响应式的&lt;/h4&gt;
&lt;h4 id=&#34;44-作业完成&#34;&gt;4.4. 作业完成&lt;/h4&gt;
&lt;h3 id=&#34;五-书籍案例&#34;&gt;五. 书籍案例&lt;/h3&gt;
&lt;h3 id=&#34;六-v-model的使用&#34;&gt;六. v-model的使用&lt;/h3&gt;
&lt;h4 id=&#34;61-v-model的基本使用&#34;&gt;6.1. v-model的基本使用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;v-model =&amp;gt; v-bind:value v-on:input&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;62-v-model和radiocheckboxselect&#34;&gt;6.2. v-model和radio/checkbox/select&lt;/h4&gt;
&lt;h4 id=&#34;63-修饰符&#34;&gt;6.3. 修饰符&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;lazy&lt;/li&gt;
&lt;li&gt;number&lt;/li&gt;
&lt;li&gt;trim&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;七-组件化开发&#34;&gt;七. 组件化开发&lt;/h3&gt;
&lt;h4 id=&#34;71-认识组件化&#34;&gt;7.1. 认识组件化&lt;/h4&gt;
&lt;h4 id=&#34;72-组件的基本使用&#34;&gt;7.2. 组件的基本使用&lt;/h4&gt;
&lt;h4 id=&#34;73-全局组件和局部组件&#34;&gt;7.3. 全局组件和局部组件&lt;/h4&gt;
&lt;h4 id=&#34;74-父组件和子组件&#34;&gt;7.4. 父组件和子组件&lt;/h4&gt;
&lt;h4 id=&#34;75-注册的语法糖&#34;&gt;7.5. 注册的语法糖&lt;/h4&gt;
&lt;h4 id=&#34;76-模板的分类写法&#34;&gt;7.6. 模板的分类写法&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;script&lt;/li&gt;
&lt;li&gt;template&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;77-数据的存放&#34;&gt;7.7. 数据的存放&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;子组件不能直接访问父组件&lt;/li&gt;
&lt;li&gt;子组件中有自己的data, 而且必须是一个函数.&lt;/li&gt;
&lt;li&gt;为什么必须是一个函数.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;78-父子组件的通信&#34;&gt;7.8. 父子组件的通信&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;父传子: props&lt;/li&gt;
&lt;li&gt;子传父: $emit&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;79-项目&#34;&gt;7.9. 项目&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;npm install&lt;/li&gt;
&lt;li&gt;npm run serve&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;vue-day-03&#34;&gt;Vue Day 03&lt;/h1&gt;
&lt;h3 id=&#34;一-组件化开发&#34;&gt;一. 组件化开发&lt;/h3&gt;
&lt;h4 id=&#34;11-父子组件的访问&#34;&gt;1.1. 父子组件的访问&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;children/refs&lt;/li&gt;
&lt;li&gt;parent/root&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;12-slot的使用&#34;&gt;1.2. slot的使用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;基本使用&lt;/li&gt;
&lt;li&gt;具名插槽&lt;/li&gt;
&lt;li&gt;编译的作用域&lt;/li&gt;
&lt;li&gt;作用域插槽&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二-前端模块化&#34;&gt;二. 前端模块化&lt;/h3&gt;
&lt;h4 id=&#34;21-为什么要使用模块化&#34;&gt;2.1. 为什么要使用模块化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;简单写js代码带来的问题&lt;/li&gt;
&lt;li&gt;闭包引起代码不可复用.&lt;/li&gt;
&lt;li&gt;自己实现了简单的模块化&lt;/li&gt;
&lt;li&gt;AMD/CMD/CommonJS&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;22-es6中模块化的使用&#34;&gt;2.2. ES6中模块化的使用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;export&lt;/li&gt;
&lt;li&gt;import&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三-webpack&#34;&gt;三. webpack&lt;/h3&gt;
&lt;h4 id=&#34;31-什么是webpack&#34;&gt;3.1. 什么是webpack&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;webpack和gulp对比&lt;/li&gt;
&lt;li&gt;webpack依赖环境&lt;/li&gt;
&lt;li&gt;安装webpack&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;32-webpack的起步&#34;&gt;3.2. webpack的起步&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;webpack命令&lt;/li&gt;
&lt;li&gt;webpack配置: webpack.config.js/package.json(scripts)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;33-webpack的loader&#34;&gt;3.3. webpack的loader&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;css-loader/style-loader&lt;/li&gt;
&lt;li&gt;less-loader/less&lt;/li&gt;
&lt;li&gt;url-loader/file-loader&lt;/li&gt;
&lt;li&gt;babel-loader&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;34-webpack中配置vue&#34;&gt;3.4. webpack中配置Vue&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;vue-loader&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;35-webpack的plugin&#34;&gt;3.5. webpack的plugin&lt;/h4&gt;
&lt;h4 id=&#34;36-搭建本地服务器&#34;&gt;3.6. 搭建本地服务器&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;webpack-dev-server&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;37-配置文件的分离&#34;&gt;3.7. 配置文件的分离&lt;/h4&gt;
&lt;h3 id=&#34;四-vue-cli&#34;&gt;四. Vue CLI&lt;/h3&gt;
&lt;h4 id=&#34;41-什么是cli&#34;&gt;4.1. 什么是CLI&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;脚手架是什么东西.&lt;/li&gt;
&lt;li&gt;CLI依赖webpack,node,npm&lt;/li&gt;
&lt;li&gt;安装CLI3 -&amp;gt; 拉去CLI2模块&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;42-cli2初始化项目的过程&#34;&gt;4.2. CLI2初始化项目的过程&lt;/h4&gt;
&lt;h4 id=&#34;43-cli2生产的目录结构的解析&#34;&gt;4.3. CLI2生产的目录结构的解析&lt;/h4&gt;
&lt;p&gt;export(导出)/import(导入)&lt;/p&gt;
&lt;p&gt;.vue&lt;/p&gt;
&lt;p&gt;dist -&amp;gt; distribution(发布)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;webpack ./src/main.js ./dist/bundle.js&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;开发时依赖&lt;/p&gt;
&lt;p&gt;运行时依赖&lt;/p&gt;
&lt;h1 id=&#34;vue-day-04&#34;&gt;Vue Day 04&lt;/h1&gt;
&lt;h3 id=&#34;一-vue-cli&#34;&gt;一. Vue CLI&lt;/h3&gt;
&lt;h4 id=&#34;11-runtime-compiler和runtime-only的区别&#34;&gt;1.1. runtime-compiler和runtime-only的区别&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ESLint到底是什么?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;template -&amp;gt; ast -&amp;gt; render -&amp;gt; vdom -&amp;gt; 真实DOM&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;render: (h) =&amp;gt; h, -&amp;gt; createElement&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;12-vue-cli3&#34;&gt;1.2. Vue CLI3&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;如何通过CLI3创建项目&lt;/li&gt;
&lt;li&gt;CLI3的目录结构&lt;/li&gt;
&lt;li&gt;配置文件: 1.Vue UI 2.隐藏的配置文件 3.自定义vue.config.js&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二-vue-router&#34;&gt;二. Vue-Router&lt;/h3&gt;
&lt;h4 id=&#34;21-什么是前端路由&#34;&gt;2.1. 什么是前端路由&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;后端渲染\后端路由&lt;/li&gt;
&lt;li&gt;前后端分离&lt;/li&gt;
&lt;li&gt;SPA\前端路由&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;22-路由的基本配置&#34;&gt;2.2. 路由的基本配置&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;安装vue-router&lt;/li&gt;
&lt;li&gt;Vue.use -&amp;gt; 创建VueRouter对象 -&amp;gt; 挂在到Vue实例上&lt;/li&gt;
&lt;li&gt;配置映射关系: 1.创建组件 2.配置映射关系 3.使用router-link/router-view&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;23-细节处理&#34;&gt;2.3. 细节处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;默认路由: redirect&lt;/li&gt;
&lt;li&gt;mode: history&lt;/li&gt;
&lt;li&gt;router-link -&amp;gt; tag/replace/active-class&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;24-动态路由&#34;&gt;2.4. 动态路由&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;/user/:id&lt;/li&gt;
&lt;li&gt;this.$route.params.id&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;25-参数的传递&#34;&gt;2.5. 参数的传递&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;params&lt;/li&gt;
&lt;li&gt;query -&amp;gt; URL&lt;/li&gt;
&lt;li&gt;URL:
&lt;ul&gt;
&lt;li&gt;协议://主机:端口/路径?查询&lt;/li&gt;
&lt;li&gt;scheme://host:port/path?query#fragment&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;26-路由嵌套&#34;&gt;2.6. 路由嵌套&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;children: []&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;27-导航守卫&#34;&gt;2.7. 导航守卫&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;全局导航守卫&lt;/li&gt;
&lt;li&gt;路由独享守卫&lt;/li&gt;
&lt;li&gt;组件类守卫&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;28-keep-alive&#34;&gt;2.8. Keep-alive&lt;/h4&gt;
&lt;h4 id=&#34;29-tabbar的封装过程&#34;&gt;2.9. TabBar的封装过程&lt;/h4&gt;
&lt;p&gt;C:\Users\Administrator\AppData\Roaming&lt;/p&gt;
&lt;p&gt;vue init webpack project&lt;/p&gt;
&lt;p&gt;runtime+compiler和runtime-only&lt;/p&gt;
&lt;p&gt;template -&amp;gt; ast -&amp;gt; render -&amp;gt; virtual dom -&amp;gt; 真实DOM&lt;/p&gt;
&lt;p&gt;vue2.5.21 -&amp;gt; vue2.x -&amp;gt; flow-type(facebook)&lt;/p&gt;
&lt;p&gt;Vue3.x -&amp;gt; TypeScript(micro(微小)soft(软件))&lt;/p&gt;
&lt;p&gt;future: 将来/未来&lt;/p&gt;
&lt;p&gt;fut: 特性&lt;/p&gt;
&lt;p&gt;rc -&amp;gt; run command&lt;/p&gt;
&lt;p&gt;vcs -&amp;gt; version control system(版本控制git/svn)&lt;/p&gt;
&lt;p&gt;什么是前端渲染, 什么是后端渲染?&lt;/p&gt;
&lt;p&gt;什么是前后端分离?&lt;/p&gt;
&lt;p&gt;什么是前端路由, 什么是后端路由?&lt;/p&gt;
&lt;p&gt;href -&amp;gt; hyper reference&lt;/p&gt;
&lt;h1 id=&#34;vue-day-05&#34;&gt;Vue Day 05&lt;/h1&gt;
&lt;h3 id=&#34;一-promise&#34;&gt;一. Promise&lt;/h3&gt;
&lt;h4 id=&#34;11-promise的基本使用&#34;&gt;1.1. Promise的基本使用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;如何将异步操作放入到promise中&lt;/li&gt;
&lt;li&gt;(resolve, reject) =&amp;gt; then/catch&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;12-promise的链式调用&#34;&gt;1.2. Promise的链式调用&lt;/h4&gt;
&lt;h4 id=&#34;13-promise的all方法&#34;&gt;1.3. Promise的all方法&lt;/h4&gt;
&lt;h3 id=&#34;二-vuex&#34;&gt;二. Vuex&lt;/h3&gt;
&lt;h4 id=&#34;21-什么是状态管理&#34;&gt;2.1. 什么是状态管理&lt;/h4&gt;
&lt;h4 id=&#34;22-vuex的基本使用&#34;&gt;2.2. Vuex的基本使用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;state -&amp;gt; 直接修改state(错误)&lt;/li&gt;
&lt;li&gt;mutations -&amp;gt; devtools&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;23-核心概念&#34;&gt;2.3. 核心概念&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;state -&amp;gt; 单一状态树&lt;/li&gt;
&lt;li&gt;getters -&amp;gt;&lt;/li&gt;
&lt;li&gt;mutations -&amp;gt;&lt;/li&gt;
&lt;li&gt;actions -&amp;gt; 异步操作(Promise)&lt;/li&gt;
&lt;li&gt;modules&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;24-目录组织方式&#34;&gt;2.4. 目录组织方式&lt;/h4&gt;
&lt;h3 id=&#34;三-网络请求封装&#34;&gt;三. 网络请求封装&lt;/h3&gt;
&lt;h4 id=&#34;31-网络请求方式的选择&#34;&gt;3.1. 网络请求方式的选择&lt;/h4&gt;
&lt;h4 id=&#34;32-axios的基本使用&#34;&gt;3.2. axios的基本使用&lt;/h4&gt;
&lt;h4 id=&#34;33-axios的相关配置&#34;&gt;3.3. axios的相关配置&lt;/h4&gt;
&lt;h4 id=&#34;34-axios的创建实例&#34;&gt;3.4. axios的创建实例&lt;/h4&gt;
&lt;h4 id=&#34;35-axios的封装&#34;&gt;3.5. axios的封装&lt;/h4&gt;
&lt;h4 id=&#34;36-axios的拦截器&#34;&gt;3.6. axios的拦截器&lt;/h4&gt;
&lt;h3 id=&#34;四-项目开发&#34;&gt;四. 项目开发&lt;/h3&gt;
&lt;h4 id=&#34;41-划分目录结构&#34;&gt;4.1. 划分目录结构&lt;/h4&gt;
&lt;h4 id=&#34;42-引用了两个css文件&#34;&gt;4.2. 引用了两个css文件&lt;/h4&gt;
&lt;h4 id=&#34;43-vueconfigjs和editorconfig&#34;&gt;4.3. vue.config.js和.editorconfig&lt;/h4&gt;
&lt;h4 id=&#34;44-项目的模块划分-tabbar-路由映射关系&#34;&gt;4.4. 项目的模块划分: tabbar -&amp;gt; 路由映射关系&lt;/h4&gt;
&lt;h4 id=&#34;45-首页开发&#34;&gt;4.5. 首页开发&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;navbar 的封装&lt;/li&gt;
&lt;li&gt;网络数据的请求&lt;/li&gt;
&lt;li&gt;轮播图&lt;/li&gt;
&lt;li&gt;推荐信息&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;git remote add origin https://github.com/coderwhy/testmall.git
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sync -&amp;gt; 同步&lt;/p&gt;
&lt;p&gt;async -&amp;gt; 异步&lt;/p&gt;
&lt;p&gt;aysnc operation: 操作&lt;/p&gt;
&lt;p&gt;xcode/iphonex/xml&lt;/p&gt;
&lt;p&gt;token -&amp;gt;&lt;/p&gt;
&lt;p&gt;linus -&amp;gt; linux/git&lt;/p&gt;
&lt;h1 id=&#34;vue-day-06&#34;&gt;Vue Day 06&lt;/h1&gt;
&lt;p&gt;goods: (流行/新款/精选)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;goods: {
  &#39;pop&#39;: {page: 5, list: [150]},
  &#39;news&#39;: {page: 2, list: [60]},
  &#39;sell&#39;: {page: 1, list: [30]}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref如果是绑定在组件中的, 那么通过&lt;strong&gt;this.$refs.refname&lt;/strong&gt;获取到的是一个组件对象.&lt;/p&gt;
&lt;p&gt;ref如果是绑定在普通的元素中, 那么通过&lt;strong&gt;this.$refs.refname&lt;/strong&gt;获取到的是一个元素对象.&lt;/p&gt;
&lt;p&gt;44 + 49 = 93&lt;/p&gt;
&lt;p&gt;vh -&amp;gt; viewport height&lt;/p&gt;
&lt;p&gt;568(100%) - 98 = 470&lt;/p&gt;
&lt;p&gt;修饰.native修饰什么时候使用?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在我们需要监听一个组件的原生事件时, 必须给对应的事件加上.native修饰符, 才能进行监听.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计算机中没有黑魔法.&lt;/p&gt;
&lt;h1 id=&#34;vue-day-07&#34;&gt;Vue Day 07&lt;/h1&gt;
&lt;h3 id=&#34;一-featureview&#34;&gt;一. FeatureView&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;独立组件封装FeatureView
&lt;ul&gt;
&lt;li&gt;div&amp;gt;a&amp;gt;img&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二-tabcontrol&#34;&gt;二. TabControl&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;独立组件的封装
&lt;ul&gt;
&lt;li&gt;props -&amp;gt; titles&lt;/li&gt;
&lt;li&gt;div&amp;gt;根据titles v-for遍历 div -&amp;gt; span{{title}}&lt;/li&gt;
&lt;li&gt;css相关&lt;/li&gt;
&lt;li&gt;选中哪一个tab, 哪一个tab的文字颜色变色, 下面border-bottom
&lt;ul&gt;
&lt;li&gt;currentIndex&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三-首页商品数据的请求&#34;&gt;三. 首页商品数据的请求&lt;/h3&gt;
&lt;h4 id=&#34;31-设计数据结构-用于保存数据&#34;&gt;3.1. 设计数据结构, 用于保存数据&lt;/h4&gt;
&lt;p&gt;goods: {&lt;/p&gt;
&lt;p&gt;pop: page/list&lt;/p&gt;
&lt;p&gt;new: page/list&lt;/p&gt;
&lt;p&gt;sell: page/list&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h4 id=&#34;32-发送数据请求&#34;&gt;3.2. 发送数据请求&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在home.js中封装getHomeGoods(type, page)&lt;/li&gt;
&lt;li&gt;在Home.vue中, 又在methods中getHomeGoods(type)&lt;/li&gt;
&lt;li&gt;调用getHomeGoods(&#39;pop&#39;)/getHomeGoods(&#39;new&#39;)/getHomeGoods(&#39;sell&#39;)
&lt;ul&gt;
&lt;li&gt;page: 动态的获取对应的page&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;获取到数据: res
&lt;ul&gt;
&lt;li&gt;this.goods[type].list.push(...res.data.list)&lt;/li&gt;
&lt;li&gt;this.goods[type].page += 1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;goods: {&lt;/p&gt;
&lt;p&gt;pop: page1:/list[30]&lt;/p&gt;
&lt;p&gt;new: page1/list[30]&lt;/p&gt;
&lt;p&gt;sell: page1/list[30]&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h3 id=&#34;四-对商品数据进行展示&#34;&gt;四. 对商品数据进行展示&lt;/h3&gt;
&lt;h4 id=&#34;41-封装goodslistvue组件&#34;&gt;4.1. 封装GoodsList.vue组件&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;props: goods -&amp;gt; list[30]&lt;/li&gt;
&lt;li&gt;v-for goods -&amp;gt; GoodsListItem[30]&lt;/li&gt;
&lt;li&gt;GoodListItem(组件) -&amp;gt; GoodsItem(数据)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;42-封装goodslistitemvue组件&#34;&gt;4.2. 封装GoodsListItem.vue组件&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;props: goodsItem&lt;/li&gt;
&lt;li&gt;goodsItem 取出数据, 并且使用正确的div/span/img基本标签进行展示&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;五-对滚动进行重构-better-scroll&#34;&gt;五. 对滚动进行重构: Better-Scroll&lt;/h3&gt;
&lt;h4 id=&#34;51-在indexhtml中使用better-scroll&#34;&gt;5.1. 在index.html中使用Better-Scroll&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;const bscroll = new BScroll(el, {   })&lt;/li&gt;
&lt;li&gt;注意: wrapper -&amp;gt; content -&amp;gt; 很多内容&lt;/li&gt;
&lt;li&gt;1.监听滚动
&lt;ul&gt;
&lt;li&gt;probeType: 0/1/2(手指滚动)/3(只要是滚动)&lt;/li&gt;
&lt;li&gt;bscroll .on(&#39;scroll&#39;, (position) =&amp;gt; {})&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2.上拉加载
&lt;ul&gt;
&lt;li&gt;pullUpLoad: true&lt;/li&gt;
&lt;li&gt;bscroll .on(&#39;pullingUp&#39;, () =&amp;gt; {})&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3.click: false
&lt;ul&gt;
&lt;li&gt;button可以监听点击&lt;/li&gt;
&lt;li&gt;div不可以&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;52-在vue项目中使用better-scroll&#34;&gt;5.2. 在Vue项目中使用Better-Scroll&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在Profile.vue中简单的演示&lt;/li&gt;
&lt;li&gt;对Better-Scroll进行封装: Scroll.vue&lt;/li&gt;
&lt;li&gt;Home.vue和Scroll.vue之间进行通信
&lt;ul&gt;
&lt;li&gt;Home.vue将probeType设置为3&lt;/li&gt;
&lt;li&gt;Scroll.vue需要通过$emit, 实时将事件发送到Home.vue&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;六-回到顶部backtop&#34;&gt;六. 回到顶部BackTop&lt;/h3&gt;
&lt;h4 id=&#34;61-对backtopvue组件的封装&#34;&gt;6.1. 对BackTop.vue组件的封装&lt;/h4&gt;
&lt;h4 id=&#34;62-如何监听组件的点击&#34;&gt;6.2. 如何监听组件的点击&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;直接监听back-top的点击, 但是可以直接监听?
&lt;ul&gt;
&lt;li&gt;不可以, 必须添加修饰.native&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;回到顶部
&lt;ul&gt;
&lt;li&gt;scroll对象, scroll.scrollTo(x, y, time)&lt;/li&gt;
&lt;li&gt;this.$refs.scroll.scrollTo(0, 0, 500)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;63-backtop组件的显示和隐藏&#34;&gt;6.3. BackTop组件的显示和隐藏&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;isShowBackTop: false&lt;/li&gt;
&lt;li&gt;监听滚动, 拿到滚动的位置:
&lt;ul&gt;
&lt;li&gt;-position.y &amp;gt; 1000  -&amp;gt; isShowBackTop: true&lt;/li&gt;
&lt;li&gt;isShowBackTop = -position.y &amp;gt; 1000&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;七-解决首页中可滚动区域的问题&#34;&gt;七. 解决首页中可滚动区域的问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Better-Scroll在决定有多少区域可以滚动时, 是根据scrollerHeight属性决定&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scrollerHeight属性是根据放Better-Scroll的content中的子组件的高度&lt;/li&gt;
&lt;li&gt;但是我们的首页中, 刚开始在计算scrollerHeight属性时, 是没有将图片计算在内的&lt;/li&gt;
&lt;li&gt;所以, 计算出来的告诉是错误的(1300+)&lt;/li&gt;
&lt;li&gt;后来图片加载进来之后有了新的高度, 但是scrollerHeight属性并没有进行更新.&lt;/li&gt;
&lt;li&gt;所以滚动出现了问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何解决这个问题了?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监听每一张图片是否加载完成, 只要有一张图片加载完成了, 执行一次refresh()&lt;/li&gt;
&lt;li&gt;如何监听图片加载完成了?
&lt;ul&gt;
&lt;li&gt;原生的js监听图片: img.onload = function() {}&lt;/li&gt;
&lt;li&gt;Vue中监听: @load=&#39;方法&#39;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调用scroll的refresh()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何将GoodsListItem.vue中的事件传入到Home.vue中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为涉及到非父子组件的通信, 所以这里我们选择了&lt;strong&gt;事件总线&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;bus -&amp;gt;总线&lt;/li&gt;
&lt;li&gt;Vue.prototype.$bus = new Vue()&lt;/li&gt;
&lt;li&gt;this.bus.emit(&#39;事件名称&#39;, 参数)&lt;/li&gt;
&lt;li&gt;this.bus.on(&#39;事件名称&#39;, 回调函数(参数))&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;问题一: refresh找不到的问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一: 在Scroll.vue中, 调用this.scroll的方法之前, 判断this.scroll对象是否有值&lt;/li&gt;
&lt;li&gt;第二: 在mounted生命周期函数中使用 this.$refs.scroll而不是created中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;问题二: 对于refresh非常频繁的问题, 进行防抖操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;防抖debounce/节流throttle(课下研究一下)&lt;/li&gt;
&lt;li&gt;防抖函数起作用的过程:
&lt;ul&gt;
&lt;li&gt;如果我们直接执行refresh, 那么refresh函数会被执行30次.&lt;/li&gt;
&lt;li&gt;可以将refresh函数传入到debounce函数中, 生成一个新的函数.&lt;/li&gt;
&lt;li&gt;之后在调用非常频繁的时候, 就使用新生成的函数.&lt;/li&gt;
&lt;li&gt;而新生成的函数, 并不会非常频繁的调用, 如果下一次执行来的非常快, 那么会将上一次取消掉&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      debounce(func, delay) {
        let timer = null
        return function (...args) {
          if (timer) clearTimeout(timer)
          timer = setTimeout(() =&amp;gt; {
            func.apply(this, args)
          }, delay)
        }
      },
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;八-上拉加载更多的功能&#34;&gt;八. 上拉加载更多的功能&lt;/h3&gt;
&lt;p&gt;y  ifu&lt;/p&gt;
&lt;h3 id=&#34;九-tabcontrol的吸顶效果&#34;&gt;九. tabControl的吸顶效果&lt;/h3&gt;
&lt;h4 id=&#34;91-获取到tabcontrol的offsettop&#34;&gt;9.1. 获取到tabControl的offsetTop&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;必须知道滚动到多少时, 开始有吸顶效果, 这个时候就需要获取tabControl的offsetTop&lt;/li&gt;
&lt;li&gt;但是, 如果直接在mounted中获取tabControl的offsetTop, 那么值是不正确.&lt;/li&gt;
&lt;li&gt;如何获取正确的值了?
&lt;ul&gt;
&lt;li&gt;监听HomeSwiper中img的加载完成.&lt;/li&gt;
&lt;li&gt;加载完成后, 发出事件, 在Home.vue中, 获取正确的值.&lt;/li&gt;
&lt;li&gt;补充:
&lt;ul&gt;
&lt;li&gt;为了不让HomeSwiper多次发出事件,&lt;/li&gt;
&lt;li&gt;可以使用isLoad的变量进行状态的记录.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注意: 这里不进行多次调用和debounce的区别&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;92-监听滚动-动态的改变tabcontrol的样式&#34;&gt;9.2. 监听滚动, 动态的改变tabControl的样式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;问题:动态的改变tabControl的样式时, 会出现两个问题:
&lt;ul&gt;
&lt;li&gt;问题一: 下面的商品内容, 会突然上移&lt;/li&gt;
&lt;li&gt;问题二: tabControl虽然设置了fixed, 但是也随着Better-Scroll一起滚出去了.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;其他方案来解决停留问题.
&lt;ul&gt;
&lt;li&gt;在最上面, 多复制了一份PlaceHolderTabControl组件对象, 利用它来实现停留效果.&lt;/li&gt;
&lt;li&gt;当用户滚动到一定位置时, PlaceHolderTabControl显示出来.&lt;/li&gt;
&lt;li&gt;当用户滚动没有达到一定位置时, PlaceHolderTabControl隐藏起来.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;十-让home保持原来的状态&#34;&gt;十. 让Home保持原来的状态&lt;/h3&gt;
&lt;h4 id=&#34;101-让home不要随意销毁掉&#34;&gt;10.1. 让Home不要随意销毁掉&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;keep-alive&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;102-让home中的内容保持原来的位置&#34;&gt;10.2. 让Home中的内容保持原来的位置&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;离开时, 保存一个位置信息saveY.&lt;/li&gt;
&lt;li&gt;进来时, 将位置设置为原来保存的位置saveY信息即可.
&lt;ul&gt;
&lt;li&gt;注意: 最好回来时, 进行一次refresh()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非父子组件通信:&lt;/p&gt;
&lt;p&gt;https://www.jb51.net/article/132371.htm&lt;/p&gt;
">Vue从入门到未完待续</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/windows-xi-tong-xia-typora-wan-quan-shi-yong-xiang-jie/"" data-c="
          &lt;p&gt;最近在用这个软件，亲测确实觉得这个软件比较好用，所以写下这篇文章，分享给大家Typora 是一款极致简洁的 markdown 文本编辑器。 支持即时渲染技术 ，没有编辑工具栏！在快速文字排版以及代码编辑方面的效率是显而易见的，自己感觉比MarkdownPad好用。「它的功能之强大、设计之冷静、体验之美妙、理念之先进，我认为值得所有笔记应用厂商学习。」&lt;/p&gt;
&lt;h2 id=&#34;邂逅typora&#34;&gt;邂逅Typora&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.typora.io/#windows&#34; target=&#34;_blank&#34; style=&#34;&#34;&gt;初遇Typora&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;typora是什么&#34;&gt;Typora是什么？&lt;/h2&gt;
&lt;p&gt;Typora 是一款支持实时预览的 Markdown 文本编辑器。它有 OS X、Windows、Linux 三个平台的版本，并且由于仍在测试中，是完全免费的。&lt;/p&gt;
&lt;h2 id=&#34;一个-markdown-文本编辑器&#34;&gt;一个 Markdown 文本编辑器&lt;/h2&gt;
&lt;p&gt;Typora 首先是一个 Markdown 文本编辑器，它支持且仅支持 Markdown 语法的文本编辑。在 Typora 官网 上他们将 Typora 描述为 「A truly minimal markdown editor. 」。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606715264191.png&#34; alt=&#34;官网首页&#34; loading=&#34;lazy&#34;&gt;&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;官网首页&lt;/center&gt;&lt;/p&gt;
&lt;h2 id=&#34;关于markdown&#34;&gt;关于Markdown&lt;/h2&gt;
&lt;p&gt;Markdown 是用来编写结构化文档的一种纯文本格式，它使我们在双手不离开键盘的情况下，可以对文本进行一定程度的格式排版。你可以在&lt;a href=&#34;https://tyloo-code.github.io/post/markdown-ji-ben-yu-fa/&#34;&gt;这篇文章&lt;/a&gt;中快速入门 Markdown。&lt;/p&gt;
&lt;p&gt;由于目前还没有一个权威机构对 Markdown 的语法进行规范，各应用厂商制作时遵循的 Markdown 语法也是不尽相同的。其中比较受到认可的是&lt;a href=&#34;http://localhost:4000/post-images/1606715866342.png&#34;&gt;GFM标准&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606718544020.png&#34; alt=&#34;严格模式&#34; loading=&#34;lazy&#34;&gt;&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;严格模式&lt;/center&gt;&lt;/p&gt;
&lt;h2 id=&#34;写得舒服&#34;&gt;写得舒服&lt;/h2&gt;
&lt;p&gt;一个文本编辑器，&lt;strong&gt;写得舒服&lt;/strong&gt;是关键。我曾说过，「更有趣的是，一个笔记应用不会因为它支持 Markdown 语法而高级或易用很多。」，细枝末节处的人性化考虑才是最重要的。而 Typora 的编辑体验显然是经过深思熟虑设计的产物。&lt;/p&gt;
&lt;p&gt;我认为：一个优秀的笔记应用应该给用户&lt;strong&gt;选择 Markdown 语法风格的权利&lt;/strong&gt;。而 Typora 在这一点上是我目前见过所有 Markdown 笔记应用中做得最好的。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606718646444.jpg&#34; alt=&#34;文本编辑设置&#34; loading=&#34;lazy&#34;&gt;&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;文本编辑设置&lt;/center&gt;&lt;br&gt;
通过打开 文件 - 偏好设置 你会发现 Typora 为编辑体验的考虑细致到了令人叹为观止的程度。Typora 中提供了大量有关 Markdown 偏好的设置，据此，你可以构建一个几乎完全适合自己的 Markdown 编辑器。下面我将依次介绍一些与文本编辑体验有关的功能亮点。&lt;/p&gt;
&lt;p&gt;##图片插入&lt;br&gt;
Typora 的图片插入功能是广受好评的。要知道，Markdown 原生不太注重图片插入的功能，但你可以在 Typora 中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接使用 右键 - 复制 Ctrl + V 将网络图片、剪贴板图片复制到文档中&lt;/li&gt;
&lt;li&gt;拖动本地图片到文档中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Typora 会自动帮你插入符合 Markdown 语法的图片语句，并给它加上标题。&lt;/p&gt;
&lt;p&gt;更强大的是，Typora 支持在拖动或 Ctrl + V 网络图片后自动将其保存到本地。你可以在 文件 - 偏好设置 - 编辑器 - 图片插入 中选择复制到哪个路径，什么情况下需要复制。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606719092672.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;图片插入&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;这一功能保证了即使网络图片源失效了，你还有本地的备份可用。同时也能使你的文档文件夹更合理、完整。&lt;/p&gt;
&lt;h2 id=&#34;打字机模式和专注模式&#34;&gt;打字机模式和专注模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;打字机模式&lt;/strong&gt;使得你所编辑的那一行永远处于屏幕正中。&lt;br&gt;
&lt;strong&gt;专注模式&lt;/strong&gt;使你正在编辑的那一行保留颜色，而其他行的字体呈灰色。&lt;/p&gt;
&lt;p&gt;你可以在 视图 - 专注模式 / 打字机模式 中勾选使用这两个模式。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606720738399.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;两种模式&lt;/center&gt; 
&lt;h2 id=&#34;实时预览&#34;&gt;实时预览&lt;/h2&gt;
&lt;p&gt;我想很果断地下这个结论：到现在还不支持编辑界面实时预览的 Markdown 编辑器基本可以退出市场了。Typora 在这一方面显然已经领先了一大步——他们连 Markdown 语法的标记都在实时预览中消去了。当你离开正在编辑的有格式的文本段后，Typora 会自动隐藏 Markdown 标记，只留下 &lt;strong&gt;所见即所得&lt;/strong&gt; 的美妙。他们把这称为&lt;em&gt;Hybrid View&lt;/em&gt; 。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606721116860.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;所见即所得&lt;/center&gt; 
&lt;p&gt;为了防止一些程序 bug 的发生（虽然在我使用下来感到是很少的）导致格式问题无法修改，Typora 保留了一个「源代码模式」。你可以通过 视图 - 源代码模式 或左下角的 &amp;lt;/&amp;gt; 按钮进入。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606721181434.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;源代码模式&lt;/center&gt; 
&lt;h2 id=&#34;大纲-文件侧边栏&#34;&gt;大纲 / 文件侧边栏&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1606721243748.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;侧边栏&lt;/center&gt; 
&lt;p&gt;Typora 会根据你 Markdown 标记的 H1、H2、H3…… 各级标题为你呈现一个大纲。&lt;/p&gt;
&lt;p&gt;你也可以选择查看文件夹中的文件，但由于目前 Typora 只支持查看 md 文件，因此我认为文件侧边栏这个功能还是很鸡肋的。&lt;/p&gt;
&lt;h2 id=&#34;空格与换行&#34;&gt;空格与换行&lt;/h2&gt;
&lt;p&gt;Typora 在空格与换行部分主要是使用 &lt;a href=&#34;https://commonmark.org&#34;&gt;CommonMark&lt;/a&gt; 作为标注规范。与前文提到的 GFM 一样，CommonMark 也是比较流行的 Markdown 语言规范（解析器）之一。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;空格：&lt;/strong&gt;&lt;br&gt;
在输入连续的空格后，Typora 会在编辑器视图里为你保留这些空格，但当你打印或导出时，这些空格会被省略成一个。&lt;br&gt;
你可以在源代码模式下，为每个空格前加一个 \ 转义符，或者直接使用 HTML 风格的 &amp;amp;nbps; 来保持连续的空格。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;软换行：&lt;/strong&gt;&lt;br&gt;
需要说明的是，在 Markdown 语法中，换行（line break）与换段是不同的。且换行分为软换行和硬换行。在 Typora 中，你可以通过 Shift + Enter 完成一次软换行。软换行只在编辑界面可见，当文档被导出时换行会被省略。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;硬换行：&lt;/strong&gt;&lt;br&gt;
你可以通过 空格 + 空格 + Shift + Enter 完成一次硬换行，而这也是许多 Markdown 编辑器所原生支持的。硬换行在文档被导出时将被保留，且没有换段的段后距。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;换段：&lt;/strong&gt;&lt;br&gt;
你可以通过 Enter 完成一次换段。Typora 会自动帮你完成两次 Shift + Enter 的软换行，从而完成一次换段。这也意味着在 Markdown 语法下，换段是通过在段与段之间加入空行来实现的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Windows 风格（CR+LF）与 Unix 风格（CR）的换行符：&lt;/strong&gt;&lt;br&gt;
CR 表示回车 \r ，即回到一行的开头，而 LF 表示换行 \n ，即另起一行。&lt;br&gt;
所以 Windows 风格的换行符本质是「回车 + 换行」，而 Unix 风格的换行符是「换行」。这也是为什么 Unix / Mac 系统下的文件，如果在 Windows 系统直接打开会全部在同一行内。 你可以在 文件 - 偏好设置 - 编辑器 - 默认换行符 中对此进行切换。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下附以上各空格、换行、换段的测试结果图。具体内容你可以在官网的 &lt;a href=&#34;http://support.typora.io/Line-Break/&#34;&gt;这篇文档&lt;/a&gt; 中查阅。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606722389444.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;空格、换行、换段&lt;/center&gt; 
&lt;h2 id=&#34;一个学术文档编辑器&#34;&gt;一个学术文档编辑器&lt;/h2&gt;
&lt;p&gt;除了基本的文本编辑体验极佳之外，Typora 还是一个非常优秀的学术文档编辑器。当然作为一个轻量级的、基于 Markdown 的编辑器，它不能与那些 LaTeX 编辑器相提并论，但它仍支持了许多可用于学术写作的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LaTeX&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;LaTeX 是一种基于 TeX 的排版系统，由于它易于快速生成复杂表格和数学公式，非常适用于生成高印刷质量的科技和数学类文档。如果你常阅读数学、计算机等领域的学术论文，你一定对 LaTeX 不陌生。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Typora 原生支持 LaTeX 语法，你有两种方式输入 LaTeX 风格的数学公式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;行内公式（inline）：&lt;/strong&gt; 用 $...$ 括起公式，公式会出现在行内。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;块间公式（display）：&lt;/strong&gt; 用 $$...$$ 括起公式（注意 $$ 后需要换行），公式会默认显示在行中间。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体的 LaTeX 语法在此不赘述了，你可以在 &lt;a href=&#34;https://blog.csdn.net/happyday_d/article/details/83715440&#34;&gt;这篇文章&lt;/a&gt; 中查看。&lt;/p&gt;
&lt;h2 id=&#34;代码高亮&#34;&gt;代码高亮&lt;/h2&gt;
&lt;p&gt;Typora 中代码的插入也可以分为行内和块间两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;行内代码：用`...` 或``...`` 括起代码，代码会以主题中设置的样式出现在行内，但不会实现代码高亮。&lt;/li&gt;
&lt;li&gt;代码块：输入 ``` 后并输入语言名，换行，开始写代码，Typora 就会自动帮你实现代码高亮。Typora 原生支持许多编程语言代码块的语法高亮，基本日常常用的编程语言它都能很好地支持。&lt;br&gt;
除此以外，你也可以直接换行开始写，而后再选择语言。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;链接引用与脚注&#34;&gt;链接引用与脚注&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;链接引用&lt;/strong&gt;类似于我们常在论文末尾看到的「参考文献」的写法，你可以通过 []: 的语法来为你的文档加上链接引用。&lt;br&gt;
&lt;strong&gt;脚注&lt;/strong&gt;在少数派的文章中也很常见，即某段话结尾右上角标有数字标记，页面底部进行注释的写法。你可以在需要插入脚注标号的位置写 [^ number ] ，再在下方通过 [^ number ]: 在文档中插入脚注。注意不要遗漏了脚注编号 number 前后的空格。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606723891564.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;链接引用和脚注
&lt;/center&gt; 
&lt;h2 id=&#34;一个伪装成文本编辑器的浏览器&#34;&gt;一个伪装成文本编辑器的浏览器&lt;/h2&gt;
&lt;p&gt;当我的一个朋友问我「Typora 有什么好写的？」时，我回答「Typora 是一个伪装成文本编辑器的浏览器」。是的，事实上如果你有一定的计算机基础，你可以找到许多有关于「Typora 其实是一个浏览器」的蛛丝马迹。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606724542832.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;图片插入&lt;/p&gt;
&lt;/center&gt; 
&lt;p&gt;在图片插入的选项中，Typora 用了「复制图片到 ./${filename}.assets 文件夹」的说法，而这其实是网页前端常用的 Javascript 字符串模板语法的风格。&lt;/p&gt;
&lt;p&gt;再比如，Typora 将更遵循 GFM 标准的 Markdown 语法模式称为「严格模式 Strict Mode」，这一说法常见于 HTML 和 JavaScript 编程中。类似「源代码模式」的说法也是同理。&lt;/p&gt;
&lt;p&gt;当然，最明显的一点是当你按下 Shift + F12 快捷键时，页面会弹出一个基于 Chrome 的开发者工具栏，也就是我们在浏览器中常说的「审查元素」。&lt;img src=&#34;http://localhost:4000/post-images/1606724640253.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;审查元素&lt;/p&gt;
&lt;/center&gt; 
&lt;h2 id=&#34;伪装从何而来&#34;&gt;伪装从何而来？&lt;/h2&gt;
&lt;p&gt;当我们把视角放在「Typora 是一个支持 Markdown 语言的文本编辑器」的出发点来考虑这个问题，一切就都显得很明白了。&lt;/p&gt;
&lt;p&gt;John Gruber 在 2004 年用 Perl 创造了 Markdown 语言，这个语言的目的是希望大家使用「易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的 XHTML（或是 HTML）」。也就是说，&lt;strong&gt;在 Markdown 诞生之初，它就是为了被浏览器阅读而设计的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们在用 Markdown 语言撰写文稿的时候，其实本质上是在借助某种编程语言的转化（解析器）来编写一个 HTML 网页。Markdown 从它诞生之初就与 Web 技术有着及其紧密的联系。&lt;/p&gt;
&lt;p&gt;如果我说，我们每一篇文稿都是一个网页，那就很好理解了。Typora 利用解析器先将我们写的 Markdown 文档解析成为 HTML 文档，再为它嵌入一个 CSS 样式，最后再加上可能需要的脚本等。&lt;/p&gt;
&lt;h2 id=&#34;html&#34;&gt;HTML&lt;/h2&gt;
&lt;p&gt;HTML 是一种标记语言，主要负责构成网页的骨架，它包含所有不加装饰的网页元素。在 Typora 的使用场景下则是所有的&lt;strong&gt;文本、段落、标题等&lt;/strong&gt;的记号。&lt;/p&gt;
&lt;p&gt;你可以把一张网页想象成一幅数字油画，HTML 就是那个黑白线条的底，上面写满了数字标记，示意你哪一块区域要涂什么颜色。而 CSS 则负责在对应的区域涂上颜色，甚至加上一些装饰等。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606724955000.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;数字油画
&lt;/center&gt; 
&lt;h3 id=&#34;html-标签&#34;&gt;HTML 标签&lt;/h3&gt;
&lt;p&gt;Typora 支持许多常用的 HTML 标签，如果你了解 HTML 语法的话，你可以写出十分美观丰富的文档页面。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606725029628.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;HTML 标签
&lt;/center&gt; 
&lt;p&gt;事实上你可以在 Typora 中完成许多基本的 HTML 风格的文本输入，例如 HTML 字符、HTML 块、HTML 风格的注释，甚至是视频和音频。具体支持的功能和限制请在 &lt;a href=&#34;http://support.typora.io/HTML/&#34;&gt;官方文档&lt;/a&gt; 中查阅。&lt;/p&gt;
&lt;h3 id=&#34;导出为-html&#34;&gt;导出为 HTML&lt;/h3&gt;
&lt;p&gt;有了这一功能，我们就可以在 Typora 中创造出远超普通 Markdown 文档的页面效果。&lt;/p&gt;
&lt;p&gt;Typora 原生支持将文档导出为 HTML 格式的文件，并选择是否要嵌入 style（也就是后文我将提到的 CSS 的部分）。&lt;/p&gt;
&lt;p&gt;除此之外，由于其本身「浏览器」的属性，你可以直接在实时预览界面用 Ctrl +C 复制到 HTML 代码。一个实用的用处是将这些 HTML 代码直接 Ctrl + V 黏贴到微信公众号后台，基本可以保证两边显示效果相同。这一点不仅使公众号推送可以有更自由、美观的样式，也让编辑、排版更轻松了。（由于微信自带浏览器的一些特性，可能有少部分 CSS style 不能生效，建议多多校对。）&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606725222158.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;公众号
&lt;/center&gt; 
&lt;p&gt;具体如何用 Typora 完成公众号写作，你可以在 &lt;a href=&#34;https://sspai.com/post/40524&#34;&gt;这篇文章&lt;/a&gt; 中进一步了解。&lt;/p&gt;
&lt;h2 id=&#34;css&#34;&gt;CSS&lt;/h2&gt;
&lt;p&gt;为了让文档更美观，我们可以为其加上 CSS style。我认为 Typora 对 CSS 的支持让它成为一众桌面笔记应用中最与众不同的一个。在 Typora 中 CSS 被称为「主题」，但其本质仍是 CSS 文件。你可以在 文件 - 偏好设置 - 主题 - 打开主题文件夹 看到这些 CSS 文件。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606725328223.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;主题&lt;/p&gt;
&lt;/center&gt; 
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1606725342168.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;主题文件夹
&lt;/center&gt; 
&lt;p&gt;选择不同的主题可以使文档拥有不同的外观，但不会影响内容。Typora 自带了若干主题，你也可以在 &lt;a href=&#34;http://theme.typora.io&#34;&gt;官网&lt;/a&gt; 下载更多的主题。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606725423540.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;主题商店
&lt;/center&gt; 
&lt;p&gt;除此以外，如果你有一定的 Web 编程基础，你当然也可以自己修改、新建适合你使用需求的 CSS 文件。我自己就写了一份名为 WeChat 的 CSS 文件，来符合我公众号特定的排版需求，例如正文是 15px，页边距是 8，小标题是 18px 等等。&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606725495732.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;CSS文件
&lt;/center&gt; 
&lt;p&gt;使用 Typora 的「主题」功能写公众号的一个好处是，只需要每次都套用同样的主题，我们就可以在保证每次排版规范都相同的同时，节省许多重复的工作。&lt;/p&gt;
&lt;h2 id=&#34;yaml-front-matter&#34;&gt;YAML front-matter&lt;/h2&gt;
&lt;p&gt;Typora 支持在文档头部加上基于 YAML 的 front-matter 信息，这一特性适用于把 Markdown 文档分类归档上传到用 Hexo 框架搭建的博客中。我对于这一点不太了解，这里就不误导大家了。有所了解的朋友可以在评论区谈谈！&lt;/p&gt;
&lt;h2 id=&#34;写在最后&#34;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;因为移动端生产效率低，所以只有桌面端应用。因为左顾右盼的两栏式预览影响思路，所以他们甚至去掉了 Markdown 语法标记，只留下最终呈现的样式。因为 Markdown 是为了 HTML 呈现而设计的，所以他们提供了从入门到高级的一系列 Web 辅助功能…… 这一切都只是为了纯粹的&lt;strong&gt;生产效率&lt;/strong&gt;。如果我们回头想想，Markdown 语言本身，当初不也是为了高效地生成简单网页而诞生的吗？&lt;/p&gt;
&lt;p&gt;最后，让我们一起期待这款&lt;strong&gt;顶级桌面文本生产力工具&lt;/strong&gt;的正式版的到来吧！😆&lt;/p&gt;
&lt;p&gt;文章转自：https://sspai.com/post/54912&lt;/p&gt;
">Windows系统下Typora 完全使用详解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/markdown-ji-ben-yu-fa/"" data-c="
          &lt;p&gt;Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;br&gt;
1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。&lt;br&gt;
2、操作简单。添加标题时Markdown只需要在标题内容前加#即可&lt;br&gt;
&lt;strong&gt;缺点：&lt;/strong&gt;&lt;br&gt;
1、需要记一些语法（当然，是很简单。五分钟学会）。&lt;br&gt;
2、有些平台不支持Markdown编辑模式。&lt;/p&gt;
&lt;h1 id=&#34;一-标题&#34;&gt;一、标题&lt;/h1&gt;
&lt;p&gt;在想要设置为标题的文字前面加#来表示&lt;br&gt;
一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。&lt;/p&gt;
&lt;p&gt;注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606703470701.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;h1 id=&#34;这是一级标题&#34;&gt;这是一级标题&lt;/h1&gt;
&lt;h2 id=&#34;这是二级标题&#34;&gt;这是二级标题&lt;/h2&gt;
&lt;h3 id=&#34;这是三级标题&#34;&gt;这是三级标题&lt;/h3&gt;
&lt;h4 id=&#34;这是四级标题&#34;&gt;这是四级标题&lt;/h4&gt;
&lt;h5 id=&#34;这是五级标题&#34;&gt;这是五级标题&lt;/h5&gt;
&lt;h6 id=&#34;这是六级标题&#34;&gt;这是六级标题&lt;/h6&gt;
&lt;h1 id=&#34;二-字体&#34;&gt;二、字体&lt;/h1&gt;
&lt;h3 id=&#34;加粗&#34;&gt;加粗&lt;/h3&gt;
&lt;p&gt;要加粗的文字左右分别用两个*号包起来&lt;/p&gt;
&lt;h3 id=&#34;斜体&#34;&gt;斜体&lt;/h3&gt;
&lt;p&gt;要倾斜的文字左右分别用一个*号包起来&lt;/p&gt;
&lt;h3 id=&#34;斜体加粗&#34;&gt;斜体加粗&lt;/h3&gt;
&lt;p&gt;要倾斜和加粗的文字左右分别用三个*号包起来&lt;/p&gt;
&lt;h3 id=&#34;删除线&#34;&gt;删除线&lt;/h3&gt;
&lt;p&gt;要加删除线的文字左右分别用两个~~号包起来&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606703939197.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;br&gt;
&lt;strong&gt;这是加粗的文字&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;这是倾斜的文字&lt;/em&gt;`&lt;br&gt;
&lt;em&gt;&lt;strong&gt;这是斜体加粗的文字&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
&lt;s&gt;这是加删除线的文字&lt;/s&gt;&lt;/p&gt;
&lt;h1 id=&#34;三-引用&#34;&gt;三、引用&lt;/h1&gt;
&lt;p&gt;在引用的文字前加&amp;gt;即可。引用也可以嵌套，如加两个&amp;gt;&amp;gt;三个&amp;gt;&amp;gt;&amp;gt;n个...&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606704234954.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是引用的内容&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是引用的内容&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这是引用的内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;四-分割线&#34;&gt;四、分割线&lt;/h1&gt;
&lt;p&gt;三个或者三个以上的 - 或者 * 都可以。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606704462750.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;效果如下&#34;&gt;效果如下：&lt;/h2&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;h1 id=&#34;五-图片&#34;&gt;五、图片&lt;/h1&gt;
&lt;p&gt;语法：![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)&lt;br&gt;
图片alt就是显示在图片下面的文字，相当于对图片内容的解释。&lt;br&gt;
图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606704900357.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;![]&lt;/p&gt;
&lt;p&gt;效果如下：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606717141216.svg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;Gridea-Markdown&lt;/center&gt; 
&lt;p&gt;&lt;strong&gt;上传本地图片直接点击导航栏的图片标志，选择图片即可&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;markdown格式追求的是简单、多平台统一。那么图片的存储就是一个问题，需要用图床，提供统一的外链，这样就不用在不同的平台去处理图片的问题了。才能做到书写一次，各处使用。&lt;/p&gt;
&lt;h1 id=&#34;六-超链接&#34;&gt;六、超链接&lt;/h1&gt;
&lt;p&gt;语法：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606708259670.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606708357274.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;br&gt;
&lt;a href=&#34;http://jianshu.com&#34;&gt;简书&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://baidu.com&#34;&gt;百度&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1606708441292.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;七-列表&#34;&gt;七、列表&lt;/h1&gt;
&lt;h3 id=&#34;无序列表&#34;&gt;无序列表&lt;/h3&gt;
&lt;p&gt;语法：&lt;br&gt;
无序列表用 - + * 任何一种都可以&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606709101155.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列表内容&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;列表内容&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;列表内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;有序列表&#34;&gt;有序列表&lt;/h3&gt;
&lt;p&gt;语法：&lt;br&gt;
数字加点&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606709243091.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;列表内容&lt;/li&gt;
&lt;li&gt;列表内容&lt;/li&gt;
&lt;li&gt;列表内容&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;列表嵌套&#34;&gt;列表嵌套&lt;/h3&gt;
&lt;h4 id=&#34;上一级和下一级之间敲三个空格即可&#34;&gt;上一级和下一级之间敲三个空格即可&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://localhost:4000/post-images/1606709356169.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;八-表格&#34;&gt;八、表格&lt;/h1&gt;
&lt;p&gt;语法：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606709722229.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606709789868.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;姓名&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;技能&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;排行&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;刘备&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;哭&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;大哥&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;关羽&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;打&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;二哥&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;张飞&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;骂&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;三弟&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;九-代码&#34;&gt;九、代码&lt;/h1&gt;
&lt;p&gt;语法：&lt;br&gt;
单行代码：代码之间分别用一个反引号包起来&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606709967461.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606709977762.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
单行代码&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606710064570.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;代码块&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606710077370.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;br&gt;
&lt;code&gt;create database hero;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    function fun(){
         echo &amp;quot;这是一句非常牛逼的代码&amp;quot;;
    }
    fun();
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;十-流程图&#34;&gt;十、流程图&lt;/h1&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-flow&#34;&gt;st=&amp;gt;start: 开始
op=&amp;gt;operation: My Operation
cond=&amp;gt;condition: Yes or No?
e=&amp;gt;end
st-&amp;gt;op-&amp;gt;cond
cond(yes)-&amp;gt;e
cond(no)-&amp;gt;op
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606710630750.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;文章转自：https://www.jianshu.com/p/191d1e21f7ed&lt;/p&gt;
">Markdown基本语法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/helloworld/"" data-c="
          &lt;p&gt;与Gridea的初次邂逅!😘&lt;br&gt;
&lt;img src=&#34;http://localhost:4000/post-images/1606659885219.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Gridea 是一款麻雀虽小却五脏俱全的静态博客写作客户端，他能让你告别繁琐的 Git 操作，更加快速方便的管理你的个人 Blog，同时 Gridea 恰到好处的主题和实用的配置功能也能一定程度上帮助你美化 Blog，如果你的动手能力够强，甚至可以自己调教。作为一款免费的工具，如果你有任何的建议都可以去官方项目页面进行反馈，根据目前的版本迭代速度看，作者还是非常勤劳的，期待未来有更多的新鲜功能。&lt;/p&gt;
">HelloWorld</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;center style=&#34;font-size:16px;color:SlateGray;text-decoration:null;padding-bottom:4px&#34;&gt;在这个快、短社交时代，能够有一个独立的地方，一个属于自己的地方来记录下一些内容。能够让自己的声音不会随着各种信息流而流逝。&lt;/center&gt; 
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;center style=&#34;font-size:16px;color:SlateGray;text-decoration:null;padding-bottom:4px&#34;&gt;小破林硕士在读 小小涉足前端开发&lt;/center&gt; 
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
 &lt;center style=&#34;font-size:16px;color:DarkOrange;text-decoration:underline;&#34;&gt;
1002705465@qq.com
&lt;/center&gt;">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="http://localhost:4000/post/hello-gridea/"" data-c="
          &lt;p&gt;👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;
✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/getgridea/gridea&#34;&gt;Github&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://gridea.dev/&#34;&gt;Gridea 主页&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://fehey.com/&#34;&gt;示例网站&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性👇&lt;/h2&gt;
&lt;p&gt;📝  你可以使用最酷的 &lt;strong&gt;Markdown&lt;/strong&gt; 语法，进行快速创作&lt;/p&gt;
&lt;p&gt;🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片&lt;/p&gt;
&lt;p&gt;🏷️  你可以对文章进行标签分组&lt;/p&gt;
&lt;p&gt;📋  你可以自定义菜单，甚至可以创建外部链接菜单&lt;/p&gt;
&lt;p&gt;💻  你可以在 &lt;strong&gt;Windows&lt;/strong&gt;，&lt;strong&gt;MacOS&lt;/strong&gt; 或 &lt;strong&gt;Linux&lt;/strong&gt; 设备上使用此客户端&lt;/p&gt;
&lt;p&gt;🌎  你可以使用 &lt;strong&gt;𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌&lt;/strong&gt; 或 &lt;strong&gt;Coding Pages&lt;/strong&gt; 向世界展示，未来将支持更多平台&lt;/p&gt;
&lt;p&gt;💬  你可以进行简单的配置，接入 &lt;a href=&#34;https://github.com/gitalk/gitalk&#34;&gt;Gitalk&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/SukkaW/DisqusJS&#34;&gt;DisqusJS&lt;/a&gt; 评论系统&lt;/p&gt;
&lt;p&gt;🇬🇧  你可以使用&lt;strong&gt;中文简体&lt;/strong&gt;或&lt;strong&gt;英语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力&lt;/p&gt;
&lt;p&gt;🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步&lt;/p&gt;
&lt;p&gt;🌱 当然 &lt;strong&gt;Gridea&lt;/strong&gt; 还很年轻，有很多不足，但请相信，它会不停向前 🏃&lt;/p&gt;
&lt;p&gt;未来，它一定会成为你离不开的伙伴&lt;/p&gt;
&lt;p&gt;尽情发挥你的才华吧！&lt;/p&gt;
&lt;p&gt;😘 Enjoy~&lt;/p&gt;
">Hello Gridea</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>





</html>