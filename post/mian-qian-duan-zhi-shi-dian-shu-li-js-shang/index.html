<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="知行合一">
<meta name="theme-color" content="#000">
<title>【面】前端知识点梳理（JS） | Tyloo</title>
<link rel="shortcut icon" href="/favicon.ico?v=1619617801148">
<link rel="stylesheet" href="/media/css/pisces.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>





  <meta name="description" content="【面】前端知识点梳理（JS）" />
  <meta name="keywords" content="" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="pisces">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Tyloo</span>
            </a>  
          
        </div>
        
          <p class="subtitle">知行合一</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout pisces ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body pisces" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">来碗鸡丁炒饭</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">50</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">4</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">4</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  



  <div style="width: 100%; position: relative;">
    <canvas id="canvasDiyBlock" style="width:100%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
    <script src="/media/js/magic/clock.js"></script>
  </div>

</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li><a href="#-1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80">-1. 面向对象编程基础！！</a>
<ul>
<li><a href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">1. 什么是面向对象</a></li>
<li><a href="#2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99">2. 面向对象的六大原则</a>
<ul>
<li><a href="#1-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99">1. 单一职责原则</a></li>
<li><a href="#2-%E5%BC%80-%E9%97%AD%E5%8E%9F%E5%88%99">2. 开-闭原则</a></li>
<li><a href="#3-%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99">3. 里氏代换原则</a></li>
<li><a href="#4-%E4%BE%9D%E8%B5%96%E5%80%92%E6%8D%A2%E5%8E%9F%E5%88%99">4. 依赖倒换原则</a></li>
<li><a href="#5-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99">5. 接口隔离原则</a></li>
<li><a href="#6-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99">6. 迪米特法则</a></li>
</ul>
</li>
<li><a href="#3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7">3. 面向对象的三大特性</a>
<ul>
<li><a href="#1-%E5%B0%81%E8%A3%85">1. 封装</a></li>
<li><a href="#2-%E7%BB%A7%E6%89%BF">2. 继承</a></li>
<li><a href="#3-%E5%A4%9A%E6%80%81">3. 多态</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#0-new-%E4%B8%8E-objectcreate-%E5%8C%BA%E5%88%AB">0. new 与 Object.create() 区别</a>
<ul>
<li><a href="#1-new%E7%9A%84%E5%8E%9F%E7%90%86">1. new的原理</a></li>
<li><a href="#2-objectcreate%E4%BB%8B%E7%BB%8D">2. Object.create()介绍</a></li>
</ul>
</li>
<li><a href="#1-%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E7%BB%A7%E6%89%BF">1. 原型/原型链/构造函数/实例/继承</a>
<ul>
<li><a href="#11-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95">1.1 创建对象的几种方法</a></li>
<li><a href="#12-%E5%8E%9F%E5%9E%8B-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E5%AE%9E%E4%BE%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE">1.2 原型、构造函数、实例、原型链</a></li>
<li><a href="#13-instanceof-%E7%9A%84%E5%8E%9F%E7%90%86">1.3 instanceof 的原理</a></li>
<li><a href="#14-instanceof-%E5%92%8C-typeof-%E7%9A%84%E5%8C%BA%E5%88%AB">1.4 instanceof 和 typeof 的区别</a></li>
<li><a href="#15-%E5%8E%9F%E5%9E%8B%E9%93%BE">1.5 原型链</a></li>
<li><a href="#%E4%BE%8B%E5%AD%90">例子</a></li>
</ul>
</li>
<li><a href="#2-%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF">2. 有几种方式可以实现继承</a>
<ul>
<li><a href="#1-%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF">1.  原型链继承</a></li>
<li><a href="#2-%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">2. 借用构造函数</a></li>
<li><a href="#3-%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%E5%8E%9F%E5%9E%8B%E9%93%BE-%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">3. 组合继承(原型链 + 借用构造函数)</a></li>
<li><a href="#4-%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF">4. 原型式继承</a></li>
<li><a href="#5-%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF">5. 寄生式继承</a></li>
<li><a href="#6-%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF">6. 寄生组合式继承</a></li>
<li><a href="#7-es6%E7%BB%A7%E6%89%BF">7 es6继承</a></li>
</ul>
</li>
<li><a href="#3-%E7%94%A8%E5%8E%9F%E5%9E%8B%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3">3. 用原型实现继承有什么缺点，怎么解决</a></li>
<li><a href="#4-arguments">4. arguments</a></li>
<li><a href="#5-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD">5. 数据类型判断</a>
<ul>
<li><a href="#50-null%E5%92%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB">5.0 null和undefined的区别</a></li>
<li><a href="#51-javascript-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">5.1 JavaScript 数据类型</a></li>
<li><a href="#52-%E6%A3%80%E9%AA%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">5.2 检验数据类型</a>
<ul>
<li><a href="#521-typeof">5.2.1 typeof</a></li>
<li><a href="#522-instanceof">5.2.2 instanceof</a></li>
<li><a href="#523-objectprototypetostringcall">5.2.3 Object.prototype.toString.call()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3">6. 作用域、作用域链和闭包的理解</a>
<ul>
<li><a href="#61-%E4%BD%9C%E7%94%A8%E5%9F%9F">6.1 作用域</a></li>
<li><a href="#62-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BEscope-chain">6.2 作用域链（Scope Chain）</a>
<ul>
<li><a href="#621-%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83execution-context">6.2.1 执行环境（execution context）</a></li>
<li><a href="#622-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE">6.2.2 作用域链</a></li>
</ul>
</li>
<li><a href="#63-%E9%97%AD%E5%8C%85">6.3 闭包</a>
<ul>
<li><a href="#1-%E9%97%AD%E5%8C%85%E7%9A%84%E5%AE%9A%E4%B9%89">1. 闭包的定义</a></li>
<li><a href="#2-%E9%97%AD%E5%8C%85%E7%9A%84%E5%8E%9F%E7%90%86">2. 闭包的原理</a></li>
<li><a href="#3-%E9%97%AD%E5%8C%85%E7%9A%84%E7%89%B9%E7%82%B9">3. 闭包的特点</a></li>
<li><a href="#4-%E9%97%AD%E5%8C%85%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">4. 闭包的优缺点</a></li>
<li><a href="#5-%E9%97%AD%E5%8C%85%E7%9A%84%E4%BD%9C%E7%94%A8">5. 闭包的作用</a></li>
<li><a href="#6-%E9%97%AD%E5%8C%85%E5%8F%98%E9%87%8F%E5%9B%9E%E6%94%B6">6. 闭包变量回收</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#7-ajax%E7%9A%84%E5%8E%9F%E7%94%9F%E5%86%99%E6%B3%95">7. Ajax的原生写法</a>
<ul>
<li><a href="#71-ajax-%E6%98%AF%E4%BB%80%E4%B9%88">7.1 Ajax 是什么？</a></li>
<li><a href="#72-ajax%E7%9A%84%E4%BD%BF%E7%94%A8">7.2 Ajax的使用</a>
<ul>
<li><a href="#721-%E5%88%9B%E5%BB%BAxmlhttprequest%E5%AF%B9%E8%B1%A1">7.2.1 创建XMLHttpRequest对象</a></li>
<li><a href="#722-%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8">7.2.2 连接服务器</a></li>
<li><a href="#723-%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82">7.2.3 向服务器发送请求</a></li>
<li><a href="#724-%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6%E5%8F%98%E5%8C%96">7.2.4 监听事件变化</a></li>
</ul>
</li>
<li><a href="#73-ajax%E5%8E%9F%E7%94%9F%E5%86%99%E6%B3%95">7.3 Ajax原生写法</a>
<ul>
<li><a href="#731-get%E8%AF%B7%E6%B1%82">7.3.1 Get请求</a></li>
<li><a href="#732-post%E8%AF%B7%E6%B1%82">7.3.2 Post请求</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#8-%E5%AF%B9%E8%B1%A1%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E6%B5%85%E6%8B%B7%E8%B4%9D">8. 对象深拷贝、浅拷贝</a>
<ul>
<li><a href="#81-%E6%B5%85%E6%8B%B7%E8%B4%9D">8.1 浅拷贝</a></li>
<li><a href="#82-%E6%B7%B1%E6%8B%B7%E8%B4%9D">8.2 深拷贝</a></li>
</ul>
</li>
<li><a href="#9-%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD-%E9%A2%84%E5%8A%A0%E8%BD%BD">9. 图片懒加载、预加载</a>
<ul>
<li><a href="#91-%E6%87%92%E5%8A%A0%E8%BD%BD">9.1 懒加载</a>
<ul>
<li><a href="#911-%E4%BB%80%E4%B9%88%E6%98%AF%E6%87%92%E5%8A%A0%E8%BD%BD">9.1.1 什么是懒加载</a></li>
<li><a href="#912-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD">9.1.2 为什么要使用图片懒加载？</a></li>
<li><a href="#913-%E6%87%92%E5%8A%A0%E8%BD%BD%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">9.1.3 懒加载具体实现原理</a></li>
</ul>
</li>
<li><a href="#92-%E9%A2%84%E5%8A%A0%E8%BD%BD">9.2 预加载</a>
<ul>
<li><a href="#921-%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%84%E5%8A%A0%E8%BD%BD">9.2.1 什么是预加载</a></li>
<li><a href="#922-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87%E9%A2%84%E5%8A%A0%E8%BD%BD">9.2.2 为什么要使用图片预加载？</a></li>
<li><a href="#923-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B">9.2.3 实现方式有哪些？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#10-%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E8%BF%9B%E5%BA%A6%E6%9D%A1">10. 实现页面加载进度条</a>
<ul>
<li><a href="#101-html%E7%BB%93%E6%9E%84">10.1 html结构：</a></li>
<li><a href="#102-css%E7%BB%93%E6%9E%84">10.2 CSS结构：</a></li>
<li><a href="#103-javascript-%E9%83%A8%E5%88%86">10.3 JavaScript 部分</a></li>
</ul>
</li>
<li><a href="#11-this%E5%85%B3%E9%94%AE%E5%AD%97">11. this关键字</a>
<ul>
<li><a href="#111-%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84this">11.1 全局对象中的this</a></li>
<li><a href="#112-%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this">11.2 函数中的this</a></li>
<li><a href="#113-%E4%BD%BF%E7%94%A8callapply%E6%98%BE%E7%A4%BA%E6%8C%87%E5%AE%9Athis">11.3 使用call，apply显示指定this</a></li>
<li><a href="#114-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95%E4%B8%8A%E7%9A%84this">11.4 构造函数与原型方法上的this</a></li>
</ul>
</li>
<li><a href="#12-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">12. 函数式编程</a></li>
<li><a href="#13-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0parseint">13. 手动实现parseInt</a></li>
<li><a href="#14-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5">14. 为什么会有同源策略</a>
<ul>
<li><a href="#141-%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5">14.1 什么是同源策略</a></li>
<li><a href="#142-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A6%81%E4%BD%BF%E7%94%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5">14.2 为什么浏览器要使用同源策略</a></li>
</ul>
</li>
<li><a href="#15-%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89">15. 怎么判断两个对象是否相等</a></li>
<li><a href="#16-%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B">16. 事件模型</a>
<ul>
<li><a href="#1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.基本概念</a></li>
<li><a href="#2-%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD">2. 事件传播</a></li>
<li><a href="#3-%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E6%8D%95%E8%8E%B7">3. 事件冒泡和捕获</a></li>
<li><a href="#4-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98">4. 事件委托</a></li>
<li><a href="#5-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E4%BC%98%E7%82%B9">5. 事件委托的优点</a></li>
<li><a href="#6-%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA">6. 事件的默认行为</a></li>
<li><a href="#7-%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BA%8B%E4%BB%B6%E5%85%88%E5%86%92%E6%B3%A1%E5%90%8E%E6%8D%95%E8%8E%B7">7. 如何让事件先冒泡后捕获</a></li>
</ul>
</li>
<li><a href="#17-dom%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0-%E8%8A%82%E7%82%B9%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B7%BB%E5%8A%A0-%E8%8A%82%E7%82%B9%E7%9A%84%E6%9B%BF%E6%8D%A2%E5%92%8C%E5%88%A0%E9%99%A4">17. DOM基本操作（获取元素、节点的创建和添加、节点的替换和删除）</a>
<ul>
<li><a href="#1-%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0">1. 获取元素</a></li>
<li><a href="#2-%E8%8A%82%E7%82%B9%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B7%BB%E5%8A%A0%E5%88%9B%E5%BB%BA%E5%AE%8C%E4%B8%80%E5%AE%9A%E8%A6%81%E6%B7%BB%E5%8A%A0">2. 节点的创建和添加（创建完一定要添加）</a>
<ul>
<li><a href="#1-%E8%8A%82%E7%82%B9%E7%9A%84%E5%88%9B%E5%BB%BA">1. 节点的创建</a></li>
<li><a href="#2-%E8%8A%82%E7%82%B9%E7%9A%84%E6%B7%BB%E5%8A%A0-%E5%89%AA%E5%88%87%E6%93%8D%E4%BD%9C">2. 节点的添加、剪切操作</a></li>
</ul>
</li>
<li><a href="#3-%E8%8A%82%E7%82%B9%E7%9A%84%E6%9B%BF%E6%8D%A2%E5%92%8C%E5%88%A0%E9%99%A4">3. 节点的替换和删除</a>
<ul>
<li><a href="#1%E8%8A%82%E7%82%B9%E7%9A%84%E6%9B%BF%E6%8D%A2">1.节点的替换</a></li>
<li><a href="#2-%E8%8A%82%E7%82%B9%E7%9A%84%E5%88%A0%E9%99%A4-%E5%88%A0%E9%99%A4%E5%AD%90%E8%8A%82%E7%82%B9">2. 节点的删除 、删除子节点</a></li>
</ul>
</li>
<li><a href="#4-%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96%E4%B8%8E%E9%9D%99%E6%80%81%E8%8E%B7%E5%8F%96">4. 动态获取与静态获取</a>
<ul>
<li><a href="#1-get%E7%B3%BB%E5%88%97%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E5%BC%8F%E6%98%AF%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96">1. get系列获取元素的方式是动态获取</a></li>
<li><a href="#2-query%E7%B3%BB%E5%88%97%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E5%BC%8F%E6%98%AF%E9%9D%99%E6%80%81%E6%80%81%E8%8E%B7%E5%8F%96">2. query系列获取元素的方式是静态态获取</a></li>
</ul>
</li>
<li><a href="#5-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%88%9B%E5%BB%BA%E7%A9%BA%E8%8A%82%E7%82%B9%E7%9A%84%E6%97%B6%E5%80%99%E6%B7%BB%E5%8A%A0%E5%86%85%E5%AE%B9">5. 如何在创建空节点的时候添加内容</a>
<ul>
<li><a href="#1-%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9">1. 元素节点</a></li>
<li><a href="#2-%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9">2. 元素节点</a></li>
</ul>
</li>
<li><a href="#6-%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">6. 元素节点的常用方法</a>
<ul>
<li><a href="#1-%E5%B1%9E%E6%80%A7%E9%9B%86%E5%90%88">1. 属性集合</a></li>
<li><a href="#2-%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7%E8%8A%82%E7%82%B9">2. 设置属性节点</a></li>
<li><a href="#3-%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%E8%8A%82%E7%82%B9">3. 获取属性节点</a></li>
<li><a href="#4-%E5%88%A0%E9%99%A4%E5%B1%9E%E6%80%A7%E8%8A%82%E7%82%B9">4. 删除属性节点</a></li>
<li><a href="#5-%E5%88%A4%E6%96%AD%E6%9C%89%E6%B2%A1%E6%9C%89%E5%AD%90%E8%8A%82%E7%82%B9">5. 判断有没有子节点</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#18-js%E9%81%8D%E5%8E%86dom%E6%A0%91">18. js遍历dom树</a>
<ul>
<li><a href="#1-%E9%81%8D%E5%8E%86dom%E6%A0%91">1. 遍历dom树</a></li>
<li><a href="#2-%E5%A4%9A%E5%8F%89-dom-%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">2. 多叉 DOM 树的遍历</a>
<ul>
<li><a href="#1-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86">1. 广度优先遍历</a></li>
<li><a href="#2-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86">2. 深度优先遍历</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#19-%E9%9D%A2%E8%AF%95%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F">19. 面试查缺补漏</a>
<ul>
<li><a href="#1-js%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E6%96%B9%E5%BC%8F">1. JS页面跳转方式</a></li>
<li><a href="#2-js%E5%BC%B9%E5%87%BA%E6%A1%86%E6%9C%89%E5%93%AA%E4%BA%9B">2. JS弹出框有哪些</a></li>
<li><a href="#3-url%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E7%9A%84%E6%96%B9%E5%BC%8F">3. url编码和解码的方式</a>
<ul>
<li><a href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81url%E7%BC%96%E7%A0%81">1. 为什么要URL编码？</a></li>
<li><a href="#2-js%E7%BC%96%E7%A0%81%E5%87%BD%E6%95%B0">2. JS编码函数</a></li>
<li><a href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%A4%E6%AC%A1%E7%BC%96%E7%A0%81">3. 为什么两次编码</a></li>
</ul>
</li>
<li><a href="#4-meta%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7">4. meta常用属性</a>
<ul>
<li><a href="#1-charset%E5%B1%9E%E6%80%A7">1. charset属性</a></li>
<li><a href="#2-name-content%E5%B1%9E%E6%80%A7">2. name + content属性</a></li>
<li><a href="#3-http-equiv%E5%B1%9E%E6%80%A7">3. http-equiv属性</a></li>
</ul>
</li>
<li><a href="#5-a%E6%A0%87%E7%AD%BE%E5%AE%9E%E7%8E%B0%E6%89%93%E7%94%B5%E8%AF%9D">5. a标签实现打电话</a></li>
<li><a href="#6-css%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF">6. CSS哪些属性可以继承？</a></li>
<li><a href="#7-windowscroll%E6%96%B9%E6%B3%95">7. window.scroll方法</a>
<ul>
<li><a href="#1-windowscroll%E5%88%B0">1. window.scroll（到）</a></li>
<li><a href="#2windowscrollto">2.window.scrollTo</a></li>
<li><a href="#3-windowscrollby%E8%B7%9D%E7%A6%BB">3. window.scrollBy（距离）</a></li>
</ul>
</li>
<li><a href="#8-head%E5%A4%B4%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E6%A0%87%E7%AD%BE">8. head头包含哪些标签？</a></li>
</ul>
</li>
<li><a href="#17-window%E7%9A%84onload%E4%BA%8B%E4%BB%B6%E5%92%8Cdomcontentloaded">17. window的onload事件和domcontentloaded</a></li>
<li><a href="#18-forin%E8%BF%AD%E4%BB%A3%E5%92%8Cforof%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">18. for...in迭代和for...of有什么区别</a>
<ul>
<li><a href="#1-forin">1. for…in</a></li>
<li><a href="#2-forof">2. for…of</a></li>
</ul>
</li>
<li><a href="#19-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96-%E5%92%8C-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">19. 函数柯里化 和 高阶函数</a>
<ul>
<li><a href="#1-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96">1. 函数柯里化</a></li>
<li><a href="#2-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">2. 高阶函数</a>
<ul>
<li><a href="#1-arrayprototypemap">1. Array.prototype.map</a></li>
<li><a href="#2-arrayprototypereduce">2. Array.prototype.reduce</a></li>
<li><a href="#3-arrayprototypefilter">3. Array.prototype.filter</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#20-call-%E4%B8%8E-apply%E5%8C%BA%E5%88%AB%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0bind">20.  call 与 apply区别，原生实现bind</a>
<ul>
<li><a href="#1-call-%E5%92%8C-apply-%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9">1. call 和 apply 的共同点</a></li>
<li><a href="#2-call-%E5%92%8C-apply-%E7%9A%84%E5%8C%BA%E5%88%AB">2. call 和 apply 的区别</a></li>
<li><a href="#3-call-%E5%92%8C-apply-%E7%9A%84%E7%94%A8%E9%80%94">3 call 和 apply 的用途</a></li>
<li><a href="#4-bind-%E7%9A%84%E4%BD%BF%E7%94%A8">4. bind 的使用</a></li>
<li><a href="#5-%E6%80%BB%E7%BB%93">5. 总结</a></li>
</ul>
</li>
<li><a href="#21-%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E9%97%AD%E5%8C%85%E7%BB%93%E5%90%88">21. 立即执行函数和使用场景（与闭包结合）</a>
<ul>
<li><a href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0">1. 什么是立即执行函数？</a></li>
<li><a href="#2-%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%86%99%E6%B3%95">2. 立即执行函数的写法：</a></li>
<li><a href="#3-%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8">3. 立即执行函数的作用：</a></li>
<li><a href="#4-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">4. 使用场景</a></li>
</ul>
</li>
<li><a href="#22-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A6%81%E6%B1%82%E8%AF%B4%E5%87%BA%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E4%BC%98%E7%BC%BA%E7%82%B9%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0">22. 设计模式(要求说出如何实现,应用,优缺点)/单例模式实现</a>
<ul>
<li><a href="#1-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F">1. 创建型模式</a>
<ul>
<li><a href="#1-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">1. 工厂模式</a></li>
<li><a href="#2-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">2. 单例模式</a></li>
<li><a href="#3-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F">3. 原型模式</a></li>
</ul>
</li>
<li><a href="#2-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F">2. 结构型模式</a>
<ul>
<li><a href="#1-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">1. 适配器模式</a></li>
</ul>
</li>
<li><a href="#3-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F">3. 行为型模式</a>
<ul>
<li><a href="#1-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AE%A2%E9%98%85-%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F">1. 观察者模式(订阅-发布模式)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#23-iframe%E7%9A%84%E7%BC%BA%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B">23. iframe的缺点有哪些</a>
<ul>
<li><a href="#1-iframe%E7%9A%84%E4%BC%98%E7%82%B9">1. iframe的优点：</a></li>
<li><a href="#2-iframe%E7%9A%84%E7%BC%BA%E7%82%B9">2. iframe的缺点：</a></li>
</ul>
</li>
<li><a href="#24-%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98">24. 数组问题</a>
<ul>
<li><a href="#1-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D">1. 数组去重</a>
<ul>
<li><a href="#1-%E5%88%A9%E7%94%A8es6-set%E5%8E%BB%E9%87%8Des6%E4%B8%AD%E6%9C%80%E5%B8%B8%E7%94%A8">1. 利用ES6 Set去重（ES6中最常用）</a></li>
<li><a href="#2-%E5%88%A9%E7%94%A8for%E5%B5%8C%E5%A5%97for%E7%84%B6%E5%90%8Esplice%E5%8E%BB%E9%87%8Des5%E4%B8%AD%E6%9C%80%E5%B8%B8%E7%94%A8">2. 利用for嵌套for，然后splice去重（ES5中最常用）</a></li>
<li><a href="#3-%E5%88%A9%E7%94%A8indexof%E5%8E%BB%E9%87%8D">3. 利用indexOf去重</a></li>
<li><a href="#4-%E5%88%A9%E7%94%A8sort">4. 利用sort()</a></li>
<li><a href="#5-%E5%88%A9%E7%94%A8includes">5. 利用includes</a></li>
<li><a href="#6-%E5%88%A9%E7%94%A8filter">6. 利用filter</a></li>
<li><a href="#7-%E5%88%A9%E7%94%A8map%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8E%BB%E9%87%8D">7. 利用Map数据结构去重</a></li>
</ul>
</li>
<li><a href="#2-%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">2. 数组常用方法</a>
<ul>
<li><a href="#1-arraymap">1. Array.map()</a></li>
<li><a href="#2-arrayforeach">2. Array.forEach()</a></li>
<li><a href="#3-arrayfilter">3. Array.filter()</a></li>
<li><a href="#4-arrayevery">4. Array.every()</a></li>
<li><a href="#5-arraysome">5. Array.some()</a></li>
<li><a href="#6-arrayreduce">6. Array.reduce()</a></li>
<li><a href="#7-arraypush">7. Array.push()</a></li>
<li><a href="#8-arraypop">8. Array.pop()</a></li>
<li><a href="#9-arrayshift">9. Array.shift()</a></li>
<li><a href="#10-arrayunshift">10. Array.unshift()</a></li>
<li><a href="#11-arrayisarray">11. Array.isArray()</a></li>
<li><a href="#12-arrayconcat">12. Array.concat()</a></li>
<li><a href="#13-arraytostring">13. Array.toString()</a></li>
<li><a href="#14-arrayjoin">14. Array.join()</a></li>
<li><a href="#15-arraysplice%E5%BC%80%E5%A7%8B%E4%BD%8D%E7%BD%AE-%E5%88%A0%E9%99%A4%E7%9A%84%E4%B8%AA%E6%95%B0%E5%85%83%E7%B4%A0">15. Array.splice(开始位置， 删除的个数，元素)</a></li>
</ul>
</li>
<li><a href="#3-%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E9%87%8D%E5%A4%8D%E9%A1%B9">3. 查找数组重复项</a></li>
<li><a href="#4-%E6%89%81%E5%B9%B3%E5%8C%96%E6%95%B0%E7%BB%84flatten">4. 扁平化数组（flatten）</a>
<ul>
<li><a href="#1-%E8%BF%AD%E4%BB%A3%E9%80%92%E5%BD%92">1. 迭代递归</a></li>
<li><a href="#2-%E6%9B%B2%E7%BA%BF%E6%95%91%E5%9B%BD%E6%B3%95">2. 曲线救国法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#25-dom%E5%92%8Cbom%E7%9B%B8%E5%85%B3">25. DOM和BOM相关</a>
<ul>
<li><a href="#1dom">1.DOM</a>
<ul>
<li><a href="#1-dom%E6%98%AF%E4%BB%80%E4%B9%88">1. DOM是什么：</a></li>
<li><a href="#2-dom0%E7%BA%A7%E5%92%8Cdom2%E7%BA%A7%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">2. DOM0级和DOM2级有什么区别：</a></li>
<li><a href="#3-textcontent-innertext-innnerhtml-value%E7%9A%84%E5%8C%BA%E5%88%AB">3. textContent、innerText、innnerHTML、value的区别：</a></li>
<li><a href="#4-%E5%85%B3%E4%BA%8Edom%E7%9A%84api%E6%9C%89%E4%BB%80%E4%B9%88">4. 关于dom的api有什么：</a></li>
<li><a href="#5%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC">5.什么是事件监听:</a></li>
<li><a href="#6-%E8%AF%B4%E8%AF%B4%E5%89%8D%E7%AB%AF%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%B5%81">6. 说说前端中的事件流</a></li>
<li><a href="#7-%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BA%8B%E4%BB%B6%E5%85%88%E5%86%92%E6%B3%A1%E5%90%8E%E6%8D%95%E8%8E%B7-2">7. 如何让事件先冒泡后捕获</a></li>
<li><a href="#8-%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86">8. 说一下事件代理：</a></li>
<li><a href="#9-%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3">9. 事件类型相关：</a></li>
<li><a href="#10-%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB">10. 静态绑定事件与动态绑定事件的区别：</a></li>
<li><a href="#11-%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%A4%A7%E5%B0%8F">11. 元素的位置和大小</a></li>
<li><a href="#12-js%E6%8B%96%E5%8A%A8%E5%8F%8A%E6%8B%96%E6%8B%BD%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0">12. js拖动及拖拽功能的实现</a></li>
</ul>
</li>
<li><a href="#2-bom%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">2. (BOM)浏览器对象模型：</a>
<ul>
<li><a href="#1-%E5%AE%9E%E7%94%A8%E7%9A%84bom%E5%B1%9E%E6%80%A7%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95">1. 实用的BOM属性对象方法：</a></li>
<li><a href="#2-settimeoutfn100100%E6%AF%AB%E7%A7%92%E6%98%AF%E5%A6%82%E4%BD%95%E6%9D%83%E8%A1%A1%E7%9A%84">2. setTimeout(fn,100);100毫秒是如何权衡的：</a></li>
<li><a href="#3-requestanimationframe">3. requestAnimationFrame</a></li>
<li><a href="#4-%E5%88%86%E5%88%AB%E7%94%A8setintervalsettimeoutrequestanimationframe%E5%88%B6%E4%BD%9C%E6%9C%89%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%BF%9B%E5%BA%A6%E6%9D%A1%E6%95%88%E6%9E%9C">4. 分别用setInterval,setTimeout,requestAnimationFrame制作有个简单的进度条效果：</a></li>
<li><a href="#5-js%E4%B8%AD%E7%9A%84%E8%BD%AE%E6%92%AD%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%81%87%E5%A6%82%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%9C%89%E4%B8%A4%E4%B8%AA%E8%BD%AE%E6%92%AD%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0">5. js中的轮播实现原理？假如一个页面上有两个轮播，你会怎么实现？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#26-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93server-side-render">26. 服务端渲染（server side render）</a>
<ul>
<li><a href="#1-ssr%E7%9A%84%E4%BC%98%E5%8A%BF">1. SSR的优势</a></li>
<li><a href="#2-ssr%E7%9A%84%E5%8A%A3%E5%8A%BF">2. SSR的劣势</a></li>
</ul>
</li>
<li><a href="#27-js-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6">27.  JS 垃圾回收机制</a>
<ul>
<li><a href="#1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">1. 垃圾回收</a></li>
<li><a href="#2-%E5%8F%AF%E8%BE%BE%E6%80%A7">2. 可达性</a></li>
<li><a href="#3%E4%B8%A4%E4%B8%AA%E5%BC%95%E7%94%A8">3.两个引用</a></li>
<li><a href="#4-%E7%9B%B8%E4%BA%92%E5%85%B3%E8%81%94%E7%9A%84%E5%AF%B9%E8%B1%A1">4. 相互关联的对象</a></li>
<li><a href="#5-%E5%86%85%E9%83%A8%E7%AE%97%E6%B3%95">5. 内部算法</a></li>
<li><a href="#6%E9%9D%A2%E8%AF%95%E6%80%8E%E4%B9%88%E5%9B%9E%E7%AD%94">6.面试怎么回答</a></li>
</ul>
</li>
<li><a href="#28-eventloop">28. eventloop</a>
<ul>
<li><a href="#1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B">1. 进程和线程</a></li>
<li><a href="#2-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E4%B8%8E%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97">2. 函数调用栈与任务队列</a></li>
<li><a href="#3-%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1">3. 宏任务与微任务</a></li>
<li><a href="#4%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFevent-loop">4.事件循环（Event Loop）</a></li>
</ul>
</li>
<li><a href="#29-%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E8%AE%A9%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E6%88%90%E4%BB%A5%E5%8D%83%E4%B8%BA%E7%B2%BE%E5%BA%A6%E7%9A%84%E6%95%B0%E5%AD%97">29. 如何快速让字符串变成以千为精度的数字</a>
<ul>
<li><a href="#1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B0%E5%AD%97%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95">1. 字符串转换成数字的三种方法</a></li>
<li><a href="#2-%E6%95%B0%E5%AD%97%E5%8D%83%E4%BD%8D%E7%AC%A6%E6%A0%BC%E5%BC%8F%E5%8C%96">2. 数字千位符格式化</a></li>
</ul>
</li>
<li><a href="#30-js%E4%B8%ADv8%E5%BC%95%E6%93%8E%E7%9A%84%E8%AF%A6%E8%A7%A3">30. js中v8引擎的详解</a>
<ul>
<li><a href="#1-v8%E5%BC%95%E6%93%8E%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0">1. v8引擎出现的原因</a></li>
<li><a href="#2-%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E5%8F%8A%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93">2. 渲染引擎及网页渲染</a>
<ul>
<li><a href="#1-%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E">1. 渲染引擎</a></li>
<li><a href="#2-%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B">2. 网页渲染流程</a></li>
<li><a href="#3-javascript%E5%BC%95%E6%93%8E">3. JavaScript引擎</a></li>
</ul>
</li>
<li><a href="#3-v8%E5%BC%95%E6%93%8E">3. V8引擎</a></li>
<li><a href="#4-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA">4. 数据表示</a></li>
<li><a href="#5-%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B">5. 工作过程</a>
<ul>
<li><a href="#%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5">编译阶段</a></li>
<li><a href="#%E8%BF%90%E8%A1%8C%E9%98%B6%E6%AE%B5">运行阶段</a></li>
<li><a href="#%E4%BC%98%E5%8C%96%E5%9B%9E%E6%BB%9A">优化回滚</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://Tyloo-code.github.io/post/mian-qian-duan-zhi-shi-dian-shu-li-js-shang/">
      【面】前端知识点梳理（JS）
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2021-03-05 11:39:37">2021-03-05</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>124<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>30967<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
    
    
    <span id="/post/mian-qian-duan-zhi-shi-dian-shu-li-js-shang/" data-flag-title="【面】前端知识点梳理（JS）" class="meta-item pc-show leancloud_visitors">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-eye"></i>
      <span><span class="language" data-lan="view">浏览量</span>：<span class="leancloud-visitors-count"></span></span>
    </span>
    
  </div>
</section>
            <div class="post-body next-md-body" id="post_body">
              <h1 id="-1-面向对象编程基础">-1. 面向对象编程基础！！</h1>
<blockquote>
<p>面向对象适合的是那些业务逻辑复杂（其实用“繁杂”更恰当一些）的大型项目。所谓繁杂，繁指多，杂指乱，项目“杂乱”，可以表现为：功能多改动多，所以代码量大、开发人员多、开发/维护跨度时间长……</p>
</blockquote>
<h2 id="1-什么是面向对象">1. 什么是面向对象</h2>
<p>面向对象 ( Object Oriented ) 是将现实问题构建关系，然后抽象成 <strong>类 ( class )</strong>，给类定义属性和方法后，再将类实例化成 <strong>实例 ( instance )</strong> ，通过访问实例的属性和调用方法来进行使用。</p>
<p>在不同的语言中，对象的定义范围不同。在 Java 等静态语言中，一般把类的实例称为对象。</p>
<h2 id="2-面向对象的六大原则">2. 面向对象的六大原则</h2>
<h3 id="1-单一职责原则">1. 单一职责原则</h3>
<p>一个合理的类，应该仅有一个引起它变化的原因，即单一职责,就是设计的这个类功能应该只有一个;</p>
<ul>
<li>优点：消除耦合，减小因需求变化引起代码僵化。</li>
</ul>
<h3 id="2-开-闭原则">2. 开-闭原则</h3>
<p>讲的是设计要对扩展有好的支持，而对修改要严格限制。即对扩展开放，对修改封闭。</p>
<ul>
<li>优点：降低了程序各部分之间的耦合性，其适应性、灵活性、稳定性都比较好。当已有软件系统需要增加新的功能时，不需要对作为系统基础的抽象层进行修改，只需要在原有基础上附加新的模块就能实现所需要添加的功能。增加的新模块对原有的模块完全没有影响或影响很小，这样就无须为原有模块进行重新测试。</li>
</ul>
<h3 id="3-里氏代换原则">3. 里氏代换原则</h3>
<p>规则是“子类必须能够替换基类，否则不应当设计为其子类。”也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。</p>
<ul>
<li>优点：可以很容易的实现同一父类下各个子类的互换，而客户端可以毫不察觉。</li>
</ul>
<h3 id="4-依赖倒换原则">4. 依赖倒换原则</h3>
<p>“设计要依赖于抽象而不是具体化”。换句话说就是设计的时候我们要用抽象来思考，而不是一上来就开始划分我需要哪些哪些类，因为这些是具体。<br>
<img src="https://Tyloo-code.github.io/post-images/1619593049456.png" alt="" loading="lazy"></p>
<ul>
<li>优点：人的思维本身实际上就是很抽象的，我们分析问题的时候不是一下子就考虑到细节，而是很抽象的将整个问题都构思出来，所以面向抽象设计是符合人的思维的。另外这个原则会很好的支持（开闭原则）OCP，面向抽象的设计使我们能够不必太多依赖于实现，这样扩展就成为了可能。</li>
</ul>
<h3 id="5-接口隔离原则">5. 接口隔离原则</h3>
<p>“将大的接口打散成多个小接口”，让系统解耦，从而容易重构，更改和重新部署。</p>
<ul>
<li>优点：会使一个软件系统功能扩展时，修改的压力不会传到别的对象那里。</li>
</ul>
<h3 id="6-迪米特法则">6. 迪米特法则</h3>
<p>它讲的是“一个对象应当尽可能少的去了解其他对象”。</p>
<ul>
<li>优点：消除耦合。</li>
</ul>
<h2 id="3-面向对象的三大特性">3. 面向对象的三大特性</h2>
<p>理解了理论知识后，接着通过例子，再理解面向对象的三大特征：<code>封装</code>、<code>继承</code>、<code>多态</code>。</p>
<h3 id="1-封装">1. 封装</h3>
<p>封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。</p>
<p><code>封装</code>，<strong>也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作</strong>，对不可信的进行信息隐藏。</p>
<h3 id="2-继承">2. 继承</h3>
<p>面向对象编程 (OOP) 语言的一个主要功能就是“<code>继承</code>”。继承是指这样一种能力：<strong>它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展</strong>。</p>
<p>通过继承创建的新类称为“子类”或“派生类”。<br>
被继承的类称为“基类”、“父类”或“超类”。</p>
<p>要实现继承，可以通过“<strong>继承</strong>”（Inheritance）和“<strong>组合</strong>”（Composition）来实现。</p>
<p>继承概念的实现方式有三类：<code>实现继承</code>、<code>接口继承</code>和<code>可视继承</code>。<br>
<img src="https://Tyloo-code.github.io/post-images/1619592096963.png" alt="" loading="lazy"></p>
<h3 id="3-多态">3. 多态</h3>
<p>多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，<br>
简单的说，就是一句话：<code>允许将子类类型的指针赋值给父类类型的指针</code>。</p>
<p>实现多态，有二种方式，覆盖，重载。</p>
<ul>
<li>覆盖，是指子类重新定义父类的虚函数的做法。</li>
<li>重载，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。</li>
</ul>
<p>那么，多态的作用是什么呢？我们知道，<code>封装</code>可以隐藏实现细节，使得代码模块化；<code>继承</code>可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而<code>多态</code>则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。</p>
<h1 id="0-new-与-objectcreate-区别">0. new 与 Object.create() 区别</h1>
<h2 id="1-new的原理">1. new的原理</h2>
<p>new 大概会执行以下四个步骤：</p>
<ul>
<li>创建一个空对象</li>
<li>将空对象的原型链连接到另一个对象</li>
<li>执行构造函数中的代码并绑定 this 到这个对象</li>
<li>如函数没有返回值，则返回该对象</li>
</ul>
<p>自己实现一个 _new(Constructor,...args):</p>
<pre><code>function _new() {
     // 参数为 对象A，属性
      // 1.创建一个空对象
     let obj = {}
 
     // 2.将该空对象的原型链连接到传入的对象
     let [Con, ...args] = arguments
     obj.__proto__ = Con.prototype
 
     // 3.执行函数并绑定 this
     let res = Con.apply(obj, args)
 
     // 4.如果函数有返回值并且为object，则返回函数的返回值，否则返回obj
     return res instanceof Object ? res : obj
   }
 
   function Person(name, age) {
     this.name = name
     this.age = age
   }
   Person.prototype.getName = function() {
     return this.name
   }
 
   let p = _new(Person, &quot;sillywa&quot;, 23)
</code></pre>
<h2 id="2-objectcreate介绍">2. Object.create()介绍</h2>
<p>Object.create(null) 创建的对象是一个空对象，在该对象上没有继承 Object.prototype 原型链上的属性或者方法,例如：toString(), hasOwnProperty()等方法</p>
<p>**Object.create()**方法接受两个参数:Object.create(<code>obj</code>,<code>propertiesObject</code>) ;</p>
<ul>
<li>obj:一个对象，应该是新创建的对象的原型。</li>
<li>propertiesObject：可选。该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符（这些属性描述符的结构与Object.defineProperties()的第二个参数一样）</li>
</ul>
<h1 id="1-原型原型链构造函数实例继承">1. 原型/原型链/构造函数/实例/继承</h1>
<h2 id="11-创建对象的几种方法">1.1 创建对象的几种方法</h2>
<pre><code>&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
		//创建对象的几种方式
		//1.字面量
		var obj1 = {name: 'solo obj1'};
		//2.new Object
		var obj2 = new Object({name: 'solo obj2'})
		//3.构造函数创建
		var M = function(name){
			this.name = name;
		}
		var obj3 = new M('solo obj3');
		//4.Object.create
		var p = {name: 'p'};
		var obj4 = Object.create(p);
	&lt;/script&gt;
</code></pre>
<h2 id="12-原型-构造函数-实例-原型链">1.2 原型、构造函数、实例、原型链</h2>
<p>构造函数、原型对象、实例的关系可以参照下图：<br>
<img src="https://Tyloo-code.github.io/post-images/1614923904668.png" alt="" loading="lazy"></p>
<p>构造函数.prototype.constructor === 构造函数<br>
M.prototype.constructor === M 的结果为 true</p>
<p>构造函数.prototype === 实例对象. proto<br>
M.prototype === obj3._ proto _ 的结果为 true</p>
<h2 id="13-instanceof-的原理">1.3 instanceof 的原理</h2>
<p>instanceof 的原理是判断<strong>实例对象的</strong> <strong>proto</strong> 是否与<strong>构造函数的prototype</strong>指向同一个引用。</p>
<h2 id="14-instanceof-和-typeof-的区别">1.4 instanceof 和 typeof 的区别</h2>
<p>typeof 对于基本数据类型（<code>null, undefined, string, number, boolean, symbol</code>），除了 null 都会返回正确的类型。null 会返回 object。</p>
<p>typeof 对于对象类型，除了函数会返回 function，其他的都返回 object。</p>
<h2 id="15-原型链">1.5 原型链</h2>
<p>JS中每个函数都存在有一个原型对象属性prototype。并且所有函数的默认原型都是Object的实例。每个继承父函数的子函数的对象都包含一个内部属性proto。该属性包含一个指针，指向父函数的prototype。若父函数的原型对象的_proto_属性为再上一层函数。在此过程中就形成了原型链。</p>
<p><code>原型链的作用是用来实现继承,比如我们新建一个数组,数组的方法就是从数组的原型上继承而来的</code>。</p>
<p>当访问对象a.b的时候，首先会查找当前对象的b属性，如果没有，然后依次按照prototype往上找直到找到Object.prototype为止，没有则返回undefined，所以说无处不在。<br>
<img src="https://Tyloo-code.github.io/post-images/1619259847019.png" alt="" loading="lazy"></p>
<p>js的想要调用公共类的方式就是继承原型。</p>
<p>比如原生的[].forEach()方法，之所以任意数组都能使用，是应为forEach()被定义在了数组的构造函数function Array(){}上，也就是数组的原型上；</p>
<h2 id="例子">例子</h2>
<pre><code>function F(){} var f = new F(); // 构造器 
F.prototype.constructor === F; // true 
F.__proto__ === Function.prototype; // true 
Function.prototype.__proto__ === Object.prototype; // true Object.prototype.__proto__ === null; // true // 实例
f.__proto__ === F.prototype; // true 
F.prototype.__proto__ === Object.prototype; // true Object.prototype.__proto__ === null;// true
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://Tyloo-code.github.io/post-images/1614925004509.png" alt="" loading="lazy"></figure>
<h1 id="2-有几种方式可以实现继承">2. 有几种方式可以实现继承</h1>
<p>ES5实现继承有6种方式：</p>
<ul>
<li>原型链继承</li>
<li>借用构造函数继承</li>
<li>组合继承</li>
<li>原型式继承</li>
<li>寄生式继承</li>
<li>寄生组合式继承</li>
</ul>
<p><strong>寄生组合式</strong>继承是大家公认的最好的实现引用类型继承的方法。</p>
<h2 id="1-原型链继承">1.  原型链继承</h2>
<p>原型链继承的基本思想是<strong>利用原型让一个引用类型继承另一个引用类型的属性和方法</strong>。</p>
<pre><code>
function SuperType() {
    this.name = 'Yvette';
    this.colors = ['pink', 'blue', 'green'];
}
SuperType.prototype.getName = function () {
    return this.name;
}
function SubType() {
    this.age = 22;
}
SubType.prototype = new SuperType();
SubType.prototype.getAge = function() {
    return this.age;
}
SubType.prototype.constructor = SubType;
let instance1 = new SubType();
instance1.colors.push('yellow');
console.log(instance1.getName()); //'Yvette'
console.log(instance1.colors);//[ 'pink', 'blue', 'green', 'yellow' ]
 
let instance2 = new SubType();
console.log(instance2.colors);//[ 'pink', 'blue', 'green', 'yellow' ]
</code></pre>
<p><strong>缺点：</strong></p>
<ol>
<li>通过原型来实现继承时，原型会变成另一个类型的实例，原先的实例属性变成了现在的原型属性，该原型的引用类型属性会被所有的实例共享。</li>
<li>在创建子类型的实例时，没有办法在不影响所有对象实例的情况下给超类型的构造函数中传递参数。</li>
</ol>
<h2 id="2-借用构造函数">2. 借用构造函数</h2>
<p><strong>借用构造函数</strong>的技术，其基本思想为: 在子类型的构造函数中调用超类型构造函数。</p>
<pre><code>function SuperType(name) {
    this.name = name;
    this.colors = ['pink', 'blue', 'green'];
}
function SubType(name) {
    SuperType.call(this, name);
}
let instance1 = new SubType('Yvette');
instance1.colors.push('yellow');
console.log(instance1.colors);//['pink', 'blue', 'green', yellow]
 
let instance2 = new SubType('Jack');
console.log(instance2.colors); //['pink', 'blue', 'green']
</code></pre>
<p><strong>优点:</strong></p>
<ol>
<li>可以向超类传递参数</li>
<li>解决了原型中包含引用类型值被所有实例共享的问题</li>
</ol>
<p><strong>缺点:</strong></p>
<ol>
<li>方法都在构造函数中定义，函数复用无从谈起，另外超类型原型中定义的方法对于子类型而言都是不可见的。</li>
</ol>
<h2 id="3-组合继承原型链-借用构造函数">3. 组合继承(原型链 + 借用构造函数)</h2>
<p>基本思路：使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承，既通过在原型上定义方法来实现了函数复用，又保证了每个实例都有自己的属性。</p>
<pre><code>function SuperType(name) {
    this.name = name;
    this.colors = ['pink', 'blue', 'green'];
}
SuperType.prototype.sayName = function () {
    console.log(this.name);
}
function SuberType(name, age) {
    SuperType.call(this, name);
    this.age = age;
}
SuberType.prototype = new SuperType();
SuberType.prototype.constructor = SuberType;
SuberType.prototype.sayAge = function () {
    console.log(this.age);
}
let instance1 = new SuberType('Yvette', 20);
instance1.colors.push('yellow');
console.log(instance1.colors); //[ 'pink', 'blue', 'green', 'yellow' ]
instance1.sayName(); //Yvette
 
let instance2 = new SuberType('Jack', 22);
console.log(instance2.colors); //[ 'pink', 'blue', 'green' ]
instance2.sayName();//Jack
</code></pre>
<p><strong>优点:</strong></p>
<ol>
<li>可以向超类传递参数</li>
<li>每个实例都有自己的属性</li>
<li>实现了函数复用</li>
</ol>
<p><strong>缺点:</strong><br>
无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。</p>
<h2 id="4-原型式继承">4. 原型式继承</h2>
<p>原型继承的基本思想：<br>
借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。</p>
<pre><code>
function object(o) {
    function F() { }
    F.prototype = o;
    return new F();
}
</code></pre>
<p>在 object() 函数内部，先创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例，从本质上讲，object() 对传入的对象执行了一次浅拷贝。</p>
<p>在没有必要创建构造函数，仅让一个对象与另一个对象保持相似的情况下，原型式继承是可以胜任的。</p>
<p><strong>缺点:</strong></p>
<ol>
<li>同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。</li>
</ol>
<h2 id="5-寄生式继承">5. 寄生式继承</h2>
<p>寄生式继承是与原型式继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部已某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</p>
<pre><code>
function createAnother(original) {
    var clone = object(original);//通过调用函数创建一个新对象
    clone.sayHi = function () {//以某种方式增强这个对象
        console.log('hi');
    };
    return clone;//返回这个对象
}
var person = {
    name: 'Yvette',
    hobbies: ['reading', 'photography']
};
 
var person2 = createAnother(person);
person2.sayHi(); //hi
</code></pre>
<p>基于 person 返回了一个新对象 -—— person2，新对象不仅具有 person 的所有属性和方法，而且还有自己的 sayHi() 方法。在考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。</p>
<p><strong>缺点：</strong></p>
<ol>
<li>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而效率低下。</li>
<li>同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。</li>
</ol>
<h2 id="6-寄生组合式继承">6. 寄生组合式继承</h2>
<p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法，<br>
<strong>基本思路：</strong><br>
不必为了指定子类型的原型而调用超类型的构造函数，我们需要的仅是超类型原型的一个副本，本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p>
<pre><code>function inheritPrototype(subType, superType) {
    var prototype = object(superType.prototype); //创建对象
    prototype.constructor = subType;//增强对象
    subType.prototype = prototype;//指定对象
}
</code></pre>
<ul>
<li>第一步：创建超类型原型的一个副本</li>
<li>第二步：为创建的副本添加 constructor 属性</li>
<li>第三步：将新创建的对象赋值给子类型的原型</li>
</ul>
<p>至此，我们就可以通过调用 inheritPrototype 来替换为子类型原型赋值的语句：</p>
<pre><code>
function SuperType(name) {
    this.name = name;
    this.colors = ['pink', 'blue', 'green'];
}
//...code
function SuberType(name, age) {
    SuperType.call(this, name);
    this.age = age;
}
SuberType.prototype = new SuperType();
inheritPrototype(SuberType, SuperType);
//...code
</code></pre>
<p><strong>优点:</strong></p>
<ol>
<li>只调用了一次超类构造函数，效率更高。避免在SuberType.prototype上面创建不必要的、多余的属性，与其同时，原型链还能保持不变。</li>
</ol>
<p>因此寄生组合继承是引用类型最理性的继承范式。</p>
<h2 id="7-es6继承">7 es6继承</h2>
<p>ES6新增class和extends语法，用来定义类和实现继承，底层也是采用了寄生组合式继承。</p>
<h1 id="3-用原型实现继承有什么缺点怎么解决">3. 用原型实现继承有什么缺点，怎么解决</h1>
<p><strong>原型继承</strong></p>
<pre><code>function Human(){
this.name=&quot;teacher&quot;;
this,age=39;
}
function Man(){
}
Man.prototype=new Human();
var m=new Man();
/*此时Man.name=teacher;Man.age=39；*/
</code></pre>
<p><strong>优点：</strong><br>
可以继承构造函数属性，也可继承原型属性</p>
<p><strong>缺点：</strong><br>
1，在创建子类实例化时，不能向超类型的构造函数中传参<br>
2，子类型继承了父类型原型中的所有属性和方法，但对于引用类型属性值所有实例共享，故不能在不改变其他实例情况下改变。</p>
<p><strong>解决方式</strong><br>
使用混合继承。</p>
<h1 id="4-arguments">4. arguments</h1>
<p>arguments 是一个<strong>类似数组</strong>的对象, 对应于传递给函数的<strong>参数</strong>。</p>
<p>arguments对象是所有函数中可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。</p>
<pre><code>arguments[0]
arguments[1]
arguments[2]
</code></pre>
<p>arguments对象不是一个 Array 。它类似于数组，但除了 长度之外没有任何数组属性。</p>
<p>可以使用 Array.from()方法或 spread 运算符将 arguments 转换为真正的数组：</p>
<pre><code>let args = Array.from(arguments);
let args = [...arguments];
</code></pre>
<p>如果你调用一个函数，当这个函数的参数数量比它显式声明的参数数量更多的时候，你就可以使用 arguments 对象。你可以用 arguments.length 来得到参数的数量，然后可以用 arguments object 来对每个参数进行处理。</p>
<ul>
<li>arguments.callee：指向当前执行的函数。</li>
<li>arguments.caller **：指向调用当前函数的函数。</li>
<li>arguments.length：指向传递给当前函数的参数数量。</li>
</ul>
<p><code>模拟函数重载</code></p>
<pre><code>function add(num1, num2, num3) {
if (arguments.length === 2) {
    console.log(&quot;Result is &quot; + (num1 + num2));
     }
else if (arguments.length === 3) {
    console.log(&quot;Result is &quot; + (num1 + num2 + num3));
     }
｝
</code></pre>
<p>add(1, 2);<br>
add(1, 2, 3)</p>
<p>执行结果如下：<br>
Result is 3<br>
Result is 6</p>
<h1 id="5-数据类型判断">5. 数据类型判断</h1>
<h2 id="50-null和undefined的区别">5.0 null和undefined的区别</h2>
<figure data-type="image" tabindex="2"><img src="https://Tyloo-code.github.io/post-images/1619269681622.png" alt="" loading="lazy"></figure>
<h2 id="51-javascript-数据类型">5.1 JavaScript 数据类型</h2>
<p>JavaScript 数据类型有两种，分别是基本数据类型和引用数据类型。</p>
<ul>
<li>
<p>基本数据类型<br>
Number<br>
String<br>
Boolean<br>
Undefined<br>
Null<br>
Symbol (ES6 新增，表示独一无二的值)</p>
</li>
<li>
<p>引用数据类型<br>
Object<br>
Function<br>
Array</p>
</li>
</ul>
<h2 id="52-检验数据类型">5.2 检验数据类型</h2>
<h3 id="521-typeof">5.2.1 typeof</h3>
<p>它返回一个表示数据类型的字符串，返回结果包括：</p>
<ul>
<li>number</li>
<li>boolean</li>
<li>string</li>
<li>symbol</li>
<li>object</li>
<li>undefined</li>
<li>function</li>
</ul>
<p><strong>缺点</strong>：<br>
除 function 以外的对象都会被识别成 object ，这样显然是不合理的，这时就需要 instanceof 来进行判断。</p>
<h3 id="522-instanceof">5.2.2 instanceof</h3>
<p><strong>instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</strong><br>
简单来说就是 instanceof 是用来判断 A 是否为 B 的实例，表达式为</p>
<pre><code>A  (object)  instanceof  B  (constructor)
</code></pre>
<p>如果A是B的实例，则返回true,否则返回 false。</p>
<p><strong>缺点</strong><br>
1.<strong>是否处于原型链上的判断方法不严谨</strong><br>
instanceof 方法判断的是是否处于原型链上，而不是是不是处于原型链最后一位</p>
<p>2.<strong>无法判断字面量方式创建的基本数据类型</strong></p>
<p>3.<strong>无法检测 null 和 undefined</strong></p>
<h3 id="523-objectprototypetostringcall">5.2.3 Object.prototype.toString.call()</h3>
<p>在 Number、String，Boolean，Array，RegExp、Date、Function 等对象上 toString() 方法都是被重写过了的，会按照一定的规则返回字符串。但是在 object 对象上，这个方式是返回当前方法执行的主体（方法中的this）所属类的详细信息即&quot;[object Object]&quot;,其中第一个object代表当前实例是对象数据类型的(这个是固定的 onject)，第二个Object代表的是this所属的类型。</p>
<p>为了每个对象都能通过 Object.prototype.toString() 来检测，需要以 Function.prototype.call() 或者 Function.prototype.apply() 的形式来调用，传递要检查的对象作为第一个参数，称为 thisArg。</p>
<pre><code>Object.prototype.toString.call('') ;   // [object String]
Object.prototype.toString.call(1) ;    // [object Number]
Object.prototype.toString.call(true) ; // [object Boolean]
Object.prototype.toString.call(undefined) ; // [object Undefined]
Object.prototype.toString.call(null) ; // [object Null]
Object.prototype.toString.call(new Function()) ; // [object Function]
Object.prototype.toString.call(new Date()) ; // [object Date]
Object.prototype.toString.call([]) ; // [object Array]
Object.prototype.toString.call(new RegExp()) ; // [object RegExp]
Object.prototype.toString.call(new Error()) ; // [object Error]
Object.prototype.toString.call(document) ; // [object HTMLDocument]
Object.prototype.toString.call(window) ; //[object global] window是全局对象global的引用
</code></pre>
<h1 id="6-作用域-作用域链和闭包的理解">6. 作用域、作用域链和闭包的理解</h1>
<h2 id="61-作用域">6.1 作用域</h2>
<p>变量的作用域无非就是两种：<strong>全局变量</strong>和<strong>局部变量</strong>。<br>
<code>全局作用域</code>：<br>
最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是可以访问的：</p>
<pre><code>&lt;script&gt;
      var outerVar = &quot;outer&quot;;
      function fn(){
         console.log(outerVar);
      }
      fn();//result:outer
   &lt;/script&gt;
</code></pre>
<p><code>局部作用域</code>：<br>
和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无法访问的，最常见的例如函数内部</p>
<pre><code>&lt;script&gt;
      function fn(){
         var innerVar = &quot;inner&quot;;
      }
      fn();
      console.log(innerVar);// ReferenceError: innerVar is not defined
&lt;/script&gt;
</code></pre>
<p><code>只要函数内定义了一个局部变量，函数在解析的时候都会将这个变量“提前声明”：</code></p>
<pre><code>&lt;script&gt;
      var scope = &quot;global&quot;;
      function fn(){
         var scope;//提前声明了局部变量
         console.log(scope);//result:undefined
         scope = &quot;local&quot;;
         console.log(scope);//result:local;
      }
      fn();
   &lt;/script&gt;
</code></pre>
<h2 id="62-作用域链scope-chain">6.2 作用域链（Scope Chain）</h2>
<p>作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。</p>
<h3 id="621-执行环境execution-context">6.2.1 执行环境（execution context）</h3>
<p><strong>js为每一个执行环境关联了一个变量对象。环境中定义的所有变量和函数都保存在这个对象中。</strong></p>
<p>全局执行环境是最外围的执行环境，全局执行环境被认为是window对象，因此所有的全局变量和函数都作为window对象的属性和方法创建的。</p>
<pre><code> &lt;script&gt;
      var scope = &quot;global&quot;; 
      function fn1(){
         return scope; 
      }
      function fn2(){
         return scope;
      }
      fn1();
      fn2();
   &lt;/script&gt;
</code></pre>
<p>上面代码执行情况演示：<br>
<img src="https://Tyloo-code.github.io/post-images/1614938134873.jpg" alt="" loading="lazy"></p>
<h3 id="622-作用域链">6.2.2 作用域链</h3>
<pre><code>
name=&quot;lwy&quot;;
function t(){
    var name=&quot;tlwy&quot;;
    function s(){
        var name=&quot;slwy&quot;;
        console.log(name);
    }
    function ss(){
        console.log(name);
    }
    s();
    ss();
}
t();
</code></pre>
<p>当执行s时，将创建函数s的执行环境(调用对象),并将该对象置于链表开头，然后将函数t的调用对象链接在之后，最后是全局对象。然后从链表开头寻找变量name,很明显name是&quot;slwy&quot;。</p>
<p>但执行ss()时，作用域链是： ss()-&gt;t()-&gt;window,所以name是”tlwy&quot;</p>
<h2 id="63-闭包">6.3 闭包</h2>
<figure data-type="image" tabindex="3"><img src="https://Tyloo-code.github.io/post-images/1614941970240.png" alt="" loading="lazy"></figure>
<h3 id="1-闭包的定义">1. 闭包的定义</h3>
<p>一个函数对其周围状态(变量)的<strong>引用</strong>并<strong>保存</strong>周围变量，乃至函数执行完成后仍然可以访问的现象称之为闭包。</p>
<h3 id="2-闭包的原理">2. 闭包的原理</h3>
<p>闭包的实现原理，其实是利用了作用域链的特性，我们都知道作用域链就是在当前执行环境下访问某个变量时，如果不存在就一直向外层寻找，最终寻找到最外层也就是全局作用域，这样就形成了一个链条。</p>
<h3 id="3-闭包的特点">3. 闭包的特点</h3>
<ol>
<li>函数嵌套函数。</li>
<li>函数内部可以引用外部的参数和变量。</li>
<li>参数和变量不会被垃圾回收机制回收。</li>
</ol>
<h3 id="4-闭包的优缺点">4. 闭包的优缺点</h3>
<p><strong>优点</strong>：</p>
<ul>
<li>希望一个变量长期存储在内存中。</li>
<li>避免全局变量的污染。</li>
<li>私有成员的存在。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>导致变量不会被垃圾回收机制回收，造成内存消耗</li>
<li>不恰当的使用闭包可能会造成内存泄漏的问题</li>
</ul>
<h3 id="5-闭包的作用">5. 闭包的作用</h3>
<p>闭包有两个<code>作用</code>：</p>
<ul>
<li>第一个就是读取及操作外部函数的私有变量（沿着作用域链寻找）</li>
<li>第二个就是让这些外部变量始终保存在内存中</li>
</ul>
<pre><code>&lt;script&gt;
      function outer(){
         var result = new Array();
         for(var i = 0; i &lt; 2; i++){//注：i是outer()的局部变量
            result[i] = function(){
               return i;
            }
         }
         return result;//返回一个函数对象数组
         //这个时候会初始化result.length个关于内部函数的作用域链
      }
      var fn = outer();
      console.log(fn[0]());//result：2
      console.log(fn[1]());//result：2
   &lt;/script&gt;
</code></pre>
<p><strong>js函数内的变量值不是在编译的时候就确定的，而是等在运行时期再去寻找的。</strong></p>
<p>闭包让外部访问函数内部的变量成为可能（私有属性），因为被引用的数据常驻内存，可能会造成内存泄露（一块内存长期被变量占据而不进行释放），闭包可以让你在一个内层函数中访问到其外层函数的作用域的状态并保存，在js中每当创建一个函数，闭包环境就在函数创建时产生，闭包环境相互独立，如果闭包环境引用外部函数作用域的一个变量a，即使当外部函数作用域的变量被销毁释放内存，但变量a不会被删除。</p>
<pre><code> function outer(){
         var result = new Array();
         for(var i = 0; i &lt; 2; i++){
            //定义一个带参函数
            result[i] = function(num){
               function innerarg(){
                  return num;
               }
               return innerarg;
            }(i);//预先执行函数写法
            //把i当成参数传进去
         }
         return result;
      }
</code></pre>
<h3 id="6-闭包变量回收">6. 闭包变量回收</h3>
<p>当闭包函数无外链引用时，闭包函数被垃圾回收机制标记，<code>闭包自身呗回收，里边的变量自然就一起被回收了</code></p>
<h1 id="7-ajax的原生写法">7. Ajax的原生写法</h1>
<h2 id="71-ajax-是什么">7.1 Ajax 是什么？</h2>
<ul>
<li>全称Asynchronous JavaScript and XML；</li>
<li>异步的 JavaScript 和 XML；</li>
<li>可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页内容；</li>
<li>能够实现局部刷新，大大降低了资源的浪费；</li>
<li>不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行；</li>
</ul>
<h2 id="72-ajax的使用">7.2 Ajax的使用</h2>
<p>Ajax的使用分为四部分：<br>
1.） 创建一个XMLHttpRequest对象；</p>
<p>2.） 配置请求信息；</p>
<ul>
<li>请求的方式；</li>
<li>请求文件的路径；</li>
<li>是否异步，默认为true；</li>
</ul>
<p>3.）发送请求；</p>
<ul>
<li>get与post的区别；</li>
<li>get与post的使用场景；</li>
</ul>
<p>4.） 监听状态变化，执行相应回调函数；</p>
<ul>
<li>http状态码都有哪些？</li>
<li>不同状态码代表的含义？</li>
</ul>
<h3 id="721-创建xmlhttprequest对象">7.2.1 创建XMLHttpRequest对象</h3>
<p><code>var xhr = new XMLHttpRequest()</code>;</p>
<h3 id="722-连接服务器">7.2.2 连接服务器</h3>
<p>使用 XMLHttpRequest 对象的open() 方法：</p>
<h3 id="723-向服务器发送请求">7.2.3 向服务器发送请求</h3>
<p>使用 XMLHttpRequest 对象的send() 方法：<br>
<img src="https://Tyloo-code.github.io/post-images/1614951772130.png" alt="" loading="lazy"></p>
<h3 id="724-监听事件变化">7.2.4 监听事件变化</h3>
<ul>
<li>如果是同步请求的话，不需要写监听事件变化函数；</li>
<li>一般默认都是异步请求，才写监听函数；</li>
</ul>
<p>存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。</p>
<ul>
<li>0: 请求未初始化</li>
<li>1: 服务器连接已建立</li>
<li>2: 请求已接收</li>
<li>3: 请求处理中</li>
<li>4: 请求已完成，且响应已就绪</li>
</ul>
<h2 id="73-ajax原生写法">7.3 Ajax原生写法</h2>
<h3 id="731-get请求">7.3.1 Get请求</h3>
<pre><code>const xhr = new XMLHttpRequest()
        xhr.open(&quot;GET&quot;, &quot;http://localhost:3000/users?id=1&quot;)
        xhr.send(null)

        xhr.onreadystatechange = function () {
            if (this.readyState === 4) {
                console.log(this.responseText);
            }
        }
</code></pre>
<h3 id="732-post请求">7.3.2 Post请求</h3>
<pre><code>const xhr = new XMLHttpRequest()
        xhr.open(&quot;POST&quot;, &quot;http://localhost:3000/users&quot;)
        xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)
        // 转换为json传递
        xhr.send(JSON.stringify({
            &quot;name&quot;: &quot;luke&quot;,
            &quot;age&quot; : 19,
            &quot;class&quot;: 2
        }))

        xhr.onreadystatechange = function () {
            if (this.readyState === 4) {
                console.log(this.responseText);
            }
        }
</code></pre>
<h1 id="8-对象深拷贝-浅拷贝">8. 对象深拷贝、浅拷贝</h1>
<pre><code>let a = {
    age: 1
}
let b = a
a.age = 2
console.log(b.age) // 2
</code></pre>
<p>从上述例子中我们可以发现，如果给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。</p>
<blockquote>
<p>如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。</p>
</blockquote>
<ol>
<li><code>如果是基本数据类型，名字和值都会储存在栈内存中</code></li>
<li><code>如果是引用数据类型，名字存在栈内存中，值存在堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值</code></li>
</ol>
<h2 id="81-浅拷贝">8.1 浅拷贝</h2>
<p><img src="https://Tyloo-code.github.io/post-images/1617331269019.png" alt="" loading="lazy"><br>
首先可以通过 <code>Object.assign</code> 来解决这个问题。</p>
<pre><code>let a = {
    age: 1
}
let b = Object.assign({}, a)
a.age = 2
console.log(b.age) // 1
</code></pre>
<p>当然我们也可以通过展开运算符<code>（…）</code>来解决</p>
<pre><code>let a = {
    age: 1
}
let b = {...a}
a.age = 2
console.log(b.age) // 1
</code></pre>
<p>通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就需要使用到深拷贝了</p>
<pre><code>let a = {
    age: 1,
    jobs: {
        first: 'FE'
    }
}
let b = {...a}
a.jobs.first = 'native'
console.log(b.jobs.first) // native
</code></pre>
<p>浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到刚开始的话题了，两者享有相同的引用。要解决这个问题，我们需要引入深拷贝。</p>
<h2 id="82-深拷贝">8.2 深拷贝</h2>
<p><img src="https://Tyloo-code.github.io/post-images/1617331301932.png" alt="" loading="lazy"><br>
这个问题通常可以通过 <code>JSON.parse(JSON.stringify(object))</code> 来解决。</p>
<pre><code>let a = {
    age: 1,
    jobs: {
        first: 'FE'
    }
}
let b = JSON.parse(JSON.stringify(a))
a.jobs.first = 'native'
console.log(b.jobs.first) // FE
</code></pre>
<p>但是该方法也是有局限性的：</p>
<ul>
<li>会忽略 undefined</li>
<li>会忽略 symbol</li>
<li>不能序列化函数</li>
<li>不能解决循环引用的对象</li>
</ul>
<h1 id="9-图片懒加载-预加载">9. 图片懒加载、预加载</h1>
<h2 id="91-懒加载">9.1 懒加载</h2>
<h3 id="911-什么是懒加载">9.1.1 什么是懒加载</h3>
<p><strong>懒加载又称延迟加载</strong>。当访问一个页面的时候，需要先把img元素或者其他元素的背景图先用一张默认的图片代替（占位图），这样浏览器渲染页面的时候就只需请求一次。当图片出现在浏览器可视区域的时候，才设置图片的真实路径，把图片显示出来。</p>
<h3 id="912-为什么要使用图片懒加载">9.1.2 为什么要使用图片懒加载？</h3>
<p>当页面中图片的数量多到一定数量的时候，并且图片大小比较大，比如各种商场网站，图片素材网等等。如果在页面一加载的时候就加载全部图片，显然会影响网站加载速度和加大服务器负担，而且用户体验也必然不好，那么这时候可以采用懒加载。</p>
<h3 id="913-懒加载具体实现原理">9.1.3 懒加载具体实现原理</h3>
<p>页面中的img元素之所以会发送http请求的原因是设置了src属性，否则浏览器就不会发送请求去下载这个图片。<br>
首先在页面中把所有的图片用一张占位图进行占位，并且在元素下设置data-src自定义属性，存放图片的真实路径，当需要用到的时候取出该真实路径动态添加给src。</p>
<p><code>懒加载具体实现方式</code>：</p>
<ul>
<li>
<p>1.第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟.</p>
</li>
<li>
<p>2.第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。</p>
</li>
<li>
<p>3.第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离便开始加载，这样能保证用户拉下时正好能看到图片。</p>
</li>
</ul>
<h2 id="92-预加载">9.2 预加载</h2>
<h3 id="921-什么是预加载">9.2.1 什么是预加载</h3>
<p>预加载就是提前加载图片，当用户需要查看时可直接从本地缓存中渲染。</p>
<h3 id="922-为什么要使用图片预加载">9.2.2 为什么要使用图片预加载？</h3>
<p>当页面中图片比较大的时候，页面加载的时候会出现该区域空白的效果或者看到图片正在慢慢地加载出来，为了提高用户体验，需要把这些图片提前加载到缓存中，当用户一打开页面的时候，这些图片就会快速的呈现出来，获得更好的用户体验效果。</p>
<h3 id="923-实现方式有哪些">9.2.3 实现方式有哪些？</h3>
<p>方法1：使用css和JavaScript实现预加载<br>
方法2：只使用JavaScript实现预加载<br>
方法3：使用ajax实现预加载</p>
<p>常用的是<code>new Image()</code>;设置其src来实现预载，再使用onload方法回调预载完成事件。只要浏览器把图片下载到本地，同样的src就会使用缓存，这是最基本也是最实用的预载方法。当Image下载完图片头后，会得到宽和高，因此可以在预载前得到图片的大小(方法是用记时器轮循宽高变化。)</p>
<h1 id="10-实现页面加载进度条">10. 实现页面加载进度条</h1>
<figure data-type="image" tabindex="4"><img src="https://Tyloo-code.github.io/post-images/1615011309891.gif" alt="" loading="lazy"></figure>
<h2 id="101-html结构">10.1 html结构：</h2>
<pre><code> &lt;div id=&quot;progressBox&quot;&gt;
        &lt;div id=&quot;progressBar&quot;&gt;0%&lt;/div&gt;
        &lt;!-- 设定第二个层以便当进度超过文字的时候，修改文字的颜色 --&gt;
        &lt;div id=&quot;progressText&quot;&gt;0%&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h2 id="102-css结构">10.2 CSS结构：</h2>
<pre><code>&lt;style&gt;
        #progressBox {
            width: 300px;
            height: 40px;
            border: 1px solid #C8C8C8;
            background: white;
            position: relative;
            margin: 0 auto;
            margin-top: 100px;
        }
 
        #progressBar {
            position: absolute;
            left: 0;
            top: 0;
            z-index: 2;
            height: 40px;
            width: 100%;
            line-height: 40px;
            color: white;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            font-family: Georgia;
            clip: rect(0px, 0, 40px, 0px);
            background: #00A1F5;
        }
 
        #progressText {
            position: absolute;
            left: 0;
            top: 0;
            z-index: 1;
            width: 100%;
            height: 40px;
            line-height: 40px;
            color: black;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            font-family: Georgia;
        }
    &lt;/style&gt;
</code></pre>
<h2 id="103-javascript-部分">10.3 JavaScript 部分</h2>
<pre><code>&lt;script&gt;
        window.onload = function () {
            // 设定当前起始状态值,
            // 真实情况中用html5的onprogress和onload来完成
            // 还可以跟后台配合，通过ajax实时的返回数据
            var iNow = 0;
            // 设定定时器
            var timer = setInterval(function () {
                // 如果当前的值为100
                if (iNow == 100) {
                    // 清除定时器
                    clearInterval(timer);
                }else {
                    // 将当前状态值累加1
                    iNow += 1;
                    // 调用执行状态的函数,传入状态值
                    progressFn(iNow);
                }
 
            }, 30);
 
 
            function progressFn(cent) {
                // 获取最外层的div
                var oDiv1 = document.getElementById('progressBox');
                // 获取内层进度条的div
                var oDiv2 = document.getElementById('progressBar');
                // 获取内层文字发生变化时的div
                var oDiv3 = document.getElementById('progressText');
 
                // 获取总进度条的宽度
                var allWidth = parseInt(getStyle(oDiv1, 'width'));
 
                // 设定内层两个div的文字内容一样
                oDiv2.innerHTML = cent + '%';
                oDiv3.innerHTML = cent + '%';
 
                // 修改clip的的宽度值
                oDiv2.style.clip = 'rect(0px, ' + cent / 100 * allWidth + 'px, 40px, 0px)';
 
                // 获取当前元素的属性值
                function getStyle(obj, attr) {
                    // 兼容IE
                    if (obj.currentStyle) {
                        return obj.currentStyle[attr];
                    }else {
                        // 第二个参数为false是通用的写法，目的是为了兼容老版本
                        return getComputedStyle(obj, false)[attr];
                    }
                }
            }
        };
    &lt;/script&gt;
</code></pre>
<h1 id="11-this关键字">11. this关键字</h1>
<p>首先我们需要得出一个非常重要一定要牢记于心的结论，<code>this的指向，是在函数被调用的时候确定的</code>。也就是执行上下文被创建时确定的。因此，一个函数中的this指向，可以是非常灵活的。比如下面的例子中，同一个函数由于调用方式的不同，this指向了不一样的对象。</p>
<pre><code>var a = 10;
var obj = {
    a: 20
}
function fn () {
    console.log(this.a);
}
fn(); // 10
fn.call(obj); // 20
</code></pre>
<p>除此之外，<code>在函数执行过程中，this一旦被确定，就不可更改了。</code></p>
<ul>
<li>
<p>情况1：如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window，这里需要说明的是在js的严格版中this指向的不是window，但是我们这里不探讨严格版的问题，你想了解可以自行上网查找。</p>
</li>
<li>
<p>情况2：如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。</p>
</li>
<li>
<p>情况3：如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象，</p>
</li>
</ul>
<h2 id="111-全局对象中的this">11.1 全局对象中的this</h2>
<p>关于全局对象的this，我之前在总结变量对象的时候提到过，它是一个比较特殊的存在。全局环境中的this，指向它本身。</p>
<h2 id="112-函数中的this">11.2 函数中的this</h2>
<p>在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。<strong>如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined</strong>。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。</p>
<pre><code>var a = 20;
var foo = {
    a: 10,
    getA: function () {
        return this.a;
    }
}
console.log(foo.getA()); // 10

var test = foo.getA;
console.log(test());  // 20
</code></pre>
<p><code>foo.getA()</code>中，getA是调用者，他不是独立调用，被对象foo所拥有，因此它的this指向了foo。而<code>test()</code>作为调用者，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined，在非严格模式，自动转向全局window。</p>
<h2 id="113-使用callapply显示指定this">11.3 使用call，apply显示指定this</h2>
<p>JavaScript内部提供了一种机制，让我们可以自行手动设置this的指向。它们就是call与apply。所有的函数都具有着两个方法。它们除了参数略有不同，其功能完全一样。它们的第一个参数都为this将要指向的对象。</p>
<p>而call与applay后面的参数，都是向将要执行的函数传递参数。其中call以一个一个的形式传递，apply以数组的形式传递。这是他们唯一的不同。</p>
<pre><code>function fn(num1, num2) {
    console.log(this.a + num1 + num2);
}
var obj = {
    a: 20
}

fn.call(obj, 100, 10); // 130
fn.apply(obj, [20, 10]); // 50
</code></pre>
<h2 id="114-构造函数与原型方法上的this">11.4 构造函数与原型方法上的this</h2>
<p>通过new操作符调用构造函数，会经历以下4个阶段。</p>
<ul>
<li>创建一个新的对象；</li>
<li>将构造函数的this指向这个新对象；</li>
<li>指向构造函数的代码，为这个对象添加属性，方法等；</li>
<li>返回新对象。</li>
</ul>
<pre><code>function Person(name, age) {

    // 这里的this指向了谁?
    this.name = name;
    this.age = age;   
}

Person.prototype.getName = function() {

    // 这里的this又指向了谁？
    return this.name;
}

// 上面的2个this，是同一个吗，他们是否指向了原型对象？

var p1 = new Person('Nick', 20);
p1.getName();
</code></pre>
<p>因此，当new操作符调用构造函数时，this其实指向的是这个新创建的对象，最后又将新的对象返回出来，被实例对象p1接收。因此，我们可以说，这个时候，构造函数的this，指向了新的实例对象，p1。</p>
<h1 id="12-函数式编程">12. 函数式编程</h1>
<p>函数式编程是一种编程范式，是一种构建计算机程序结构和元素的风格，它把计算看作是对数学函数的评估，<strong>避免了状态的变化和数据的可变</strong>。</p>
<p><strong>纯函数</strong>：</p>
<ul>
<li>如果给定相同的参数，则返回相同的结果(也称为确定性)。</li>
<li>它不会引起任何副作用。</li>
</ul>
<p><strong>特点</strong></p>
<ol>
<li>函数是一等公民</li>
<li>只用表达式不用语句</li>
<li>没有副作用(side effect)</li>
<li>不修改状态</li>
<li>引用透明</li>
</ol>
<p><strong>优势</strong></p>
<ol>
<li>代码简洁，开发快速</li>
<li>接近自然语言，易于理解</li>
<li>更方便的代码管理</li>
<li>易于&quot;并发编程&quot;</li>
<li>代码的热升级</li>
</ol>
<h1 id="13-手动实现parseint">13. 手动实现parseInt</h1>
<p>主要用到的ES5中的<code>map</code>函数和<code>reduce</code>函数，还有利用了javascript是弱类型转换的特点</p>
<pre><code>function str2num(str) {
  var strArr = str.split('')
  var strArrNum = strArr.map(function (str) {
    return +str
  })
  var num = strArrNum.reduce(function (x, y) {
    return x * 10 + y
  })
  return num
}
str2num('123')
</code></pre>
<h1 id="14-为什么会有同源策略">14. 为什么会有同源策略</h1>
<h2 id="141-什么是同源策略">14.1 什么是同源策略</h2>
<p>两个页面地址中的协议，域名，端口号一致，则表示同源</p>
<h2 id="142-为什么浏览器要使用同源策略">14.2 为什么浏览器要使用同源策略</h2>
<p>设置同源策略的主要目的是为了安全，如果没有同源限制，在浏览器中的cookie等其他数据可以任意读取，不同域下的DOM任意操作，ajax任意请求其他网站的数据，包括隐私数据。</p>
<h1 id="15-怎么判断两个对象是否相等">15. 怎么判断两个对象是否相等</h1>
<p>方法一：通过<code>JSON.stringify(obj)</code>来判断两个对象转后的字符串是否相等</p>
<ul>
<li>优点：用法简单，对于顺序相同的两个对象可以快速进行比较得到结果</li>
<li>缺点：这种方法有限制就是当两个对比的对象中key的顺序不是完全相同时会比较出错</li>
</ul>
<p>方法二：<code>getOwnPropertyNames</code>该方法可以将Object对象的第一层key获取到并返回一个由第一层key组成的数组。</p>
<ul>
<li>优点：相对方法一进行了优化，可以应对不同顺序的Object进行比较，不用担心顺序不同而对比出错</li>
<li>缺点：从方法中可以看到只能获取到第一层的key组成的数组，当对象是复合对象时无法进行多层对象的比较</li>
</ul>
<pre><code>// 对Object扩展一个方法chargeObjectEqual
Object.prototype.chargeObjectEqual = function(obj){
    // 当前Object对象
    var propsCurr = Object.getOwnPropertyNames(this);
    // 要比较的另外一个Object对象
    var propsCompare = Object.getOwnPropertyNames(obj);
    if (propsCurr.length != propsCompare.length) {
        return false;
    }
    for (var i = 0,max = propsCurr.length; i &lt; max; i++) {
        var propName = propsCurr[i];
        if (this[propName] !== obj[propName]) {
            return false;
        }
    }
    return true;
}
</code></pre>
<h1 id="16-事件模型">16. 事件模型</h1>
<h2 id="1基本概念">1.基本概念</h2>
<p><strong>事件代理</strong>（Event Delegation），又称之为事件委托。是JavaScript中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定在子元素的响应事件（click、keydown......）委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。</p>
<h2 id="2-事件传播">2. 事件传播</h2>
<p>一个事件触发后，会在子元素和父元素之间<strong>传播</strong>（propagation）。这种传播分成三个阶段<br>
<img src="https://Tyloo-code.github.io/post-images/1615169023216.jpg" alt="" loading="lazy"><br>
如上图所示，事件传播分成三个阶段：</p>
<ul>
<li>捕获阶段：从window对象传导到目标节点（上层传到底层）称为“捕获阶段”（capture phase），捕获阶段不会响应任何事件；</li>
<li>目标阶段：在目标节点上触发，称为“目标阶段”</li>
<li>冒泡阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。<strong>事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层</strong>；</li>
</ul>
<h2 id="3-事件冒泡和捕获">3. 事件冒泡和捕获</h2>
<p><code>冒泡</code></p>
<ul>
<li><strong>就是从事件 目标 的事件处理函数开始，依次向外，直到 window 的事件处理函数触发（先执行目标元素事件，再依次执行父元素事件）</strong></li>
</ul>
<p><code>捕获</code></p>
<ul>
<li><strong>就是从 window 的事件处理函数开始，依次向内，直到事件 目标 的事件处理函数执行（最后才执行目标元素）</strong><br>
<img src="https://Tyloo-code.github.io/post-images/1619616013812.jpg" alt="" loading="lazy"></li>
</ul>
<p><code>阻止事件传播</code></p>
<ul>
<li>如果想只触发当前点击对象的事件，不想让外层的事件触发 ，可以使用不冒泡<strong>e.cancelBubble=true</strong>或不传播 <strong>e.stopPropagation()</strong></li>
</ul>
<pre><code>var box = document.querySelector('.box')
    var atr = document.querySelector('.atr')
    box.onclick = function (e) {
        e.stopPropagation() // 不传播
        console.log('我被点击了box')
    }
    atr.onclick = function (e) {
        e.cancelBubble=true //不冒泡
        console.log('我被点击了atr')
    }
</code></pre>
<h2 id="4-事件委托">4. 事件委托</h2>
<ul>
<li>因为我们的冒泡机制，点击子元素的时候，也会同步触发父元素的相同事件 ，所以我们就可以把子元素的事件委托给父元素来做</li>
<li><strong>点击子元素的时候，不管子元素有没有点击事件，只要父元素有点击事件，那么就可以触发父元素的点击事件</strong></li>
</ul>
<pre><code> atr.onclick = function (e) {
        // e.stopPropagation()
        var e = e || window.event //event兼容写法
        var target = e.target || e.srcElement //target兼容写法
        console.log(target,'执行子盒子的点击事件')
    }
box.onclick = function (e) {
        var e = e || window.event //event兼容写法
        var target = e.target || e.srcElement //target兼容写法
        console.log(target,'执行父盒子的点击事件')
    }
</code></pre>
<p><code>target</code></p>
<ul>
<li>target 这个属性是事件对象里面的属性，表示你点击的目标</li>
<li>当你触发点击事件的时候，你点击在哪个元素上，target 就是哪个元素</li>
<li>这个 target 也不兼容，在 IE 下要使用 srcElement</li>
</ul>
<p><code>委托</code></p>
<ul>
<li>这个时候，当我们点击 box里面的元素的时候，也可以触发 box 的点事件</li>
<li>并且在事件内部，我们也可以拿到你点击的到底是哪个对象</li>
<li>这个时候，我们就可以把 li 的事件委托给 box 父级来做</li>
</ul>
<pre><code>var box = document.querySelector('.box')
    var atr = document.querySelector('.atr')
    
    atr.onclick = function (e) {
        var e = e || window.event //event兼容写法
        var target = e.target || e.srcElement //target兼容写法
        if(target.className=='atr'){
            //这里面就找到需要操作的元素
            console.log(111)
        }
    }
</code></pre>
<h2 id="5-事件委托的优点">5. 事件委托的优点</h2>
<p><strong>【1】可以大量节省内存占用，减少事件注册，比如在ul上代理所有li的click事件就非常棒</strong></p>
<p><strong>【2】可以实现当新增子对象时无需再次对其绑定（动态绑定事件）</strong></p>
<h2 id="6-事件的默认行为">6. 事件的默认行为</h2>
<p><strong>默认行为，就是不用我们注册，它自己就存在的事情</strong></p>
<ul>
<li>比如我们点击鼠标右键的时候，会自动弹出一个菜单</li>
<li>比如我们点击 a 标签的时候，我们不需要注册点击事件，他自己就会跳转页面</li>
</ul>
<p><strong>这些不需要我们注册就能实现的事情，我们叫做默认事件</strong></p>
<p><code>阻止默认行为</code><br>
<img src="https://Tyloo-code.github.io/post-images/1619617595767.png" alt="" loading="lazy"></p>
<pre><code>var oA = document.querySelector('a')
    a.addEventListener('click', function (e) {
        e = e || window.event
        console.log(this.href)
        //下面这个是兼容写法
        e.preventDefault ? e.preventDefault() : e.returnValue = false
    })
</code></pre>
<h2 id="7-如何让事件先冒泡后捕获">7. 如何让事件先冒泡后捕获</h2>
<p>若要实现先冒泡后捕获，给一个元素绑定两个addEventListener，其中一个第三个参数设置为false（即冒泡），另一个第三个参数设置为true（即捕获），调整它们的代码顺序，将设置为false的监听事件放在设置为true的监听事件前面即可。</p>
<h1 id="17-dom基本操作获取元素-节点的创建和添加-节点的替换和删除">17. DOM基本操作（获取元素、节点的创建和添加、节点的替换和删除）</h1>
<h2 id="1-获取元素">1. 获取元素</h2>
<p><code>document.getElementById</code>通过id名字获取节点</p>
<pre><code> &lt;div id=&quot;box&quot;&gt;
        &lt;ul&gt;
            &lt;li&gt;1&lt;/li&gt;
            &lt;li&gt;2&lt;/li&gt;
            &lt;li&gt;3&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
</code></pre>
<pre><code>var oBox = document.getElementById(&quot;box&quot;);
</code></pre>
<p><code>document.getElementsByClassName</code>通过class名字获取节点 获取的是一个数组</p>
<pre><code>&lt;div class=&quot;box&quot;&gt;
        &lt;ul&gt;
            &lt;li&gt;1&lt;/li&gt;
            &lt;li&gt;2&lt;/li&gt;
            &lt;li&gt;3&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
</code></pre>
<pre><code>var oBox = document.getElementsByClassName(&quot;box&quot;);
</code></pre>
<p>在HTML与CSS里.class类名是<code>可以重复</code>使用的，在页面上可能出现多个重复的.class类名，他是获取到多个把获取到多个放在数组里</p>
<pre><code>var oBox = document.getElementsByClassName(&quot;box&quot;)[0]
 //通过下标来换取索引0的值也可以获取别的索引值
</code></pre>
<p><code>document.getElementsByTagName</code> 通过标签名字获取节点 获取的是一个数组</p>
<pre><code>&lt;div class=&quot;box&quot;&gt;
        &lt;ul&gt;
            &lt;li&gt;1&lt;/li&gt;
            &lt;li&gt;2&lt;/li&gt;
            &lt;li&gt;3&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
    &lt;div&gt;&lt;/div&gt;
</code></pre>
<pre><code>var aBox = document.getElementsByTagName(&quot;div&quot;);
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://Tyloo-code.github.io/post-images/1618115504124.png" alt="" loading="lazy"></figure>
<blockquote>
<p>那么如何获取数组里面的值呢？？？</p>
</blockquote>
<pre><code>var aBox = document.getElementsByTagName(&quot;div&quot;)[2];//通过下标来换取索引2的值
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://Tyloo-code.github.io/post-images/1618115545753.png" alt="" loading="lazy"></figure>
<p><code>document.querySelectorAll</code> 通过复合（层级）选择器获取节点 获取的是一个数组</p>
<pre><code> &lt;div class=&quot;box&quot;&gt;
        &lt;ul&gt;
            &lt;li&gt;1&lt;/li&gt;
            &lt;li&gt;2&lt;/li&gt;
            &lt;li&gt;3&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
</code></pre>
<pre><code> var  aLi = document.querySelectorAll(&quot;.box ul li&quot;);
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://Tyloo-code.github.io/post-images/1618115797303.png" alt="" loading="lazy"></figure>
<blockquote>
<p>那么如何获取数组里面的值呢？？？</p>
</blockquote>
<pre><code>var aLi  = document.querySelectorAll(&quot;.box ul li&quot;)[1];
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://Tyloo-code.github.io/post-images/1618115827067.png" alt="" loading="lazy"></figure>
<p><code>document.querySelector</code> 通过复合（层级）选择器获取符合条件的第一个节点</p>
<pre><code>var oLi = document.querySelector(&quot;.box ul li&quot;);
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://Tyloo-code.github.io/post-images/1618115873612.png" alt="" loading="lazy"></figure>
<p><code>document.getElementsByName</code> 通过name属性获取节点 获取的是一个数组</p>
<pre><code>&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男
&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女
</code></pre>
<pre><code>var aInput = document.getElementsByName(&quot;sex&quot;);
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://Tyloo-code.github.io/post-images/1618116016375.png" alt="" loading="lazy"></figure>
<p><strong>获取特殊元素的方式</strong></p>
<ul>
<li><code>document.head</code> 获取<code>head</code>标签</li>
<li><code>document.body</code> 获取<code>body</code>标签</li>
<li><code>document.documentElement</code> 获取<code>html</code>标签<br>
<img src="https://Tyloo-code.github.io/post-images/1618116077529.png" alt="" loading="lazy"></li>
</ul>
<h2 id="2-节点的创建和添加创建完一定要添加">2. 节点的创建和添加（创建完一定要添加）</h2>
<h3 id="1-节点的创建">1. 节点的创建</h3>
<p><code>document.createElement</code> 创建元素节点</p>
<pre><code> var oDiv = document.createElement(&quot;div&quot;);
</code></pre>
<p><strong>如何把这个属性节点添加到DOM树中?</strong></p>
<pre><code>&lt;div id=&quot;box&quot;&gt;
        &lt;span&gt;我是haven&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<pre><code>var oBox = document.getElementById(&quot;box&quot;);
var oDiv = document.createElement(&quot;div&quot;);
oBox.appendChild(oDiv); 
</code></pre>
<figure data-type="image" tabindex="11"><img src="https://Tyloo-code.github.io/post-images/1618116529080.png" alt="" loading="lazy"></figure>
<p><code>document.createTextNode</code>创建文本节点</p>
<pre><code>var oText = document.createTextNode(&quot;heaven&quot;)
</code></pre>
<p><strong>如何把这个文本节点添加到DOM树中?</strong></p>
<pre><code>&lt;div id=&quot;box&quot;&gt;
    &lt;span&gt;我是haven&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<pre><code>var oBox = document.getElementById(&quot;box&quot;);
var oText = document.createTextNode(&quot;heaven&quot;);
oBox.appendChild(oText);
</code></pre>
<figure data-type="image" tabindex="12"><img src="https://Tyloo-code.github.io/post-images/1618116715791.png" alt="" loading="lazy"></figure>
<p><code>document.createComment</code> 创建注释节点</p>
<pre><code>var oComment = document.createComment(&quot;我是注释节点&quot;);
</code></pre>
<p><strong>如何把这个注释节点添加到DOM树中?</strong></p>
<pre><code>&lt;div id=&quot;box&quot;&gt;
    &lt;span&gt;我是haven&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<pre><code>var obox = document.getElementById(&quot;box&quot;);
var oComment = document.createComment(&quot;我是注释节点&quot;);
obox.appendChild(oComment);
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://Tyloo-code.github.io/post-images/1618117356273.png" alt="" loading="lazy"></figure>
<h3 id="2-节点的添加-剪切操作">2. 节点的添加、剪切操作</h3>
<p><code>parentNode.appendChild(子节点)</code> 把子节点插入到父节点的最后面</p>
<pre><code>&lt;div id=&quot;box&quot;&gt;
   &lt;span&gt;我是haven&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<pre><code>var oBox = document.getElementById(&quot;box&quot;);
var oDiv = document.createElement(&quot;div&quot;);
oBox.appendChild(oDiv);//把oDiv插入到oBox的最后面是以字符串形式添加的
</code></pre>
<figure data-type="image" tabindex="14"><img src="https://Tyloo-code.github.io/post-images/1618117728592.png" alt="" loading="lazy"></figure>
<p><code>parentNode.insertBefore(A,B)</code> 把节点A添加到节点B之前</p>
<pre><code>&lt;div id=&quot;box&quot;&gt;
        &lt;h2&gt;我是标题&lt;/h2&gt;
        &lt;span&gt;我是haven&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<pre><code> var oBox = document.getElementById(&quot;box&quot;);
 var oSpan = document.getElementsByTagName(&quot;span&quot;)[0];
 var oDiv = document.createElement(&quot;div&quot;);
 oBox.insertBefore(oDiv,oSpan);
</code></pre>
<figure data-type="image" tabindex="15"><img src="https://Tyloo-code.github.io/post-images/1618117898677.png" alt="" loading="lazy"></figure>
<p><strong>结论：无论是appendChild方法还是insertBefore方法都可以对节点的 添加、剪切操作，都可以操作一次不能操作多次</strong></p>
<h2 id="3-节点的替换和删除">3. 节点的替换和删除</h2>
<h3 id="1节点的替换">1.节点的替换</h3>
<p><code>parentNode.replaceChild(A,B)</code> 用节点A替换节点B</p>
<pre><code>&lt;div id=&quot;box&quot;&gt;
    &lt;h2&gt;我是标题2&lt;/h2&gt;
    &lt;span&gt;我是heaven&lt;/span&gt;
    &lt;h3&gt;我是标题3&lt;/h3&gt;
&lt;/div&gt;
</code></pre>
<pre><code>var oBox = document.getElementById(&quot;box&quot;);
var oH3 = document.getElementsByTagName(&quot;h3&quot;)[0]
var oDiv = document.createElement(&quot;div&quot;);
oBox.replaceChild(oDiv,oH3);
</code></pre>
<figure data-type="image" tabindex="16"><img src="https://Tyloo-code.github.io/post-images/1618119399959.png" alt="" loading="lazy"></figure>
<h3 id="2-节点的删除-删除子节点">2. 节点的删除 、删除子节点</h3>
<p><code>parentNode.removeChild(子节点)</code> 删除子节点</p>
<pre><code>&lt;div id=&quot;box&quot;&gt;
    &lt;h2&gt;我是标题2&lt;/h2&gt;
    &lt;span&gt;我是heaven&lt;/span&gt;
    &lt;h3&gt;我是标题3&lt;/h3&gt;
&lt;/div&gt;
</code></pre>
<pre><code>var oBox = document.getElementById(&quot;box&quot;);
var oH3 = document.getElementsByTagName(&quot;h3&quot;);
oBox.removeChild(oH3[0]);
</code></pre>
<figure data-type="image" tabindex="17"><img src="https://Tyloo-code.github.io/post-images/1618119515957.png" alt="" loading="lazy"></figure>
<h2 id="4-动态获取与静态获取">4. 动态获取与静态获取</h2>
<h3 id="1-get系列获取元素的方式是动态获取">1. get系列获取元素的方式是动态获取</h3>
<blockquote>
<p>动态获取指的是：在获取节点之后还可以检测出符合条件的节点、并放置到集合中</p>
</blockquote>
<pre><code>  &lt;div id=&quot;box&quot;&gt;
        &lt;h3&gt;1&lt;/h3&gt;
        &lt;h3&gt;2&lt;/h3&gt;
        &lt;h3&gt;3&lt;/h3&gt;
    &lt;/div&gt;
</code></pre>
<pre><code>var oBox = document.getElementById(&quot;box&quot;);
var oH3 = document.getElementsByTagName(&quot;h3&quot;);
var h3 = document.createElement(&quot;h3&quot;);
oBox.appendChild(h3);
</code></pre>
<p><img src="https://Tyloo-code.github.io/post-images/1618119951624.png" alt="" loading="lazy"><br>
<strong>动态获取的方式是能再次感知到用js的方法添加新的标签的</strong></p>
<h3 id="2-query系列获取元素的方式是静态态获取">2. query系列获取元素的方式是静态态获取</h3>
<blockquote>
<p>静态获取指的是：在获取节点之后无法检测出符合条件的节点、不能放置到集合中</p>
</blockquote>
<pre><code>var oBox = document.getElementById(&quot;box&quot;);
var oH3 = document.querySelectorAll(&quot;h3&quot;);
var h3 = document.createElement(&quot;h3&quot;);
oBox.appendChild(h3);
</code></pre>
<p><img src="https://Tyloo-code.github.io/post-images/1618120005689.png" alt="" loading="lazy"><br>
静态获取的方式是不能能再次感知到用js的方法添加新的标签的</p>
<h2 id="5-如何在创建空节点的时候添加内容">5. 如何在创建空节点的时候添加内容</h2>
<h3 id="1-元素节点">1. 元素节点</h3>
<p><code>innerText</code> 可以设置节点的文本内容、也可以读取节点的内容、<code>不可以解析</code>标签</p>
<pre><code>&lt;div id=&quot;box&quot;&gt;
    &lt;h3&gt;1&lt;/h3&gt;
    &lt;h3&gt;2&lt;/h3&gt;
    &lt;h3&gt;3&lt;/h3&gt;
&lt;/div&gt;
</code></pre>
<pre><code>var oBox = document.getElementById(&quot;box&quot;);
var oH3 = document.createElement(&quot;h3&quot;);
oBox.appendChild(oH3);
oH3.innerText = &quot;我是h3节点&quot;;//创建h3标签添加文本内容
</code></pre>
<figure data-type="image" tabindex="18"><img src="https://Tyloo-code.github.io/post-images/1618120681297.png" alt="" loading="lazy"></figure>
<p><strong>那么如何读取元素节点的内容呢？？</strong></p>
<pre><code>var oBox = document.getElementById(&quot;box&quot;);
var oH3 = document.querySelectorAll(&quot;h3&quot;);
console.log(oH3[2].innerText);//读取节点的文本内容
</code></pre>
<p><img src="https://Tyloo-code.github.io/post-images/1618121295691.png" alt="" loading="lazy"><br>
<strong>修改并赋值</strong><code>innerText</code></p>
<pre><code>var oBox = document.getElementById(&quot;box&quot;);
var oH3 = document.querySelectorAll(&quot;h3&quot;);
oH3[0].innerText = &quot;我是修改并赋值的节点&quot;;
</code></pre>
<figure data-type="image" tabindex="19"><img src="https://Tyloo-code.github.io/post-images/1618121299074.png" alt="" loading="lazy"></figure>
<h3 id="2-元素节点">2. 元素节点</h3>
<p><code>innerHTML</code>可以设置节点的文本内容、也可以读取节点的内容、可以<code>解析</code>标签</p>
<p><strong>怎么样innerHTML方法解析字符串中的标签</strong></p>
<pre><code>var oBox = document.getElementById(&quot;box&quot;);
var oH3 = document.querySelectorAll(&quot;h3&quot;);
oH3[0].innerHTML = &quot;&lt;a&gt;我是修改后的文本节点的内容&lt;/a&gt;&quot;;
console.log(oH3[0].innerHTML);
</code></pre>
<p>打印的结果是用<code>innerHTML</code>替换的结果<br>
<img src="https://Tyloo-code.github.io/post-images/1618121585550.png" alt="" loading="lazy"></p>
<h2 id="6-元素节点的常用方法">6. 元素节点的常用方法</h2>
<h3 id="1-属性集合">1. 属性集合</h3>
<pre><code>&lt;div id=&quot;box&quot;&gt;
    &lt;h3 class=&quot;no&quot;&gt;测试标题&lt;/h3&gt;
&lt;/div&gt;
</code></pre>
<p>如何拿到<code>h3</code>标签的属性集合</p>
<pre><code>var oBox = document.getElementById(&quot;box&quot;);
        console.log(oBox.children[0].attributes);
</code></pre>
<figure data-type="image" tabindex="20"><img src="https://Tyloo-code.github.io/post-images/1618123899949.png" alt="" loading="lazy"></figure>
<h3 id="2-设置属性节点">2. 设置属性节点</h3>
<p><code>setAttribute</code>(属性节点名,属性节点值)、设置指定的属性节点</p>
<pre><code>&lt;div id=&quot;box&quot;&gt;
    &lt;h3 class=&quot;no&quot;&gt;测试标题&lt;/h3&gt;
&lt;/div&gt;
</code></pre>
<pre><code>var oBox = document.getElementById(&quot;box&quot;);
oBox.children[0].setAttribute(&quot;id&quot;, &quot;title&quot;)
</code></pre>
<figure data-type="image" tabindex="21"><img src="https://Tyloo-code.github.io/post-images/1618124020361.png" alt="" loading="lazy"></figure>
<h3 id="3-获取属性节点">3. 获取属性节点</h3>
<p><code>getAttribute</code>(属性节点名)、获取指定属性节点名称的值</p>
<pre><code>var oBox = document.getElementById(&quot;box&quot;);
console.log(oBox.children[0].getAttribute(&quot;class&quot;));
</code></pre>
<figure data-type="image" tabindex="22"><img src="https://Tyloo-code.github.io/post-images/1618124061317.png" alt="" loading="lazy"></figure>
<h3 id="4-删除属性节点">4. 删除属性节点</h3>
<p><code>removeAttribute</code>(属性节点名)、删除指定属性节点</p>
<pre><code>&lt;div id=&quot;box&quot;&gt;
    &lt;h3 class=&quot;no&quot;&gt;测试标题&lt;/h3&gt;
&lt;/div&gt;
</code></pre>
<pre><code>var oBox = document.getElementById(&quot;box&quot;);
oBox.children[0].removeAttribute(&quot;class&quot;);
</code></pre>
<figure data-type="image" tabindex="23"><img src="https://Tyloo-code.github.io/post-images/1618124130227.png" alt="" loading="lazy"></figure>
<h3 id="5-判断有没有子节点">5. 判断有没有子节点</h3>
<p><code>hasChildNodes</code> 判断元素节点有没有子节点</p>
<pre><code>var oBox = document.getElementById(&quot;box&quot;);
console.log(oBox.children[0].hasChildNodes());
</code></pre>
<figure data-type="image" tabindex="24"><img src="https://Tyloo-code.github.io/post-images/1618124186614.png" alt="" loading="lazy"></figure>
<ul>
<li>如果有则返回返回结果是true</li>
<li>如果没有则返回结果是是false</li>
</ul>
<h1 id="18-js遍历dom树">18. js遍历dom树</h1>
<h2 id="1-遍历dom树">1. 遍历dom树</h2>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;遍历DOM树&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;h1&gt;遍历 DOM 树&lt;/h1&gt;
&lt;p style=&quot;color: green;&quot;&gt;Tip: 可以在遍历的回调函数中任意定制需求&lt;/p&gt;
&lt;div&gt;
  &lt;ul&gt;
    &lt;li&gt;123&lt;/li&gt;
    &lt;li&gt;456&lt;/li&gt;
    &lt;li&gt;789&lt;/li&gt;
  &lt;/ul&gt;
  &lt;div&gt;
    &lt;div&gt;
      &lt;span&gt;haha&lt;/span&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;demo_node&quot;&gt;
  &lt;ul&gt;
    &lt;li&gt;123&lt;/li&gt;
  &lt;/ul&gt;
  &lt;p&gt;hello&lt;/p&gt;
  &lt;h2&gt;world&lt;/h2&gt;
  &lt;div&gt;
    &lt;p&gt;dsa&lt;/p&gt;
    &lt;h3&gt;
      &lt;span&gt;dsads&lt;/span&gt;
    &lt;/h3&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;

  //获取页面中的根节点--根标签
  var root=document.documentElement;//html
  //函数遍历DOM树
  //根据根节点,调用fn的函数,显示的是根节点的名字
  function forDOM(root1) {
    //调用f1,显示的是节点的名字
   // f1(root1);
    //获取根节点中所有的子节点
    var children=root1.children;
    //调用遍历所有子节点的函数
    forChildren(children);
  }
  //给我所有的子节点,我把这个子节点中的所有的子节点显示出来
  function forChildren(children) {
    //遍历所有的子节点
    for(var i=0;i&lt;children.length;i++){
      //每个子节点
      var child=children[i];
      //显示每个子节点的名字
      f1(child);
      //判断child下面有没有子节点,如果还有子节点,那么就继续的遍历
      child.children&amp;&amp;forDOM(child);
    }
  }
  //函数调用,传入根节点
  forDOM(root);
  function f1(node) {
    console.log(&quot;节点的名字:&quot;+node.nodeName);
  }
  //节点:nodeName,nodeType,nodeValue

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="2-多叉-dom-树的遍历">2. 多叉 DOM 树的遍历</h2>
<h3 id="1-广度优先遍历">1. 广度优先遍历</h3>
<p>首先遍历根节点，然后访问第一层节点，第二层节点，....,直到访问到最后一层。<br>
借助于队列，用非递归的方式对多叉树进行遍历</p>
<pre><code>Tree.prototype.BFSearch =  function(node,callback){  
    var queue=[];  
    while(node!=null){          
           callback(node);  
       if(node.children.length!=0){  
        for (var i=0;i&lt;node.children.length;i++){  
            queue.push(node.children[i]);//借助于队列,暂存当前节点的所有子节点  
        }   
        }  
            node=queue.shift();//先入先出，借助于数据结构：队列  
    }         
};  
</code></pre>
<h3 id="2-深度优先遍历">2. 深度优先遍历</h3>
<p>首先遍历根节点，然后沿着一条路径遍历到最深的一层，最后在逐层返回。<br>
借助于栈,实现多叉 DOM树 的深度优先遍历。</p>
<pre><code>Tree.prototype.DFSearch =  function(node,callback){  
        var stack=[];         
        while(node!=null){  
        callback(node);  
        if(node.children.length!=0){  
        for (var i=node.children.length-1;i&gt;=0;i--){//按照相反的子节点顺序压入栈  
            stack.push(node.children[i]);//将该节点的所有子节点压入栈  
        }  
        }  
            node = stack.pop();//弹出栈的子节点顺序就是原来的正确顺序(因为栈是先入后出的)        
    }     
};  
</code></pre>
<h1 id="19-面试查缺补漏">19. 面试查缺补漏</h1>
<h2 id="1-js页面跳转方式">1. JS页面跳转方式</h2>
<ul>
<li>window.location.href= 'url': 比较常用的方法，直接跟指定要跳转的地方。</li>
<li>window.history.back(-1);: 参见的浏览器返回上一个已访问的页面，直到访问最初访问的页面。</li>
<li>window.navigate(&quot;url&quot;);: navigate对象包含有关浏览器的信息，也可以作为页面跳转，后面直接加要跳转的地方。</li>
<li>top.location= 'url';: 当页面中有内嵌框架时，指定最顶层的窗口跳转，及包含框架的最外层浏览器</li>
</ul>
<figure data-type="image" tabindex="25"><img src="https://Tyloo-code.github.io/post-images/1618478544386.png" alt="" loading="lazy"></figure>
<h2 id="2-js弹出框有哪些">2. JS弹出框有哪些</h2>
<p><strong>第一种：alert()方法</strong><br>
<img src="https://Tyloo-code.github.io/post-images/1618479050149.png" alt="" loading="lazy"><br>
<strong>第二种：confirm()方法</strong><br>
<img src="https://Tyloo-code.github.io/post-images/1618479053584.png" alt="" loading="lazy"><br>
<strong>第三种： prompt()方法</strong><br>
不但可以显示信息，而且还提供了一个文本框要求用户使用键盘输入自己的信息，同时她还包含“确认”或“取消”两个按钮，如果用户“确认”按钮，则prompt()方法返回用户在文本框中输入的内容（是字符串类型)或者初始值(如果用户没有输入信息);如果用户单击“取消”按钮，则prompt()方法返回null<br>
<img src="https://Tyloo-code.github.io/post-images/1618479103065.png" alt="" loading="lazy"><br>
<img src="https://Tyloo-code.github.io/post-images/1618479124548.png" alt="" loading="lazy"></p>
<h2 id="3-url编码和解码的方式">3. url编码和解码的方式</h2>
<h3 id="1-为什么要url编码">1. 为什么要URL编码？</h3>
<p><strong>在因特网上传送URL，只能采用ASCII字符集</strong><br>
只有字母和数字[0-9a-zA-Z]、一些特殊符号$-_.+!*'()[不包括双引号]、以及某些保留字（空格转换为+），才可以不经过编码直接用于URL</p>
<p>这意味着 如果URL中有汉字，就必须编码后使用。</p>
<h3 id="2-js编码函数">2. JS编码函数</h3>
<p><strong>encodeURI函数(推荐使用)</strong><br>
这个函数才是javascript中真正用来对URL编码的函数</p>
<p>它着眼于对整个URL进行编码，因此除了常见的符号以外，对其他一些在网址中有特殊含义的符号&quot;; / ? : @ &amp; = + $ , #&quot;，也不进行编码。编码后，它输出符号的utf-8形式，并且在每个字节前加上%。<br>
需要注意的是，它不对单引号’编码</p>
<p>它对应的解码函数是decodeURI()。</p>
<h3 id="3-为什么两次编码">3. 为什么两次编码</h3>
<figure data-type="image" tabindex="26"><img src="https://Tyloo-code.github.io/post-images/1618481823390.png" alt="" loading="lazy"></figure>
<h2 id="4-meta常用属性">4. meta常用属性</h2>
<h3 id="1-charset属性">1. charset属性</h3>
<pre><code>&lt;!-- 定义网页文档的字符集 --&gt;
&lt;meta charset=&quot;utf-8&quot; /&gt;
</code></pre>
<h3 id="2-name-content属性">2. name + content属性</h3>
<pre><code>&lt;!-- 网页作者 --&gt;
&lt;meta name=&quot;author&quot; content=&quot;开源技术团队&quot;/&gt;
&lt;!-- 网页地址 --&gt;
&lt;meta name=&quot;website&quot; content=&quot;https://sanyuan0704.github.io/frontend_daily_question/&quot;/&gt;
&lt;!-- 网页版权信息 --&gt;
 &lt;meta name=&quot;copyright&quot; content=&quot;2018-2019 demo.com&quot;/&gt;
&lt;!-- 网页关键字, 用于SEO --&gt;
&lt;meta name=&quot;keywords&quot; content=&quot;meta,html&quot;/&gt;
&lt;!-- 网页描述 --&gt;
&lt;meta name=&quot;description&quot; content=&quot;网页描述&quot;/&gt;
&lt;!-- 搜索引擎索引方式，一般为all，不用深究 --&gt;
&lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt;
&lt;!-- 移动端常用视口设置 --&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0, user-scalable=no&quot;/&gt;
&lt;!-- 
  viewport参数详解：
  width：宽度（数值 / device-width）（默认为980 像素）
  height：高度（数值 / device-height）
  initial-scale：初始的缩放比例 （范围从&gt;0 到10）
  minimum-scale：允许用户缩放到的最小比例
  maximum-scale：允许用户缩放到的最大比例
  user-scalable：用户是否可以手动缩 (no,yes)
 --&gt;
</code></pre>
<h3 id="3-http-equiv属性">3. http-equiv属性</h3>
<pre><code>&lt;!-- expires指定网页的过期时间。一旦网页过期，必须从服务器上下载。 --&gt;
&lt;meta http-equiv=&quot;expires&quot; content=&quot;Fri, 12 Jan 2020 18:18:18 GMT&quot;/&gt;
&lt;!-- 等待一定的时间刷新或跳转到其他url。下面1表示1秒 --&gt;
&lt;meta http-equiv=&quot;refresh&quot; content=&quot;1; url=https://www.baidu.com&quot;/&gt;
&lt;!-- 禁止浏览器从本地缓存中读取网页，即浏览器一旦离开网页在无法连接网络的情况下就无法访问到页面。 --&gt;
&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;/&gt;
&lt;!-- 也是设置cookie的一种方式，并且可以指定过期时间 --&gt;
&lt;meta http-equiv=&quot;set-cookie&quot; content=&quot;name=value expires=Fri, 12 Jan 2001 18:18:18 GMT,path=/&quot;/&gt;
&lt;!-- 使用浏览器版本 --&gt;
&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;
&lt;!-- 针对WebApp全屏模式，隐藏状态栏/设置状态栏颜色，content的值为default | black | black-translucent --&gt;
&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot; /&gt;
</code></pre>
<h2 id="5-a标签实现打电话">5. a标签实现打电话</h2>
<ol>
<li>最常用WEB页面JS实现一键拨号的电话拨打功能：</li>
</ol>
<pre><code>&lt;a href=&quot;tel:13764567708&quot;&gt;移动WEB页面JS一键拨打号码咨询功能&lt;/a&gt;
</code></pre>
<p>在拨号界面，显示号码，并提示拨打。支持大部分的浏览器，但是在QQ浏览器上支持不好。</p>
<ol start="2">
<li>最常用WEB页面JS实现一键发送短信功能：</li>
</ol>
<pre><code>&lt;a href=&quot;sms:13764567708&quot;&gt;移动WEB页面JS一键发送短信咨询功能&lt;/a&gt;
</code></pre>
<p>在信息录入界面，显示发送号码，并提示录入信息。</p>
<p>支持大部分的浏览器，但是在QQ浏览器上支持不好。</p>
<ol start="3">
<li>最常用WEB页面发邮件：</li>
</ol>
<pre><code>&lt;a href=&quot;mailto:youemail@mail.com?subject=邮件标题&amp;body=邮件内容&quot;&gt;告诉我们&lt;/a&gt;
</code></pre>
<h2 id="6-css哪些属性可以继承">6. CSS哪些属性可以继承？</h2>
<p><strong>css继承特性主要是指文本方面的继承，盒模型相关的属性基本没有继承特性</strong>。<br>
<code>不可继承的</code>：</p>
<p>display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、top、bottom、left、right、z-index、float、clear、 table-layout、vertical-align、page-break-after</p>
<p><code>所有元素可继承的</code>：</p>
<p>visibility和cursor</p>
<p><code>终极块级元素可继承的</code>：</p>
<p>text-indent和text-align</p>
<p><code>内联元素可继承的</code>：</p>
<p>letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction</p>
<p><code>列表元素可继承的</code>：</p>
<p>list-style、list-style-type、list-style-position、list-style-image</p>
<h2 id="7-windowscroll方法">7. window.scroll方法</h2>
<h3 id="1-windowscroll到">1. window.scroll（到）</h3>
<figure data-type="image" tabindex="27"><img src="https://Tyloo-code.github.io/post-images/1618490087718.png" alt="" loading="lazy"></figure>
<h3 id="2windowscrollto">2.window.scrollTo</h3>
<figure data-type="image" tabindex="28"><img src="https://Tyloo-code.github.io/post-images/1618490106662.png" alt="" loading="lazy"></figure>
<p>与scroll一样</p>
<h3 id="3-windowscrollby距离">3. window.scrollBy（距离）</h3>
<figure data-type="image" tabindex="29"><img src="https://Tyloo-code.github.io/post-images/1618490176094.png" alt="" loading="lazy"></figure>
<h2 id="8-head头包含哪些标签">8. head头包含哪些标签？</h2>
<p>head标签是所有头部元素的容器。</p>
<pre><code>&lt;head&gt;内的元素可包含脚本，指示浏览器在何处可以找到样式表，提供元信息等。
可添加到head部分的标签：&lt;title&gt;、&lt;base&gt;、&lt;meta&gt;、&lt;link&gt;、&lt;script&gt;、&lt;style&gt;:
&lt;title&gt;：指定整个网页的标题，在浏览器最上方显示。
&lt;base&gt;:为页面上的所有链接规定默认地址或默认目标(target)。
&lt;meta&gt;：提供有关页面的基本信息。
&lt;link&gt;：定义文档与外部资源的关系。
&lt;script&gt;:定义客户端脚本，如JavaScript。
&lt;style&gt;:定义内部样式表与网页的关系。
</code></pre>
<h1 id="17-window的onload事件和domcontentloaded">17. window的onload事件和domcontentloaded</h1>
<ul>
<li>DOMContentLoaded方法是当DOM加载完成，不包括样式表，图片，flash触发的事件</li>
<li>onload事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了，用于检测一个加载完全的页面</li>
</ul>
<p>开发中我们经常需要给一些元素的事件绑定处理函数。但问题是，如果那个元素还没有加载到页面上，但是绑定事件已经执行完了，是没有效果的。这两个事件大致就是用来避免这样一种情况，将绑定的函数放在这两个事件的回调中，保证能在页面的某些元素加载完毕之后再绑定事件的函数。</p>
<p>当然DOMContentLoaded机制更加合理，因为我们可以容忍图片，flash延迟加载，却不可以容忍看见内容后页面不可交互。</p>
<h1 id="18-forin迭代和forof有什么区别">18. for...in迭代和for...of有什么区别</h1>
<h2 id="1-forin">1. for…in</h2>
<p>for…in 循环返回的值是数据的结构的<strong>key</strong>(类比键值名)<br>
<code>遍历对象</code>返回的对象<code>key</code>值，<code>遍历数组</code>返回的数组的<code>下标</code>（key）<br>
for…in 不仅可以遍历数字 键名，还会遍历原型上的值和手动添加其他的键<br>
for…in 循环出的是（key）<br>
总结：<br>
for…in 循环特别适合遍历对象</p>
<h2 id="2-forof">2. for…of</h2>
<p>for…of 是ES6新引入的特性。修复了ES5引入的for…in的不足支持set().map()<br>
for…of不能循环普通的对象，需要通过和OBject.Keys()搭配使用<br>
for…of不同与forEach<br>
它可以与break.continue和return 配合使用<br>
for…of 循环可以随时推出循环<br>
for…of 循环出的是（<strong>value</strong>）<br>
总结：<br>
for…of 循环特别适合<code>遍历数组</code></p>
<h1 id="19-函数柯里化-和-高阶函数">19. 函数柯里化 和 高阶函数</h1>
<h2 id="1-函数柯里化">1. 函数柯里化</h2>
<p>柯里化，是函数式编程的一个重要概念。它既能减少代码冗余，也能增加可读性。<br>
<strong>定义</strong>：在数学和计算机科学中，柯里化是一种将使用<strong>多个参数</strong>的一个函数转换成一系列使用<strong>一个参数</strong>的函数的技术。<br>
<code>简单版：</code></p>
<pre><code>function add(a) {
  function sum(b) { // 使用闭包
      a = a + b; // 累加
      return sum;
   }
   sum.toString = function() { // 重写toString()方法
      return a;
  }
   return sum; // 返回一个函数
}

add(1); // 1
add(1)(2);  // 3
add(1)(2)(3) // 6
</code></pre>
<p><code>完整版：</code></p>
<pre><code>function add() {
  // 第一次执行时，定义一个数组专门用来存储所有的参数
  var _args = [].slice.call(arguments);

  // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值
  var adder = function () {
      var _adder = function() {
          _args.push(...arguments);
          return _adder;
      };

      // 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回
      _adder.toString = function () {
          return _args.reduce(function (a, b) {
              return a + b;
          });
      }

      return _adder;
  }
  return adder(..._args);
}

var a = add(1)(2)(3)(4);   // f 10
var b = add(1, 2, 3, 4);   // f 10
var c = add(1, 2)(3, 4);   // f 10
var d = add(1, 2, 3)(4);   // f 10
</code></pre>
<p><strong>总结：</strong></p>
<p>函数的柯里化，是 Javascript 中函数式编程的一个重要概念。<code>它返回的，是一个函数的函数</code>。其实现方式，需要依赖<code>参数以及递归</code>，通过<code>拆分参数</code>的方式，来调用一个多参数的函数方法，以达到减少代码冗余，增加可读性的目的。</p>
<h2 id="2-高阶函数">2. 高阶函数</h2>
<h3 id="1-arrayprototypemap">1. Array.prototype.map</h3>
<p><code>map()</code>(映射)方法最后生成一个新数组，不改变原始数组的值。其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p>
<pre><code>array.map(callback,[ thisObject]);
</code></pre>
<p>callback(回调函数)</p>
<pre><code>[].map(function(currentValue, index, array) {
    // ...
});
</code></pre>
<p>传递给<code>map</code>的回调函数（<code>callback</code>）接受三个参数，分别是<code>currentValue</code>——正在遍历的元素；<code>index</code>（可选）——元素索引；<code>array</code>（可选）——原数组本身，除了 callback 之外还可以接受 this 值（可选），用于执行 callback 函数时使用的this 值。</p>
<p>来个简单的例子方便理解，现在有一个数组[1,2,3,4]，我们想要生成一个新数组，其每个元素皆是之前数组的两倍</p>
<pre><code>const arr1 = [1, 2, 3, 4];
const arr2 = arr1.map(item =&gt; item * 2);

console.log( arr2 );
// [2, 4, 6, 8]
console.log( arr1 );
// [1, 2, 3, 4]
</code></pre>
<p><code>map高阶函数注意点</code></p>
<p>callback需要有return值，否则会出现所有项映射为undefind；</p>
<pre><code>[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt);
//输出结果为  [1,NaN,NaN]

[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;].map(x=&gt;parseInt(x));
//输出结果为  [1,2,3]
</code></pre>
<h3 id="2-arrayprototypereduce">2. Array.prototype.reduce</h3>
<p><code>reduce()</code>方法对数组中的每个元素执行一个提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值。传递给 reduce 的回调函数（callback）接受四个参数，分别是累加器 <code>accumulator</code>；<code>currentValue</code>——正在操作的元素；<code>currentIndex</code>（可选）——元素索引，但是它的开始会有特殊说明；<code>array</code>（可选）——原始数组本身，除了 callback 之外还可以接受初始值 initialValue 值（可选）。</p>
<p>例子，现在有一个数组 [0, 1, 2, 3, 4]，需要计算数组元素的和，需求比较简单，来看下代码实现。</p>
<pre><code>const arr = [0, 1, 2, 3, 4];
let sum = arr.reduce((accumulator, currentValue, currentIndex, array) =&gt; {
  return accumulator + currentValue;
});

console.log( sum );
// 10
console.log( arr );
// [0, 1, 2, 3, 4]
</code></pre>
<figure data-type="image" tabindex="30"><img src="https://Tyloo-code.github.io/post-images/1615256323803.png" alt="" loading="lazy"></figure>
<h3 id="3-arrayprototypefilter">3. Array.prototype.filter</h3>
<p><code>filter</code>(过滤，筛选) 方法创建一个新数组,原始数组不发生改变。</p>
<pre><code>array.filter(callback,[ thisObject]);
</code></pre>
<p>接收的参数和 map 是一样的，filter的<code>callback</code>函数需要返回布尔值true或false. 如果为true则表示通过啦！如果为false则失败，其返回值是一个新数组，由通过测试为true的所有元素组成，如果没有任何数组元素通过测试，则返回空数组。</p>
<p>来个例子介绍下，现在有一个数组 [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]，我们想要生成一个新数组，这个数组要求没有重复的内容，即为去重。</p>
<pre><code>const arr1 = [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4];
const arr2 = arr1.filter( (element, index, self) =&gt; {
    return self.indexOf( element ) === index;
});

console.log( arr2 );
// [1, 2, 3, 5, 4]
console.log( arr1 );
// [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]
</code></pre>
<h1 id="20-call-与-apply区别原生实现bind">20.  call 与 apply区别，原生实现bind</h1>
<h2 id="1-call-和-apply-的共同点">1. call 和 apply 的共同点</h2>
<p>它们的共同点是，都能够<strong>改变函数执行时的上下文</strong>，将一个对象的方法交给另一个对象来执行，并且是立即执行的。</p>
<p>为何要改变执行上下文？举一个生活中的小例子：平时没时间做饭的我，周末想给孩子炖个腌笃鲜尝尝。但是没有适合的锅，而我又不想出去买。所以就问邻居借了一个锅来用，这样既达到了目的，又节省了开支，一举两得。</p>
<p>改变执行上下文也是一样的，A 对象有一个方法，而 B 对象因为某种原因，也需要用到同样的方法，那么这时候我们是单独为 B 对象扩展一个方法呢，还是借用一下 A 对象的方法呢？当然是借用 A 对象的啦，既完成了需求，又减少了内存的占用。</p>
<p>另外，它们的写法也很类似，<strong>调用 call 和 apply 的对象，必须是一个函数 Function</strong>。接下来，就会说到具体的写法，那也是它们区别的主要体现。</p>
<h2 id="2-call-和-apply-的区别">2. call 和 apply 的区别</h2>
<p><strong>call 的写法</strong></p>
<pre><code>Function.call(obj,[param1[,param2[,…[,paramN]]]])
</code></pre>
<ul>
<li>调用 call 的对象，必须是个函数 Function。</li>
<li>call 的第一个参数，是一个对象。 Function 的调用者，将会指向这个对象。如果不传，则默认为全局对象 window。</li>
<li>第二个参数开始，可以接收任意个参数。每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空。</li>
</ul>
<pre><code>function func (a,b,c) {}

func.call(obj, 1,2,3)
// func 接收到的参数实际上是 1,2,3

func.call(obj, [1,2,3])
// func 接收到的参数实际上是 [1,2,3],undefined,undefined
</code></pre>
<p><strong>apply 的写法</strong></p>
<pre><code>Function.apply(obj[,argArray])
</code></pre>
<ul>
<li>它的调用者必须是函数 Function，并且只接收两个参数，第一个参数的规则与 call 一致。</li>
<li>第二个参数，必须是数组或者类数组，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。这也是 call 和 apply 之间，很重要的一个区别。</li>
</ul>
<pre><code>func.apply(obj, [1,2,3])
// func 接收到的参数实际上是 1,2,3

func.apply(obj, {
    0: 1,
    1: 2,
    2: 3,
    length: 3
})
// func 接收到的参数实际上是 1,2,3
</code></pre>
<p><strong>类数组无法使用 forEach、splice、push 等数组原型链上的方法</strong></p>
<h2 id="3-call-和-apply-的用途">3 call 和 apply 的用途</h2>
<p><code>call 的使用场景</code></p>
<ol>
<li><strong>对象的继承</strong></li>
</ol>
<pre><code>function superClass () {
    this.a = 1;
    this.print = function () {
        console.log(this.a);
    }
}

function subClass () {
    superClass.call(this);
    this.print();
}

subClass();
// 1
</code></pre>
<p>subClass 通过 call 方法，继承了 superClass 的 print 方法和 a 变量。此外，subClass 还可以扩展自己的其他方法。</p>
<ol start="2">
<li><strong>借用方法</strong></li>
</ol>
<pre><code>let domNodes = Array.prototype.slice.call(document.getElementsByTagName(&quot;*&quot;));
</code></pre>
<p><code>apply 的一些妙用</code></p>
<ol>
<li><strong>Math.max</strong></li>
</ol>
<pre><code>let max = Math.max.apply(null, array);
</code></pre>
<p>同理，要获取数组中最小的一项，可以这样：</p>
<pre><code>let min = Math.min.apply(null, array);
</code></pre>
<ol start="2">
<li><strong>实现两个数组合并</strong></li>
</ol>
<pre><code>let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];

Array.prototype.push.apply(arr1, arr2);
console.log(arr1); // [1, 2, 3, 4, 5, 6]
</code></pre>
<h2 id="4-bind-的使用">4. bind 的使用</h2>
<p>bind() 方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。</p>
<p>它的语法如下：</p>
<pre><code>Function.bind(thisArg[, arg1[, arg2[, ...]]])
</code></pre>
<p>bind 方法 与 apply 和 call 比较类似，也能改变函数体内的 this 指向。不同的是，<code>bind 方法的返回值是函数，并且需要稍后调用，才会执行</code>。而 apply 和 call 则是<code>立即调用</code>。</p>
<p>来看下面这个例子：</p>
<pre><code>function add (a, b) {
    return a + b;
}

function sub (a, b) {
    return a - b;
}

add.bind(sub, 5, 3); // 这时，并不会返回 8
add.bind(sub, 5, 3)(); // 调用后，返回 8
</code></pre>
<p>如果 bind 的第一个参数是 null 或者 undefined，this 就指向全局对象 window。</p>
<h2 id="5-总结">5. 总结</h2>
<p>call 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。</p>
<p>bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。</p>
<p><code>原生实现bind函数</code></p>
<pre><code>// 原生js实现bind函数
// 所有的函数都要有bind方法，所以要定义在Function的原型对象上
Function.prototype.myBind = function(objThis,...params){
    // objThis是要绑定的this对象，...params是因为参数数量不确定才用解构语法
    const thisFn = this;//当前调用的函数，例如fn.myBind()就把fn保存到thisFn
    let funcForBind = function(...secondParams){ // 要返回的函数
        // 判断函数是否是用new function生成的
        const isNew = this instanceof funcForBind
        const thisArg = isNew?this:objThis //this的指向
        // 绑定好this和参数返回到外层，暂时用call绑定，call也可以原生实现
        return thisFn.call(thisArg,...params,...secondParams)
    }
    // 绑定原型
    funcForBind.prototype = Object.create(thisFn)
    return funcForBind //返回绑定好的函数
} 
</code></pre>
<h1 id="21-立即执行函数和使用场景与闭包结合">21. 立即执行函数和使用场景（与闭包结合）</h1>
<h2 id="1-什么是立即执行函数">1. 什么是立即执行函数？</h2>
<p>声明一个函数，并马上调用这个匿名函数就叫做立即执行函数；也可以说立即执行函数是一种语法，让你的函数在定义以后立即执行；<br>
<img src="https://Tyloo-code.github.io/post-images/1615271995138.jpg" alt="" loading="lazy"></p>
<h2 id="2-立即执行函数的写法">2. 立即执行函数的写法：</h2>
<pre><code>(function(){
//code
}())

(function (){
//code
})()
</code></pre>
<p>上边的两种写法，都是以圆括号开头，引擎会意味后面跟的是表达式，而不是一个函数定义语句，所以就避免了错误，这就叫做&quot;立即调用的函数表达式&quot;。</p>
<pre><code>(function () {alert(&quot;我是匿名函数&quot;)}())   //用括号把整个表达式包起来
(function () {alert(&quot;我是匿名函数&quot;)})()  //用括号把函数包起来
!function () {alert(&quot;我是匿名函数&quot;)}()  //求反，我们不在意值是多少，只想通过语法检查
</code></pre>
<h2 id="3-立即执行函数的作用">3. 立即执行函数的作用：</h2>
<ul>
<li>不必为函数命名，避免了污染全局变量</li>
<li>立即执行函数内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量</li>
<li>封装变量</li>
</ul>
<p>总而言之：<strong>立即执行函数会形成一个单独的作用域，我们可以封装一些临时变量或者局部变量，避免污染全局变量</strong></p>
<h2 id="4-使用场景">4. 使用场景</h2>
<ol>
<li>怎样使以下alert的结果为0,1,2：</li>
</ol>
<pre><code> &lt;ul id=&quot;list&quot;&gt;
        &lt;li&gt;公司简介&lt;/li&gt;
        &lt;li&gt;联系我们&lt;/li&gt;
        &lt;li&gt;营销网络&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
       var list = document.getElementById(&quot;list&quot;);
      var li = list.children;
      for(var i = 0 ;i&lt;li.length;i++){
       ( function(j){
            li[j].onclick = function(){
              alert(j);
          })(i); //把实参i赋值给形参j
        }
      }
     &lt;/script&gt;  
</code></pre>
<p>结合闭包</p>
<pre><code>for (var i = 1; i &lt;= 5; i++) {
  (function(j) {
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })(i);
}
</code></pre>
<ol start="2">
<li>如何避免了污染全局变量</li>
</ol>
<p>某些代码只需要执行一次，比如只需要显示一个时间，但是这些代码也需要一些临时的变量，但是初始化过程结束之后，就再也不会被用到，如果将这些变量作为全局变量，不是一个好的主意，我们可以用立即执行函数——去将我们所有的代码包裹在它的局部作用域中，不会让任何变量泄露成全局变量，看如下代码：<br>
<img src="https://Tyloo-code.github.io/post-images/1615273235393.jpg" alt="" loading="lazy"><br>
比如上面的代码，如果没有被包裹在立即执行函数中，而是直接以非函数的形式直接写在&lt;script&gt;</script>标签里面，虽然也会立即执行，但是临时变量todaydom,days,today,year,month,date,day,msg都将成为全局变量（初始化代码遗留的产物）。<br>
而用立即执行函数之后，这些变量都不会在全局变量中存在，以后也不会其他地方使用，有效的避免了污染全局变量。</p>
<h1 id="22-设计模式要求说出如何实现应用优缺点单例模式实现">22. 设计模式(要求说出如何实现,应用,优缺点)/单例模式实现</h1>
<figure data-type="image" tabindex="31"><img src="https://Tyloo-code.github.io/post-images/1615273736555.png" alt="" loading="lazy"></figure>
<h2 id="1-创建型模式">1. 创建型模式</h2>
<h3 id="1-工厂模式">1. 工厂模式</h3>
<p>工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象，用工厂方法代替new操作的一种模式。</p>
<pre><code>function Animal(opts){
    var obj = new Object();
    obj.color = opts.color;
    obj.name= opts.name;
    obj.getInfo = function(){
        return '名称：'+ onj.name+'， 颜色：'+ obj.color;
    }
    return obj;
}
var cat = Animal({name: '波斯猫', color: '白色'});
cat.getInfo();
</code></pre>
<p><strong>小结:</strong></p>
<ul>
<li>构造函数和创建者分离，对new操作进行封装</li>
<li>符合开放封闭原则</li>
</ul>
<h3 id="2-单例模式">2. 单例模式</h3>
<p><img src="https://Tyloo-code.github.io/post-images/1615274155679.png" alt="" loading="lazy"><br>
单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例。</p>
<pre><code>var Single = (function(){
    var instance;
    function init() {
        // 定义私有方法和属性
        // 操作逻辑
        return {
           // 定义公共方法和属性
        };
    }
    return {
        // 获取实例
        getInstance:function(){
            if(!instance){
                instance = init();
            }
            return instance;
        }
    }
})();

var obj1 = Single.getInstance();
var obj2 = Single.getInstance();
console.log(obj1 === obj2);
</code></pre>
<p><strong>小结:</strong></p>
<ol>
<li>单例模式的主要思想就是，实例如果已经创建，则直接返回</li>
</ol>
<pre><code>function creatSingleton() {
    var obj = null
    // 实例如已经创建过，直接返回
    if (!obj) {
        obj = xxx
    }
    return obj
}
</code></pre>
<ol start="2">
<li>符合开放封闭原则</li>
</ol>
<h3 id="3-原型模式">3. 原型模式</h3>
<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<p>在JavaScript中，实现原型模式是在ECMAScript5中，提出的Object.create方法，使用现有的对象来提供新创建的对象的__proto__。</p>
<pre><code>var prototype = {
    name: 'Jack',
    getName: function() {
        return this.name
    }
}

var obj = Object.create(prototype, {
    job: {
        value: 'IT'
    }
})

console.log(obj.getName())  // Jack
console.log(obj.job)  // IT
console.log(obj.__proto__ === prototype)  //true
</code></pre>
<h2 id="2-结构型模式">2. 结构型模式</h2>
<h3 id="1-适配器模式">1. 适配器模式</h3>
<figure data-type="image" tabindex="32"><img src="https://Tyloo-code.github.io/post-images/1615274391311.png" alt="" loading="lazy"></figure>
<pre><code>class GooleMap {
    show() {
        console.log('渲染谷歌地图')
    }
}

class BaiduMap {
    display() {
        console.log('渲染百度地图')
    }
}


// 定义适配器类, 对BaiduMap类进行封装
class BaiduMapAdapter {
    show() {
        var baiduMap = new BaiduMap()
        return baiduMap.display() 
    }
}

function render(map) {
    if (map.show instanceof Function) {
        map.show()
    }
}

render(new GooleMap())         // 渲染谷歌地图
render(new BaiduMapAdapter())  // 渲染百度地图
</code></pre>
<p><strong>小结:</strong></p>
<ul>
<li>适配器模式主要解决两个接口之间不匹配的问题，不会改变原有的接口，而是由一个对象对另一个对象的包装。</li>
<li>适配器模式符合开放封闭原则</li>
</ul>
<h2 id="3-行为型模式">3. 行为型模式</h2>
<h3 id="1-观察者模式订阅-发布模式">1. 观察者模式(订阅-发布模式)</h3>
<p><img src="https://Tyloo-code.github.io/post-images/1615274507790.png" alt="" loading="lazy"><br>
<strong>发布者发出通知 =&gt;主题对象收到通知并推送给订阅者 =&gt; 订阅者执行相应的操作。</strong></p>
<pre><code> // 一个发布者 publisher，功能就是负责发布消息 - publish
        var pub = {
            publish: function () {
                dep.notify();
            }
        }
        // 多个订阅者 subscribers， 在发布者发布消息之后执行函数
        var sub1 = { 
            update: function () {
                console.log(1);
            }
        }
        var sub2 = { 
            update: function () {
                console.log(2);
            }
        }
        var sub3 = { 
            update: function () {
                console.log(3);
            }
        }
        // 一个主题对象
        function Dep() {
            this.subs = [sub1, sub2, sub3];
        }
        Dep.prototype.notify = function () {
            this.subs.forEach(function (sub) {
                sub.update();
            });
        }

        // 发布者发布消息， 主题对象执行notify方法，进而触发订阅者执行Update方法
        var dep = new Dep();
        pub.publish();
</code></pre>
<h1 id="23-iframe的缺点有哪些">23. iframe的缺点有哪些</h1>
<h2 id="1-iframe的优点">1. iframe的优点：</h2>
<ol>
<li>iframe能够原封不动的把嵌入的网页展现出来。</li>
<li>如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。</li>
<li>网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。</li>
<li>如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。</li>
</ol>
<h2 id="2-iframe的缺点">2. iframe的缺点：</h2>
<ol>
<li>会产生很多页面，<code>不容易管理</code>。</li>
<li>iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，<code>用户体验度差</code>。</li>
<li>代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会<code>不利于搜索引擎优化</code>。</li>
<li>很多的移动设备（PDA手机）无法完全显示框架，<code>设备兼容性差</code>。</li>
<li>iframe框架页面会<code>增加服务器的http请求</code>，对于大型网站是不可取的。<br>
分析了这么多，现在基本上都是用<code>Ajax来代替iframe</code>，所以iframe已经渐渐的退出了前端开发。</li>
</ol>
<h1 id="24-数组问题">24. 数组问题</h1>
<h2 id="1-数组去重">1. 数组去重</h2>
<h3 id="1-利用es6-set去重es6中最常用">1. 利用ES6 Set去重（ES6中最常用）</h3>
<pre><code>function unique (arr) {
  return Array.from(new Set(arr))
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr))
 //[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, {}, {}]
</code></pre>
<p>不考虑兼容性，这种去重的方法代码最少。这种方法还无法去掉“{}”空对象，后面的高阶方法会添加去掉重复“{}”的方法。</p>
<h3 id="2-利用for嵌套for然后splice去重es5中最常用">2. 利用for嵌套for，然后splice去重（ES5中最常用）</h3>
<pre><code>function unique(arr){            
  for(var i=0; i&lt;arr.length; i++){
      for(var j=i+1; j&lt;arr.length; j++){
          if(arr[i]===arr[j]){         //第一个等同于第二个，splice方法删除第二个
              arr.splice(j,1);
              j--;
          }
      }
  }
return arr;
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr))
//  [1, 'true',true, 15,false,undefined,null, NaN,NaN, 'NaN',0, 'a',{}, {}]  //NaN和{}没有去重
</code></pre>
<p>双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。</p>
<h3 id="3-利用indexof去重">3. 利用indexOf去重</h3>
<pre><code>function unique(arr) {
  if (!Array.isArray(arr)) {
      console.log('type error!')
      return
  }
  var array = [];
  for (var i = 0; i &lt; arr.length; i++) {
      if (array .indexOf(arr[i]) === -1) {
          array .push(arr[i])
      }
  }
  return array;
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr))
 // [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, {…}, {…}]  //NaN、{}没有去重
</code></pre>
<p>新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组。</p>
<h3 id="4-利用sort">4. 利用sort()</h3>
<pre><code>function unique(arr) {
  if (!Array.isArray(arr)) {
      console.log('type error!')
      return;
  }
  arr = arr.sort()
  var arrry= [arr[0]];
  for (var i = 1; i &lt; arr.length; i++) {
      if (arr[i] !== arr[i-1]) {
          arrry.push(arr[i]);
      }
  }
  return arrry;
}
   var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
      console.log(unique(arr))
// [0, 1, 15, &quot;NaN&quot;, NaN, NaN, {…}, {…}, &quot;a&quot;, false, null, true, &quot;true&quot;, undefined]      //NaN、{}没有去重
</code></pre>
<p>利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对。</p>
<h3 id="5-利用includes">5. 利用includes</h3>
<pre><code>function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error!')
        return
    }
    var array =[];
    for(var i = 0; i &lt; arr.length; i++) {
            if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值
                    array.push(arr[i]);
              }
    }
    return array
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
    console.log(unique(arr))
    //[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, {…}, {…}]     //{}没有去重
</code></pre>
<h3 id="6-利用filter">6. 利用filter</h3>
<pre><code>function unique(arr) {
  return arr.filter(function(item, index, arr) {
    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素
    return arr.indexOf(item, 0) === index;
  });
}
    var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
        console.log(unique(arr))
//[1, &quot;true&quot;, true, 15, false, undefined, null, &quot;NaN&quot;, 0, &quot;a&quot;, {…}, {…}]
</code></pre>
<h3 id="7-利用map数据结构去重">7. 利用Map数据结构去重</h3>
<pre><code>function arrayNonRepeatfy(arr) {
  let map = new Map();
  let array = new Array();  // 数组用于返回结果
  for (let i = 0; i &lt; arr.length; i++) {
    if(map.has(arr[i])) {  // 如果有该key值
      map.set(arr[i], true); 
    } else { 
      map.set(arr[i], false);   // 如果没有该key值
      array.push(arr[i]);
    }
  } 
  return array ;
}
 var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
    console.log(arrayNonRepeatfy(arr))
//[1, &quot;a&quot;, &quot;true&quot;, true, 15, false, 1, {…}, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, {…}, undefined]
</code></pre>
<h2 id="2-数组常用方法">2. 数组常用方法</h2>
<h3 id="1-arraymap">1. Array.map()</h3>
<p>此方法是将数组中的每个元素调用一个提供的函数，结果作为一个新的数组返回，并<code>没有改变原来的数组</code></p>
<pre><code>let arr = [1, 2, 3, 4, 5]
    let newArr = arr.map(x =&gt; x*2)
    //arr= [1, 2, 3, 4, 5]   原数组保持不变
    //newArr = [2, 4, 6, 8, 10] 返回新数组
</code></pre>
<h3 id="2-arrayforeach">2. Array.forEach()</h3>
<p>此方法是将数组中的每个元素执行传进提供的函数，没有返回值，<code>改变原数组</code>，注意和map方法区分</p>
<pre><code>let arr = [1, 2, 3, 4, 5]
   num.forEach(x =&gt; x*2)
   // arr = [1, 2, 3, 4, 5]  数组改变,注意和map区分
</code></pre>
<h3 id="3-arrayfilter">3. Array.filter()</h3>
<p>此方法是将所有元素进行判断，将满足条件的元素作为一个新的数组返回</p>
<pre><code>let arr = [1, 2, 3, 4, 5]
    const isBigEnough = value =&gt; value &gt;= 3
    let newArr = arr.filter(isBigEnough )
    //newNum = [3, 4, 5] 满足条件的元素返回为一个新的数组
</code></pre>
<h3 id="4-arrayevery">4. Array.every()</h3>
<p>此方法是将所有元素进行判断返回一个布尔值，如果<code>所有元素</code>都满足判断条件，则返回true，否则为false：</p>
<pre><code>let arr = [1, 2, 3, 4, 5]
    const isLessThan4 = value =&gt; value &lt; 4
    const isLessThan6 =&gt; value =&gt; value &lt; 6
    arr.every(isLessThan4 ) //false
    arr.every(isLessThan6 ) //true
</code></pre>
<h3 id="5-arraysome">5. Array.some()</h3>
<p>此方法是将所有元素进行判断返回一个布尔值，如果<code>存在</code>元素都满足判断条件，则返回true，若所有元素都不满足判断条件，则返回false：</p>
<pre><code>let arr= [1, 2, 3, 4, 5]
    const isLessThan4 = value =&gt; value &lt; 4
    const isLessThan6 = value =&gt; value &gt; 6
    arr.some(isLessThan4 ) //true
    arr.some(isLessThan6 ) //false
</code></pre>
<h3 id="6-arrayreduce">6. Array.reduce()</h3>
<p>此方法是所有元素调用返回函数，返回值为最后结果,传入的值必须是函数类型：</p>
<pre><code>let arr = [1, 2, 3, 4, 5]
   const add = (a, b) =&gt; a + b
   let sum = arr.reduce(add)
   //sum = 15  相当于累加的效果
   与之相对应的还有一个 Array.reduceRight() 方法，区别是这个是从右向左操作的
</code></pre>
<h3 id="7-arraypush">7. Array.push()</h3>
<p>此方法是在数组的后面添加新加元素，此方法改变了数组的长度：</p>
<h3 id="8-arraypop">8. Array.pop()</h3>
<p>此方法在数组后面删除<code>最后一个元素</code>，并返回数组，此方法改变了数组的长度：</p>
<pre><code>let arr = [1, 2, 3, 4, 5]
    arr.pop()
    console.log(arr) //[1, 2, 3, 4]
    console.log(arr.length) //4
</code></pre>
<h3 id="9-arrayshift">9. Array.shift()</h3>
<p>此方法在数组后面删除<code>第一个元素</code>，并返回数组，此方法改变了数组的长度：</p>
<pre><code>let arr = [1, 2, 3, 4, 5]
    arr.shift()
    console.log(arr) //[2, 3, 4, 5]
    console.log(arr.length) //4 
</code></pre>
<h3 id="10-arrayunshift">10. Array.unshift()</h3>
<p>此方法是将一个或多个元素添加到数组的开头，并返回新数组的长度：</p>
<pre><code>let arr = [1, 2, 3, 4, 5]
    arr.unshift(6, 7)
    console.log(arr) //[6, 7, 1, 2, 3, 4, 5]
    console.log(arr.length) //7 
</code></pre>
<h3 id="11-arrayisarray">11. Array.isArray()</h3>
<p>判断一个对象是不是数组，返回的是布尔值</p>
<h3 id="12-arrayconcat">12. Array.concat()</h3>
<p>此方法是一个可以将多个数组拼接成一个数组：</p>
<pre><code>let arr1 = [1, 2, 3]
      arr2 = [4, 5]
  let arr = arr1.concat(arr2)
  console.log(arr)//[1, 2, 3, 4, 5]
</code></pre>
<h3 id="13-arraytostring">13. Array.toString()</h3>
<p>此方法将数组转化为字符串：</p>
<pre><code>let arr = [1, 2, 3, 4, 5];
   let str = arr.toString()
   console.log(str)// 1,2,3,4,5
</code></pre>
<h3 id="14-arrayjoin">14. Array.join()</h3>
<p>此方法也是将数组转化为字符串：</p>
<pre><code>let arr = [1, 2, 3, 4, 5];
  let str1 = arr.join()
  let str2 = arr.join(',')
  let str3 = arr.join('##')
  console.log(str1)// 1,2,3,4,5
  console.log(str2)// 1,2,3,4,5
  console.log(str3)// 1##2##3##4##5
</code></pre>
<p><code>可以设置元素之间的间隔</code></p>
<h3 id="15-arraysplice开始位置-删除的个数元素">15. Array.splice(开始位置， 删除的个数，元素)</h3>
<p><strong>万能方法，可以实现增删改：</strong><code>0增，3删，1改</code></p>
<pre><code>let arr = [1, 2, 3, 4, 5];
     let arr1 = arr.splice(2, 0 'haha')
     let arr2 = arr.splice(2, 3)
     let arr1 = arr.splice(2, 1 'haha')
     console.log(arr1) //[1, 2, 'haha', 3, 4, 5]新增一个元素
     console.log(arr2) //[1, 2] 删除三个元素
     console.log(arr3) //[1, 2, 'haha', 4, 5] 替换一个元素
</code></pre>
<h2 id="3-查找数组重复项">3. 查找数组重复项</h2>
<pre><code>let arr= [1,2,3,4,5,1,2];
let rep = [];
arr.forEach((item,index)=&gt;{
	if(arr.indexOf(item)!=index){ // 匹配数组元素第一个item位置和当前循环的index
        let obj = {};
        obj.key = (arr.indexOf(item) + 1) + '|' + (index + 1); // 用'|'分隔两个重复项的下标   
		obj.value = item;
        rep.push(obj);
	}
});
console.log(rep)
</code></pre>
<h2 id="4-扁平化数组flatten">4. 扁平化数组（flatten）</h2>
<p>扁平化就是将嵌套的数组变成一维数组的过程。</p>
<p>通常有几种方法可以实现扁平化：</p>
<ul>
<li>迭代递归法</li>
<li>曲线救国法</li>
</ul>
<h3 id="1-迭代递归">1. 迭代递归</h3>
<pre><code>var array = [[1,2,3],4,5,6,[[7]],[]]
var result = flatten(array)

console.log(result)
</code></pre>
<p><code>for...of 实现</code></p>
<pre><code>function flatten(arr, result = []) {
    for (let item of arr) {
        if (Array.isArray(item))
            flatten(item, result)
        else
            result.push(item)
    }
    return result
}
</code></pre>
<p>我们使用 result 变量存储结果，然后迭代当前数组，如果值也是数组则继续扁平化，否则将值放入 result 里。</p>
<p><code>生成器实现</code></p>
<p>迭代器的升级版就是生成器（Generator），其实这种扁平化最适合用生成器来做了，因为我们的目的就是生成一个个的值，然后把它们组织成一维数组：</p>
<pre><code>function* flat(arr) {
    for (let item of arr) {
        if (Array.isArray(item))
            yield* flat(item)
        else
            yield item
    }
}

function flatten(arr) {
    let result = []
    for (let val of flat(arr)) {
        result.push(val)
    }
    return result
}
</code></pre>
<p>这里有两点需要注意：</p>
<ol>
<li>嵌套 yield 需要再加一个星号，这被称为生成器委托。</li>
<li>不能使用 forEach 代替 for...of 但可以用 for 循环，因为 for 循环和for...of 可以中断迭代去执行 yield，forEach 不行</li>
</ol>
<p><code>reduce 三句实现法</code></p>
<pre><code>function flatten(arr) {
  return arr.reduce((flat, toFlatten) =&gt; {
    return flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten);
  }, []);
}
</code></pre>
<h3 id="2-曲线救国法">2. 曲线救国法</h3>
<p><code>降维打击法</code></p>
<pre><code>function flatten(arr){
    let str = arr.toString()
    return str.split(',')
}
</code></pre>
<p>转成字符串，之后再复原成数组，不过这个方法有个缺点，就是原来的空数组转的空字符串也会被放入新生成的数组里去。</p>
<h1 id="25-dom和bom相关">25. DOM和BOM相关</h1>
<h2 id="1dom">1.DOM</h2>
<h3 id="1-dom是什么">1. DOM是什么：</h3>
<p>DOM（Document Object Model）<code>文档对象模型</code>，是<strong>处理可扩展标志语言</strong>的标准编程接口。</p>
<p>DOM 是 <strong>W3C</strong> 的标准</p>
<h3 id="2-dom0级和dom2级有什么区别">2. DOM0级和DOM2级有什么区别：</h3>
<p><code>DOM0</code>级中为某个dom元素绑定多个事件时，只有最后一个事件有效。<code>onclick</code></p>
<p><code>DOM2</code>级中可以为单个元素绑定多个事件，每个事件都可以被触发。<code>addEventListener</code></p>
<h3 id="3-textcontent-innertext-innnerhtml-value的区别">3. textContent、innerText、innnerHTML、value的区别：</h3>
<ul>
<li>textContent用来获取和设置文本内容，与innerText的差别是:<code>textContent</code>获取到的内容包括了元素中的<code>style标签</code>和<code>script标签</code>的内容。</li>
<li>innerText只能获取和设置<code>文本</code>内容，不能获取和设置html代码</li>
<li>innerHTML可以获取和设置<code>html</code>代码</li>
<li>value获取的是<code>表单元素</code>的值</li>
</ul>
<h3 id="4-关于dom的api有什么">4. 关于dom的api有什么：</h3>
<p><strong>节点创建型api：</strong></p>
<ul>
<li>document.createElement()</li>
<li>document.createTextNode()</li>
<li>parent.cloneNode(true)</li>
<li>document.createDocumentFragment() <code>创建文档片段,解决大量添加节点造成的回流问题</code></li>
</ul>
<p><strong>页面修改型API：</strong></p>
<ul>
<li>parent.appendChild(child)</li>
<li>parent.insertBefore(newNode,referenceNode) <code>将新元素添加到父元素中指定的子元素前面</code></li>
<li>parent.removeChild(child)</li>
<li>parent.replcaeChild(newChild,oldChild)</li>
</ul>
<p><strong>节点查询型API：</strong></p>
<ul>
<li>document.getElementById()</li>
<li>document.getElementsByTagName() 返回的是一个即时的HTMLCollection类型</li>
<li>document.getElementsByName() 根据指定的name属性获取元素,返回的是一个即时的NodeList</li>
<li>document.getElementsByClassName() 返回的是一个即时的HTMLCollection</li>
<li>document.querySelector() 获取匹配到的第一个元素，采用的是深度优先搜索。</li>
<li>docuemnt.querySelectorAll()<br>
返回的是一个非即时的NodeList，也就是说结果不会随着文档树的变化而变化</li>
</ul>
<p><strong>节点关系型api：</strong></p>
<p><strong>父关系型：</strong></p>
<ul>
<li>node.parentNode()</li>
</ul>
<p><strong>兄弟关系型</strong></p>
<ul>
<li>node.previouSibling() 返回节点的前一个节点（包括元素节点，文本节点，注释节点）</li>
<li>node.previousElementSibling() 返回前一个元素节点</li>
<li>node.nextSibling() 返回下一个节点</li>
<li>node.nextElementSibling() 返回下一个元素节点</li>
</ul>
<p><strong>子关系型</strong></p>
<ul>
<li>parent.childNodes() 返回一个即时的NodeList，包括了文本节点和注释节点</li>
<li>parent.children() 一个即时的HTMLCollection，子节点都是Element</li>
<li>parent.firsrtNode()</li>
<li>parent.lastNode()</li>
<li>hasChildNodes()</li>
</ul>
<p><strong>元素属性型api：</strong></p>
<ul>
<li>element.setAttribute(“name”,“value”) 为元素添加属性</li>
<li>element.getAtrribute(“name”) 获取元素的属性</li>
</ul>
<p><strong>元素样式型api：</strong></p>
<ul>
<li>window.getComputedStyle(element) 返回一个CSSStyleDeclaration,可以从中访问元素的任意样式属性。</li>
<li>element.getBoundingClientRect() 返回一个DOMRect对象，里面<strong>包括了元素相对于可视区的位置top,left</strong>,以及元素的大小,单位为纯数字。可用于判断某元素是否出现在了可视区域。</li>
</ul>
<h3 id="5什么是事件监听">5.什么是事件监听:</h3>
<p><code>addEventListener()方法</code>，用于向指定元素添加事件句柄，它可以更简单的控制事件，语法为</p>
<p>element.addEventListener(event, function, useCapture);</p>
<ul>
<li>第一个参数是事件的类型(如 “click” 或 “mousedown”).</li>
<li>第二个参数是事件触发后调用的函数。</li>
<li>第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。</li>
</ul>
<p>事件传递有两种方式，<code>冒泡</code>和<code>捕获</code></p>
<p>事件传递定义了元素事件触发的顺序，如果你将P元素插入到div元素中，用户点击P元素，</p>
<p>在冒泡中，内部元素先被触发，然后再触发外部元素，<br>
捕获中，外部元素先被触发，在触发内部元素，</p>
<h3 id="6-说说前端中的事件流">6. 说说前端中的事件流</h3>
<p>事件发生时会在元素节点之间按照特定的顺序传播，整个过程分为<code>捕获阶段，目标阶段和冒泡阶段</code>，这个<code>传播过程</code>叫做Dom事件流。</p>
<p>事件冒泡：从事件源逐级向上传播到DOM最顶层节点的过程。</p>
<p>事件捕获：从DOM最顶层节点逐级向下传播到事件源的过程。</p>
<p>addEventListener用于指定事件处理程序，共接收三个参数。分别是触发事件，事件处理程序函数以及一个布尔值。第三个参数默认为false，表示在该事件的处理函数会在冒泡阶段被调用。若改为true，则表示事件处理函数会在捕获阶段被调用。</p>
<h3 id="7-如何让事件先冒泡后捕获-2">7. 如何让事件先冒泡后捕获</h3>
<p>对于<code>目标元素</code>来说，如果DOM节点通过addEventListener同时绑定了两个事件监听函数，一个用于捕获，一个用于冒泡，那么两个事件的执行顺序是按照代码添加的顺序执行的。所以，先绑定冒泡的函数，再绑定捕获的函数，即可实现。</p>
<p>对于<code>非目标元素</code>来说，可以给捕获事件的处理程序添加一个定时器，将处理程序推入下一个宏任务执行。</p>
<h3 id="8-说一下事件代理">8. 说一下事件代理：</h3>
<p>事件委托是指 不在子节点单独设置事件监听器，而将事件<code>监听器设置在父节点上</code>，再利用<code>冒泡原理</code>使每一个子节点都能触发该事件。</p>
<p>事件委托的优点：只操作一次Dom，提高了程序的性能。</p>
<p>常用于</p>
<ul>
<li>ul和li标签的事件监听，一般采用事件委托机制将事件监听器绑定在ul上。</li>
<li>还适合动态元素的绑定，新添加的子元素不需单独添加事件处理程序。</li>
</ul>
<p><strong>（1）了解事件代理吗，这样做有什么好处</strong></p>
<p>事件代理就是说我们将事件添加到本来要添加的事件的父节点，将事件委托给父节点来触发处理函数，这通常会使用在大量的同级元素需要添加同一类事件的时候，比如一个动态的非常多的列表，需要为每个列表项都添加点击事件，这时就可以使用事件代理，通过判断e.target.nodeName来判断发生的具体元素，这样做的好处是减少事件绑定，同事动态的DOM结构任然可以监听，事件代理发生在冒泡阶段</p>
<p><strong>（2）事件代理在捕获阶段的实际应用</strong></p>
<p>可以在父元素层面阻止事件向子元素传播，也可代替子元素执行某些操作。</p>
<h3 id="9-事件类型相关">9. 事件类型相关：</h3>
<p>（1）<code>mouseover和mouseenter的区别</code></p>
<ul>
<li>mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移出事件是mouseout。</li>
<li>mouseenter：鼠标移入子元素时不会再次触发mouseenter事件，对应的移出事件是mouseleave。</li>
</ul>
<p>（2）<code>三种键盘事件的区别：</code></p>
<ul>
<li>keyup: 松开键盘触发</li>
<li>keydown:按下键盘触发</li>
<li>keypress:不能识别功能键，比如ctrl,alt,shift,左右箭头。可以区分大小写。</li>
</ul>
<p>在输入框中按下一个键的全过程：触发keydown/keypress事件-&gt;文字键入输入框中-&gt;触发keyup事件</p>
<p>按下按键后<code>自动对焦</code>输入框，应该使用<code>keyup</code>，不应该使用keydown/keypress,因为后者会使按键落入输入框中,对于回车键的话还不能使用keypress。</p>
<h3 id="10-静态绑定事件与动态绑定事件的区别">10. 静态绑定事件与动态绑定事件的区别：</h3>
<p><strong>静态绑定</strong>事件是指直接在Html标签上通过οnclick=&quot;hide()&quot;来绑定事件。</p>
<p>缺点：</p>
<ul>
<li>html和js文件存在耦合，不符合结构和行为分离的原则。</li>
<li>可能存在引发错误，如果js代码还没加载就触发该事件则会抛出错误</li>
</ul>
<p><strong>动态绑定</strong>事件是指通过js动态绑定事件，element.onclick() element.addEventListener()。</p>
<h3 id="11-元素的位置和大小">11. 元素的位置和大小</h3>
<p><strong>① offset系列：</strong><br>
<strong>offsetTop（获取元素位置）: 相对于带有‘定位’的父元素的偏移量</strong><br>
<code>offsetHeight: content+padding+border</code></p>
<p><strong>② cilent系列：</strong><br>
<strong>clientHeight(获取元素宽高): content+padding,不包含border</strong></p>
<p><strong>③ scroll系列：</strong><br>
<strong>scrollTop（获取滚动的距离）</strong>: 向下滚动后，上面被卷去的距离，即隐藏的高度。</p>
<p><strong>④ document.clientWidth与document.style.width的区别：</strong></p>
<ul>
<li>区别1：前者可以获取任意样式表中的width样式值，包括行内样式的，内嵌样式的，外部样式的；后者只能获取行内的样式。</li>
<li>区别2：clientWidth获取的是数字型的，style获取的带有px后缀</li>
<li>区别3：clientWidth包含了padding,而style.width只包含content。</li>
<li>区别4：clientWidth是只读属性，所以一般用于获取元素的大小；而style.width是可读可写的，可用于获取，也可用于修改。</li>
</ul>
<p><strong>⑤ 判断一个元素是否已经出现在了可视区域：(此问题可应用在懒加载中)</strong><br>
<code>使用element.getBoundingClientRect().top获取在可视区的位置。</code></p>
<pre><code>window.addEventListener(&quot;scroll&quot;, function () {
    let viewPortHeight = window.pageYOffset;
    let offset = box2.getBoundingClientRect().top;
    if (offset &lt; viewPortHeight) {
        if (offset + box2.offsetHeight &lt; 0) {
            console.log(&quot;他走了&quot;);
        } else {
            console.log(&quot;他来啦他来啦&quot;);
        }
    }
});
</code></pre>
<h3 id="12-js拖动及拖拽功能的实现">12. js拖动及拖拽功能的实现</h3>
<p><code>（1）拖动功能的实现：</code></p>
<p>前置条件：</p>
<ol>
<li>拖动事件的三个过程：鼠标按下mousedown,鼠标移动mousemove,鼠标松开mouseup<br>
鼠标按下后执行mousemove事件。</li>
<li>盒子采用绝对定位，通过left和top属性来修改位置。</li>
</ol>
<p>方法一：（直接根据鼠标移动的距离确定元素移动的距离）</p>
<ul>
<li>鼠标的坐标通过clientX,clientY获取：</li>
<li>盒子的定位信息：鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的offetLeft.</li>
</ul>
<p><code>（2）拖拽功能的实现：</code></p>
<p>使用html5提供的拖拽API（Drag 和 drop）</p>
<h2 id="2-bom浏览器对象模型">2. (BOM)浏览器对象模型：</h2>
<h3 id="1-实用的bom属性对象方法">1. 实用的BOM属性对象方法：</h3>
<p><code>location对象</code></p>
<ul>
<li>location.href– 返回或设置当前文档的URL</li>
<li>location.search – 返回URL中的查询字符串部分。例如 http://www.dreamdu.com/dreamdu.php?id=5&amp;name=dreamdu 返回包括(?)后面的内容?id=5&amp;name=dreamdu</li>
<li>location.hash – 返回URL#后面的内容，如果没有#，返回空</li>
<li>location. – 返回URL中的域名部分，例如www.dreamdu.com</li>
<li>location.hostname – 返回URL中的主域名部分，例如dreamdu.com</li>
<li>location.pathname – 返回URL的域名后的部分。例如 http://www.dreamdu.com/xhtml/ 返回/xhtml/</li>
<li>location.port – 返回URL中的端口部分。例如 http://www.dreamdu.com:8080/xhtml/ 返回8080</li>
<li>location.protocol – 返回URL中的协议部分。例如 http://www.dreamdu.com:8080/xhtml/ 返回(//)前面的内容http:</li>
<li>location.assign() – 重定向页面，与location.href一样，会记录历史，能后退页面</li>
<li>location.replace() – 设置当前文档的URL，不记录历史，不能后退页面</li>
<li>location.reload() – 重载当前页面,相当于F5。添加参数true则表示强制刷新，直接从服务器获取数据，不从浏览器缓存中取数据，相当于Ctrl+F5</li>
</ul>
<p><code>history对象</code></p>
<ul>
<li>history.go(n) – 前进或后退指定的页面数;</li>
<li>history.back() – 后退一页</li>
<li>history.forward() – 前进一页</li>
</ul>
<p><code>navigator对象</code></p>
<ul>
<li>navigator包含了用户浏览器的信息</li>
<li>navigator.userAgent – 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)</li>
<li>navigator.cookieEnabled – 返回浏览器是否支持(启用)cookie</li>
</ul>
<h3 id="2-settimeoutfn100100毫秒是如何权衡的">2. setTimeout(fn,100);100毫秒是如何权衡的：</h3>
<p>100ms指的是将回调函数加入到任务队列所花的时间。至于具体什么时候执行，需要看主线程的执行栈中是否还有任务在执行。</p>
<h3 id="3-requestanimationframe">3. requestAnimationFrame</h3>
<p>特点：requestAnimationFrame采用系统时间间隔，保证了最佳的绘制效率。</p>
<p>使用方法：requestAnimationFrame接收一个回调函数，这个回调函数会在下一次浏览器重绘之前调用。</p>
<h3 id="4-分别用setintervalsettimeoutrequestanimationframe制作有个简单的进度条效果">4. 分别用setInterval,setTimeout,requestAnimationFrame制作有个简单的进度条效果：</h3>
<p><code>setInterval:</code></p>
<pre><code>&lt;div
     style=&quot;width: 0; height: 20px; background-color: orange&quot;
     id=&quot;div&quot;
     &gt;&lt;/div&gt;
&lt;script&gt;
    let timer = setInterval(() =&gt; {
        if (parseInt(div.style.width) &gt;= 500) {
            return clearInterval(timer);
        }
        console.log(div.style.width);
        div.style.width = parseInt(div.style.width) + 5 + &quot;px&quot;;
        div.innerHTML = parseInt(div.style.width) / 5 + &quot;%&quot;;
    }, 16);
&lt;/script&gt;
</code></pre>
<p>setTimeout:</p>
<pre><code>&lt;div
     style=&quot;width: 0; height: 20px; background-color: orange&quot;
     id=&quot;div&quot;
     &gt;&lt;/div&gt;
&lt;script&gt;
    let timer = setTimeout(function fn() {
        if (parseInt(div.style.width) &lt; 500) {
            div.style.width = parseInt(div.style.width) + 5 + &quot;px&quot;;
            div.innerHTML = parseInt(div.style.width) / 5 + &quot;%&quot;;
            timer = setTimeout(fn, 16);
        } else {
            clearTimeout(timer);
        }
    }, 16);
&lt;/script&gt;
</code></pre>
<p>requestAnimationFrame:类似于setTimeout,需要一次次的调用</p>
<pre><code>&lt;div
     style=&quot;width: 0; height: 20px; background-color: orange&quot;
     id=&quot;div&quot;
     &gt;&lt;/div&gt;
&lt;script&gt;
    let timer = requestAnimationFrame(function fn() {
        if (parseInt(div.style.width) &lt; 500) {
            div.style.width = parseInt(div.style.width) + 5 + &quot;px&quot;;
            div.innerHTML = parseInt(div.style.width) / 5 + &quot;%&quot;;
            requestAnimationFrame(fn);
        } else {
            cancelAnimationFrame(timer);
        }
    });
&lt;/script&gt;
</code></pre>
<h3 id="5-js中的轮播实现原理假如一个页面上有两个轮播你会怎么实现">5. js中的轮播实现原理？假如一个页面上有两个轮播，你会怎么实现？</h3>
<ol>
<li>让图片存在一个数组中，然后将最后一张图片重复添加在数组的头部，将第一张图片重复添加在数组的最后。</li>
<li>然后准备一个只能显示一张图片的盒子，对盒子做溢出隐藏处理。</li>
<li>通过定时器增减索引，显示对应的图片，实现轮播功能。</li>
</ol>
<p>如果有两个轮播，可封装一个轮播组件，将需要轮播的图片作为参数传递。</p>
<h1 id="26-服务端渲染server-side-render">26. 服务端渲染（server side render）</h1>
<p><code>服务端渲染(SSR)</code>：页面上的内容是由服务器上的代码决定的。即，页面上的内容在服务器上已经生成好了，服务器把这个内容给到浏览器，浏览器拿到这个内容直接显示在页面上即可。</p>
<p><code>客户端渲染(CSR)</code> ：一个网页是由JS文件渲染出来的，而不是服务器直接返回回来的。<br>
<img src="https://Tyloo-code.github.io/post-images/1615364099956.jpg" alt="" loading="lazy"></p>
<h2 id="1-ssr的优势">1. SSR的优势</h2>
<ol>
<li>
<p>更利于SEO<br>
服务端渲染返回给客户端的是已经获取了异步数据并执行JavaScript脚本的最终HTML，网络爬中就可以抓取到完整页面的信息。</p>
</li>
<li>
<p>更利于首屏渲染<br>
首屏的渲染是node发送过来的html字符串，并不依赖于js文件了，这就会使用户更快的看到页面的内容。尤其是针对大型单页应用，打包后文件体积比较大，普通客户端渲染加载所有所需文件时间较长，首页就会有一个很长的白屏等待时间。</p>
</li>
</ol>
<h2 id="2-ssr的劣势">2. SSR的劣势</h2>
<ol>
<li>
<p>服务端压力较大</p>
</li>
<li>
<p>开发条件受限</p>
</li>
<li>
<p>学习成本相对较高</p>
</li>
</ol>
<h1 id="27-js-垃圾回收机制">27.  JS 垃圾回收机制</h1>
<h2 id="1-垃圾回收">1. 垃圾回收</h2>
<p>JavaScript 中的内存管理是自动执行的，而且是不可见的。我们创建基本类型、对象、函数……所有这些都需要内存。</p>
<h2 id="2-可达性">2. 可达性</h2>
<p>JavaScript 中内存管理的主要概念是可达性。</p>
<p>简单地说，“可达性” 值就是那些以某种方式<code>可访问</code>或<code>可用</code>的值，它们被保证存储在内存中。</p>
<ol>
<li>有一组基本的固有可达值，由于显而易见的原因无法删除。例如:</li>
</ol>
<ul>
<li>本地函数的局部变量和参数</li>
<li>当前嵌套调用链上的其他函数的变量和参数</li>
<li>全局变量</li>
<li>还有一些其他的，内部的</li>
</ul>
<p><code>这些值称为根。</code></p>
<ol start="2">
<li>如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的。</li>
</ol>
<ul>
<li>如果局部变量中有对象，并且该对象具有引用另一个对象的属性，则该对象被视为<strong>可达性</strong>， 它引用的那些也是可以访问的</li>
</ul>
<p><strong>下面是最简单的例子:</strong></p>
<pre><code>// user 具有对象的引用
let user = {
  name: &quot;John&quot;
};
</code></pre>
<p><img src="https://Tyloo-code.github.io/post-images/1615366337580.png" alt="" loading="lazy"><br>
这里箭头表示一个对象引用。全局变量<code>“user”</code>引用对象 <code>{name:“John”}</code>(为了简洁起见，我们将其命名为John)。John 的 <code>“name”</code>属性存储一个基本类型，因此它被绘制在对象中。</p>
<p>如果 <code>user</code> 的值被覆盖，则引用丢失:</p>
<pre><code>user = null;
</code></pre>
<p><img src="https://Tyloo-code.github.io/post-images/1615366388527.png" alt="" loading="lazy"><br>
现在 John 变成不可达的状态，没有办法访问它，没有对它的引用。垃圾回收器将丢弃 John 数据并释放内存。</p>
<h2 id="3两个引用">3.两个引用</h2>
<p>现在让我们假设我们将引用从 <code>user</code>复制到 <code>admin</code>:</p>
<pre><code>// user具有对象的引用
let user = {
  name: &quot;John&quot;
};
let admin = user;
</code></pre>
<p><img src="https://Tyloo-code.github.io/post-images/1615366454334.png" alt="" loading="lazy"><br>
现在如果我们做同样的事情:</p>
<pre><code>user = null;
</code></pre>
<p>该对象仍然可以通过 <code>admin</code> 全局变量访问，所以它在内存中。如果我们也覆盖<code>admin</code>，那么它可以被释放。</p>
<h2 id="4-相互关联的对象">4. 相互关联的对象</h2>
<p>现在来看一个更复杂的例子， family 对象：</p>
<pre><code>function marry (man, woman) {
  woman.husban = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman
  }
}

let family = marry({
  name: &quot;John&quot;
}, {
  name: &quot;Ann&quot;
})
</code></pre>
<p>产生的内存结构:<br>
<img src="https://Tyloo-code.github.io/post-images/1615366611256.png" alt="" loading="lazy"><br>
现在让我们删除两个引用:</p>
<pre><code>delete family.father;
delete family.mother.husband;
</code></pre>
<p><img src="https://Tyloo-code.github.io/post-images/1615366634406.png" alt="" loading="lazy"><br>
仅仅删除这两个引用中的一个是不够的，因为所有对象仍然是可访问的。</p>
<p>但是如果我们把这两个都删除，那么我们可以看到 John 不再有传入的引用:<br>
<img src="https://Tyloo-code.github.io/post-images/1615366651083.png" alt="" loading="lazy"><br>
输出引用无关紧要。只有传入的对象才能使对象可访问，因此，John 现在是不可访问的，并将从内存中删除所有不可访问的数据。</p>
<p>垃圾回收之后：<br>
<img src="https://Tyloo-code.github.io/post-images/1615366668995.png" alt="" loading="lazy"></p>
<h2 id="5-内部算法">5. 内部算法</h2>
<p>基本的垃圾回收算法称为“<strong>标记-清除</strong>”，定期执行以下“垃圾回收”步骤:</p>
<ul>
<li>垃圾回收器获取根并“<strong>标记</strong>”(记住)它们。</li>
<li>然后它访问并“标记”所有来自它们的引用。</li>
<li>然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。</li>
<li>以此类推，直到有未访问的引用(可以从根访问)为止。</li>
<li>除标记的对象外，所有对象都被删除。</li>
</ul>
<p>例如，对象结构如下:<br>
<img src="https://Tyloo-code.github.io/post-images/1615366772644.png" alt="" loading="lazy"><br>
我们可以清楚地看到右边有一个“不可到达的块”。现在让我们看看“<strong>标记并清除</strong>”垃圾回收器如何处理它。</p>
<p><strong>第一步标记根</strong><br>
<img src="https://Tyloo-code.github.io/post-images/1615367324843.png" alt="" loading="lazy"><br>
<strong>然后标记他们的引用</strong><br>
<img src="https://Tyloo-code.github.io/post-images/1615367344647.png" alt="" loading="lazy"><br>
<strong>以及子孙代的引用:</strong><br>
<img src="https://Tyloo-code.github.io/post-images/1615367365917.png" alt="" loading="lazy"><br>
现在进程中不能访问的对象被认为是不可访问的，将被删除:<br>
<img src="https://Tyloo-code.github.io/post-images/1615367388777.png" alt="" loading="lazy"><br>
<code>这就是垃圾收集的工作原理。JavaScript引擎应用了许多优化，使其运行得更快，并且不影响执行。</code></p>
<h2 id="6面试怎么回答">6.面试怎么回答</h2>
<p><strong>1）问什么是垃圾</strong></p>
<p>一般来说没有被引用的对象就是垃圾，就是要被清除， 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。</p>
<p><strong>2）如何检垃圾</strong></p>
<p>一种算法是标记 标记-清除 算法</p>
<h1 id="28-eventloop">28. eventloop</h1>
<p><code>Event Loop</code>即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用<strong>异步</strong>的原理。</p>
<h2 id="1-进程和线程">1. 进程和线程</h2>
<p>线程，是程序执行流的最小单位。线程可与同属一个进程的其他线程共享所拥有的全部资源，同一进程中的多个线程之间可以并发执行。线程有<code>就绪</code>，<code>阻塞</code>，<code>运行</code>三种基本状态。</p>
<p>阮一峰大神针对进程和线程的类比，很是形象：<code>计算机的核心CPU</code>，是个工厂，时刻运转着，工厂里有很多个车间（进程），一个车间开工其他车间不能开工，就是说：<code>单核CPU一次只能运行一个进程。任何时候，CPU总是运行一个进程</code>。</p>
<p>而一个车间里面有很多工人（线程），协同完成一个任务。所以：<code>一个进程可以包括多个线程</code>。车间空间是工人共享的，<code>一个进程中的内存空间是所有线程共享的</code>。</p>
<p>但是房间大小不同个，容纳量不同，有些线程进去了，其他线程就不能再进去使用了。这就是：<code>一个线程使用某些共享内存时，其他线程得等它结束后才能使用共享内存</code>。</p>
<p>内存可以上锁，防止其他线程进来，【互斥锁】也就是防止多个线程读写同一块内存区域。</p>
<p>还有些共享内存比较大，可以容纳多个线程，但是也是有限的，只能容纳固定数目的线程使用。如何保证多个线程不冲突呢？内存门口有个钥匙架，如果发现钥匙架空了，那就不能再进去了【信号量】。</p>
<h2 id="2-函数调用栈与任务队列">2. 函数调用栈与任务队列</h2>
<p>Javascript有一个main thread 主进程和call-stack（一个调用堆栈），在对一个调用堆栈中的task处理的时候，其他的都要等着。当在执行过程中遇到一些类似于setTimeout等异步操作的时候，会交给浏览器的其他模块(以webkit为例，是webcore模块)进行处理，当到达setTimeout指定的延时执行的时间之后，task(回调函数)会放入到任务队列之中。一般不同的异步任务的回调函数会放入不同的任务队列之中。等到调用栈中所有task执行完毕之后，接着去执行任务队列之中的task(回调函数)。</p>
<p>任务队列是“先进先出”的数据结构，先来的优先被主线程读取。<br>
<img src="https://Tyloo-code.github.io/post-images/1615368924655.png" alt="" loading="lazy"></p>
<p>在上图中，调用栈中遇到DOM操作、ajax请求以及setTimeout等WebAPIs的时候就会交给浏览器内核的其他模块进行处理，webkit内核在Javasctipt执行引擎之外，有一个重要的模块是webcore模块。对于图中WebAPIs提到的三种API，webcore分别提供了DOM Binding、network、timer模块来处理底层实现。等到这些模块处理完这些操作的时候将回调函数放入任务队列中，之后等栈中的task执行完之后再去执行任务队列之中的回调函数。</p>
<p><strong>小结：</strong></p>
<ul>
<li>所有的代码都要通过函数调用栈中调用执行。</li>
<li>当遇到前文中提到的APIs的时候，会交给浏览器内核的其他模块进行处理。</li>
<li>任务队列中存放的是回调函数。</li>
<li>等到调用栈中的task执行完之后再回去执行任务队列之中的task。</li>
</ul>
<h2 id="3-宏任务与微任务">3. 宏任务与微任务</h2>
<p>其中setTimeout叫做macro-task(宏任务)，当然如我们所想，还有如promise的micro-task(微任务)。</p>
<ol>
<li>
<p>macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。</p>
</li>
<li>
<p>micro-task包括：process.nextTick, Promise, Object.observe, MutationObserver</p>
</li>
</ol>
<p>事件循环的顺序是从script开始第一次循环，随后全局上下文进入函数调用栈，碰到macro-task就将其交给处理它的模块处理完之后将回调函数放进macro-task的队列之中，碰到micro-task也是将其回调函数放进micro-task的队列之中。直到函数调用栈清空只剩全局执行上下文，然后开始执行所有的micro-task。当所有可执行的micro-task执行完毕之后。循环再次执行macro-task中的一个任务队列，执行完之后再执行所有的micro-task，就这样一直循环。</p>
<p><strong>总结：</strong></p>
<ol>
<li>
<p>不同的任务会放进不同的任务队列之中。</p>
</li>
<li>
<p>先执行macro-task，等到函数调用栈清空之后再执行所有在队列之中的micro-task。</p>
</li>
<li>
<p>等到所有micro-task执行完之后再从macro-task中的一个任务队列开始执行，就这样一直循环。</p>
</li>
<li>
<p>当有多个macro-task(micro-task)队列时，事件循环的顺序是按上文macro-task(micro-task)的分类中书写的顺序执行的。</p>
</li>
</ol>
<h2 id="4事件循环event-loop">4.事件循环（Event Loop）</h2>
<p>JavaScript是单线程的，单线程意味着需要一个任务队列来管理任务事件，任务分为两种：<code>同步任务</code>和<code>异步任务</code>。同步任务是在主线程上面排队执行的任务，只有前面任务完成，下一个任务才能执行。异步任务是不进入主线程，而是进入任务队列中，只有通知主线程某个异步任务可以执行了，该任务方可执行。<br>
<img src="https://Tyloo-code.github.io/post-images/1615368575238.png" alt="" loading="lazy"></p>
<ul>
<li>我们的同步任务在主线程上运行会形成一个执行栈</li>
<li>如果碰到异步任务，比如setTimeout、onClick等等的一些操作，我们会将他的执行结果放入队列，此期间主线程不阻塞</li>
<li>等到主线程中的所有同步任务执行完毕，就会通过event loop在队列里面从头开始取，在执行栈中执行</li>
<li>event loop永远不会断</li>
<li>以上的这一整个流程就是Event Loop（事件循环机制）</li>
</ul>
<h1 id="29-如何快速让字符串变成以千为精度的数字">29. 如何快速让字符串变成以千为精度的数字</h1>
<h2 id="1-字符串转换成数字的三种方法">1. 字符串转换成数字的三种方法</h2>
<p><code>转换函数、强制类型转换、利用js变量弱类型转换</code>。</p>
<ol>
<li>转换函数：<br>
js提供了parseInt()和parseFloat()两个转换函数。前者把值转换成整数，后者把值转换成浮点数。只有对String类型调用这些方法，这两个函数才能正确运行；对其他类型返回的都是NaN(Not a Number)。</li>
</ol>
<p>parseInt()方法还有基模式，可以把二进制、八进制、十六进制或其他任何进制的字符串转换成整数。基是由parseInt()方法的第二个参数指定的，示例如下：</p>
<pre><code>parseInt(&quot;AF&quot;,   16);   //returns   175
parseInt(&quot;10&quot;,   2);   //returns   2
parseInt(&quot;10&quot;,   8);   //returns   8
parseInt(&quot;10&quot;,   10);   //returns   10
</code></pre>
<ol start="2">
<li>强制类型转换<br>
ECMAScript中可用的3种强制类型转换如下：</li>
</ol>
<ul>
<li>Boolean(value)——把给定的值转换成Boolean型；</li>
<li>Number(value)——把给定的值转换成数字（可以是整数或浮点数）；</li>
<li>String(value)——把给定的值转换成字符串。</li>
</ul>
<ol start="3">
<li>利用js变量弱类型转换</li>
</ol>
<h2 id="2-数字千位符格式化">2. 数字千位符格式化</h2>
<pre><code>function toThousands(num) {
    var result = '', counter = 0;
    num = (num || 0).toString();
    for (var i = num.length - 1; i &gt;= 0; i--) {
        counter++;
        result = num.charAt(i) + result;
        if (!(counter % 3) &amp;&amp; i != 0) { result = ',' + result; }
    }
    return result;
}
</code></pre>
<h1 id="30-js中v8引擎的详解">30. js中v8引擎的详解</h1>
<h2 id="1-v8引擎出现的原因">1. v8引擎出现的原因</h2>
<p>这里先说一下什么是<code>编译型语言</code>和<code>解释性语言</code>：</p>
<p><code>编译型</code>语言： 在程序执行之前必须进行专门的编译过程，有如下特点：</p>
<ul>
<li><code>只须编译一次</code>就可以把源代码<code>编译成机器语言</code>，后面的执行<code>无须重新编译</code>，直接使用之前的编译结果就可以；因此其执行的<code>效率比较高</code></li>
<li>编译性语言代表：C、C++、Java、Pascal/Object Pascal（Delphi）</li>
<li>程序执行效率比较高，但比较依赖编译器，因此跨平台性差一些</li>
</ul>
<p><code>解释型</code>语言 - 解释型语言，支持动态类型，弱类型，在<code>程序运行</code>的时候<code>才进行编译</code>，而编译前需要确定变量的类型，效率比较低，对不同系统平台有较大的兼容性</p>
<ul>
<li>源代码<code>不能直接</code>翻译成机器语言，而是先翻译成<code>中间代码</code>，再由<code>解释器</code>对中间代码进行<code>解释运行</code> 源代码—&gt;中间代码—&gt;机器语言</li>
<li>程序<code>不需要编译</code>，程序在运行时才翻译成机器语言，<code>每执行一次都要翻译一次</code></li>
<li>解释型语言代表：Python、JavaScript、Shell、Ruby、MATLAB等</li>
<li>运行效率一般相对<code>比较低</code>，<code>依赖解释器</code>，跨平台性好</li>
</ul>
<p><strong>比较：</strong></p>
<ul>
<li>一般，<code>编译型语言的运行效率比解释型语言更高</code>；但是不能一概而论，部分解释性语言的解释器通过在运行时动态优化代码，甚至能使解释性语言的性能超过编译性语言；</li>
<li>编译性语言的跨平台特性比解释性语言差一些；</li>
</ul>
<p>进过以上说明，解释型语言，<code>运行效率低</code>，随着Web相关技术的发展，JavaScript所要承担的工作也越来越多，早就超越了“表单验证”的范畴，<code>这就更需要快速的解析和执行JavaScript脚本</code>。<code>V8引擎</code>就是为解决这一问题而生，在node中也是采用该引擎来解析JavaScript</p>
<h2 id="2-渲染引擎及网页渲染">2. 渲染引擎及网页渲染</h2>
<p>为用户提供网页浏览服务无疑是最重要的功能，如下介绍：</p>
<h3 id="1-渲染引擎">1. 渲染引擎</h3>
<ul>
<li><code>渲染引擎</code> - 能够能够将HTML/CSS/JavaScript文本及相应的<code>资源文件</code>转换成<code>图像</code>结果.</li>
<li><code>作用</code> - 将<code>资源文件</code>转化为<code>用户可见</code>的结果。</li>
<li>渲染引擎的种类 - Tridend(IE)、Gecko(FF),WebKit(Safari,Chrome,Andriod浏览器)等.</li>
<li>介绍 - WebKit是由苹果2005年发起的一个开源项目，引起了众多公司的重视，几年间被很多公司所采用，在移动端更占据了垄断地位。更有甚者，开发出了基于WebKit的支持HTML5的web操作系统(如：Chrome OS、Web OS)。</li>
</ul>
<p><strong>WebKit的大致结构</strong><br>
<img src="https://Tyloo-code.github.io/post-images/1616375134643.png" alt="" loading="lazy"><br>
<img src="https://Tyloo-code.github.io/post-images/1616375172770.png" alt="" loading="lazy"></p>
<h3 id="2-网页渲染流程">2. 网页渲染流程</h3>
<p>上面介绍了渲染引擎的各个模块，那么一张网页，要经历怎样的过程，才能展示给用户。<br>
<img src="https://Tyloo-code.github.io/post-images/1616375416528.png" alt="" loading="lazy"></p>
<p><code>过程</code> - 首先是网页内容，输入到HTML解析器，HTML解析器解析，然后构建DOM树，在这期间如果遇到JavaScript代码则交给JavaScript引擎处理；如果来自CSS解析器的样式信息，构建一个内部绘图模型。该模型由布局模块计算模型内部各个元素的位置和大小信息，最后由绘图模块完成从该模型到图像的绘制。在网页渲染的过程中，大致可分为下面3个阶段：<br>
<img src="https://Tyloo-code.github.io/post-images/1616375499789.png" alt="" loading="lazy"></p>
<p>上述是一个完整的渲染过程，现代网页很多都是动态的，随着网页与用户的交互，浏览器需要不断的重复渲染过程。</p>
<h3 id="3-javascript引擎">3. JavaScript引擎</h3>
<p><img src="https://Tyloo-code.github.io/post-images/1616376387769.png" alt="" loading="lazy"><br>
JavaScript本质上是一种<code>解释型语言</code>，与编译型语言不同的是它需要<code>一边执行一边解析</code>，而编译型语言在执行时已经完成编译，可直接执行，有更快的执行速度(如上图所示)。JavaScript代码是在浏览器端解析和执行的，如果需要时间太长，会影响用户体验。那么<code>提高JavaScript的解析速度</code>就是当务之急。JavaScript引擎和渲染引擎的关系如下图所示：<br>
<img src="https://Tyloo-code.github.io/post-images/1616376459980.png" alt="" loading="lazy"><br>
avaScript语言是解释型语言，为了<code>提高性能</code>，引入了J<code>ava虚拟机</code>和<code>C++编译器</code>中的众多<code>技术</code>。现在JavaScript引擎的执行过程大致是:<br>
<code>源代码</code>-→<code>抽象语法树</code>-→<code>字节码</code>-→<code>JIT</code>-→<code>本地代码</code>(V8引擎没有中间字节码)。</p>
<p>V8更加直接的将<code>抽象语法树</code>通过<code>JIT技术</code>转换成<code>本地代码</code>，<code>放弃了</code>在<code>字节码</code>阶段可以进行的一些性能优化，但保证了执行速度。在V8生成本地代码后，也会通过Profiler采集一些信息，来优化本地代码。虽然，少了生成字节码这一阶段的性能优化，但极大减少了转换时间。</p>
<h2 id="3-v8引擎">3. V8引擎</h2>
<ul>
<li>V8引擎是一个<code>JavaScript引擎</code>实现，最初由一些语言方面专家设计，后被谷歌收购，随后谷歌对其进行了<code>开源</code>。</li>
<li>V8使用<code>C++开发</code>，在运行JavaScript之前，相比其它的JavaScript的引擎转换成字节码或解释执行，<code>V8将其编译成原生机器码</code>（IA-32, x86-64, ARM, or MIPS CPUs），并且使用了如<code>内联缓存</code>（inline caching）等方法来<code>提高性能</code>。</li>
<li>有了这些功能，JavaScript程序在V8引擎下的运行速度媲美二进制程序。</li>
<li>V8支持<code>众多操作系统</code>，如windows、linux、android等，也支持其他硬件架构，如IA32,X64,ARM等，具有很好的<code>可移植</code>和<code>跨平台特性</code>。</li>
</ul>
<h2 id="4-数据表示">4. 数据表示</h2>
<p>JavaScript是一种动态类型语言，<code>在编译时并不能准确知道变量的类型</code>，<code>只可以在运行时确定</code>，这就不像c++或者java等静态类型语言，在编译时候就可以确切知道变量的类型。然而，<code>在运行时计算和决定类型，会严重影响语言性能</code>，这也就是JavaScript运行效率比C++或者JAVA低很多的原因之一。</p>
<p>在C++中，源代码需要经过编译才能执行，在生成本地代码的过程中，变量的地址和类型已经确定，运行本地代码时利用数组和位移就可以存取变量和方法的地址，不需要再进行额外的查找，几个机器指令即可完成，节省了确定类型和地址的时间。由于JavaScript是无类型语言，那就不能像c++那样在执行时已经知道变量的类型和地址，需要临时确定。JavaScript 和C++有以下几个区别：</p>
<ul>
<li>
<p><code>编译确定位置</code> -<code>C++</code>编译阶段确定位置偏移信息，在<code>执行时直接存取</code>，<code>JavaScript</code>在<code>执行阶段确定</code>，而且执行期间可以修改对象属性；</p>
</li>
<li>
<p><code>偏移信息共享</code> - <code>C++</code>有类型定义，执行时<code>不能动态改变</code>，可共享偏移信息，<code>JavaScript</code>每个对象都是<code>自描述</code>，属性和位置偏移信息都包含在自身的结构中；</p>
</li>
<li>
<p><code>偏移信息查找</code> - <code>C++</code>查找偏移地址很简单，在编译代码阶段，对使用的某类型成员变量<code>直接设置偏移位置</code>，<code>JavaScript</code>中使用一个对象，需要通过<code>属性名匹配</code>才能找到相应的值，需要更多的操作。</p>
</li>
</ul>
<figure data-type="image" tabindex="33"><img src="https://Tyloo-code.github.io/post-images/1616377366139.png" alt="" loading="lazy"></figure>
<h2 id="5-工作过程">5. 工作过程</h2>
<figure data-type="image" tabindex="34"><img src="https://Tyloo-code.github.io/post-images/1616377457407.png" alt="" loading="lazy"></figure>
<h3 id="编译阶段">编译阶段</h3>
<figure data-type="image" tabindex="35"><img src="https://Tyloo-code.github.io/post-images/1616377563413.png" alt="" loading="lazy"></figure>
<h3 id="运行阶段">运行阶段</h3>
<p>由于<code>V8缺少了生成中间代码这一环节</code>，缺少了必要的优化，为了提升性能，V8会在<code>生成本地代码后</code>，使用<code>数据分析器</code>(profiler)<code>采集一些信息</code>，然后根据这些数据将本地代码进行优化，生成更高效的本地代码，这是一个逐步改进的过程。同时，当发现优化后代码的性能还不如未优化的代码，V8将退回原来的代码，也就是优化回滚。<br>
<img src="https://Tyloo-code.github.io/post-images/1616377618319.png" alt="" loading="lazy"></p>
<h3 id="优化回滚">优化回滚</h3>
<figure data-type="image" tabindex="36"><img src="https://Tyloo-code.github.io/post-images/1616377669446.png" alt="" loading="lazy"></figure>

            </div>
            
              <div class="reward-btn">
                <div class="reward-btn-text">赞赏</div>
              </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      来碗鸡丁炒饭
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://Tyloo-code.github.io/post/mian-qian-duan-zhi-shi-dian-shu-li-js-shang/" title="【面】前端知识点梳理（JS）">https://Tyloo-code.github.io/post/mian-qian-duan-zhi-shi-dian-shu-li-js-shang/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="js中==和===区别" href="https://Tyloo-code.github.io/post/js-zhong-he-qu-bie/">js中==和===区别</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="js中==和===区别" href="https://Tyloo-code.github.io/post/js-zhong-he-qu-bie/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="【面】23条前端性能优化" href="https://Tyloo-code.github.io/post/mian-23-tiao-qian-duan-xing-neng-you-hua/">【面】23条前端性能优化</a>
        <a class="nav-mobile-next" title="【面】23条前端性能优化" href="https://Tyloo-code.github.io/post/mian-23-tiao-qian-duan-xing-neng-you-hua/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  
    
      <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>
  var gitalk = new Gitalk({
    clientID: '1d7311971e46d3cb2b7f',
    clientSecret: '825202727778b1d14410ce66b7952398e1213211',
    repo: 'tyloo-code.github.io',
    owner: 'tyloo-code',
    admin: ['tyloo-code'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container')
</script>
    
    
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a
        href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      <a href="http://beian.miit.gov.cn/" target="_blank">京ICP备2020046098号-1</a>
    </div>
  </footer>
  
  
  <div class="pisces back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.onresize = function () {
    calcuHeight();
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, transitionDir, {});
          }
        })
        window.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = "";
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px;border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
            <img id="zfb" class="reward-img" src="\media\images\custom-zfbImg.png" alt="赞赏码">
          
          
            <img id="wx" class="reward-img" src="\media\images\custom-wxImg.png" alt="赞赏码">
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip">打开微信扫一扫，即可进行扫码打赏哦</p>
    </div>
    <div class="bottom">
      
      <div id="zfbBtn" class="pay-text">
        支付宝
      </div>
      
      
      <div id="wxBtn" class="pay-text">
        微信支付
      </div>
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        window.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        window.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        window.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        window.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      window.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      window.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/javascript-shi-xian-dui-jie-gou/"" data-c="
          &lt;h1 id=&#34;1-js实现堆&#34;&gt;1. JS实现堆&lt;/h1&gt;
&lt;p&gt;JS中没有封装好的队列、栈和堆。队列和栈可以用数组模拟，但是堆需要自己封装数据结构。或者封装一个构造函数，每次建堆都是一个实例化的过程。&lt;br&gt;
在JAVA和C++中也都提供了优先队列这个数据结构，这个数据结构的底层实现也是用堆完成的。&lt;br&gt;
下面我们用JS模拟一个堆以实现优先队列。&lt;/p&gt;
&lt;h1 id=&#34;2-堆的几个特性&#34;&gt;2. 堆的几个特性&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;堆本身是一棵满二叉树，这里我们实现一个小根堆&lt;/li&gt;
&lt;li&gt;左孩子索引 = （父元素索引+1）*2-1&lt;/li&gt;
&lt;li&gt;右孩子索引 = （父元素索引+1）*2&lt;/li&gt;
&lt;li&gt;插入元素放在树的最后（树是用数组实现的，也就是push到数组的最后面），然后比较这个节点和父节点的大小，小于父节点就交换父子节点。直到父节点为根节点。&lt;/li&gt;
&lt;li&gt;删除元素删除的是根节点，根节点和树的最后一个节点（last）交换位置，然后存储树的数组长度-1，这样树中就没有被删除的根节点。被交换的last节点和子元素中的最小值比较，如果last节点大于最小值，交换两节点，直到不存在子元素。完成删除操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;3-代码实现&#34;&gt;3. 代码实现&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt; function Heap()
    {
        this.data = [];
    }

    Heap.prototype.print = function () {
        console.log(&amp;quot;Heap: &amp;quot; + this.data);
    }

    Heap.prototype.build = function(data){
        // 初始化
        this.data = [];
        if (!data instanceof Array)
            return false;

        // 入堆
        for (var i = 0; i &amp;lt; data.length; ++i) {
            this.insert(data[i]);
        }

        return true;
    }

    Heap.prototype.insert = function( nValue ){
        if (!this.data instanceof Array) {
            this.data = [];
        }

        this.data.push(nValue);
        // 更新新节点
        var nIndex = this.data.length-1;
        var nFatherIndex = Math.floor((nIndex-1)/2);
        while (nFatherIndex &amp;gt; 0){
            if (this.data[nIndex] &amp;lt; this.data[nFatherIndex]) {
                var temp = this.data[nIndex];
                this.data[nIndex] = this.data[nFatherIndex];
                this.data[nFatherIndex] = temp;
            }

            nIndex = nFatherIndex;
            nFatherIndex = Math.floor((nIndex-1)/2);
        }
    }

    Heap.prototype.delete = function( ){
        if (!this.data instanceof Array) {
            return null;
        }

        var nIndex = 0;
        var nValue = this.data[nIndex];
        var nMaxIndex = this.data.length-1;
        // 更新新节点
        var nLeaf = this.data.pop();
        this.data[nIndex] = nLeaf;

        while (nIndex &amp;lt; nMaxIndex ){
            var nLeftIndex = 2 * (nIndex+1) - 1;
            var nRightIndex = 2 * (nIndex+1);

            // 找最小的一个子节点(nLeftIndex &amp;lt; nRightIndex)
            var nSelectIndex = nLeftIndex;
            if (nRightIndex &amp;lt; nMaxIndex) {
                nSelectIndex = (this.data[nLeftIndex] &amp;gt; this.data[nRightIndex]) ? nRightIndex : nLeftIndex;
            }

            if (nSelectIndex &amp;lt; nMaxIndex &amp;amp;&amp;amp; this.data[nIndex] &amp;gt; this.data[nSelectIndex] ){
                var temp = this.data[nIndex];
                this.data[nIndex] = this.data[nSelectIndex];
                this.data[nSelectIndex] = temp;
            }

            nIndex = nSelectIndex;
        }

        return nValue;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试用例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    var heap = new Heap();
    heap.build([1,2,5,7,9,11,13,15]);
    heap.print();
    console.log(&#39;----------&#39;)
    // insert
    heap.insert(4);
    heap.print();
    console.log(&#39;----------&#39;)
    // delete
    heap.delete();
    heap.print();

&lt;/code&gt;&lt;/pre&gt;
">JavaScript实现堆结构</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/mian-qian-duan-zhi-shi-dian-shu-li-xiang-mu/"" data-c="
          &lt;h1 id=&#34;1-vue-中如何实现监测数组变化&#34;&gt;1. Vue 中如何实现监测数组变化&lt;/h1&gt;
&lt;p&gt;Vue 框架是通过&lt;strong&gt;遍历数组&lt;/strong&gt; 和&lt;strong&gt;递归遍历&lt;/strong&gt;对象，从⽽达到利⽤Object.defineProperty() 也能对对象和数组（部分⽅法的操作）进⾏监听。&lt;/p&gt;
&lt;p&gt;Vue 将被侦听的数组的变更⽅法进⾏了包裹，所以它们也将会触发视图更新。这些被包裹过的⽅法包&lt;br&gt;
括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;push()&lt;/li&gt;
&lt;li&gt;pop()&lt;/li&gt;
&lt;li&gt;shift()&lt;/li&gt;
&lt;li&gt;unshift()&lt;/li&gt;
&lt;li&gt;splice()&lt;/li&gt;
&lt;li&gt;sort()&lt;/li&gt;
&lt;li&gt;reverse()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使⽤函数劫持的⽅式，重写了数组的⽅法&lt;/li&gt;
&lt;li&gt;Vue 将 data 中的数组，进⾏了原型链重写。指向了⾃⼰定义的数组原型⽅法，这样当调⽤数组&lt;br&gt;
API 的时候，可以通知依赖更新。如果数组中包含着引⽤类型。会对数组中的引⽤类型再次进⾏监&lt;br&gt;
控拦截处理&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;2-vue-中的-key-有什么作用&#34;&gt;2. Vue 中的 key 有什么作用&lt;/h1&gt;
&lt;p&gt;所以 Vue 中 key 的作⽤是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;key 是为 Vue 中 vnode 的唯⼀标记，通过这个 key，我们的 diff 操作可以更准确、更快速&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;更准确&lt;/code&gt;：因为带 key 就不是就地复⽤了，在 sameNode 函数&lt;code&gt;a.key === b.key&lt;/code&gt; 对⽐中可以避免就地复⽤的情况。所以会更加准确。&lt;br&gt;
&lt;code&gt;更快速&lt;/code&gt;：利⽤ key 的唯⼀性⽣成 map 对象来获取对应节点，⽐遍历⽅式更快&lt;/p&gt;
&lt;h1 id=&#34;3-你对-vue-项目做过哪些优化&#34;&gt;3. 你对 Vue 项⽬做过哪些优化&lt;/h1&gt;
&lt;h2 id=&#34;1-代码层面的优化&#34;&gt;1. 代码层面的优化&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;v-if 和 v-show 区分使用场景&lt;/li&gt;
&lt;li&gt;computed 和 watch 区分使用场景&lt;/li&gt;
&lt;li&gt;v-for 遍历必须为 item 添加 key，且避免同时使用 v-if&lt;/li&gt;
&lt;li&gt;图片资源懒加载&lt;/li&gt;
&lt;li&gt;路由懒加载&lt;/li&gt;
&lt;li&gt;服务端渲染 SSR or 预渲染&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-webpack-层面的优化&#34;&gt;2. Webpack 层⾯的优化&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Webpack 对图片进行压缩（image-webpack-loader）&lt;/li&gt;
&lt;li&gt;减少 ES6 转为 ES5 的冗余代码（babel-plugin-transform-runtime）&lt;/li&gt;
&lt;li&gt;提取公共代码（CommonsChunkPlugin）&lt;/li&gt;
&lt;li&gt;提取组件的 CSS&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-基础的-web-技术优化&#34;&gt;3. 基础的 Web 技术优化&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;开启 gzip 压缩&lt;/li&gt;
&lt;li&gt;浏览器缓存（静态资源进行缓存）&lt;/li&gt;
&lt;li&gt;CDN 的使用&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;4-vue30特性你有什么了解的吗&#34;&gt;4.  vue3.0特性你有什么了解的吗&lt;/h1&gt;
&lt;p&gt;Vue 3.0 正⾛在发布的路上，Vue 3.0 的⽬标是让 Vue 核⼼变得更⼩、更快、更强⼤，因此 Vue 3.0 增加以下这些新特性：&lt;/p&gt;
&lt;h2 id=&#34;1-监测机制的改变&#34;&gt;1. 监测机制的改变&lt;/h2&gt;
&lt;p&gt;3.0 将带来基于代理 Proxy 的 observer 实现，提供全语⾔覆盖的反应性跟踪。这消除了 Vue 2 当中基于Object.defineProperty 的实现所存在的很多限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只能监测属性，不能监测对象&lt;/li&gt;
&lt;li&gt;检测属性的添加和删除；&lt;/li&gt;
&lt;li&gt;检测数组索引和⻓度的变更；&lt;/li&gt;
&lt;li&gt;⽀持 Map、Set、WeakMap 和 WeakSet。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;新的 observer 还提供了以下特性：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;⽤于创建 observable 的公开 API。这为中⼩规模场景提供了简单轻量级的跨组件状态管理解决⽅&lt;br&gt;
案。&lt;/li&gt;
&lt;li&gt;默认采⽤惰性观察。在 2.x 中，不管反应式数据有多⼤，都会在启动时被观察到。如果你的数据集&lt;br&gt;
很⼤，这可能会在应⽤启动时带来明显的开销。在 3.x 中，只观察⽤于渲染应⽤程序最初可⻅部分&lt;br&gt;
的数据。&lt;/li&gt;
&lt;li&gt;更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。&lt;/li&gt;
&lt;li&gt;不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除⾮系统在内部暂时&lt;br&gt;
将其“解禁”。这个机制可⽤于冻结 prop 传递或 Vuex 状态树以外的变化。&lt;/li&gt;
&lt;li&gt;更好的调试功能：我们可以使⽤新的 renderTracked 和 renderTriggered 钩⼦精确地跟踪组件在&lt;br&gt;
什么时候以及为什么重新渲染。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-模板&#34;&gt;2. 模板&lt;/h2&gt;
&lt;p&gt;模板⽅⾯没有⼤的变更，只改了作⽤域插槽，2.x 的机制导致作⽤域插槽变了，⽗组件会重新渲染，⽽&lt;br&gt;
3.0 把作⽤域插槽改成了函数的⽅式，这样只会影响⼦组件的重新渲染，提升了渲染的性能。&lt;/p&gt;
&lt;p&gt;同时，对于 render 函数的⽅⾯，vue3.0 也会进⾏⼀系列更改来⽅便习惯直接使⽤ api 来⽣成 vdom 。&lt;/p&gt;
&lt;h2 id=&#34;3-对象式的组件声明方式&#34;&gt;3. 对象式的组件声明⽅式&lt;/h2&gt;
&lt;p&gt;vue2.x 中的组件是通过声明的⽅式传⼊⼀系列 option，和 TypeScript 的结合需要通过⼀些装饰器的⽅式来做，虽然能实现功能，但是⽐较麻烦。3.0 修改了组件的声明⽅式，改成了类式的写法，这样使得和&lt;br&gt;
TypeScript 的结合变得很容易。&lt;/p&gt;
&lt;p&gt;此外，vue 的源码也改⽤了 TypeScript 来写。其实当代码的功能复杂之后，必须有⼀个静态类型系统来&lt;br&gt;
做⼀些辅助管理。现在 vue3.0 也全⾯改⽤ TypeScript 来重写了，更是使得对外暴露的 api 更容易结合TypeScript。静态类型系统对于复杂代码的维护确实很有必要。&lt;/p&gt;
&lt;h2 id=&#34;4-其它方面的更改&#34;&gt;4. 其它⽅⾯的更改&lt;/h2&gt;
&lt;p&gt;vue3.0 的改变是全⾯的，上⾯只涉及到主要的 3 个⽅⾯，还有⼀些其他的更改：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;⽀持⾃定义渲染器，从⽽使得 weex 可以通过⾃定义渲染器的⽅式来扩展，⽽不是直接 fork 源码来&lt;br&gt;
改的⽅式。&lt;/li&gt;
&lt;li&gt;⽀持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对⼀些特殊&lt;br&gt;
的场景做了处理。&lt;/li&gt;
&lt;li&gt;基于 treeshaking 优化，提供了更多的内置功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;5-滚动到底部加载更多&#34;&gt;5. 滚动到底部加载更多&lt;/h1&gt;
&lt;p&gt;需要三个高度：&lt;code&gt;scrollHeight&lt;/code&gt;（文档内容实际高度，包括超出视窗的溢出部分）、&lt;code&gt;scrollTop&lt;/code&gt;（滚动条滚动距离）、&lt;code&gt;clientHeight&lt;/code&gt;（窗口可视范围高度）。当 &lt;code&gt;clientHeight + scrollTop &amp;gt;= scrollHeight&lt;/code&gt; 时，表示已经抵达内容的底部了，可以加载更多内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scrollHeight：通过 document.documentElement.scrollHeight 、document.body.scrollHeight 可以获取;&lt;/li&gt;
&lt;li&gt;scrollTop：通过window.pageYOffset 、 document.documentElement.scrollTop 、 document.body.scrollTop 可以获取&lt;/li&gt;
&lt;li&gt;clientHeight：通过window.innerHeight 、 document.documentElement.clientHeight 、 document.body.clientHeight 可以获取;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;   window.onscroll= function(){
        //文档内容实际高度（包括超出视窗的溢出部分）
        var scrollHeight = Math.max(document.documentElement.scrollHeight, document.body.scrollHeight);
        //滚动条滚动距离
        var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
        //窗口可视范围高度
        var clientHeight = window.innerHeight || Math.min(document.documentElement.clientHeight,document.body.clientHeight);
        
        if(clientHeight + scrollTop &amp;gt;= scrollHeight){
            console.log(&amp;quot;===加载更多内容……===&amp;quot;);
        }
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;6-vue无限滚动方案&#34;&gt;6. vue无限滚动方案&lt;/h1&gt;
&lt;h2 id=&#34;1-实现无限滚动逻辑&#34;&gt;1. 实现无限滚动逻辑&lt;/h2&gt;
&lt;p&gt;在组件的方法中，您需要创建一个名为&lt;code&gt;scroll()&lt;/code&gt;的新函数，并将其加载到&lt;code&gt;mounted()&lt;/code&gt;生命周期方法中。&lt;br&gt;
这个&lt;code&gt;scroll()&lt;/code&gt;方法应该有一个简单的条件来计算页面的底部，判断它为true或false，并执行一些操作。我们将利用文档对象的&lt;code&gt;documentElement.scrollTop&lt;/code&gt;，&lt;code&gt;documentElement.offsetHeight&lt;/code&gt;属性和窗口的&lt;code&gt;innerHeight&lt;/code&gt;属性来确定是否滚动到底部：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;window.onscroll = () =&amp;gt; {
  let bottomOfWindow = document.documentElement.scrollTop + window.innerHeight === document.documentElement.offsetHeight;

  if (bottomOfWindow) {
    // Do something, anything!
  }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-性能优化方案&#34;&gt;2. 性能优化方案&lt;/h2&gt;
&lt;p&gt;对此前端业界有一个通用解决方案叫virtualize，虚拟化，就是把整个列表虚拟化，无论你列表元素有多少，我只虚拟化一定数目的元素(大于一屏幕)，然后在滚动过程中动态的更新这些元素，这样的话我们页面重新渲染时候进行的style和layout过程的对象元素就是固定的了，时间不会变长。具体的实现方法参考下图。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615968713779.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当列表滚动到item8之前，不做任何操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;滚动到8的时候，此时可见区域的元素是4到8，这时更新DOM的8个元素为4到11，也就是说1-8批量更新成了4-11。但是用户可见区域看到的仍然是4到8，只是bench缓冲区的元素添加了9到11三个元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;元素完成了更新，但是滚动条的位置也要完成更新，因为实际上此时可见区域的item4并不是之前列表DOM中的第4个元素了，而是变成了第1个元素，所以滚动条此时位置变回到了列表的起点，这里需要给列表一个padding-top值，设成3倍元素高度size，从而维持滚动条的位置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;7-移动端返回顶部&#34;&gt;7. 移动端返回顶部&lt;/h1&gt;
&lt;p&gt;页面滚动到一定高度出现返回顶部按钮，点击返回顶部，按钮消失&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; mounted() {
	window.addEventListener(&#39;scroll&#39;,function(){
	 var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
	 if(scrollTop&amp;gt;800){
		 document.getElementById(&amp;quot;default_drag_return&amp;quot;).style.visibility=&amp;quot;visible&amp;quot;;
		 
	 }
	 if(scrollTop&amp;lt;800){
		 document.getElementById(&amp;quot;default_drag_return&amp;quot;).style.visibility=&amp;quot;hidden&amp;quot;;
	 }
	 });
  },

  methods: {
	  topreturn:function(){
		  document.documentElement.scrollTop = document.body.scrollTop =0;
		  document.getElementById(&amp;quot;default_drag_return&amp;quot;).style.visibility=&amp;quot;hidden&amp;quot;;
		  
	  }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;8-vue-jwt后台登录权限&#34;&gt;8. Vue - JWT后台登录权限&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618468865167.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1-令牌组成&#34;&gt;1. 令牌组成&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;header.payload.signature&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;标头(Header)&lt;/li&gt;
&lt;li&gt;有效载荷(Payload)&lt;/li&gt;
&lt;li&gt;签名(Signature)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，JWT通常如下所示：xxxx.yyyy.zzzz&lt;/p&gt;
&lt;h2 id=&#34;2-header&#34;&gt;2. Header&lt;/h2&gt;
&lt;p&gt;标头通常由两部分组成：令牌的类型(JWT)和所使用的签名算法，例如HMAC SHA256或RSA。它会使用 Base64 编码组成 JWT 结构的第一部分。&lt;/p&gt;
&lt;p&gt;注意：Base64是一种编码，也就是说，它是可以被翻译回原来的样子来的。它并不是一种加密过程。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;alg&amp;quot;:&amp;quot;HS256&amp;quot;,
    &amp;quot;typ&amp;quot;:&amp;quot;JWT&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-payload&#34;&gt;3. Payload&lt;/h2&gt;
&lt;p&gt;令牌的第二部分是有效负载，其中包含声明。声明是有关实体（通常是用户）和其他数据的声明。同样的，它会使用 Base64编码组成JWT结构的第二部分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;sub&amp;quot;:&amp;quot;123456789&amp;quot;,
    &amp;quot;name&amp;quot;:&amp;quot;John Doe&amp;quot;,
    &amp;quot;admin&amp;quot;:true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-signature&#34;&gt;4. Signature&lt;/h2&gt;
&lt;p&gt;前面两部分都是使用Base64进行编码的，即前端可以解开知道里面的信息。Signature 需要使用编码后的 header 和 payload 以及我们提供的一个密钥，然后使用 header 中指定的签名算法(HS256)进行签名。签名的作用是保证JWT没有被篡改过&lt;br&gt;
如：&lt;br&gt;
HMACSHA256(base64UrlEncode(header) + &amp;quot;.&amp;quot; + base64UrlEncode(payload) , secret);&lt;/p&gt;
&lt;h2 id=&#34;5-签名目的&#34;&gt;5. 签名目的&lt;/h2&gt;
&lt;p&gt;最后一步签名的过程，实际上是对头部以及负载内容进行签名，防止内容被窜改。如果有人对头部以及负载的内容解码之后进行修改，再进行编码，最后加上之前的签名组合形成新的JWT的话，那么服务器端会判断出新的头部和负载形成的签名和JWT附带上的签名是不一样的。如果要对新的头部和负载进行签名，在不知道服务器加密时用的密钥的话，得出来的签名也是不一样的。&lt;/p&gt;
&lt;h2 id=&#34;6-信息安全问题&#34;&gt;6. 信息安全问题&lt;/h2&gt;
&lt;p&gt;在这里大家一定会问一个问题：Base64是一种编码，是可逆的，那么我的信息不就被暴露了吗?&lt;/p&gt;
&lt;p&gt;是的。所以，在JWT中，不应该在负载里面加入任何敏感的数据。在上面的例子中，我们传输的是用户的User ID。这个值实际上不是什么敏感内容，一般情况下被知道也是安全的。但是像密码这样的内容就不能被放在JWT中了。如果将用户的密码放在了JWT中，那么怀有恶意的第三方通过Base64解码就能很快地知道你的密码了。因此JWT适合用于向Web应用传递一些非敏感信息。JWT还经常用于设计用户认证和授权系统，甚至实现Web应用的单点登录。&lt;/p&gt;
&lt;h2 id=&#34;7-认证流程&#34;&gt;7. 认证流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload(负载)，将其与头部分别进行Base64编码拼接后签名，形成一个JWT(Token)。形成的JWT就是一个形同111.zzz.xxx的字符串。token head.payload.signature&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后端将JWT字符串作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在localStorage或sessionStorage上，退出登录时前端删除保存的JWT即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前端在每次请求时将JWT放入HTTP Header中的Authorization位。(解决XSS和XSRF问题）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确；检查Token是否过期；检查Token的接收方是否是自己(可选)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;8-jwt优势&#34;&gt;8. JWT优势&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;简洁(Compact)：可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快&lt;/li&gt;
&lt;li&gt;自包含(Self-contained)：负载中包含了所有用户所需要的信息，避免了多次查询数据库&lt;/li&gt;
&lt;li&gt;因为Token是以JSON加密的形式保存在客户端的，所以JWT是跨语言的，原则上任何web形式都支持。&lt;/li&gt;
&lt;li&gt;不需要在服务端保存会话信息，特别适用于分布式微服务。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619086600490.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;9-vue实现带进度条的文件拖动上传&#34;&gt;9. Vue实现带进度条的文件拖动上传&lt;/h1&gt;
&lt;h2 id=&#34;1-基本界面&#34;&gt;1. 基本界面&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot;
          content=&amp;quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&amp;quot;&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot;&amp;gt;
    &amp;lt;link href=&amp;quot;https://cdn.bootcss.com/bootstrap/4.0.0/css/bootstrap.min.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
    &amp;lt;script src=&amp;quot;https://cdn.bootcss.com/vue/2.5.13/vue.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;style&amp;gt;
        .dropbox {
            border: .25rem dashed #007bff;
            min-height: 5rem;
        }
    &amp;lt;/style&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&amp;quot;app&amp;quot; class=&amp;quot;m-5&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;dropbox p-3&amp;quot;&amp;gt;
        &amp;lt;h2 class=&amp;quot;text-center&amp;quot;&amp;gt;把要上传的文件拖动到这里&amp;lt;/h2&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
    new Vue({
        el: &#39;#app&#39;,
        data: {},
        methods: {},
        mounted: function () {}
    });
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615980095840.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;2-检测拖动事件&#34;&gt;2. 检测拖动事件&lt;/h2&gt;
&lt;p&gt;首先让页面支持文件拖拽，在 Vue 的&lt;code&gt;mounted()&lt;/code&gt; 函数中添加代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mounted: function () {
    var dropbox = document.querySelector(&#39;.dropbox&#39;);
    dropbox.addEventListener(&#39;dragenter&#39;, this.onDrag, false);
    dropbox.addEventListener(&#39;dragover&#39;, this.onDrag, false);
    dropbox.addEventListener(&#39;drop&#39;, this.onDrop, false);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当把文件拖动到浏览器的拖动区域时，会触发三种事件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文件第一次进入拖动区时，触发 dragenter 事件&lt;/li&gt;
&lt;li&gt;文件在拖动区来回拖拽时，不断触发 dragover 事件&lt;/li&gt;
&lt;li&gt;文件已经在拖动区，并松开鼠标时，触发 drop 事件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实现拖动上传，我们只需要关心 drop 事件。不过另外两个事件也需要监听，目的是阻止浏览器默认行为。如果不阻止，那么把文件拖到浏览器时，浏览器就会自动下载这个文件（默认行为），drop 事件触发不出来。&lt;/p&gt;
&lt;p&gt;事件的监听函数添加在 Vue 的 &lt;code&gt;methods&lt;/code&gt; 对象中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;methods: {
    uploadFile: function (file) {
        console.log(file);
    },
    onDrag: function (e) {
        e.stopPropagation();
        e.preventDefault();
    },
    onDrop: function (e) {
        e.stopPropagation();
        e.preventDefault();
        var dt = e.dataTransfer;
        for (var i = 0; i !== dt.files.length; i++) {
            this.uploadFile(dt.files[i]);
        }
    }
},
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;onDrop()&lt;/code&gt; 函数中，通过&lt;code&gt;e.dataTransfer.files&lt;/code&gt; 可以拿到用户拖动到浏览器的文件的基本信息，&lt;code&gt;uploadFile()&lt;/code&gt; 函数现在只这些信息打印了出来，可以了解到，拖动到浏览器的每个文件都是一个 File 对象：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615980412873.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-处理拖动事件&#34;&gt;3. 处理拖动事件&lt;/h2&gt;
&lt;p&gt;现在，我们要给 &lt;code&gt;uploadFile()&lt;/code&gt; 函数增加功能，实现拖动文件时，拖动区出现文件名和一个上传进度条。&lt;/p&gt;
&lt;p&gt;首先在 Vue 的 data 对象中定义 &lt;strong&gt;files&lt;/strong&gt; 属性，用来保存所有拖动到浏览器中文件的名称。然后在&lt;code&gt;uploadFile()&lt;/code&gt; 函数每当被调用时，把文件名和上传进度保存到 files 中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data: {
    files: []
},
methods: {
    uploadFile: function (file) {
        var item = {
            name: file.name,
            uploadPercentage: 67
        };
        this.files.push(item);
    },
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上传进度的功能在后面再介绍，先写一个固定值。&lt;/p&gt;
&lt;p&gt;相应地，在HTML代码中，用 &lt;code&gt;v-for&lt;/code&gt; 关键字显示 &lt;code&gt;files&lt;/code&gt; 的每一项：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;dropbox p-3&amp;quot;&amp;gt;
    &amp;lt;h2 class=&amp;quot;text-center&amp;quot;&amp;gt;把要上传的文件拖动到这里&amp;lt;/h2&amp;gt;
    &amp;lt;div class=&amp;quot;border m-2 d-inline-block p-4&amp;quot; style=&amp;quot;width:15rem&amp;quot; v-for=&amp;quot;file in files&amp;quot;&amp;gt;
        &amp;lt;h5 class=&amp;quot;mt-0&amp;quot;&amp;gt;{{ file.name }}&amp;lt;/h5&amp;gt;
        &amp;lt;div class=&amp;quot;progress&amp;quot;&amp;gt;
            &amp;lt;div class=&amp;quot;progress-bar progress-bar-striped&amp;quot;
                    :style=&amp;quot;{ width: file.uploadPercentage+&#39;%&#39; }&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而且，“把要上传的文件拖动到这里” 的提示只在拖动区没有文件的时候才显示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;h2 v-if=&amp;quot;files.length===0&amp;quot; class=&amp;quot;text-center&amp;quot;&amp;gt;把要上传的文件拖动到这里&amp;lt;/h2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样，拖动效果就有了：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615980581346.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-文件上传&#34;&gt;4. 文件上传&lt;/h2&gt;
&lt;p&gt;接下来实现真正的文件上传，继续往 &lt;code&gt;uploadFile()&lt;/code&gt; 函数添加代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;uploadFile: function (file) {
    var item = {
        name: file.name,
        uploadPercentage: 67
    };
    this.files.push(item);
    var fd = new FormData();
    fd.append(&#39;myFile&#39;, file);

    var xhr = new XMLHttpRequest();
    xhr.open(&#39;POST&#39;, &#39;upload.php&#39;, true);
    xhr.send(fd);
},
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里用到了 FormData，把要上传的文件附在了 FormData 上，并通过AJAX方式发送给PHP端。&lt;/p&gt;
&lt;h2 id=&#34;5-进度条的展示&#34;&gt;5. 进度条的展示&lt;/h2&gt;
&lt;p&gt;基本的上传功能完成了，最后我们来完成进度条。每当AJAX请求发送了一段时间的数据时，都会生成一个 progress 事件，我们可以监听 progress 事件来知道当前的上传进度：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;uploadFile: function (file) {
    ...
    xhr.upload.addEventListener(&#39;progress&#39;, function (e) {
        item.uploadPercentage = Math.round((e.loaded * 100) / e.total);
    }, false);
    xhr.send(fd);
},
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;e.loaded&lt;/code&gt; 代表当前AJAX发送了多少字节，e.total 代表AJAX总共要发送多少字节。通过这两个属性可以计算上传进度的百分比。&lt;/p&gt;
&lt;p&gt;这样，一个带进度条的文件拖动上传功能就完成了。&lt;/p&gt;
&lt;h1 id=&#34;10-formdata传递参数&#34;&gt;10. FormData传递参数&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;FormData的主要用途有两个：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将form表单元素的name与value进行组合，实现表单数据的序列化，从而减少表单元素的拼接，提高工作效率。&lt;/li&gt;
&lt;li&gt;异步上传文件&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;1-创建formdata对象&#34;&gt;1. 创建formData对象&lt;/h2&gt;
&lt;h3 id=&#34;1-创建一个空对象&#34;&gt;1. 创建一个空对象：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;//通过FormData构造函数创建一个空对象
var formdata=new FormData();
//可以通过append()方法来追加数据
formdata.append(&amp;quot;name&amp;quot;,&amp;quot;laotie&amp;quot;);
//通过get方法对值进行读取
console.log(formdata.get(&amp;quot;name&amp;quot;));//laotie
//通过set方法对值进行设置
formdata.set(&amp;quot;name&amp;quot;,&amp;quot;laoliu&amp;quot;);
console.log(formdata.get(&amp;quot;name&amp;quot;));//laoliu
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-通过表单对formdata进行初始化&#34;&gt;2. 通过表单对formData进行初始化&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;创建表单：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form id=&amp;quot;advForm&amp;quot;&amp;gt;
    &amp;lt;p&amp;gt;广告名称：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;advName&amp;quot;  value=&amp;quot;xixi&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;广告类别：&amp;lt;select name=&amp;quot;advType&amp;quot;&amp;gt;
        &amp;lt;option value=&amp;quot;1&amp;quot;&amp;gt;轮播图&amp;lt;/option&amp;gt;
        &amp;lt;option value=&amp;quot;2&amp;quot;&amp;gt;轮播图底部广告&amp;lt;/option&amp;gt;
        &amp;lt;option value=&amp;quot;3&amp;quot;&amp;gt;热门回收广告&amp;lt;/option&amp;gt;
        &amp;lt;option value=&amp;quot;4&amp;quot;&amp;gt;优品精选广告&amp;lt;/option&amp;gt;
    &amp;lt;/select&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;&amp;lt;input type=&amp;quot;button&amp;quot; id=&amp;quot;btn&amp;quot; value=&amp;quot;添加&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;通过表单元素作为参数，实现对formData的初始化：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//获得表单按钮元素
var btn=document.querySelector(&amp;quot;#btn&amp;quot;);
//为按钮添加点击事件
btn.onclick=function(){
    //根据ID获得页面当中的form表单元素
    var form=document.querySelector(&amp;quot;#advForm&amp;quot;);
    //将获得的表单元素作为参数，对formData进行初始化
    var formdata=new FormData(form);
    //通过get方法获得name为advName元素的value值
    console.log(formdata.get(&amp;quot;advName&amp;quot;));//xixi
    //通过get方法获得name为advType元素的value值
    console.log(formdata.get(&amp;quot;advType&amp;quot;));//1 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-操作方法&#34;&gt;2. 操作方法&lt;/h2&gt;
&lt;h3 id=&#34;1-通过getkey与getallkey来获取相对应的值&#34;&gt;1. 通过get(key)与getAll(key)来获取相对应的值&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// 获取key为age的第一个值
formdata.get(&amp;quot;age&amp;quot;); 
 // 获取key为age的所有值，返回值为数组类型
formdata.getAll(&amp;quot;age&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-通过appendkeyvalue在数据末尾追加数据&#34;&gt;2. 通过append(key,value)在数据末尾追加数据&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;//通过FormData构造函数创建一个空对象
var formdata=new FormData();
//通过append()方法在末尾追加key为name值为laoliu的数据
formdata.append(&amp;quot;name&amp;quot;,&amp;quot;laoliu&amp;quot;);
//通过append()方法在末尾追加key为name值为laoli的数据
formdata.append(&amp;quot;name&amp;quot;,&amp;quot;laoli&amp;quot;);
//通过append()方法在末尾追加key为name值为laotie的数据
formdata.append(&amp;quot;name&amp;quot;,&amp;quot;laotie&amp;quot;);
//通过get方法读取key为name的第一个值
console.log(formdata.get(&amp;quot;name&amp;quot;));//laoliu
//通过getAll方法读取key为name的所有值
console.log(formdata.getAll(&amp;quot;name&amp;quot;));//[&amp;quot;laoliu&amp;quot;, &amp;quot;laoli&amp;quot;, &amp;quot;laotie&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-通过setkey-value来设置修改数据&#34;&gt;3. 通过set(key, value)来设置修改数据&lt;/h3&gt;
&lt;p&gt;key的值不存在，会添加一条数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//通过FormData构造函数创建一个空对象
var formdata=new FormData();
//如果key的值不存在会为数据添加一个key为name值为laoliu的数据
formdata.set(&amp;quot;name&amp;quot;,&amp;quot;laoli&amp;quot;);
//通过get方法读取key为name的第一个值
console.log(formdata.get(&amp;quot;name&amp;quot;));//laoli
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;key的值存在，会修改对应的value值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//通过FormData构造函数创建一个空对象
var formdata=new FormData();
//通过append()方法在末尾追加key为name值为laoliu的数据
formdata.append(&amp;quot;name&amp;quot;,&amp;quot;laoliu&amp;quot;);
//通过append()方法在末尾追加key为name值为laoliu2的数据
formdata.append(&amp;quot;name&amp;quot;,&amp;quot;laoliu2&amp;quot;);
//通过get方法读取key为name的第一个值
console.log(formdata.get(&amp;quot;name&amp;quot;));//laoliu
//通过getAll方法读取key为name的所有值
console.log(formdata.getAll(&amp;quot;name&amp;quot;));//[&amp;quot;laoliu&amp;quot;, &amp;quot;laoliu2&amp;quot;]

//将存在的key为name的值修改为laoli
formdata.set(&amp;quot;name&amp;quot;,&amp;quot;laoli&amp;quot;);
//通过get方法读取key为name的第一个值
console.log(formdata.get(&amp;quot;name&amp;quot;));//laoli
//通过getAll方法读取key为name的所有值
console.log(formdata.getAll(&amp;quot;name&amp;quot;));//[&amp;quot;laoli&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-通过haskey来判断是否存在对应的key值&#34;&gt;4. 通过has(key)来判断是否存在对应的key值&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;//通过FormData构造函数创建一个空对象
var formdata=new FormData();
//通过append()方法在末尾追加key为name值为laoliu的数据
formdata.append(&amp;quot;name&amp;quot;,&amp;quot;laoliu&amp;quot;);
//判断是否包含key为name的数据
console.log(formdata.has(&amp;quot;name&amp;quot;));//true
//判断是否包含key为age的数据
console.log(formdata.has(&amp;quot;age&amp;quot;));//false
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-通过deletekey可以删除数据&#34;&gt;5. 通过delete(key)可以删除数据&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;//通过FormData构造函数创建一个空对象
var formdata=new FormData();
//通过append()方法在末尾追加key为name值为laoliu的数据
formdata.append(&amp;quot;name&amp;quot;,&amp;quot;laoliu&amp;quot;);
console.log(formdata.get(&amp;quot;name&amp;quot;));//laoliu
//删除key为name的值
formdata.delete(&amp;quot;name&amp;quot;);
console.log(formdata.get(&amp;quot;name&amp;quot;));//null
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-通过xmlhttprequest发送数据&#34;&gt;3. 通过XMLHttpRequest发送数据&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;创建表单：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form id=&amp;quot;advForm&amp;quot;&amp;gt;
    &amp;lt;p&amp;gt;广告名称：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;advName&amp;quot; value=&amp;quot;xixi&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;广告类别：&amp;lt;select name=&amp;quot;advType&amp;quot;&amp;gt;
        &amp;lt;option value=&amp;quot;1&amp;quot;&amp;gt;轮播图&amp;lt;/option&amp;gt;
        &amp;lt;option value=&amp;quot;2&amp;quot;&amp;gt;轮播图底部广告&amp;lt;/option&amp;gt;
        &amp;lt;option value=&amp;quot;3&amp;quot;&amp;gt;热门回收广告&amp;lt;/option&amp;gt;
        &amp;lt;option value=&amp;quot;4&amp;quot;&amp;gt;优品精选广告&amp;lt;/option&amp;gt;
    &amp;lt;/select&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;广告图片：&amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;advPic&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;广告地址：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;advUrl&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;广告排序：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;orderBy&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;&amp;lt;input type=&amp;quot;button&amp;quot; id=&amp;quot;btn&amp;quot; value=&amp;quot;添加&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;发送数据：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var btn=document.querySelector(&amp;quot;#btn&amp;quot;);
btn.onclick=function(){
    var formdata=new FormData(document.getElementById(&amp;quot;advForm&amp;quot;));
    var xhr=new XMLHttpRequest();
    xhr.open(&amp;quot;post&amp;quot;,&amp;quot;http://127.0.0.1/adv&amp;quot;);
    xhr.send(formdata);
    xhr.onload=function(){
        if(xhr.status==200){
            //...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;11-vue防止用户手动修改url访问非权限页面&#34;&gt;11. Vue防止用户手动修改URL访问非权限页面&lt;/h1&gt;
&lt;p&gt;今天在写filter的时候，要做一个防止用户手动修改URL访问非权限页面的验证。在网上搜索了下，&lt;/p&gt;
&lt;p&gt;发现可以通过：&lt;code&gt;request.getHeader(&amp;quot;referer&amp;quot;);&lt;/code&gt;  &lt;br&gt;
// js的话：javascript:document.referrer来防止，&lt;/p&gt;
&lt;p&gt;如果返回值为null的话，说明是手动修改url访问的，然后进而通过后台，判断是否该登陆用户具&lt;/p&gt;
&lt;p&gt;有访问权限，如果有，放行，否则，跳转到错误页面。&lt;/p&gt;
&lt;p&gt;原理：&lt;code&gt;referer只有从别的页面点击连接来到这页的才会有内容，否则为null。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;request.getHeader(&amp;quot;referer&amp;quot;)的作用：&lt;/strong&gt;&lt;br&gt;
①防止盗连，比如我是个下载软件的网站，在下载页面我先用referer来判断上一页面是不是自己网站，如果不是，说明有人盗连了你的下载地址。&lt;/p&gt;
&lt;p&gt;②电子商务网站的安全，我在提交信用卡等重要信息的页面用referer来判断上一页是不是自己的网站，如果不是，可能是黑客用自己写的一个表单，来提交，为了能跳过你上一页里的javascript的验证等目的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void doFilter(ServletRequest request, ServletResponse response,
			FilterChain chain) throws IOException, ServletException {
		HttpServletRequest req = (HttpServletRequest) request;
		HttpServletResponse resp = (HttpServletResponse) response;
		String conString = &amp;quot;&amp;quot;;
		conString = req.getHeader(&amp;quot;REFERER&amp;quot;);//获取父url--如果不是直接输入的话就是先前的访问过来的页面，要是用户输入了，这个父url是不存在的
		if(&amp;quot;&amp;quot;.equals(conString) || null==conString){ //判断如果上一个目录为空的话，说明是用户直接输入url访问的
			String servletPath = req.getServletPath();//当前请求url，去掉几个可以直接访问的页面
			if(servletPath.contains(&amp;quot;index.jsp&amp;quot;) || servletPath.contains(&amp;quot;admin/login.jsp&amp;quot;)){ //跳过index.jsp和登陆Login.jsp
				chain.doFilter(request, response);
			} else {
				resp.sendRedirect(&amp;quot;/ejuornal/index.jsp&amp;quot;);//跳回首页
			}
		} else {
			chain.doFilter(request, response);
		}
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;12-手动一个v-model组件&#34;&gt;12. 手动一个v-model组件&lt;/h1&gt;
&lt;h2 id=&#34;1-知识储备&#34;&gt;1. 知识储备&lt;/h2&gt;
&lt;p&gt;在开始之前我们先需要知道一些知识，v-model是一个语法糖，如下：&lt;br&gt;
&lt;code&gt;&amp;lt;input type=&amp;quot;text&amp;quot; v-model=&amp;quot;name&amp;quot;&amp;gt;&lt;/code&gt;&lt;br&gt;
实则是等于下面的：&lt;br&gt;
&lt;code&gt;&amp;lt;input type=&amp;quot;text&amp;quot; :value=&amp;quot;name&amp;quot; @input=&amp;quot;name=$event.target.value&amp;quot;&amp;gt;&lt;/code&gt;&lt;br&gt;
也就是说，&lt;strong&gt;v-model就是绑定了一个名为value的props和一个事件input&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;注意：所以在子组件中可以通过props中定义value接受值，然后通过$emit触发input事件传新值并修改。
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616570989198.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1-最简单的实现方法&#34;&gt;1. 最简单的实现方法&lt;/h2&gt;
&lt;p&gt;综合上述特性，我们可以认为我们要实现自定义组件的双向绑定，其实需要的功能其实是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组件内部可以接收并同步父组件传入的value值&lt;/li&gt;
&lt;li&gt;组件内部可以在该双向绑定值修改时emit一个input事件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们知道，直接修改父组件传入的值（prop）是不被允许的，&lt;br&gt;
而且需要在双向绑定值于组件内部修改时拦截其操作，改为向父组件emit事件&lt;/p&gt;
&lt;p&gt;首先是父组件的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;&amp;quot;&amp;gt;
      &amp;lt;p&amp;gt;{{name}}&amp;lt;/p&amp;gt;
      &amp;lt;son v-model=&amp;quot;name&amp;quot;&amp;gt;&amp;lt;/son&amp;gt;
      &amp;lt;!-- 等同于下面 --&amp;gt;
      &amp;lt;!-- &amp;lt;son type=&amp;quot;text&amp;quot; :value=&amp;quot;name&amp;quot; @input=&amp;quot;name=子组件传回来的值&amp;quot;&amp;gt; --&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
import Son from &#39;./son&#39;
export default {
  name: &amp;quot;&amp;quot;,
  data() {
    return {
        name:&#39;ydw&#39;,
    }
  },
  components: {
      Son
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后是子组件的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class&amp;gt;
      &amp;lt;input type=&amp;quot;text&amp;quot; :value=&amp;quot;value&amp;quot; @input=&amp;quot;$emit(&#39;input&#39;,$event.target.value)&amp;quot;&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
export default {
  name: &amp;quot;&amp;quot;,
  props:{
      value:{
          type: String,
          defalut () 
              return &#39;&#39;
          }
      }
  },
  data() {
    return {

    }
  },
  components: {
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;父组件中我加了一个注释的代码行，其实是帮助我自己理解的，不知道有没有小伙伴跟我一样，第一次看的时候压根不知道它在做什么的？哭唧唧。&lt;/p&gt;
&lt;h2 id=&#34;3-使用最新的语法model属性&#34;&gt;3. 使用最新的语法，model属性。&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616555019332.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
也就是说这个属性是为了回避props定义的value这个名字的。&lt;/p&gt;
&lt;p&gt;下面看看它的用法，我们先看子组件怎么修改：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; :value=&amp;quot;val&amp;quot; @input=&amp;quot;$emit(&#39;change&#39;,$event.target.value)&amp;quot; /&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;                                                 export default {         
  name: &amp;quot;&amp;quot;,
  model:{
    prop:&#39;val&#39;,
    event:&#39;change&#39;
  },
  props: {
    val: {
      type: String,
      defalut() {
        return &amp;quot;&amp;quot;;
      }
    }
  },
  data() {                                                       
    return {                                                                  
    };
  }
};
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;model属性中prop是重新命名传值的名字，而event则是重新命名事件的名字，但是同样的，props中的传值名字必须与model属性中的prop的名字一样。其实只要对比一下第一种方法就知道，vue多出一个model属性是为了value这个名字可以使用。&lt;/p&gt;
&lt;h2 id=&#34;4-vue20封装elementui&#34;&gt;4. Vue2.0封装elementUI&lt;/h2&gt;
&lt;p&gt;首先讲我简单的封装代码上来：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;form-container&amp;quot;&amp;gt;
    &amp;lt;el-form
      :model=&amp;quot;filterObject&amp;quot;
      label-position=&amp;quot;left&amp;quot;
      :label-width=&amp;quot;labelWidth&amp;quot;
    &amp;gt;
      &amp;lt;el-row :gutter=&amp;quot;10&amp;quot;&amp;gt;
        &amp;lt;el-col
          v-for=&amp;quot;item in formData&amp;quot;
          :key=&amp;quot;item.prop&amp;quot;
          :span=&amp;quot;item.span || 8&amp;quot;
        &amp;gt;
          &amp;lt;el-form-item :label=&amp;quot;item.label&amp;quot;&amp;gt;
            &amp;lt;el-input
              v-if=&amp;quot;item.type === &#39;text&#39;&amp;quot;
              v-model=&amp;quot;filterObject[item.prop]&amp;quot;
              clearable
              :disabled=&amp;quot;item.disabled || false&amp;quot;
              :placeholder=&amp;quot;item.placeholder&amp;quot;
            &amp;gt;&amp;lt;/el-input&amp;gt;

            &amp;lt;el-select
              v-if=&amp;quot;item.type === &#39;select&#39;&amp;quot;
              v-model=&amp;quot;filterObject[item.prop]&amp;quot;
              clearable
              :placeholder=&amp;quot;item.placeholder&amp;quot;
              @change=&amp;quot;handleChange&amp;quot;
            &amp;gt;
              &amp;lt;el-option
                v-for=&amp;quot;sub in item.arr&amp;quot;
                :key=&amp;quot;sub.value&amp;quot;
                :label=&amp;quot;sub.label&amp;quot;
                :value=&amp;quot;sub.value&amp;quot;
              &amp;gt;&amp;lt;/el-option&amp;gt;
            &amp;lt;/el-select&amp;gt;
          &amp;lt;/el-form-item&amp;gt;
        &amp;lt;/el-col&amp;gt;
      &amp;lt;/el-row&amp;gt;
    &amp;lt;/el-form&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
  model: {
    prop: &#39;filterObject&#39;,
    event: &#39;change&#39;,
  },
  props: {
    filterObject: {
      type: Object,
      default() {
        return {}
      },
    },
    labelWidth: {
      type: String,
      default: &#39;80px&#39;,
    },
    formData: {
      type: Array,
      default() {
        return []
      },
    },
  },
  data() {
    return {}
  },
  methods: {
    handleChange() {
      console.log(this.filterObject)
    },
  },
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中的&lt;strong&gt;filterObject&lt;/strong&gt;就是今天的主角了，我的想法是在父组件直接传递一个对象进来，在进行相关操作的时候，父组件直接可以在外面用到这些值，而不是通过子组件暴露方法获取这些值。(ps:在封装search组件的时候可以这么做，向外暴露search，reset方法可以暴露子组件里面的值。&lt;strong&gt;其实封装search跟这个form有点相似，都是用elementUI的form表单来封装的。&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;接下来是父组件的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;home&amp;quot;&amp;gt;
    &amp;lt;HHform
      :formData=&amp;quot;searchOptions&amp;quot;
      labelWidth=&amp;quot;120px&amp;quot;
      v-model=&amp;quot;filterObject&amp;quot;
    &amp;gt;&amp;lt;/HHform&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import HHform from &#39;@/components/HH-form&#39;
export default {
  name: &#39;Home&#39;,
  components: {
    HHform,
  },
  data() {
    return {
      searchOptions: [
        {
          type: &#39;select&#39;,
          prop: &#39;status&#39;,
          label: &#39;状态：&#39;,
          span: 5,
          placeholder: &#39;请选择&#39;,
          arr: [
            {
              value: &#39;&#39;,
              label: &#39;全部招生顾问&#39;,
            },
            {
              value: 1,
              label: &#39;正常招顾&#39;,
            },
            {
              value: 2,
              label: &#39;冻结招顾&#39;,
            },
          ],
        },
        {
          type: &#39;select&#39;,
          prop: &#39;region&#39;,
          label: &#39;地区：&#39;,
          span: 5,
          placeholder: &#39;请选择&#39;,
          arr: [],
        },
        {
          type: &#39;text&#39;,
          prop: &#39;userName&#39;,
          span: 8,
          label: &#39;招生顾问名称：&#39;,
          placeholder: &#39;选择或输入搜索&#39;,
        },
        {
          type: &#39;text&#39;,
          prop: &#39;phone&#39;,
          label: &#39;手机号：&#39;,
          span: 5,
          placeholder: &#39;选择或输入搜索&#39;,
        },
      ],
      filterObject: {},
    }
  },
  methods: {},
  },
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;父组件的代码比较简单，直接通过v-model传值过去就行了。下面是演示效果。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616568833036.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;目前封装form组件的时候是使用这种方法，父组件直接传值的话，不需要子组件提供方法返回值。在封装search组件的时候则是使用子组件暴露方法的方式拿到值的，为什么这么做呢？因为在进行搜索的时候一定会暴露search跟reset方法，这时候带出去就行了。&lt;/p&gt;
&lt;h1 id=&#34;13-大数据量表格加载慢的问题解决方案&#34;&gt;13. 大数据量表格加载慢的问题解决方案&lt;/h1&gt;
&lt;p&gt;由于目前表格实现技术是通过vue+elementUI实现的，所以以上解决方法都是通过vue+js+elementUI实现的，不过思路适用于其他技术。&lt;/p&gt;
&lt;p&gt;总共有以下几种方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个页面加载所有数据&lt;/li&gt;
&lt;li&gt;假分页加载数据（滚动加载数据）&lt;/li&gt;
&lt;li&gt;无限分页加载数据&lt;/li&gt;
&lt;li&gt;真分页加载数据（滚动加载数据）&lt;/li&gt;
&lt;li&gt;模拟滚动实现加载数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-一个页面加载所有数据&#34;&gt;1. 一个页面加载所有数据&lt;/h2&gt;
&lt;p&gt;这个其实就是elementUI自带的table表格功能，一个页面加载所有数据。&lt;/p&gt;
&lt;p&gt;这种方案优点就是非常简单啊，直接调用接口获取到数据，然后传入所有数据，最后一行一行全部渲染出来。&lt;/p&gt;
&lt;p&gt;但是缺点同样明显，首先要通过后台获取数据，如果数据非常多，那么数据越多接口返回速度就越慢，你就只能看着加载圈圈一直在转啊转。数据返回后还得渲染到页面上，数据量小你可能感觉不到什么，但是数据一旦一多比如一次渲染100条、1000条以上的数据，那么页面就会卡住直到数据渲染到页面上。所以这时就要有新的解决方法了。&lt;/p&gt;
&lt;h2 id=&#34;2-假分页显示数据滚动加载数据&#34;&gt;2. 假分页显示数据（滚动加载数据）&lt;/h2&gt;
&lt;p&gt;因为后台接口返回数据并不是很慢，但是表格渲染造成页面非常卡。所以这时就需要想一种方法让数据一次不全部渲染完，而是分批渲染。一次只渲染一部分数据，前一次数据渲染完后再渲染新的数据。&lt;/p&gt;
&lt;p&gt;这里有两种方案实现。一种就是利用elementUI中的分页器和表格实现，每次只加载当前页面的数据。比如有1000条数据，每页显示100条数据，就会分为10页，第一页显示0-100区间的数据，第二页显示100-200区间的数据，以此类推。通过点击不同页实现数据的截取。另外一种就是不需要分页器，还是在一页显示，只不过首次只加载一部分数据，当鼠标滚动到列表底部的时候再加载其他部分数据，实现思路和假分页其实一样，只不过展示不同，这种情况适用于手机上列表加载上。&lt;/p&gt;
&lt;p&gt;这两种方案优点是优化了假数据的渲染速度。&lt;/p&gt;
&lt;p&gt;缺点还是没解决后台接口返回数据慢的问题。而且就算分页，一页展示的数据量还是很多、表格复杂的时候还是卡顿。你可能会说一页展示尽可能少的数据，但是如果实际情况是最少展示100条数据，这种方法就不行。&lt;/p&gt;
&lt;h2 id=&#34;3-无限分页加载数据&#34;&gt;3. 无限分页加载数据&lt;/h2&gt;
&lt;p&gt;由于数据库中数据量增加的非常快，浏览表格时就不能确定总数，否则确定总数后分页器总页数也就固定了。就会造成最后一页的数据有可能显示的不是最新的。比如日志记录统计，这个变化非常快，一会就增加几十条。由于滚动加载的方式可以不用知道总数，就可以使用滚动加载的方式。不过PC端一般都是分页的，所以分页要解决这个问题就必须不确定总数，一直有下一页，可以点击请求后台接口，直到获取没有数据为止。&lt;/p&gt;
&lt;p&gt;所以就有了无限分页。实现方式是基于假分页上的。它的思路是先显示前6页的数据，不展示总页数。当点击第6页时再次调用接口返回7-13页数据，以此类推，如果返回的数据量不足6*每页数量则表示目前所有数据已返回了。&lt;/p&gt;
&lt;p&gt;这种方案优点是可以在&lt;code&gt;不知道总条数的情况下获取实时部分数据&lt;/code&gt;。因为多次请求接口，接口数据返回速度提升。适用于数据量大、数据增加速度快的场景。&lt;/p&gt;
&lt;p&gt;缺点是不常用，不好确定数据总数，场景固定。&lt;/p&gt;
&lt;h2 id=&#34;4-真分页加载数据滚动加载数据&#34;&gt;4. 真分页加载数据（滚动加载数据）&lt;/h2&gt;
&lt;p&gt;由于接口数据返回速度慢，导致表格加载变慢。前面无限分页已经优化了这个问题，但是无限分页不适用于一般的场景。要解决这个问题就必须&lt;code&gt;多次调用&lt;/code&gt;接口返回部分数据，而不是一次返回所有数据。&lt;/p&gt;
&lt;p&gt;有两种方案解决，一种是真分页，实现方式是基于假分页上的，只不过假分页是在所有数据上截取，而真分页是调用接口实现的。而且还得改动一些勾选全选逻辑，利用缓存记录不同页的勾选情况。它的思路是每次点击分页就给后台发送带当前页参数的请求，请求当前页的数据。另一种就是不需要分页器，还是在一页显示，当鼠标滚动到列表底部的时候再请求其他部分数据，实现思路和真分页其实一样，只不过展示不同，这种情况适用于手机上列表加载上。&lt;/p&gt;
&lt;p&gt;优点是接口调用速度提升到最优了。&lt;/p&gt;
&lt;p&gt;缺点是一页渲染的数据还是很多、表格复杂的时候还是卡顿。而且代码实现批量操作不同页数据的情况比较复杂。&lt;/p&gt;
&lt;h2 id=&#34;5-模拟滚动实现加载数据&#34;&gt;5. 模拟滚动实现加载数据&lt;/h2&gt;
&lt;p&gt;这种情况和后台接口返回速度没关系，只是为了解决单页面数据量大时的渲染问题。由于某些特定情况导致表格结构复杂、浏览器版本低，导致真分页情况下单页100条数据渲染都消耗很长时间。所以必须想一种方法解决单页可以渲染大量数据而不影响性能。&lt;/p&gt;
&lt;p&gt;因为电脑显示屏就那么大，加载表格时你能直观看见的也就最多20条数据左右。所以为什么不可以只渲染20条数据左右，然后鼠标滚动就更新当前数据，DOM数量也就不会增加。就算你有百万条数据，你能直观看见的只能是20条数据左右，你只能通过总条数、滚动条来判断总数。总条数可以通过数据的数量来得到，所以只需要模拟滚动条位置就行了。滚动条一滚动就根据滚动条位置拿到能看见的数据。其实就是通过欺骗用户视觉来达到目的。&lt;/p&gt;
&lt;p&gt;你现在有100条数据需要显示在表格中，你直观只能看见20条数据左右，所以你只需要固定表格高度、每行高度就可以知道20行数据的高度，以及其余80条数据的总高度。所以现在加载100条数据的表格可以变成顶部空的只有高度的div和中部你看见的20条数据和底部空的只有高度的div的组合。滚动条向下滚动的时候增加顶部div的高度，减少底部div的高度，改变中部显示的数据。这样就实现了模拟滚动的功能。&lt;/p&gt;
&lt;p&gt;优点是优化了表格渲染的性能。可以和假分页真分页一起使用。可以摆脱复杂的分页实现方式，只用单页渲染不卡顿。&lt;/p&gt;
&lt;p&gt;缺点是实现起来比较复杂。&lt;/p&gt;
&lt;h2 id=&#34;6-总结&#34;&gt;6. 总结&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618378715611.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;14-前端性能监控你会监控哪些数据&#34;&gt;14. 前端性能监控你会监控哪些数据?&lt;/h1&gt;
&lt;h2 id=&#34;1-为什么要做性能监控&#34;&gt;1. 为什么要做性能监控&lt;/h2&gt;
&lt;p&gt;对于公司来说，性能在一定程度上与利益直接相关&lt;/p&gt;
&lt;p&gt;为什么性能会影响公司的收益呢？根本原因还是在于性能影响了用户体验。加载的延迟、操作的卡顿等都会影响用户的使用体验。尤其是移动端，用户对页面响应延迟和连接中断的容忍度很低。想象一下你拿着手机打开一个网页想看到某个信息却加载半天的心情，你很可能选择直接离开换一个网页。谷歌也将页面加载速度作为 SEO 的一个权重&lt;/p&gt;
&lt;h2 id=&#34;2-哪些点需要监控&#34;&gt;2. 哪些点需要监控&lt;/h2&gt;
&lt;p&gt;我们可以分为以下几个点来进行监控&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;白屏时间&lt;/li&gt;
&lt;li&gt;首屏时间&lt;/li&gt;
&lt;li&gt;用户可操作时间&lt;/li&gt;
&lt;li&gt;总下载时间&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-白屏时间&#34;&gt;1. 白屏时间&lt;/h3&gt;
&lt;p&gt;白屏时间是用户首次看到内容的时间，也叫做首次渲染时间，chrome 高版本有 firstPaintTime 接口来获取这个耗时，但大部分浏览器并不支持，必须想其他办法来监测。仔细观察 WebPagetest 视图分析发现，白屏时间出现在头部外链资源加载完附近，因为浏览器只有加载并解析完头部资源才会真正渲染页面。基于此我们可以通过获取头部资源加载完的时刻来近似统计白屏时间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE HTML&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;/&amp;gt;
    &amp;lt;script&amp;gt;
      var start_time = +new Date; //测试时间起点，实际统计起点为 
    &amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;  
    &amp;lt;script&amp;gt;
      var end_time = +new Date; //时间终点
      var headtime = end_time - start_time; //头部资源加载时间    
      console.log(headtime);
    &amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-首屏时间&#34;&gt;2. 首屏时间&lt;/h3&gt;
&lt;p&gt;首屏时间的统计比较复杂，因为涉及图片等多种元素及异步渲染等方式。观察加载视图可发现，影响首屏的主要因素的图片的加载。通过统计首屏内图片的加载时间便可以获取首屏渲染完成的时间。统计流程如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;首屏位置调用 API 开始统计 -&amp;gt; 
绑定首屏内所有图片的 load 事件 -&amp;gt; 页面加载完后判断图片是否在首屏内，找出加载最慢的一张 -&amp;gt;
首屏时间
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-可操作时间&#34;&gt;3. 可操作时间&lt;/h3&gt;
&lt;p&gt;用户可操作默认可以统计domready时间，因为通常会在这时候绑定事件操作。对于使用了模块化异步加载的 JS 可以在代码中去主动标记重要 JS 的加载时间，这也是产品指标的统计方式&lt;/p&gt;
&lt;h3 id=&#34;4-总下载时间&#34;&gt;4. 总下载时间&lt;/h3&gt;
&lt;p&gt;总下载时间默认可以统计onload时间，这样可以统计同步加载的资源全部加载完的耗时。如果页面中存在很多异步渲染，可以将异步渲染全部完成的时间作为总下载时间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;白屏时间指head内资源加载完成&lt;/li&gt;
&lt;li&gt;首屏时间指可视区域内最后一张图片加载完成的时间&lt;/li&gt;
&lt;li&gt;可操作时间指Document.onready时间&lt;/li&gt;
&lt;li&gt;总下载时间指Document.onload时间&lt;/li&gt;
&lt;/ul&gt;
">【面】前端知识点梳理（Vue项目）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/mian-qian-duan-zhi-shi-dian-shu-li-shou-xie-ti/"" data-c="
          &lt;h1 id=&#34;1-ip地址与整数的相互转换&#34;&gt;1 ip地址与整数的相互转换&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;//IP转成整型
function _ip2int(ip) 
{
    var num = 0;
    ip = ip.split(&amp;quot;.&amp;quot;);
    num = Number(ip[0]) * 256 * 256 * 256 + Number(ip[1]) * 256 * 256 + Number(ip[2]) * 256 + Number(ip[3]);
    num = num &amp;gt;&amp;gt;&amp;gt; 0;
    return num;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;//整型解析为IP地址
function _int2iP(num) 
{
    var str;
    var tt = new Array();
    tt[0] = (num &amp;gt;&amp;gt;&amp;gt; 24) &amp;gt;&amp;gt;&amp;gt; 0;
    tt[1] = ((num &amp;lt;&amp;lt; 8) &amp;gt;&amp;gt;&amp;gt; 24) &amp;gt;&amp;gt;&amp;gt; 0;
    tt[2] = (num &amp;lt;&amp;lt; 16) &amp;gt;&amp;gt;&amp;gt; 24;
    tt[3] = (num &amp;lt;&amp;lt; 24) &amp;gt;&amp;gt;&amp;gt; 24;
    str = String(tt[0]) + &amp;quot;.&amp;quot; + String(tt[1]) + &amp;quot;.&amp;quot; + String(tt[2]) + &amp;quot;.&amp;quot; + String(tt[3]);
    return str;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2-手写原生ajax&#34;&gt;2. 手写原生Ajax&lt;/h1&gt;
&lt;h2 id=&#34;get请求&#34;&gt;Get请求&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const xhr = new XMLHttpRequest()
        xhr.open(&amp;quot;GET&amp;quot;, &amp;quot;http://localhost:3000/users?id=1&amp;quot;)
        xhr.send(null)

        xhr.onreadystatechange = function () {
            if (this.readyState === 4) {
                console.log(this.responseText);
            }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;post请求&#34;&gt;Post请求&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const xhr = new XMLHttpRequest()
        xhr.open(&amp;quot;POST&amp;quot;, &amp;quot;http://localhost:3000/users&amp;quot;)
        xhr.setRequestHeader(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)
        // 转换为json传递
        xhr.send(JSON.stringify({
            &amp;quot;name&amp;quot;: &amp;quot;luke&amp;quot;,
            &amp;quot;age&amp;quot; : 19,
            &amp;quot;class&amp;quot;: 2
        }))

        xhr.onreadystatechange = function () {
            if (this.readyState === 4) {
                console.log(this.responseText);
            }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3-手写实现-bind&#34;&gt;3. 手写实现 bind()&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;Function.prototype.MyBind = function (context, ...args) {
  let self = this;
  return function() {
    return self.apply(context, args);
  }
}

// test
let a = {name: &#39;jack&#39;} 
let test = function() {
  console.log(this.name); // jack
}
let rs = test.MyBind(a);
rs();
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;4-手写实现-apply&#34;&gt;4. 手写实现 apply()&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;Function.prototype.myApply = function (context, args) {
  context.fn = this;
  let res;
  if (!args){
    res = context.fn();
  } else  {
    res = context.fn(...args)
  }
  return res;
}

// test
let obj = {
  name: &#39;jack&#39;
}
function test(arg1, arg2, arg3) {
  console.log(this.name)   // jack
  console.log(arg1, arg2, arg3);  // 1 2 3
}
test.myApply(obj, [1,2,3]);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5-手写实现-call&#34;&gt;5. 手写实现 call()&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;Function.prototype.myCall = function (context, ...rest) {
  context.fn = this;
  var result = context.fn(...rest);
  delete context.fn;
  return result;
}

// test
let obj = {
  name: &#39;jack&#39;
}
function test(arg1, arg2, arg3) {
  console.log(this.name)   // jack
  console.log(arg1, arg2, arg3);  // 1 2 3
}
test.myCall(obj, 1,2,3);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;6-手写实现-instanceof&#34;&gt;6. 手写实现 instanceof&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function myInstanceOf(left, right) {
  let prototype = right.prototype;
  left = left.__proto__;
  while(true) {
    if (!left) return false;
    if (left == prototype) return true;
    left = left.__proto__;
  }
}

console.log(myInstanceOf([], Array));  // true
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;7-手写实现-new&#34;&gt;7. 手写实现 new&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function myNew (fun, ...args) {
  let obj = {};
  obj.__proto__ = fun.prototype;
  let res = fun.apply(obj, args);
  return res instanceof Object ? res : obj;
}

function Animal(name) {
  this.name = name;
}
let animal = myNew(Animal, &#39;dog&#39;);
console.log(animal.name)  // dog
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;8-手写实现-jsonp&#34;&gt;8. 手写实现 jsonp&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;var newscript = document.createElement(&#39;script&#39;);
newscript.src = &#39;https://www.adb.com?callback=fn&#39;
document.body.appendChild(newscript);
function fn(data) {
  console.log(data);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;9-手写实现-promise&#34;&gt;9. 手写实现 Promise&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const PENDING = Symbol();
const REJECTED = Symbol();
const FULLFILLED = Symbol();

const MyPromise = function(fn) {
  this.state = PENDING;
  this.value = &#39;&#39;;

  const resolve = (value) =&amp;gt; {
    this.state = FULLFILLED;
    this.value = value;
  }

  const reject = (error) =&amp;gt; {
    this.state = REJECTED;
    this.value = error;
  }

  this.then = (onFullFill, onReject) =&amp;gt; {
    if (this.state == FULLFILLED) {
      onFullFill(this.value);
    } else {
      onReject(this.value);
    }
  }

  try {
    fn(resolve, reject);
  } catch(error) {
    reject(error);
  }
}

// test
let p = new MyPromise((resolve, reject) =&amp;gt; {
  resolve(&#39;hello&#39;);
})
p.then(res =&amp;gt; {
  console.log(res);  // hello
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;10-手写实现promiseall&#34;&gt;10. 手写实现promise.all()&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function isPromise(obj) {
  return !!obj &amp;amp;&amp;amp; (typeof obj === &#39;function&#39; || typeof obj === &#39;object&#39;) &amp;amp;&amp;amp; typeof obj.then == &#39;function&#39;;
}

function myPromiseAll(arr) {
  let res = []
  return new Promise((resolve, reject) =&amp;gt; {
    for (let i = 0; i &amp;lt; arr.length; i++) {
      if (isPromise(arr[i])) {
        arr[i].then(data =&amp;gt; {
          res[i] = data;
          if (res.length === arr.length) {
            resolve(res)
          }
        }).catch(error =&amp;gt; {
          reject(error)
        })
      } else {
        res[i] = arr[i];
      }
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;11-手写实现promiserace&#34;&gt;11. 手写实现promise.race()&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function myPromiseRace(arr) {
  return new Promise((resolve, reject) =&amp;gt; {
    for (let i = 0; i &amp;lt; arr.length; i++) {
      return arr[i].then(resolve, reject)
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;12-手写实现eventemitter-订阅监听模式&#34;&gt;12. 手写实现EventEmitter 订阅监听模式&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;class EventEmitter {
  constructor() {
    this.events = {};
  }
  on (eventName, callback) {
    if(!this.events[eventName]) {
      this.events[eventName] = [callback];
    } else {
      this.events[eventName].push(callback);
    }
  }

  emit(eventName, ...args) {
    this.events[eventName].forEach(fn =&amp;gt; fn.apply(this, args));
  }

  once(eventName, callback) {
    const fn = () =&amp;gt; {
      callback();
      this.remove(eventName, fn);
    }
    this.on(eventName, fn)
  }

  remove(eventName, callback) {
    this.events[eventName] = this.events[eventName].filter(fn =&amp;gt; fn != callback);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;13-手写settimout-实现-setinterval&#34;&gt;13. 手写setTimout 实现 setInterval&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function myInterval(fn, time) {
  let context = this;
  setTimeout(() =&amp;gt; {
    fn.call(context);
    myInterval(fn, time);
  }, time);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;14-手写实现深拷贝&#34;&gt;14. 手写实现深拷贝&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function deepClone(obj) {
  // 先判断是对象还是数组
  let copy = obj instanceof Array ? [] : {};
  for (let key in obj) {
    // 判断是否是对象上的属性，而不是原型上的属性
    if (obj.hasOwnProperty(key)) {
      // obj[key] 是否是对象，如果是对象，递归遍历
      copy[key] = typeof obj[key] === &#39;object&#39; ? deepClone(obj[key]) : obj[key];
    }
  }
  return copy;
}

// test
console.log(deepClone({name: &#39;jack&#39;, birth: {year: &#39;1997&#39;, month: &#39;10&#39;}})) // {name: &#39;jack&#39;, birth: {…}}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;递归实现&#34;&gt;递归实现&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;function copy(obj){
   let newobj = null;   //声明一个变量用来储存拷贝之后的内容
   
//判断数据类型是否是复杂类型，如果是则调用自己，再次循环，如果不是，直接赋值即可，
//由于null不可以循环但类型又是object，所以这个需要对null进行判断
   if(typeof(obj) == &#39;object&#39; &amp;amp;&amp;amp; obj !== null){ 
   
//声明一个变量用以储存拷贝出来的值,根据参数的具体数据类型声明不同的类型来储存
       newobj = obj instanceof Array? [] : {};   
       
//循环obj 中的每一项，如果里面还有复杂数据类型，则直接利用递归再次调用copy函数
       for(var i in obj){  
           newobj[i] = copy(obj[i])
       }
   }else{
       newobj = obj
   }    
 return newobj;    //函数必须有返回值，否则结构为undefined
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解决循环调用&#34;&gt;解决循环调用&lt;/h2&gt;
&lt;p&gt;循环引用问题的产生原因可能是对象之间相互引用，也可能是对象引用了其自身，而造成死循环的原因则是我们在进行深拷贝时并没有将这种引用情况考虑进去，因此解决问题的关键也就是可以将这些引用存储起来并在发现引用时返回被引用过的对象，从而结束递归的调用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function deepClone( originObj, map = new WeakMap() ) {
  if(!originObj || typeof originObj !== &#39;object&#39;) return originObj;  //空或者非对象则返回本身

  //如果这个对象已经被记录则直接返回
  if( map.get(originObj) ) {
      return  map.get(originObj);
  }
  //这个对象还没有被记录，将其引用记录在map中，进行拷贝    
  let result = Array.isArray(originObj) ? [] : {};  //拷贝结果
  map.set(originObj, result); //记录引用关系
  let keys = Object.keys(originObj); //originObj的全部key集合
  //拷贝
  for(let i =0,len=keys.length; i&amp;lt;len; i++) {
      let key = keys[i];
      let temp = originObj[key];
      result[key] = deepClone(temp, map);
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;15-手写实现浅拷贝&#34;&gt;15. 手写实现浅拷贝(...)&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function clone(obj) {
    var cloneObj = {}
    // for in 遍历，会遍历原型链里面的属性，所以需要排除原型链
    for(var key in obj) {
        if(obj.hasOwnProperty(key)) {
            cloneObj[key] = obj[key]
        }
    }
    return cloneObj
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;16-手写实现数组拍平&#34;&gt;16. 手写实现数组拍平&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;var flatten = function(arr) {
  let res = [];
  for (let i = 0; i &amp;lt; arr.length; i++) {
    if (Array.isArray(arr[i])) {
      res = res.concat(flatten(arr[i]))
    } else {
      res.push(arr[i])
    }
  }
  return res;
}

console.log(flatten([1,[1,2,[2,4]],3,5]));  // [1, 1, 2, 2, 4, 3, 5]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;17-手写函数防抖&#34;&gt;17. 手写函数防抖&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function debounce(fn, wait) {
  let timeout = null;
  return function() {
    let context = this;
    let args = arguments;
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() =&amp;gt; {
      fn.apply(context, args);
    }, wait);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;18-手写函数节流&#34;&gt;18. 手写函数节流&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function throttle(fn, wait) {
  let  pre = new Date();
  return function() {
    let context = this;
    let args = arguments;
    let now = new  Date();
    if (now - pre &amp;gt;= wait) {
      fn.apply(context, args);
      pre = now;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;19-手写函数柯里化实现-sum123&#34;&gt;19. 手写函数柯里化（实现 sum(1,2)(3)()）&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function sum(...args1) {
  let x = args1.reduce((prev, next) =&amp;gt; {return prev+next;})
  return function(...args2) {
    if (args2.length == 0) return x;
    let y = args2.reduce((prev, next) =&amp;gt; {return prev+next;})
    return sum(x+y)
  }
}

console.log(sum(1,2,2,5)(7)()) // 17
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;20-手写快速排序&#34;&gt;20. 手写快速排序&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function quicksort(arr) {
  if (arr.length &amp;lt;= 1) return arr;
  let pivotIndex = Math.floor(arr.length/2);
  let pivot = arr.splice(pivotIndex, 1)[0];
  let left = [];
  let right = [];
  for (let i = 0; i &amp;lt; arr.length; i++) {
    if (arr[i] &amp;lt;= pivot)  {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  return quicksort(left).concat(pivot, quicksort(right));

}

console.log(quicksort([4,3,5,2,1,6]));   //  [1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;21-手写归并排序&#34;&gt;21. 手写归并排序&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function merge(left, right) {
  let res = [];
  while(left.length &amp;gt; 0 &amp;amp;&amp;amp; right.length &amp;gt; 0) {
    if (left[0] &amp;lt; right[0]) {
      res.push(left.shift());
    } else {
      res.push(right.shift());
    }
  }
  return res.concat(left).concat(right);
}

function mergeSort(arr) {
  if (arr.length == 1) return arr;
  var middle = Math.floor(arr.length / 2);
  var left = arr.slice(0, middle);
  var right = arr.slice(middle);
  return merge(mergeSort(left), mergeSort(right));
}

console.log(mergeSort([3,2,4,5,1,6]));  // [1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;22-手写数组去重&#34;&gt;22. 手写数组去重&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;let arr2 = [1, 2, 3, 2, 33, 55, 66, 3, 55];
let newArr = [...new Set(arr2)];
console.log(newArr);

// (6) [1, 2, 3, 33, 55, 66]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;23-手写数组合并&#34;&gt;23. 手写数组合并&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;let arr3 = [&#39;a&#39;, &#39;b&#39;]
let arr4 = [&#39;c&#39;, &#39;d&#39;]

let arr6 = [...arr3, ...arr4];
console.log(arr6);
// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;24-手写实现map&#34;&gt;24. 手写实现map&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;Array.prototype.myMap = function(callbackFn, thisArg) {
 if (typeof callbackFn !== &#39;function&#39;) throw (&#39;callbackFn参数必须是函数&#39;);
 let element = this,
 len = element &amp;amp;&amp;amp; element.length || 0,
 result = [];
 if (!thisArg) thisArg = element;
 for (let index = 0; index &amp;lt; len; index++) {
 result[index] = callbackFn.call(thisArg, element[index], index, element);
 }
 return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;25-手写实现new&#34;&gt;25. 手写实现new&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;new&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新生成了一个对象&lt;/li&gt;
&lt;li&gt;新对象隐式原型链接到函数原型&lt;/li&gt;
&lt;li&gt;调用函数绑定this&lt;/li&gt;
&lt;li&gt;返回新对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;核心代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function _new(fun) {
  return function() {
    let obj = {
      __proto__: fun.prototype
    }
    fun.apply(obj, arguments)
    return obj
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试用例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function person(name, age) {
  this.name = name
  this.age = age
}
let obj = _new(person)(&#39;LL&#39;, 100)
console.log(obj) //{name: &#39;LL&#39;, age: 100}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;26-手写解析url&#34;&gt;26. 手写解析url&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;var url=&amp;quot;http://www.baidu.com/we/index.html?id=898602B8261890349226&amp;amp;aaa=123&amp;amp;ccc=456&amp;quot;;
  var transform=function(str){
      // 创建目标对象
      var REQUEST = new Object, 
      // 截取数据字符串
      data=str.slice(str.indexOf(&amp;quot;?&amp;quot;),str.length),
      // 将数据字符串表现为数组
      aParams = data.substr(1).split(&amp;quot;&amp;amp;&amp;quot;);
      for (i = 0; i &amp;lt; aParams.length; i++) {
          // 数据属性与数值分离
　　          var aParam = aParams[i].split(&amp;quot;=&amp;quot;);
          // 使用属性括号进行属性赋值
              REQUEST[aParam[0]] = aParam[1]
      }
      console.log(REQUEST);
  }
  transform(url);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;27-字符串原型-输出三个hello&#34;&gt;27. 字符串原型 输出三个hello&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;String.prototype.repeatify = String.prototype.repeatify || function(times) {
  var str = &#39;&#39;;
  for (var i = 0; i &amp;lt; times; i++) {
     str += this;
  }
  return str;
};
console.log(&#39;hello&#39;.repeatify(3));
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;28-手写实现翻转链表&#34;&gt;28. 手写实现翻转链表&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function ReverseList(pHead)
{
    let prev = null;
    let cur = pHead;
    while(cur){
      let next = cur.next;
      cur.next = prev;
      prev = cur;
      cur = next;
    }
    return prev;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;29-手写实现反转数组&#34;&gt;29. 手写实现反转数组&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;for (var i=0;i&amp;lt;array.length/2;i++){
  var temp = array[i]
  array[i] = array[array.length-1-i]
  array[array.length-1-i] = temp
}
&lt;/code&gt;&lt;/pre&gt;
">【面】前端知识点梳理（手写题）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/mian-qian-duan-zhi-shi-dian-shu-li-gong-ju-yu-zu-jian/"" data-c="
          &lt;h1 id=&#34;1-关于webpack的面试题总结&#34;&gt;1. 关于webpack的面试题总结&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;webpack与grunt、gulp的不同？&lt;/li&gt;
&lt;li&gt;与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack？&lt;/li&gt;
&lt;li&gt;有哪些常见的Loader？他们是解决什么问题的？&lt;/li&gt;
&lt;li&gt;有哪些常见的Plugin？他们是解决什么问题的？&lt;/li&gt;
&lt;li&gt;Loader和Plugin的不同？&lt;/li&gt;
&lt;li&gt;webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全&lt;/li&gt;
&lt;li&gt;是否写过Loader和Plugin？描述一下编写loader或plugin的思路？&lt;/li&gt;
&lt;li&gt;webpack的热更新是如何做到的？说明其原理？&lt;/li&gt;
&lt;li&gt;如何利用webpack来优化前端性能？（提高性能和体验）&lt;/li&gt;
&lt;li&gt;如何提高webpack的构建速度？&lt;/li&gt;
&lt;li&gt;怎么配置单页应用？怎么配置多页应用？&lt;/li&gt;
&lt;li&gt;npm打包时需要注意哪些？如何利用webpack来更好的构建？&lt;/li&gt;
&lt;li&gt;如何在vue项目中实现按需加载？&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;1-webpack与grunt-gulp的不同&#34;&gt;1. webpack与grunt、gulp的不同？&lt;/h2&gt;
&lt;p&gt;三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。&lt;/p&gt;
&lt;p&gt;grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。&lt;/p&gt;
&lt;p&gt;webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以总结一下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;从构建思路来说&lt;/strong&gt;：gulp和grunt需要开发者将整个前端构建过程拆分成多个&lt;code&gt;Task&lt;/code&gt;，并合理控制所有&lt;code&gt;Task&lt;/code&gt;的调用关系；webpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对于知识背景来说&lt;/strong&gt;：gulp更像后端开发者的思路，需要对于整个流程了如指掌 webpack更倾向于前端开发者的思路&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-与webpack类似的工具还有哪些谈谈你为什么最终选择或放弃使用webpack&#34;&gt;2. 与webpack类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用webpack？&lt;/h2&gt;
&lt;p&gt;同样是基于入口的打包工具还有以下几个主流的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;webpack&lt;/li&gt;
&lt;li&gt;rollup&lt;/li&gt;
&lt;li&gt;parcel&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;从应用场景上来看：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;webpack适用于大型复杂的前端站点构建&lt;/li&gt;
&lt;li&gt;rollup适用于基础库的打包，如vue、react&lt;/li&gt;
&lt;li&gt;parcel适用于简单的实验性项目，他可以满足低门槛的快速看到效果&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-有哪些常见的loader他们是解决什么问题的&#34;&gt;3. 有哪些常见的Loader？他们是解决什么问题的？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件&lt;/li&gt;
&lt;li&gt;url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去&lt;/li&gt;
&lt;li&gt;source-map-loader：加载额外的 Source Map 文件，以方便断点调试&lt;/li&gt;
&lt;li&gt;image-loader：加载并且压缩图片文件&lt;/li&gt;
&lt;li&gt;babel-loader：把 ES6 转换成 ES5&lt;/li&gt;
&lt;li&gt;css-loader：加载 CSS，支持模块化、压缩、文件导入等特性&lt;/li&gt;
&lt;li&gt;style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。&lt;/li&gt;
&lt;li&gt;eslint-loader：通过 ESLint 检查 JavaScript 代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-有哪些常见的plugin他们是解决什么问题的&#34;&gt;4. 有哪些常见的Plugin？他们是解决什么问题的？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;define-plugin：定义环境变量&lt;/li&gt;
&lt;li&gt;commons-chunk-plugin：提取公共代码&lt;/li&gt;
&lt;li&gt;uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-loader和plugin的不同&#34;&gt;5. Loader和Plugin的不同？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;不同的作用&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Loader直译为&amp;quot;加载器&amp;quot;。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了&lt;code&gt;加载和解析非JavaScript文件的能力&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Plugin直译为&amp;quot;插件&amp;quot;。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;不同的用法&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Loader在&lt;code&gt;module.rules&lt;/code&gt;中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）&lt;/li&gt;
&lt;li&gt;Plugin在&lt;code&gt;plugins&lt;/code&gt;中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6-webpack的构建流程是什么从读取配置到输出文件这个过程尽量说全&#34;&gt;6. webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全&lt;/h2&gt;
&lt;p&gt;Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；&lt;/li&gt;
&lt;li&gt;开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；&lt;/li&gt;
&lt;li&gt;确定入口：根据配置中的 entry 找出所有的入口文件；&lt;/li&gt;
&lt;li&gt;编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；&lt;/li&gt;
&lt;li&gt;完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；&lt;/li&gt;
&lt;li&gt;输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；&lt;/li&gt;
&lt;li&gt;输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。&lt;/p&gt;
&lt;h2 id=&#34;7-是否写过loader和plugin描述一下编写loader或plugin的思路&#34;&gt;7. 是否写过Loader和Plugin？描述一下编写loader或plugin的思路？&lt;/h2&gt;
&lt;p&gt;Loader像一个&amp;quot;翻译官&amp;quot;把读到的源文件内容转义成新的文件内容，并且每个Loader通过链式操作，将源文件一步步翻译成想要的样子。&lt;/p&gt;
&lt;p&gt;编写Loader时要遵循单一原则，每个Loader只做一种&amp;quot;转义&amp;quot;工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。&lt;/p&gt;
&lt;p&gt;相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。&lt;/p&gt;
&lt;h2 id=&#34;8-webpack的热更新是如何做到的说明其原理&#34;&gt;8. webpack的热更新是如何做到的？说明其原理？&lt;/h2&gt;
&lt;p&gt;webpack的热更新又称热替换（Hot Module Replacement），缩写为HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1617701765337.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;首先要知道server端和client端都做了处理工作&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。&lt;/li&gt;
&lt;li&gt;第二步是 webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。&lt;/li&gt;
&lt;li&gt;第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。&lt;/li&gt;
&lt;li&gt;第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。&lt;/li&gt;
&lt;li&gt;webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。&lt;/li&gt;
&lt;li&gt;HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。&lt;/li&gt;
&lt;li&gt;而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。&lt;/li&gt;
&lt;li&gt;最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;9-如何利用webpack来优化前端性能提高性能和体验&#34;&gt;9. 如何利用webpack来优化前端性能？（提高性能和体验）&lt;/h2&gt;
&lt;p&gt;用webpack优化前端性能是指优化webpack的&lt;code&gt;输出结果&lt;/code&gt;，让打包的最终结果在浏览器运行快速高效。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css&lt;/li&gt;
&lt;li&gt;利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径&lt;/li&gt;
&lt;li&gt;删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数--optimize-minimize来实现&lt;/li&gt;
&lt;li&gt;提取公共代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;10-如何提高webpack的构建速度&#34;&gt;10. 如何提高webpack的构建速度？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;多入口情况下，使用CommonsChunkPlugin来提取公共代码&lt;/li&gt;
&lt;li&gt;通过externals配置来提取常用库&lt;/li&gt;
&lt;li&gt;利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。&lt;/li&gt;
&lt;li&gt;使用Happypack 实现多线程加速编译&lt;/li&gt;
&lt;li&gt;使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度&lt;/li&gt;
&lt;li&gt;使用Tree-shaking和Scope Hoisting来剔除多余代码&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;11-怎么配置单页应用怎么配置多页应用&#34;&gt;11. 怎么配置单页应用？怎么配置多页应用？&lt;/h2&gt;
&lt;p&gt;单页应用可以理解为webpack的标准模式，直接在entry中指定单页应用的入口即可，这里不再赘述&lt;/p&gt;
&lt;p&gt;多页应用的话，可以使用webpack的 AutoWebPlugin来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。 多页应用中要注意的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套css样式表&lt;/li&gt;
&lt;li&gt;随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12-npm打包时需要注意哪些如何利用webpack来更好的构建&#34;&gt;12. npm打包时需要注意哪些？如何利用webpack来更好的构建？&lt;/h2&gt;
&lt;p&gt;NPM模块需要注意以下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;要支持CommonJS模块化规范，所以要求打包后的最后结果也遵守该规则。&lt;/li&gt;
&lt;li&gt;Npm模块使用者的环境是不确定的，很有可能并不支持ES6，所以打包的最后结果应该是采用ES5编写的。并且如果ES5是经过转换的，请最好连同SourceMap一同上传。&lt;/li&gt;
&lt;li&gt;Npm包大小应该是尽量小（有些仓库会限制包大小）&lt;/li&gt;
&lt;li&gt;发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。&lt;/li&gt;
&lt;li&gt;UI组件类的模块应该将依赖的其它资源文件，例如.css文件也需要包含在发布的模块里。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基于以上需要注意的问题，我们可以对于webpack配置做以下扩展和优化：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CommonJS模块化规范的解决方案： 设置output.libraryTarget=&#39;commonjs2&#39;使输出的代码符合CommonJS2 模块化规范，以供给其它模块导入使用&lt;/li&gt;
&lt;li&gt;输出ES5代码的解决方案：使用babel-loader把 ES6 代码转换成 ES5 的代码。再通过开启devtool: &#39;source-map&#39;输出SourceMap以发布调试。&lt;/li&gt;
&lt;li&gt;Npm包大小尽量小的解决方案：Babel 在把 ES6 代码转换成 ES5 代码时会注入一些辅助函数，最终导致每个输出的文件中都包含这段辅助函数的代码，造成了代码的冗余。解决方法是修改.babelrc文件，为其加入transform-runtime插件&lt;/li&gt;
&lt;li&gt;不能将依赖模块打包到NPM模块中的解决方案：使用externals配置项来告诉webpack哪些模块不需要打包。&lt;/li&gt;
&lt;li&gt;对于依赖的资源文件打包的解决方案：通过css-loader和extract-text-webpack-plugin来实现，配置如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;const ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;);

module.exports = {
  module: {
    rules: [
      {
        // 增加对 CSS 文件的支持
        test: /\.css/,
        // 提取出 Chunk 中的 CSS 代码到单独的文件中
        use: ExtractTextPlugin.extract({
          use: [&#39;css-loader&#39;]
        }),
      },
    ]
  },
  plugins: [
    new ExtractTextPlugin({
      // 输出的 CSS 文件名称
      filename: &#39;index.css&#39;,
    }),
  ],
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;13-如何在vue项目中实现按需加载&#34;&gt;13. 如何在vue项目中实现按需加载？&lt;/h2&gt;
&lt;p&gt;Vue UI组件库的按需加载 为了快速开发前端项目，经常会引入现成的UI组件库如ElementUI、iView等，但是他们的体积和他们所提供的功能一样，是很庞大的。 而通常情况下，我们仅仅需要少量的几个组件就足够了，但是我们却将庞大的组件库打包到我们的源码中，造成了不必要的开销。&lt;/p&gt;
&lt;p&gt;不过很多组件库已经提供了现成的解决方案，如Element出品的babel-plugin-component和AntDesign出品的babel-plugin-import 安装以上插件后，在.babelrc配置中或babel-loader的参数中进行设置，即可实现组件按需加载了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;presets&amp;quot;: [[&amp;quot;es2015&amp;quot;, { &amp;quot;modules&amp;quot;: false }]],
  &amp;quot;plugins&amp;quot;: [
    [
      &amp;quot;component&amp;quot;,
      {
        &amp;quot;libraryName&amp;quot;: &amp;quot;element-ui&amp;quot;,
        &amp;quot;styleLibraryName&amp;quot;: &amp;quot;theme-chalk&amp;quot;
      }
    ]
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;单页应用的按需加载&lt;/strong&gt; 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;import(*)&lt;/code&gt;语句来控制加载时机，webpack内置了对于import(*)的解析，会将import(*)中引入的模块作为一个新的入口在生成一个chunk。 当代码执行到import(*)语句时，会去加载Chunk对应生成的文件。import()会返回一个Promise对象，所以为了让浏览器支持，需要事先注入Promise polyfill&lt;/p&gt;
&lt;h1 id=&#34;2-git命令&#34;&gt;2. Git命令&lt;/h1&gt;
&lt;h2 id=&#34;1-什么是-rebase&#34;&gt;1. 什么是 rebase?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;git rebase&lt;/strong&gt;你其实可以把它理解成是“重新设置基线”，将你的当前分支重新设置开始点。这个时候才能知道你当前分支于你需要比较的分支之间的差异。&lt;/p&gt;
&lt;p&gt;原理很简单：rebase需要基于一个分支来设置你当前的分支的基线，这基线就是当前分支的开始时间轴向后移动到最新的跟踪分支的最后面，这样你的当前分支就是最新的跟踪分支。这里的操作是基于文件事务处理的，所以你不用怕中间失败会影响文件的一致性。在中间的过程中你可以随时取消rebase 事务。&lt;/p&gt;
&lt;h2 id=&#34;2-git-rebase-和-git-merge-有啥区别&#34;&gt;2. git rebase 和 git merge 有啥区别？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;rebase&lt;/strong&gt;会把你当前分支的 commit 放到公共分支的最后面,所以叫变基。就好像你从公共分支又重新拉出来这个分支一样。&lt;br&gt;
举例：如果你从 master 拉了个feature分支出来，然后你提交了几个 commit,这个时候刚好有人把他开发的东西合并到 master 了，这个时候 master 就比你拉分支的时候多了几个 commit,如果这个时候你 rebase master 的话，就会把你当前的几个 commit，放到那个人 commit 的后面。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618473236809.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;merge&lt;/strong&gt;会把公共分支和你当前的commit 合并在一起，形成一个新的 commit 提交&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618473414229.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要在公共分支使用rebase&lt;/li&gt;
&lt;li&gt;本地和远端对应同一条分支，优先使用rebase，而不是merge&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-为什么不要再公共分支使用rebase&#34;&gt;3. 为什么不要再公共分支使用rebase?&lt;/h2&gt;
&lt;p&gt;因为往后放的这些 commit 都是新的，这样其他从这个公共分支拉出去的人，都需要再 rebase，相当于你 rebase 东西进来，就都是新的 commit 了&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618473493968.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;merge和rebase实际上只是用的场景不一样&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;更通俗的解释一波&lt;/strong&gt;&lt;br&gt;
比如rebase，你自己开发分支一直在做，然后某一天，你想把主线的修改合到你的分支上，做一次集成，这种情况就用rebase比较好。把你的提交都放在主线修改的头上&lt;/p&gt;
&lt;p&gt;同样的,如果你在主分支上用rebase, rebase其他分支的修改,是不是要是别人想看主分支上有什么历史,他看到的就不是完整的历史，这个历史已经被你篡改了&lt;/p&gt;
&lt;h2 id=&#34;4-常用指令&#34;&gt;4. 常用指令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;git rebase -i dev 可以将dev分支合并到当前分支&lt;br&gt;
这里的”-i“是指交互模式。就是说你可以干预rebase这个事务的过程，包括设置commit message，暂停commit等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git rebase –abort 放弃一次合并&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;合并多次commit操作&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618473857337.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;3-原生js实现轮播图&#34;&gt;3. 原生js实现轮播图&lt;/h1&gt;
&lt;h2 id=&#34;步骤一建立html基本布局&#34;&gt;步骤一：建立html基本布局&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;轮播图&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;wrap&amp;quot; style=&amp;quot;left:-600px;&amp;quot;&amp;gt;
            &amp;lt;img src=&amp;quot;./img/5.jpg&amp;quot; alt=&amp;quot;&amp;quot;&amp;gt;
            &amp;lt;img src=&amp;quot;./img/1.jpg&amp;quot; alt=&amp;quot;&amp;quot;&amp;gt;
            &amp;lt;img src=&amp;quot;./img/2.jpg&amp;quot; alt=&amp;quot;&amp;quot;&amp;gt;
            &amp;lt;img src=&amp;quot;./img/3.jpg&amp;quot; alt=&amp;quot;&amp;quot;&amp;gt;
            &amp;lt;img src=&amp;quot;./img/4.jpg&amp;quot; alt=&amp;quot;&amp;quot;&amp;gt;
            &amp;lt;img src=&amp;quot;./img/5.jpg&amp;quot; alt=&amp;quot;&amp;quot;&amp;gt;
            &amp;lt;img src=&amp;quot;./img/1.jpg&amp;quot; alt=&amp;quot;&amp;quot;&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;buttons&amp;quot;&amp;gt;
            &amp;lt;span&amp;gt;1&amp;lt;/span&amp;gt;
            &amp;lt;span&amp;gt;2&amp;lt;/span&amp;gt;
            &amp;lt;span&amp;gt;3&amp;lt;/span&amp;gt;
            &amp;lt;span&amp;gt;4&amp;lt;/span&amp;gt;
            &amp;lt;span&amp;gt;5&amp;lt;/span&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;a href=&amp;quot;javascript:;&amp;quot; class=&amp;quot;arrow arrow_left&amp;quot;&amp;gt;&amp;amp;lt;&amp;lt;/a&amp;gt;
        &amp;lt;a href=&amp;quot;javascript:;&amp;quot; class=&amp;quot;arrow arrow_right&amp;quot;&amp;gt;&amp;amp;gt;&amp;lt;/a&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只有五张图片，却使用7张来轮播，这是为了实现无缝轮播&lt;/p&gt;
&lt;h2 id=&#34;步骤二-css布局&#34;&gt;步骤二： css布局&lt;/h2&gt;
&lt;p&gt;首先，resetcss，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* {
            margin:0;
            padding:0;
        }
        a{
            text-decoration: none;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着，我们为了让图片只在container中，所以需要限定其宽度和高度并且使用overflow:hidden；将其余的图片隐藏起来，并且我们希望wrap相对于container左右移动，所以设置为relative，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.container {
            position: relative;
            width: 600px;
            height: 400px;
            margin:100px auto 0 auto;
            box-shadow: 0 0 5px green;
            overflow: hidden;
        }            
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们设置wrap是绝对定位的，所以,我们就可以通过控制Left和Right来控制图片的移动了。设置z-index:1;以对后面将要放置的buttons作为参考。 因为共有七张图片，所以width为4200px（每张图片我们设置为600X400）,我们只需让图片左浮动即可实现占满一排了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; .wrap {
            position: absolute;
            width: 4200px;
            height: 400px;
            z-index: 1;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后我们把图片设置位左浮动，并限定其大小，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    .container .wrap img {
            float: left;
            width: 600px;
            height: 400px;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即这时已经显示出了第一张图片。并且充满了整个container(container是有box-shadow的);&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615789086547.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
然后我们把显示次序的buttons放在图片的右下角。并且设置z-index:2;以保证buttons是在图片的上面&lt;br&gt;
的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; .container .buttons {
            position: absolute;
            right: 150px;
            bottom:20px;
            width: 100px;
            height: 10px;
            z-index: 2;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后将buttons下面的span做一个简单的修饰，并且给和图片对应的span设置一个on类，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.container .buttons span {
            margin-left: 5px;
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: green;
            text-align: center;
            color:white;
            cursor: pointer;
        }
        .container .buttons span.on{
            background-color: red;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来，我们把左右切换的箭头加上，然后做简单的修饰，注意：因为这里使用实体来表示左右箭头，所以设置font-size才能改变其大小，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; .container .arrow {
            position: absolute;
            top: 35%;
            color: green;
            padding:0px 14px;
            border-radius: 50%;
            font-size: 50px;
            z-index: 2;
            display: none;
        }
        .container .arrow_left {
            left: 10px;
        }
        .container .arrow_right {
            right: 10px;
        }
        .container:hover .arrow {
            display: block;
        }
        .container .arrow:hover {
            background-color: rgba(0,0,0,0.2);
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;步骤三添加js逻辑&#34;&gt;步骤三：添加js逻辑&lt;/h2&gt;
&lt;p&gt;我们首先获取到 wrap（因为要设置其left才能控制轮播图），然后获取到左右两个箭头，并实现手动轮播，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var wrap = document.querySelector(&amp;quot;.wrap&amp;quot;);
        var next = document.querySelector(&amp;quot;.arrow_right&amp;quot;);
        var prev = document.querySelector(&amp;quot;.arrow_left&amp;quot;);
        next.onclick = function () {
            next_pic();
        }
        prev.onclick = function () {
            prev_pic();
        }
        function next_pic () {
            var newLeft = parseInt(wrap.style.left)-600;
            wrap.style.left = newLeft + &amp;quot;px&amp;quot;;
        }
        function prev_pic () {
            var newLeft = parseInt(wrap.style.left)+600;
            wrap.style.left = newLeft + &amp;quot;px&amp;quot;;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;值得注意的是，这里wrap.style.left是一个字符串，所以要转化为数字才能进行计算，而设定left时就要加上px成为一个字符串了。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615789317683.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看到，在第一页时，left值为-600，所以我们可以点击一次上一张，但是当再点击一次时，就出现了空白。同样的，下一张点击，到-3600是最后一张，就不能再继续点击了。　　&lt;br&gt;
&lt;strong&gt;也就是说，当我们点击下一张到-3600px（这是第一张图片）时，我们需要下次跳转到第二张，即-1200px；这样才能正常跳转；&lt;/strong&gt;&lt;br&gt;
同理，当我们点击上一张到0px（这是第五张图片时），我们希望下次跳转到第四张，即-2400px；&lt;br&gt;
按照这样的思路我们重新将next_pic和prev_pic函数修改如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function next_pic () {
            var newLeft;
            if(wrap.style.left === &amp;quot;-3600px&amp;quot;){
                newLeft = -1200;
            }else{
                newLeft = parseInt(wrap.style.left)-600;
            }
            wrap.style.left = newLeft + &amp;quot;px&amp;quot;;
        }
        function prev_pic () {
            var newLeft;
            if(wrap.style.left === &amp;quot;0px&amp;quot;){
                newLeft = -2400;
            }else{
                newLeft = parseInt(wrap.style.left)+600;
            }
            wrap.style.left = newLeft + &amp;quot;px&amp;quot;;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是，这时我们仅仅时手动循环播放的，我们如果希望自动播放，使用setInterval()即可，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; var timer = null;
        function autoPlay () {
            timer = setInterval(function () {
                next_pic();
            },1000);
        }
        autoPlay();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即先设定一个计时器，然后创建一个可以自动播放的函数，最后调用这个函数即可。 现在它就可以自动播放了，效果如下：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615789447895.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
但是如果我们想要仔细看其中一个图片的时候，我们希望轮播图停止播放，只要clearInterval()即可，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
        var container = document.querySelector(&amp;quot;.container&amp;quot;);
        container.onmouseenter = function () {
            clearInterval(timer);
        }
        container.onmouseleave = function () {
            autoPlay();    
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原理很简单，即设置buttons的index初始值为0，即第一个span的class为on，然后触发next_pic函数时，index加1，当触发prev_pic函数时，inex减1， 并设置当前index的小圆点的class为on， 这就要求index必须设置为全局变量，才能保证它在每一个函数的作用域中。&lt;/p&gt;
&lt;p&gt;添加showCurrentDot函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; var index = 0;
        var dots = document.getElementsByTagName(&amp;quot;span&amp;quot;);
        function showCurrentDot () {
            for(var i = 0, len = dots.length; i &amp;lt; len; i++){
                dots[i].className = &amp;quot;&amp;quot;;
            }
            dots[index].className = &amp;quot;on&amp;quot;;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在next_pic中添加代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;            index++;
            if(index &amp;gt; 4){
                index = 0;
            }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在prev_pic中添加代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;            index--;
            if(index &amp;lt; 0){
                index = 4;
            }
            showCurrentDot();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样，轮播图就可以自动切换，并且小圆点也在随着图片的变化而变化了。&lt;/p&gt;
&lt;p&gt;但是，这距离我们经常看到的轮播图还有一定距离 - - - 当点击小圆点时， 就可跳转到相应图片。 实现原理即：  点击小圆点，就使wrap的Left变成相应的值。代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
  for (var i = 0, len = dots.length; i &amp;lt; len; i++){
            (function(i){
                dots[i].onclick = function () {
                    var dis = index - i;
                    if(index == 4 &amp;amp;&amp;amp; parseInt(wrap.style.left)!==-3000){
                        dis = dis - 5;     
                    }
                    //和使用prev和next相同，在最开始的照片5和最终的照片1在使用时会出现问题，导致符号和位数的出错，做相应地处理即可
                    if(index == 0 &amp;amp;&amp;amp; parseInt(wrap.style.left)!== -600){
                        dis = 5 + dis;
                    }
                    wrap.style.left = (parseInt(wrap.style.left) +  dis * 600)+&amp;quot;px&amp;quot;;
                    index = i;
                    showCurrentDot();
                }
            })(i);            
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原理就是当点击到小圆点时，得到相应的i值，这个i值也就是span的index值，我们拿他和全局变量index作比较，然后重新设置wrap.style.left的值，然后把i值复制给全局变量index，最后显示当前的小原点即可。值得注意的是：这里涉及到了闭包的概念，如果直接使用for循环，则不能得到正确的结果。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615789605021.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;4-排序算法&#34;&gt;4. 排序算法&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;实现枢纽选择：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//交换两个位置的数据
let swap = function(arr, m, n){
    let temp  = arr[m]
    arr[m] = arr[n]
    arr[n] = temp
}

//快速排序
//1.选择枢纽
let median = function(arr){
  //1.取出中间的位置
  let center = Math.floor(arr.length / 2)
  let right = arr.length - 1 
  let left = 0

  //2.判断大小并进行交换
  if (arr[left] &amp;gt; arr[center]) {
    swap(arr, left, center)
  }
  if (arr[center] &amp;gt; arr[right]){
    swap(arr, center, right)
  }
  if (arr[left] &amp;gt; arr[right]) {
    swap(arr, left, right)
  }
  //3.返回枢纽
  return center
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;快速排序代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//2.快速排序
let QuickSort = function(arr){
  if (arr.length == 0) {
    return []
  }
  let center = median(arr)
  let c = arr.splice(center, 1)
  let l = []
  let r = []

  for (let i = 0; i &amp;lt; arr.length; i++) {
      if (arr[i] &amp;lt; c) {
        l.push(arr[i])
      }else{
        r.push(arr[i])
      }        
  }
  return QuickSort(l).concat(c, QuickSort(r))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5-二叉树的先序中序后序遍历&#34;&gt;5. 二叉树的先序，中序，后序遍历&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function TreeNode(x){
    this.val=val;
    this.left=null;
    this.right=null;
}
// 递归方法
function threeOrders(root){
    let preArray=[],middleArray=[],lastArray=[];
    //先序遍历：根、左、右
    function preOrder(root){
        if(root){
            preArray.push(root.val);
            preOrder(root.left);
            preOrder(root.right);
        }
    }
    //中序遍历 ： 左 根 右   
    function inOrder(root){
            if(root){
                inOrder(root.left)
                middleArray.push(root.val);
                inOrder(root.right);
            }
    }
    //后序遍历：左右根
    function lastOrder(root){
        if(root){
            lastOrder(root.left);
            lastOrder(root.right);
            lastArray.push(root.val);
        }
    }
    preOrder(root);
    inOrder(root);
    lastOrder(root);
    return [preArray,middleArray,lastArray]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;6-加油站问题贪心算法&#34;&gt;6. 加油站问题(贪心算法)&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;基本要素：&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;贪心选择&lt;/code&gt;：在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。&lt;br&gt;
&lt;code&gt;最优子结构&lt;/code&gt;：当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。&lt;/p&gt;
&lt;h2 id=&#34;汽车加油问题&#34;&gt;汽车加油问题&lt;/h2&gt;
&lt;p&gt;一辆汽车加满油后可行驶 n公里。旅途中有若干个加油站。设计一个有效算法，指出应 在哪些加油站停靠加油，使沿途加油次数最少。&lt;/p&gt;
&lt;h2 id=&#34;输入格式&#34;&gt;输入格式:&lt;/h2&gt;
&lt;p&gt;第一行有 2 个正整数n和 k（k&amp;lt;=1000 )，表示汽车加满油后可行驶n公里，且旅途中有 k个加油站。 第二行有 k+1 个整数，表示第 k 个加油站与第k-1 个加油站之间的距离。 第 0 个加油站表示出发地，汽车已加满油。 第 k+1 个加油站表示目的地。&lt;/p&gt;
&lt;h2 id=&#34;输出格式&#34;&gt;输出格式:&lt;/h2&gt;
&lt;p&gt;输出最少加油次数。如果无法到达目的地，则输出“No Solution!”。&lt;/p&gt;
&lt;h2 id=&#34;贪心性质分析&#34;&gt;贪心性质分析：&lt;/h2&gt;
&lt;p&gt;找到汽车满油量时可以行驶的最大路程范围内的最后一个加油站，加油后则继续用此方法前进。需要检查每一小段路程是否超过汽车满油量时的最大支撑路程。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function greedy(n, k, arr){ // n:加满可以行驶的公里数; k:加油站数量; arr:每个加油站之间的距离数组
  　　if (n == 0 || k == 0 || arr.length == 0 || arr[0] &amp;gt; n) {
  　　return &amp;quot;No Solution!&amp;quot;; // arr[0] &amp;gt; n ：如果第一个加油站距离太远，也无法到达
  　　};
  
  　　let res = 0, distance = 0; // res：加油次数;distance：已行驶距离
  　　for(let i = 0; i &amp;lt;= k; i++){
  　　distance += arr[i];
  　　if (distance &amp;gt; n) { // 已行驶距离 &amp;gt; 加满可以行驶的公里数
   　 if(arr[i] &amp;gt; n){ // 如果目前加油站和前一个加油站的距离 &amp;gt; 加满可以行驶的公里数，则无法到达
   　 return &amp;quot;No Solution!&amp;quot;;
  　　};
  
  　　// 可以在上一个加油站加油，行驶到目前的加油站i：
  　　distance = arr[i];
  　　res++; // 加油次数+1
  　　}
  　}
  　　return res;
  }
  
  　　let arr = [1,2,3,4,5,1,6,6];
  　　console.log(greedy(7,7,arr)) // 4
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;7-二分法数组查找&#34;&gt;7. 二分法数组查找&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;二分法实现原理：二分查找可以解决已经排好序数组的查找问题：只要数组中包含target（即要查找的值），那么通过不断缩小包含target数组的范围，最终就可以找到它。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function indexOf(arr,target,start,end){
	 start = start || 0;
	 end = end || arr.length - 1;
	 if(start &amp;gt; end){
	 	return -1;
	 }
	let mid = Math.floor((start + end)/2);
		if(arr[mid] &amp;gt; target) {
			end = mid-1;
			return indexOf(arr,target,start,end);
		}
		else if(arr[mid] &amp;lt; target){
			start = mid + 1;
			return indexOf(arr,target,start,end);
		}
		else {
			return mid;
		}
}
let a = [0,1,2,3,4,5,6,434,435];
console.log(indexOf(a,12));     //打印结果为-1
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;8-反转单链表&#34;&gt;8. 反转单链表&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;var reverseList = function (head) {
    // 闭包
    if (head === undefined || head === null) return null
    var originalHead = head
    var reverseHead
    var reverse = function (head) {
        if (head.next === null) {
            reverseHead = head
            return head
        } else {
            var node = reverse(head.next)
            node.next = head
            if (originalHead === head) {
                head.next = null
                return reverseHead
            } else {
                return head
            }
        }
    }
    return reverse(head)
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;9-取出1000内所有质数&#34;&gt;9. 取出1000内所有质数&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;let num = 1000;
	let res_arr = []; 
	for (var i = 1; i &amp;lt; num; i++) {
		let e = i;
		let noDivision = !divisionItem(res_arr, e)
		if (e != 1 &amp;amp;&amp;amp; noDivision) {
			res_arr.push(e)
		}
	}

	console.log(res_arr);

	// 每一个数字 和已有的自然数进行对比是否可以整除
	function divisionItem(arr, item) {
		let res = false;
		for (var i = 0; i &amp;lt; arr.length; i++) {
			let e = arr[i];
			if (item % e === 0) {
				res = true
				break;
			}
		}
		return res;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;10-找出数组中和为给定值的两个元素&#34;&gt;10. 找出数组中和为给定值的两个元素&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;function sameSum(arr, num){
  for (var i =0 ;i&amp;lt;arr.length;i++){
      for (var j = i+1;j&amp;lt;arr.length;j++){
          if (arr[i]+arr[j]==num){
              console.log(&#39;数组中两个元素和为&#39;+num+&#39;的两个数为：&#39;+arr[i]+&#39;和&#39;+arr[j]);
              break;
          }
          //break;
          //如果只要输出一组这样的组合就只要在内层循环里break就可以
      }
  }
}
var arr =[1,2,3,4];
sameSum(arr,5);
&lt;/code&gt;&lt;/pre&gt;
">【面】前端知识点梳理（工具与算法）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/mian-qian-duan-zhi-shi-dian-shu-li-vue/"" data-c="
          &lt;h1 id=&#34;0-v-for中key的作用&#34;&gt;0. v-for中key的作用&lt;/h1&gt;
&lt;p&gt;所以我们需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点。&lt;/p&gt;
&lt;p&gt;vue中列表循环需加:key=&amp;quot;唯一标识&amp;quot; 唯一标识可以是item里面id index等，因为vue组件高度复用增加Key可以标识组件的唯一性，为了更好地区别各个组件 key的作用主要是为了高效的更新虚拟DOM&lt;/p&gt;
&lt;p&gt;&lt;code&gt;可以这样简单地理解，无：key属性时，状态默认绑定的是位置；有：key属性时，状态根据key的属性值绑定到了相应的数组元素。&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;1-vue解决了什么问题&#34;&gt;1. vue解决了什么问题&lt;/h1&gt;
&lt;p&gt;要回答这个问题，要先理解核心知识点：组件化&lt;/p&gt;
&lt;p&gt;组件化就是一种代码设计理念。最开始的面向过程编程使一个文件的代码特别多，难以维护，所以借鉴了后端的面向对象编程，使一个本需要几千行代码的文件可以被拆分成几个几百行的文件。&lt;/p&gt;
&lt;p&gt;一个组件就是一个类 new 出来的一个对象，是一个页面的一个部分，一个组件要负责这一部分的 CSS 展示，DOM 节点的设计，以及 JS 的逻辑。合理拆解组件可以提升代码的可读性以及可维护性，将组件间共性抽离出一个通用组件，让子组件去继承这个通用组件，可以少写很多代码，最小的组件颗粒度是一个元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组件化的演进 ：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1）Angular 提出了通过面向数据编程，不用操作 DOM，但是刚出来时，性能上有瓶颈&lt;br&gt;
2）React 引入了虚拟 DOM 机制，将 DOM 的比对换成了 JS 的比对，加了diff 算法，慢慢的性能的问题就解决了，前端开始大量使用 MVVM 和 MVC 这种框架了。&lt;br&gt;
3）&lt;code&gt;vue 是一个轻量级的 MVVM 模式的框架&lt;/code&gt;，vue 引入虚拟 DOM 的目的跟 React 不同，后者是为了解决性能问题，前者是为了让&lt;code&gt;组件高度抽象化&lt;/code&gt;（虚拟 DOM 使渲染过程抽象化了）。其主要作用是使前端开发变得简单，它的设计模式让没有组件化思维的使用者也在用组件化作开发，所以写的代码不会太差。&lt;br&gt;
PS：如果对前面两个框架不熟悉的话，最好不要在面试时提到它们，否则有被继续问的风险，只谈 vue 就好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;另外 Vue 的一个优势是&lt;code&gt;速度快&lt;/code&gt;，当我们改变数据后，会引起页面重新渲染，引起的重排和重绘的代价是高昂的，有可能会破坏用户体验，让 UI 展示迟缓，重排会引起周围的 DOM 重新排列，这个范围可能是全局也可能是局部，重排的性能花销跟有多少 DOM 节点需要重新构建有关系，因此应该尽可能减少重排的次数，以及它波及的范围。&lt;br&gt;
那么 Vue 将&lt;code&gt;数据更新引起的 watcher 回调放入到 nextTick&lt;/code&gt;中（是一个微任务，当执行栈为空时，就从微任务中一次性拿取所有任务），并且同一个 watcher 只会放入一次，也就是说在当前的事件循环中，无论一个响应式数据改变多少次，&lt;code&gt;最终都只会渲染一次&lt;/code&gt;，nextTick 在下面有讲解。&lt;br&gt;
要了解这段知识点要具备这些基础知识：浏览器渲染过程、JS 运行机制、异步任务、Vue 的双向绑定。确实所有知识都是从基础知识而来的，所以学框架最终就是对基础知识有更深入的理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;2mvvm-的理解&#34;&gt;2.MVVM 的理解&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;回答思路：先聊下 MVC，再聊下 MVVM 的定义，最后进行对比。&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615468604645.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;View 传送指令到 Controller&lt;br&gt;
Controller 完成业务逻辑后，要求 Model 改变状态&lt;br&gt;
Model 将新的数据发送到 View，用户得到反馈&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所有通信都是单向的。MVC 接收用户指令，可以先通过 View 来接收，然后传递给 Controller，也可以直接通过 Controller 来接收指令。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615468656209.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;ViewModel 和 View 之间是通过双向绑定来实现数据的变更&lt;br&gt;
ViewModel 和 Model 之间是浏览器通过 ajax 跟服务器相互通信的过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这两个通信是双向的，且 View 和 Model 之间没有通信。&lt;/p&gt;
&lt;p&gt;MVVM 模式的出现是因为很多后端的代码放到了前端（大前端的到来），前端的代码可维护性、可扩展性以及安全性出现了问题，随着前端框架的演变才有了 MVVM 模式，MVVM 模式和 MVC 模式主要区别在于让开发者的注意力从对 DOM 的操作上，转移到对数据的管理上，即数据是什么，视图就展示什么，使前后端分离更容易，并大大提升了开发效率和代码的可维护性。&lt;/p&gt;
&lt;h1 id=&#34;3-双向绑定的原理数据劫持&#34;&gt;3. 双向绑定的原理？数据劫持？&lt;/h1&gt;
&lt;p&gt;Vue.js是通过&lt;code&gt;数据劫持&lt;/code&gt;以及结合&lt;code&gt;发布者-订阅者&lt;/code&gt;来实现双向绑定的，数据劫持是利用ES5的Object.defineProperty(obj, key, val)来劫持各个属性的的setter以及getter，在数据变动时发布消息给订阅者，从而触发相应的回调来更新视图。&lt;/p&gt;
&lt;p&gt;双向数据绑定，简单点来说分为三个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、Observer：观察者，这里的主要工作是递归地监听对象上的所有属性，在属性值改变的时候，触发相应的watcher。&lt;/li&gt;
&lt;li&gt;2、Watcher：订阅者，当监听的数据值修改时，执行响应的回调函数（Vue里面的更新模板内容）。&lt;/li&gt;
&lt;li&gt;3、Dep：订阅管理器，连接Observer和Watcher的桥梁，每一个Observer对应一个Dep，它内部维护一个数组，保存与该Observer相关的Watcher。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615469169345.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
反向是页面数据的变化映射到 data 中，通过 input 事件监听 input 框数据的改变，JS 得到通知再赋值给 data，只是 VM 框架使手动的过程自动化了。&lt;/p&gt;
&lt;p&gt;正向是数据驱动页面，通过 Object.defineProperty() 这个核心 API，将所有数据变成响应式数据，当访问到一个响应式数据时，就会触发它的 getter 函数，收集依赖，当一个响应式数据变化时，就会触发 setter 函数，通知依赖使视图得到更新。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615711862629.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;4-nexttick&#34;&gt;4. nextTick&lt;/h1&gt;
&lt;p&gt;nextTick 把要执行的任务&lt;code&gt;推入&lt;/code&gt;到一个&lt;code&gt;队列&lt;/code&gt;中，在下一个 tick 同步执行队列的所有任务，它是异步任务中的微任务。（关于 JS 的运行机制，这是基础知识，篇幅有限）&lt;/p&gt;
&lt;p&gt;在 Vue 中，不是每一次数据的改变都会触发所有 wather 的回调，而是将这些回调推入到一个队列中，相同的 id 的 watcher 的回调不会被重复添加，然后在下一个 tick 中再执行这些回调，因此重新渲染是异步的。这么做的好处是：比如我们写了一个将某个响应式数据不断加 1 直到 1000 的代码块，那么视图只会重新渲染一次，即从 0 到 1000，而不是重新渲染 1000 次，这是一种有效的优化手段。&lt;/p&gt;
&lt;p&gt;如果我们在更新了一个响应式数据后，需要同步拿到这个渲染后的 DOM 结果，那么就使用 $nextTick 这个方法，异步拿到这个结果。&lt;/p&gt;
&lt;p&gt;使用方式有两个：&lt;code&gt;回调方式和 Promise 方式&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;this.$nextTick(cb)
this.$nextTick().then(cb)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请注意第一种方式的使用，虽然它们都是异步执行的，但是如果你将第一种方式放在响应式数据更新的前面，那么你拿到的将是老的 DOM 结果。&lt;/p&gt;
&lt;p&gt;因为 wather 的回调函数是在 nextTick 之后执行的，使用第一种方式 wather 的回调函数将和 this.$nextTick(cb) 中的 cb 同步执行，你将它放在响应式数据更新之前的话，会先执行这个 cb，所以拿到的是未被重新渲染的 DOM 结果，而如果是放在之后，你就能拿到被重新渲染的 DOM 结果。而第二种方式的 cb 跟 watcher 的回调函数是异步执行的，所以没有顺序问题。&lt;/p&gt;
&lt;p&gt;也就是说，当我们想要改变vue中的某个数据的值时，vue不会立即重新渲染，数据不会立即发生改变，而是会在下一次事件循环的时候更新。这&lt;code&gt;主要是因为Vue中DOM的操作是异步的&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;nextTick()的应用场景主要是：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在Vue生命周期的&lt;code&gt;created()&lt;/code&gt;钩子函数进行的DOM操作一定要放在&lt;code&gt;Vue.nextTick()&lt;/code&gt;的回调函数中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进&lt;code&gt;Vue.nextTick()&lt;/code&gt;的回调函数中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;5-生命周期&#34;&gt;5. 生命周期&lt;/h1&gt;
&lt;p&gt;Vue实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载等一系列过程，我们成为Vue 实例的生命周期，钩子就是在某个阶段给你一个做某些处理的机会。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615470829040.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
回答技巧：有哪些生命周期以及在每个生命周期的时机中我们能做的事情。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;beforeCreate 钩子的执行时机是在&lt;code&gt;initState 函数之前&lt;/code&gt;，这个函数会初始化 props、data、methods、watch、computed 等属性，也就意味着，这个&lt;code&gt;钩子是不可以访问&lt;/code&gt;到以上这些属性中的数据的；&lt;/li&gt;
&lt;li&gt;created 钩子的执行时机是在&lt;code&gt;iniState 函数之后&lt;/code&gt;，因此&lt;code&gt;可以访问&lt;/code&gt;到以上这些属性中的数据；&lt;/li&gt;
&lt;li&gt;beforeMount 钩子的执行时机是在 DOM 挂载之前，还是JavaScript中的虚拟DOM形式存在的。执行顺序是先父后子；&lt;/li&gt;
&lt;li&gt;mounted 钩子的执行时机是在 DOM 挂载之后，执行顺序是先子后父；&lt;/li&gt;
&lt;li&gt;beforeUpdate 钩子的执行时机是在数据发生改变，还没有渲染之前；&lt;/li&gt;
&lt;li&gt;updated 钩子的执行时机是数据发生改变，并且被渲染后；&lt;/li&gt;
&lt;li&gt;beforeDestroy 钩子的执行时机是组件即将被销毁之前，也因此组件实例上属性的数据还可以被访问到；&lt;/li&gt;
&lt;li&gt;destroyed 钩子的执行时机是组件被销毁之后。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有两个钩子跟 keep-alive 抽象组件相关的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;activated 钩子的执行时机是在 mounted 钩子之后执行；&lt;/li&gt;
&lt;li&gt;deactivated 钩子的执行时机是在页面退出时，由于会缓存，所以不会销毁组件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;6-虚拟-dom-的原理&#34;&gt;6. 虚拟 DOM 的原理&lt;/h1&gt;
&lt;h2 id=&#34;1-浏览器渲染引擎工作流程都差不多大致分为5步&#34;&gt;1. 浏览器渲染引擎工作流程都差不多，大致分为5步&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;第一步，用HTML分析器，分析HTML元素，&lt;strong&gt;构建一颗DOM树&lt;/strong&gt;(标记化和树构建)。&lt;/li&gt;
&lt;li&gt;第二步，用CSS分析器，分析CSS文件和元素上的inline样式，生成页面的样式表。&lt;/li&gt;
&lt;li&gt;第三步，将DOM树和样式表，关联起来，构建一颗Render树(这一过程又称为Attachment)。&lt;/li&gt;
&lt;li&gt;第四步，有了Render树，浏览器开始布局，为每个Render树上的节点确定一个在显示屏上出现的精确坐标。&lt;/li&gt;
&lt;li&gt;第五步，Render树和节点显示坐标都有了，就调用每个节点paint方法，把它们绘制出来。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;用我们传统的开发模式，原生JS或JQ操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程&lt;/code&gt;。在一次操作中，我需要更新10个DOM节点，浏览器收到第一个DOM请求后并不知道还有9次更新操作，因此会马上执行流程，最终执行10次。&lt;/p&gt;
&lt;h2 id=&#34;2-为什么需要虚拟dom它有什么好处&#34;&gt;2. 为什么需要虚拟DOM，它有什么好处&lt;/h2&gt;
&lt;p&gt;虚拟DOM就是为了&lt;code&gt;解决浏览器性能问题&lt;/code&gt;而被设计出来的。&lt;/p&gt;
&lt;p&gt;出现了一个轻量级的对真实 DOM 描述的 JS 对象，称为虚拟 DOM，与真实 DOM 一一对应，将新旧虚拟 DOM 进行 diff，然后生成变更，将变更应用于真实 DOM，最终生成最新的真实 DOM。&lt;strong&gt;这是将大量的 DOM 层面操作，转换成 JS 层面的操作&lt;/strong&gt;，是很划算的。&lt;/p&gt;
&lt;p&gt;如前，若一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的&lt;code&gt;diff&lt;/code&gt;内容保存到本地一个JS对象中，最终将这个JS对象一次性attch到DOM树上，再进行后续操作，避免大量无谓的计算量。所以，用JS对象模拟DOM节点的好处是，页面的更新可以先全部反映在JS对象(虚拟DOM)上，操作内存中的JS对象的速度显然要更快，等更新完成后，再将最终的JS对象映射成真实的DOM，交由浏览器去绘制。&lt;/p&gt;
&lt;h2 id=&#34;3-diff算法的时间复杂度&#34;&gt;3. diff算法的时间复杂度&lt;/h2&gt;
&lt;p&gt;diff算法是通过&lt;strong&gt;同层的树节点&lt;/strong&gt;进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有&lt;code&gt;O(n)&lt;/code&gt;，是一种相当高效的算法&lt;/p&gt;
&lt;h2 id=&#34;4-diff操作&#34;&gt;4. Diff操作&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;diff算法的本质是找出两个对象之间的差异，目的是尽可能复用节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1-diff算法包括一下几个步骤&#34;&gt;1. diff算法包括一下几个步骤：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文&lt;br&gt;
档当中&lt;/li&gt;
&lt;li&gt;当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较(diff)，记录两棵树差异&lt;/li&gt;
&lt;li&gt;把2所记录的差异应用到步骤1所构建的真正的DOM树上(patch)，视图就更新了&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616659004075.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;我们先看一下简单的diff是怎么设计的&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;逐个遍历newVdom的节点，找到它在oldVdom中的位置，如果找到了就移动对应的DOM元素，如果没找到说明是新增节点，则新建一个节点插入。遍历完成之后如果oldVdom中还有没处理过的节点，则说明这些节点在newVdom中被删除了，删除它们即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;接下来我们看一下Vue的diff实现&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-vue的diff实现&#34;&gt;2. Vue的diff实现&lt;/h3&gt;
&lt;p&gt;来看看patch是怎么打补丁的（代码只保留核心部分）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   function patch (oldVnode, vnode) {
    // some code
    if (sameVnode(oldVnode, vnode)) {
        patchVnode(oldVnode, vnode)
    } else {
        const oEl = oldVnode.el // 当前oldVnode对应的真实元素节点
        let parentEle = api.parentNode(oEl)  // 父元素
        createEle(vnode)  // 根据Vnode生成新元素
        if (parentEle !== null) {
            api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 将新元素添加进父元素
            api.removeChild(parentEle, oldVnode.el)  // 移除以前的旧元素节点
            oldVnode = null
        }
    }
    // some code
    return vnode
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;patch函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点&lt;/p&gt;
&lt;p&gt;判断两节点是否值得比较，值得比较则执行patchVnode&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  function sameVnode (a, b) {
      return (
        a.key === b.key &amp;amp;&amp;amp;  // key值
        a.tag === b.tag &amp;amp;&amp;amp;  // 标签名
        a.isComment === b.isComment &amp;amp;&amp;amp;  // 是否为注释节点
        // 是否都定义了data，data包含一些具体信息，例如onclick , style
        isDef(a.data) === isDef(b.data) &amp;amp;&amp;amp;
        sameInputType(a, b) // 当标签是&amp;lt;input&amp;gt;的时候，type必须相同
      )
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不值得比较则用Vnode替换oldVnode&lt;/p&gt;
&lt;p&gt;当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法。那么这个方法做了什么呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个函数做了以下事情：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到对应的真实dom，称为el&lt;/li&gt;
&lt;li&gt;判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return&lt;/li&gt;
&lt;li&gt;如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。&lt;/li&gt;
&lt;li&gt;如果oldVnode有子节点而Vnode没有，则删除el的子节点&lt;/li&gt;
&lt;li&gt;如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el&lt;/li&gt;
&lt;li&gt;如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要&lt;/li&gt;
&lt;li&gt;其他几个点都很好理解，我们详细来讲一下updateChildren&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;updateChildren&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;代码量很大，不方便一行一行的讲解，所以下面结合一些示例图来描述一下&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616659267875.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如上图的例子，更新前是1到10排列的Node列表，更新后是乱序排列的Node列表。罗列一下图中有以下几种类型的节点变化情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;头部相同、尾部相同的节点：如1、10&lt;/li&gt;
&lt;li&gt;头尾相同的节点：如2、9（处理完头部相同、尾部相同节点之后）&lt;/li&gt;
&lt;li&gt;新增的节点：11&lt;/li&gt;
&lt;li&gt;删除的节点：8&lt;/li&gt;
&lt;li&gt;其他节点：3、4、5、6、7&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上图例子中设置了oldStart+oldEnd，newStart+newEnd这样2对指针，分别对应oldVdom和newVdom的起点和终点。Vue不断对vnode进行处理同时移动指针直到其中任意一对起点和终点相遇。处理过的节点Vue会在oldVdom和newVdom中同时将它标记为已处理（标记方法后文中有介绍）。Vue通过以下措施来提升diff的性能&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;优先处理特殊场景&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;头部的同类型节点、尾部的同类型节点&lt;br&gt;
这类节点更新前后位置没有发生变化，所以不用移动它们对应的DOM&lt;/li&gt;
&lt;li&gt;头尾/尾头的同类型节点&lt;br&gt;
这类节点位置很明确，不需要再花心思查找，直接移动DOM就好&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;处理了这些场景之后，一方面一些不需要做移动的DOM得到快速处理，另一方面待处理节点变少，缩小了后续操作的处理范围，性能也得到提升&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;“原地复用”&lt;br&gt;
“原地复用”是指Vue会尽可能复用DOM，尽可能不发生DOM的移动。Vue在判断更新前后指针是否指向同一个节点，其实不要求它们真实引用同一个DOM节点，实际上它仅判断指向的是否是同类节点（比如2个不同的div，在DOM上它们是不一样的，但是它们属于同类节点），如果是同类节点，那么Vue会直接复用DOM，这样的好处是不需要移动DOM&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;&amp;quot;原地复用&amp;quot;应该就是设置key和不设置key的区别：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom&lt;/p&gt;
&lt;h3 id=&#34;4-按步骤解析updatechildren过程&#34;&gt;4. 按步骤解析updateChildren过程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;处理头部的同类型节点，即oldStart和newStart指向同类节点的情况，如下图中的节点1&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种情况下，将节点1的变更更新到DOM，然后对其进行标记，标记方法是oldStart和newStart后移1位即可，过程中不需要移动DOM（更新DOM或许是要的，比如属性变更了，文本内容变更了等等）&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616659749656.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;处理尾部的同类型节点，即oldEnd和newEnd指向同类节点的情况，如下图中的节点10&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;与情况（1）类似，这种情况下，将节点10的变更更新到DOM，然后oldEnd和newEnd前移1位进行标记，同样也不需要移动DOM&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616659785101.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;处理头尾/尾头的同类型节点，即oldStart和newEnd，以及oldEnd和newStart指向同类节点的情况，如下图中的节点2和节点9&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;先看节点2，其实是往后移了，移到哪里？移到oldEnd指向的节点（即节点9）后面，移动之后标记该节点，将oldStart后移1位，newEnd前移一位&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616659870038.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
操作结束之后情况如下图&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616659893331.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
同样地，节点9也是类似的处理，处理完之后成了下面这样&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616659902079.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;处理新增的节点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;newStart来到了节点11的位置，在oldVdom中找不到节点11，说明它是新增的&lt;br&gt;
那么就创建一个新的节点，插入DOM树，插到什么位置？插到oldStart指向的节点（即节点3）前面，然后将newStart后移1位标记为已处理（注意oldVdom中没有节点11，所以标记过程中它的指针不需要移动），处理之后如下图&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616659960929.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;处理更新的节点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;经过第（4）步之后，newStart来到了节点7的位置，在oldVdom中能找到它而且不在指针位置（查找oldVdom中oldStart到oldEnd区间内的节点），说明它的位置移动了&lt;/p&gt;
&lt;p&gt;那么需要在DOM树中移动它，移到哪里？移到oldStart指向的节点（即节点3）前面，与此同时将节点标记为已处理，跟前面几种情况有点不同，newVdom中该节点在指针处，可以移动newStart进行标记，而在oldVdom中该节点不在指针处，所以采用设置为undefined的方式来标记（一定要标记吗？后面会提到）&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616660042587.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
处理之后就成了下面这样&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616660067446.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;处理3、4、5、6节点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;经过第（5）步处理之后，我们看到了令人欣慰的一幕，newStart和oldStart又指向了同一个节点（即都指向节点3），很简单，按照（1）中的做法只需移动指针即可，非常高效，3、4、5、6都如此处理，处理完之后如下图&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616660118899.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;处理需删除的节点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;经过前6步处理之后（实际上前6步是循环进行的），朋友们看newStart跨过了newEnd，它们相遇啦！而这个时候，oldStart和oldEnd还没有相遇，说明这2个指针之间的节点（包括它们指向的节点，即上图中的节点7、节点8）是此次更新中被删掉的节点。&lt;/p&gt;
&lt;p&gt;OK，那我们在DOM树中将它们删除，再回到前面我们对节点7做了标记，为什么标记是必需的？标记的目的是告诉Vue它已经处理过了，是需要出现在新DOM中的节点，不要删除它，所以在这里只需删除节点8。&lt;/p&gt;
&lt;p&gt;在应用中也可能会遇到oldVdom的起止点相遇了，但是newVdom的起止点没有相遇的情况，这个时候需要对newVdom中的未处理节点进行处理，这类节点属于更新中被加入的节点，需要将他们插入到DOM树中。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616660166307.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;至此，整个diff过程结束了&lt;/p&gt;
&lt;p&gt;整个过程是逐步找到更新前后vdom的差异，然后将差异反应到DOM树上（也就是patch），特别要提一下Vue的patch是即时的，并不是打包所有修改最后一起操作DOM&lt;/p&gt;
&lt;h1 id=&#34;7-vue不同组件之间如何通信的&#34;&gt;7. Vue不同组件之间如何通信的？&lt;/h1&gt;
&lt;p&gt;组件是 vue.js最强大的功能之一，而组件实例的作用域是相互独立的，这就意味着不同组件之间的数据无法相互引用。一般来说，组件可以有以下几种关系：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616310215248.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如上图所示，A 和 B、B 和 C、B 和 D 都是父子关系，C 和 D 是兄弟关系，A 和 C 是隔代关系（可能隔多代）。&lt;/p&gt;
&lt;h2 id=&#34;0-组件注册&#34;&gt;0. 组件注册&lt;/h2&gt;
&lt;p&gt;全局注册：Vue.component(tagName, options)&lt;/p&gt;
&lt;p&gt;局部注册：在其他组件中的 components 属性中注册某个组件，就可以使用它了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import HelloWorld from &#39;./components/HelloWorld&#39;

export default {
  components: {
    HelloWorld
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1-propsemit&#34;&gt;1. props/$emit&lt;/h2&gt;
&lt;p&gt;父组件A通过props的方式向子组件B传递，B to A 通过在 B 组件中 $emit, A 组件中 v-on 的方式实现。&lt;/p&gt;
&lt;h3 id=&#34;1-父组件向子组件传值&#34;&gt;1. 父组件向子组件传值&lt;/h3&gt;
&lt;p&gt;接下来我们通过一个例子，说明父组件如何向子组件传递值：在子组件Users.vue中如何获取父组件App.vue中的数据 &lt;code&gt;users:[&amp;quot;Henry&amp;quot;,&amp;quot;Bucky&amp;quot;,&amp;quot;Emily&amp;quot;]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//App.vue父组件
&amp;lt;template&amp;gt;
  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;
    &amp;lt;users v-bind:users=&amp;quot;users&amp;quot;&amp;gt;&amp;lt;/users&amp;gt;//前者自定义名称便于子组件调用，后者要传递数据名
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
import Users from &amp;quot;./components/Users&amp;quot;
export default {
  name: &#39;App&#39;,
  data(){
    return{
      users:[&amp;quot;Henry&amp;quot;,&amp;quot;Bucky&amp;quot;,&amp;quot;Emily&amp;quot;]
    }
  },
  components:{
    &amp;quot;users&amp;quot;:Users
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;//users子组件
&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;hello&amp;quot;&amp;gt;
    &amp;lt;ul&amp;gt;
      &amp;lt;li v-for=&amp;quot;user in users&amp;quot;&amp;gt;{{user}}&amp;lt;/li&amp;gt;//遍历传递过来的值，然后呈现到页面
    &amp;lt;/ul&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
  name: &#39;HelloWorld&#39;,
  props:{
    users:{           //这个就是父组件中子标签自定义名字
      type:Array,
      required:true
    }
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结：父组件通过props向下传递数据给子组件。注：组件中的数据共有三种形式：data、props、computed&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-子组件向父组件传值通过事件形式&#34;&gt;2. 子组件向父组件传值（通过事件形式）&lt;/h3&gt;
&lt;p&gt;接下来我们通过一个例子，说明子组件如何向父组件传递值：当我们点击“Vue.js Demo”后，子组件向父组件传递值，文字由原来的“传递的是一个值”变成“子向父组件传值”，实现子组件向父组件值的传递。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616310448077.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 子组件
&amp;lt;template&amp;gt;
  &amp;lt;header&amp;gt;
    &amp;lt;h1 @click=&amp;quot;changeTitle&amp;quot;&amp;gt;{{title}}&amp;lt;/h1&amp;gt;//绑定一个点击事件
  &amp;lt;/header&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
  name: &#39;app-header&#39;,
  data() {
    return {
      title:&amp;quot;Vue.js Demo&amp;quot;
    }
  },
  methods:{
    changeTitle() {
      this.$emit(&amp;quot;titleChanged&amp;quot;,&amp;quot;子向父组件传值&amp;quot;);//自定义事件  传递值“子向父组件传值”
    }
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// 父组件
&amp;lt;template&amp;gt;
  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;
    &amp;lt;app-header v-on:titleChanged=&amp;quot;updateTitle&amp;quot; &amp;gt;&amp;lt;/app-header&amp;gt;//与子组件titleChanged自定义事件保持一致
   // updateTitle($event)接受传递过来的文字
    &amp;lt;h2&amp;gt;{{title}}&amp;lt;/h2&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
import Header from &amp;quot;./components/Header&amp;quot;
export default {
  name: &#39;App&#39;,
  data(){
    return{
      title:&amp;quot;传递的是一个值&amp;quot;
    }
  },
  methods:{
    updateTitle(e){   //声明这个函数
      this.title = e;
    }
  },
  components:{
   &amp;quot;app-header&amp;quot;:Header,
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结：子组件通过events给父组件发送消息，实际上就是子组件把自己的数据发送到父组件。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-emiton&#34;&gt;2. $emit/$on&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;这种方法通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级&lt;/strong&gt;。当我们的项目比较大时，可以选择更好的状态管理解决方案vuex。&lt;/p&gt;
&lt;h3 id=&#34;1-具体实现方式&#34;&gt;1. 具体实现方式：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;    var Event=new Vue();
    Event.$emit(事件名,数据);
    Event.$on(事件名,data =&amp;gt; {});
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-举个例子&#34;&gt;2. 举个例子&lt;/h3&gt;
&lt;p&gt;假设兄弟组件有三个，分别是A、B、C组件，C组件如何获取A或者B组件的数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;itany&amp;quot;&amp;gt;
    &amp;lt;my-a&amp;gt;&amp;lt;/my-a&amp;gt;
    &amp;lt;my-b&amp;gt;&amp;lt;/my-b&amp;gt;
    &amp;lt;my-c&amp;gt;&amp;lt;/my-c&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;template id=&amp;quot;a&amp;quot;&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h3&amp;gt;A组件：{{name}}&amp;lt;/h3&amp;gt;
    &amp;lt;button @click=&amp;quot;send&amp;quot;&amp;gt;将数据发送给C组件&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;template id=&amp;quot;b&amp;quot;&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h3&amp;gt;B组件：{{age}}&amp;lt;/h3&amp;gt;
    &amp;lt;button @click=&amp;quot;send&amp;quot;&amp;gt;将数组发送给C组件&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;template id=&amp;quot;c&amp;quot;&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h3&amp;gt;C组件：{{name}}，{{age}}&amp;lt;/h3&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
var Event = new Vue();//定义一个空的Vue实例
var A = {
    template: &#39;#a&#39;,
    data() {
      return {
        name: &#39;tom&#39;
      }
    },
    methods: {
      send() {
        Event.$emit(&#39;data-a&#39;, this.name);
      }
    }
}
var B = {
    template: &#39;#b&#39;,
    data() {
      return {
        age: 20
      }
    },
    methods: {
      send() {
        Event.$emit(&#39;data-b&#39;, this.age);
      }
    }
}
var C = {
    template: &#39;#c&#39;,
    data() {
      return {
        name: &#39;&#39;,
        age: &amp;quot;&amp;quot;
      }
    },
    mounted() {//在模板编译完成后执行
     Event.$on(&#39;data-a&#39;,name =&amp;gt; {
         this.name = name;//箭头函数内部不会产生新的this，这边如果不用=&amp;gt;,this指代Event
     })
     Event.$on(&#39;data-b&#39;,age =&amp;gt; {
         this.age = age;
     })
    }
}
var vm = new Vue({
    el: &#39;#itany&#39;,
    components: {
      &#39;my-a&#39;: A,
      &#39;my-b&#39;: B,
      &#39;my-c&#39;: C
    }
}); 
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616310652213.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
$on 监听了自定义事件 data-a和data-b，因为有时不确定何时会触发事件，一般会在 mounted 或 created 钩子中来监听。&lt;/p&gt;
&lt;h2 id=&#34;3-vuex&#34;&gt;3. Vuex&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616310687124.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1-vuex与localstorage&#34;&gt;1. Vuex与localStorage&lt;/h3&gt;
&lt;p&gt;vuex 是 vue 的状态管理器，存储的数据是响应式的。但是并不会保存起来，刷新之后就回到了初始状态，&lt;strong&gt;具体做法应该在vuex里数据改变的时候把数据拷贝一份保存到localStorage里面，刷新之后，如果localStorage里有保存的数据，取出来再替换store里的state&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let defaultCity = &amp;quot;上海&amp;quot;
try {   // 用户关闭了本地存储功能，此时在外层加个try...catch
  if (!defaultCity){
    defaultCity = JSON.parse(window.localStorage.getItem(&#39;defaultCity&#39;))
  }
}catch(e){}
export default new Vuex.Store({
  state: {
    city: defaultCity
  },
  mutations: {
    changeCity(state, city) {
      state.city = city
      try {
      window.localStorage.setItem(&#39;defaultCity&#39;, JSON.stringify(state.city));
      // 数据改变的时候把数据拷贝一份保存到localStorage里面
      } catch (e) {}
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里需要注意的是：由于vuex里，我们保存的状态，都是数组，而localStorage只支持字符串，所以需要用JSON转换：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;JSON.stringify(state.subscribeList);   // array -&amp;gt; string
JSON.parse(window.localStorage.getItem(&amp;quot;subscribeList&amp;quot;));    // string -&amp;gt; array 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-attrslisteners&#34;&gt;4. $attrs/$listeners&lt;/h2&gt;
&lt;p&gt;多级组件嵌套需要传递数据时，通常使用的方法是通过vuex。但如果仅仅是传递数据，而不做中间处理，使用 vuex 处理，未免有点大材小用。为此Vue2.4 版本提供了另一种方法----$attrs/$listeners&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=&amp;quot;$attrs&amp;quot; 传入内部组件。通常配合 interitAttrs 选项一起使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&amp;quot;$listeners&amp;quot; 传入内部组件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单来说：&lt;code&gt;$attrs&lt;/code&gt;与&lt;code&gt;$listeners&lt;/code&gt;是两个对象，&lt;code&gt;$attrs&lt;/code&gt;里存放的是父组件中绑定的非 Props 属性，&lt;code&gt;$listeners&lt;/code&gt;里存放的是父组件中绑定的非原生事件。&lt;/p&gt;
&lt;h2 id=&#34;5-parent-children与-ref&#34;&gt;5. $parent / $children与 ref&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ref&lt;/code&gt;：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$parent&lt;/code&gt;/ &lt;code&gt;$children&lt;/code&gt;：访问父 / 子实例&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意的是：这两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据。我们先来看个用&lt;code&gt;ref&lt;/code&gt;来访问组件的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// component-a 子组件
export default {
  data () {
    return {
      title: &#39;Vue.js&#39;
    }
  },
  methods: {
    sayHello () {
      window.alert(&#39;Hello&#39;);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// 父组件
&amp;lt;template&amp;gt;
  &amp;lt;component-a ref=&amp;quot;comA&amp;quot;&amp;gt;&amp;lt;/component-a&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
  export default {
    mounted () {
      const comA = this.$refs.comA;
      console.log(comA.title);  // Vue.js
      comA.sayHello();  // 弹窗
    }
  }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;不过，这两种方法的弊端是，无法在跨级或兄弟间通信。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们想在 component-a 中，访问到引用它的页面中（这里就是 parent.vue）的两个 component-b 组件，那这种情况下，就得配置额外的插件或工具了，比如 Vuex 和 Bus 的解决方案。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616312059426.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;8-vuex-的理解&#34;&gt;8. vuex 的理解&lt;/h1&gt;
&lt;h2 id=&#34;1-初识vuex&#34;&gt;1. 初识VueX&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;VueX&lt;/code&gt;是适用于在&lt;code&gt;Vue&lt;/code&gt;项目开发时使用的状态管理工具。&lt;br&gt;
&lt;code&gt;Vue&lt;/code&gt;为这些被多个组件频繁使用的值提供了一个统一管理的工具——&lt;code&gt;VueX&lt;/code&gt;。在具有VueX的Vue项目中，我们只需要把这些值定义在VueX中，即可在整个Vue项目的组件中使用。&lt;/p&gt;
&lt;h2 id=&#34;2-vuex中的核心内容&#34;&gt;2. VueX中的核心内容&lt;/h2&gt;
&lt;p&gt;在VueX对象中，其实不止有&lt;code&gt;state&lt;/code&gt;，还有用来操作&lt;code&gt;state&lt;/code&gt;中数据的方法集，以及当我们需要对state中的数据需要加工的方法集等等成员。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;成员列表：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;state 存放状态&lt;/li&gt;
&lt;li&gt;mutations state成员操作&lt;/li&gt;
&lt;li&gt;getters 加工state成员给外界&lt;/li&gt;
&lt;li&gt;actions 异步操作&lt;/li&gt;
&lt;li&gt;modules 模块化状态管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;21-vuex的工作流程&#34;&gt;2.1 VueX的工作流程&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616207478171.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;首先，&lt;code&gt;Vue&lt;/code&gt;组件如果调用某个&lt;code&gt;VueX&lt;/code&gt;的方法过程中需要向后端请求时或者说出现异步操作时，需要&lt;code&gt;dispatch&lt;/code&gt; VueX中&lt;code&gt;actions&lt;/code&gt;的方法，以保证数据的同步。可以说，&lt;code&gt;action&lt;/code&gt;的存在就是为了让&lt;code&gt;mutations&lt;/code&gt;中的方法能在异步操作中起作用。&lt;/p&gt;
&lt;p&gt;如果没有异步操作，那么我们就可以直接在组件内提交状态中的&lt;code&gt;Mutations&lt;/code&gt;中自己编写的方法来达成对&lt;code&gt;state&lt;/code&gt;成员的操作。不建议在组件中直接对state中的成员进行操作，这是因为直接修改(例如：this.$store.state.name = &#39;hello&#39;)的话不能被&lt;code&gt;VueDevtools&lt;/code&gt;所监控到。&lt;/p&gt;
&lt;p&gt;最后被修改后的&lt;code&gt;state&lt;/code&gt;成员会被渲染到组件的原位置当中去。&lt;/p&gt;
&lt;h3 id=&#34;22-mutations&#34;&gt;2.2 Mutations&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;mutations&lt;/code&gt;是操作&lt;code&gt;state&lt;/code&gt;数据的方法的集合，比如对该数据的修改、增加、删除等等。&lt;/p&gt;
&lt;p&gt;mutations方法都有默认的形参：&lt;/p&gt;
&lt;p&gt;([state] [,payload])&lt;/p&gt;
&lt;p&gt;&lt;code&gt;state&lt;/code&gt;是当前VueX对象中的state&lt;br&gt;
&lt;code&gt;payload&lt;/code&gt;是该方法在被调用时传递参数使用的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;this.$store.commit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;增加&lt;/strong&gt;：Vue.set 为某个对象设置成员的值，若不存在则新增&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Vue.set(state,&amp;quot;age&amp;quot;,15)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;删除&lt;/strong&gt;：Vue.delete 删除成员&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Vue.delete(state,&#39;age&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;23-getters&#34;&gt;2.3 Getters&lt;/h3&gt;
&lt;p&gt;可以对state中的成员加工后传递给外界&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Getters中的方法有两个默认参数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;state 当前VueX对象中的状态对象&lt;/li&gt;
&lt;li&gt;getters 当前getters对象，用于将getters下的其他getter拿来用&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;getters:{
    nameInfo(state){
        return &amp;quot;姓名:&amp;quot;+state.name
    },
    fullInfo(state,getters){
        return getters.nameInfo+&#39;年龄:&#39;+state.age
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;组件中调用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;this.$store.getters.fullInfo
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;24-actions&#34;&gt;2.4 Actions&lt;/h3&gt;
&lt;p&gt;由于直接在&lt;code&gt;mutation&lt;/code&gt;方法中进行&lt;strong&gt;异步操作&lt;/strong&gt;，将会引起数据失效。所以提供了&lt;code&gt;Actions&lt;/code&gt;来专门进行异步操作，最终提交&lt;code&gt;mutation&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;Actions中的方法有两个默认参数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;context 上下文(相当于箭头函数中的this)对象&lt;/li&gt;
&lt;li&gt;payload 挂载参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于&lt;code&gt;setTimeout&lt;/code&gt;和&lt;code&gt;promise&lt;/code&gt;是异步操作，所以需要使用&lt;code&gt;actions&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; aEdit(context,payload){
        return new Promise((resolve,reject)=&amp;gt;{
            setTimeout(()=&amp;gt;{
                context.commit(&#39;edit&#39;,payload)
                resolve()
            },2000)
        })
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在组件中调用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;this.$store.dispatch(&#39;aEdit&#39;,{age:15})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;25-models&#34;&gt;2.5 Models&lt;/h3&gt;
&lt;p&gt;当项目庞大，状态非常多时，可以采用&lt;strong&gt;模块化管理模式&lt;/strong&gt;。Vuex 允许我们将 &lt;code&gt;store&lt;/code&gt;分割成模块（&lt;code&gt;module&lt;/code&gt;）。每个模块拥有自己的&lt;code&gt;state、mutation、action、getter&lt;/code&gt;、甚至是嵌套子模块——从上至下进行同样方式的分割。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;models:{
    a:{
        state:{},
        getters:{},
        ....
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;组件内调用模块a的状态：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;this.$store.state.a
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于模块内部的 mutation 和 getter，&lt;strong&gt;接收的第一个参数是模块的局部状态对象&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同样，对于模块内部的 action，局部状态通过 &lt;code&gt;context.state&lt;/code&gt; 暴露出来，根节点状态则为 &lt;code&gt;context.rootState&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于模块内部的&lt;code&gt;getter&lt;/code&gt;，根节点状态会作为第三个参数暴露出来&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-规范目录结构&#34;&gt;3. 规范目录结构&lt;/h2&gt;
&lt;p&gt;如果把整个&lt;code&gt;store&lt;/code&gt;都放在&lt;code&gt;index.js&lt;/code&gt;中是不合理的，所以需要拆分。比较合适的目录格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;store:.
│  actions.js
│  getters.js
│  index.js
│  mutations.js
│  mutations_type.js   ##该项为存放mutaions方法常量的文件，按需要可加入
│
└─modules
        Astore.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对应的内容存放在对应的文件中，和以前一样，在&lt;code&gt;index.js&lt;/code&gt;中存放并导出&lt;code&gt;store&lt;/code&gt;。&lt;code&gt;state&lt;/code&gt;中的数据尽量放在&lt;code&gt;index.j&lt;/code&gt;s中。而&lt;code&gt;modules&lt;/code&gt;中的&lt;code&gt;Astore&lt;/code&gt;局部模块状态如果多的话也可以进行细分。&lt;/p&gt;
&lt;h2 id=&#34;4-vuex的优缺点&#34;&gt;4. vuex的优缺点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;vuex的优点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;解决了非父子组件的消息传递（将数据存放在state中）&lt;/li&gt;
&lt;li&gt;减少了AJAX请求次数，有些情景可以直接从内存中的state获取&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;vuex的缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;刷新浏览器，vuex中的state会重新变为初始状态&lt;br&gt;
解决方案vuex-along ,vuex-persistedstate&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-命名空间&#34;&gt;5. 命名空间&lt;/h2&gt;
&lt;p&gt;getter，mutation，action 他们默认都是注册在全局命名空间的，所以我们默认是可以和使用根状态一样去使用他们，但是这样不可避免会出现命名冲突的问题，所以使模块有更高的封装性与复用性，我们可以通过添加 &lt;code&gt;namespaced: true&lt;/code&gt; 使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// moduleB 模块导出的时候加个 namespaced: true,
export default {
  namespaced: true,
  state,
  getters,
  mutations,
  actions,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;51-辅助函数的使用&#34;&gt;5.1 辅助函数的使用&lt;/h3&gt;
&lt;p&gt;除了这个之外，如果你当前组件用的 vuex 状态都是一个模块的话，我们可以使用 createNamespacedHelpers 创建基于某个命名空间辅助函数，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { createNamespacedHelpers } from &#39;vuex&#39;

const { mapState, mapActions } = createNamespacedHelpers(&#39;moduleB&#39;) // moduleName
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样创建之后，我们就可以用之前的写法来访问到模块的状态。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...mapState({
  bName: state =&amp;gt; state.bName,
}),
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;52-在带命名空间的模块内访问全局内容&#34;&gt;5.2 在带命名空间的模块内访问全局内容&lt;/h3&gt;
&lt;p&gt;如果你希望使用全局 state 和 getter，rootState 和 rootGetter 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。&lt;/p&gt;
&lt;p&gt;若需要在全局命名空间内分发 action 或提交 mutation，将 { root: true } 作为第三参数传给 dispatch 或 commit 即可&lt;/p&gt;
&lt;h1 id=&#34;9-defineproperty对数组和对象的监听&#34;&gt;9. defineProperty对数组和对象的监听&lt;/h1&gt;
&lt;h2 id=&#34;1-objectdefineproperty-对象属性监听&#34;&gt;1. Object.defineProperty 对象属性监听&lt;/h2&gt;
&lt;p&gt;现在我们有这样一个对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let obj = {
	name:&#39;码不停息&#39;,
    age:18,
    love:[&#39;吃饭&#39;,&#39;睡觉&#39;,&#39;打豆豆&#39;]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们想实现只要是对象里面的任何数据改变,都要跟新视图或者执行我们自己的逻辑,那我们需要怎么办呢?&lt;/p&gt;
&lt;p&gt;我们似乎需要解决以下几个问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;obj&lt;/code&gt;对象有多个属性,可能需要__循环__添加到&lt;code&gt;Object.defineProperty&lt;/code&gt;里面&lt;br&gt;
*&lt;code&gt;obj&lt;/code&gt;的属性也可能是对象或者数组,可能需要__递归__&lt;/li&gt;
&lt;li&gt;用户可能给&lt;code&gt;obj&lt;/code&gt;赋值新的属性,这种情况可能需要 &lt;strong&gt;单独处理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;let a = {&#39;b&#39;: 1};
Object.defineProperty(a, &#39;b&#39;, {
    enumerable: false,
    configurable: false,
    get: function(){
        console.log(&#39;b&#39; + &#39;被访问&#39;);
    },
    set: function(newVal){
        console.log(&#39;b&#39; + &#39;被修改，新&#39; + &#39;b&#39; + &#39;=&#39; + newVal);
    }
});

a.b = 2;   // b被修改，新b=2
a.b;       // b被访问
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可能会有对象中属性的值还是对象这种嵌套情况，可以通过递归解决&lt;/p&gt;
&lt;h2 id=&#34;2-objectdefineproperty-数组属性监听&#34;&gt;2. Object.defineProperty 数组属性监听&lt;/h2&gt;
&lt;p&gt;Object.defineProperty 是对象的方法监听不到数组的变更的，重写&lt;code&gt;Array&lt;/code&gt;的原型方法来实现&lt;/p&gt;
&lt;p&gt;原理就是&lt;code&gt;重写数组的七个原始方法&lt;/code&gt;，当使用者执行这些方法时，我们就可以监听到数据的变化，然后做些更新操作，下面我们在&lt;code&gt;observer&lt;/code&gt;中加上关于对数组的判断&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const orginalProto = Array.prototype;
const arrayProto = Object.create(orginalProto); // 先克隆一份Array的原型出来
const methodsToPatch = [
  &#39;push&#39;,
  &#39;pop&#39;,
  &#39;shift&#39;,
  &#39;unshift&#39;,
  &#39;splice&#39;,
  &#39;sort&#39;,
  &#39;reverse&#39;
]
methodsToPatch.forEach(method =&amp;gt; {
  arrayProto[method] = function () {
    // 执行原始操作
    orginalProto[method].apply(this, arguments)
    console.log(&#39;监听赋值成功&#39;, method)
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;10-proxy-相比于-defineproperty-的优势&#34;&gt;10. Proxy 相比于 defineProperty 的优势&lt;/h1&gt;
&lt;p&gt;Proxy 是 ES6 提供的一个对象代理，简单来说就是我们不直接对一个（私有）对象进行读写，而是通过这个对象代理对这个对象进行读写，通过对象代理可以对这个对象的&lt;strong&gt;数据作过滤保护&lt;/strong&gt;，使得这个对象可以成为&lt;strong&gt;私有属性&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;1-objectdefineproperty只能劫持对象的属性而proxy是直接代理对象&#34;&gt;1. Object.defineProperty只能劫持对象的属性，而Proxy是直接代理对象。&lt;/h2&gt;
&lt;p&gt;由于 &lt;code&gt;Object.defineProperty&lt;/code&gt; 只能对属性进行劫持，需要遍历对象的每个属性，如果属性值也是对象，则需要深度遍历。而 &lt;code&gt;Proxy&lt;/code&gt; 直接代理对象，不需要遍历操作。&lt;/p&gt;
&lt;h2 id=&#34;2-objectdefineproperty对新增属性需要手动进行observe&#34;&gt;2. Object.defineProperty对新增属性需要手动进行Observe。&lt;/h2&gt;
&lt;p&gt;由于 &lt;code&gt;Object.defineProperty&lt;/code&gt; 劫持的是对象的属性，所以新增属性时，需要重新遍历对象，对其新增属性再使用 &lt;code&gt;Object.defineProperty&lt;/code&gt; 进行劫持。&lt;/p&gt;
&lt;p&gt;也正是因为这个原因，使用vue给 &lt;code&gt;data&lt;/code&gt; 中的数组或对象新增属性时，需要使用 &lt;code&gt;vm.$set&lt;/code&gt; 才能保证新增的属性也是响应式的。&lt;/p&gt;
&lt;p&gt;在 set 方法中，对 &lt;code&gt;target&lt;/code&gt; 是&lt;strong&gt;数组&lt;/strong&gt;和&lt;strong&gt;对象&lt;/strong&gt;做了分别的处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;target 是数组时，会调用重写过的 splice 方法进行手动 Observe 。&lt;/li&gt;
&lt;li&gt;对于对象，如果 key 本来就是对象的属性，则直接修改值触发更新，否则调用 defineReactive 方法重新定义响应式对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果采用 proxy 实现， &lt;code&gt;Proxy&lt;/code&gt; 通过 set(target, propKey, value, receiver) 拦截对象属性的设置，是可以拦截到对象的新增属性的。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616222994837.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
不止如此， Proxy 对数组的方法也可以监测到，不需要像上面vue2.x源码中那样进行 hack 。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616223001054.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-proxy支持13种拦截操作这是defineproperty所不具有的&#34;&gt;3. Proxy支持13种拦截操作，这是defineProperty所不具有的&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;get(target, propKey, receiver)：拦截对象属性的读取，比如 proxy.foo 和 proxy[&#39;foo&#39;] 。&lt;/li&gt;
&lt;li&gt;set(target, propKey, value, receiver)：拦截对象属性的设置，比如 proxy.foo = v 或 proxy[&#39;foo&#39;] = v ，返回一个布尔值。&lt;/li&gt;
&lt;li&gt;has(target, propKey)：拦截 propKey in proxy 的操作，返回一个布尔值。&lt;/li&gt;
&lt;li&gt;deleteProperty(target, propKey)：拦截 delete proxy[propKey] 的操作，返回一个布尔值。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;优势一：Proxy 可以直接&lt;code&gt;监听对象本身&lt;/code&gt;，而 defineProperty 只能&lt;code&gt;监听属性&lt;/code&gt;，只有通过递归调用才能监听对象；&lt;br&gt;
优势二：当我们使用数组方法来操作数组后，Proxy 可以直接监听&lt;code&gt;数组变化&lt;/code&gt;，而 defineProperty 是无法监听到数组下标变化的，常用八种数组方法 push, pop, shift, unshift, splice, sort, reverse 在 vue 中能监听得到，是因为 vue 源码中使用了 defineReactive 方法来渲染页面；&lt;br&gt;
优势三：Proxy 有 13 中拦截方式，多于 defineProperty；&lt;br&gt;
优势四：Proxy 返回一个新对象，可以只&lt;code&gt;操作新对象&lt;/code&gt;，不会污染原对象，而 defineProperty 只能遍历对象属性&lt;code&gt;直接修改&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而 defineProperty 的兼容性更好，vue 3.0 版本将会用 Proxy 代替 definProperty。&lt;/p&gt;
&lt;h1 id=&#34;11-computed-和-watch-区别&#34;&gt;11、computed 和 watch 区别&lt;/h1&gt;
&lt;h2 id=&#34;1-计算属性computed&#34;&gt;1. 计算属性computed :&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;支持缓存，只有依赖数据发生改变，才会重新进行计算&lt;/li&gt;
&lt;li&gt;不支持异步，当computed内有异步操作时无效，无法监听数据的变化&lt;/li&gt;
&lt;li&gt;computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值&lt;/li&gt;
&lt;li&gt;如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed&lt;/li&gt;
&lt;li&gt;如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-侦听属性watch&#34;&gt;2. 侦听属性watch：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;不支持缓存，数据变，直接会触发相应的操作；&lt;/li&gt;
&lt;li&gt;watch支持异步；&lt;/li&gt;
&lt;li&gt;监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；&lt;/li&gt;
&lt;li&gt;当一个属性发生变化时，需要执行对应的操作；一对多；&lt;/li&gt;
&lt;li&gt;监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，&lt;br&gt;
　　immediate：组件加载立即触发回调函数执行，&lt;br&gt;
　　deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异，只有以响应式的方式触发才会被监听到。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + &#39; &#39; + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(&#39; &#39;)
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
},
watch: {
    a: {
      handler(newVal) {
        console.log(newVal)
      },
      deep: true,
      immediate: true
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;12-vue-router-hash-html5-新增的-pushstate&#34;&gt;12. vue-router (hash， HTML5 新增的 pushState)&lt;/h1&gt;
&lt;h2 id=&#34;1-单页应用如何实现其路由功能-路由原理&#34;&gt;1. 单页应用，如何实现其路由功能---路由原理&lt;/h2&gt;
&lt;p&gt;vue-router 默认启用 &lt;code&gt;hash&lt;/code&gt; 模式，如果只是 hash 的改变在任何时候都不会向后端发起请求，如果想要在一个页面中跳转到一个区域，有两种方法：设置一个锚点：使用 a 标签的 name 属性，二是使用 id 元素，可以在任何元素上使用。&lt;/p&gt;
&lt;p&gt;核心原理是利用了 hash 的 &lt;code&gt;onhashchange&lt;/code&gt;事件，一旦 hash 发生改变就会触发这个事件&lt;br&gt;
还可以在路由配置中，用 mode 配置项，值为 history，就可以改成 history 模式，实际上就是使用了浏览器的 history API&lt;/p&gt;
&lt;p&gt;通过这种模式可以去掉 hash 的丑陋，但是也有一个问题，如果用户刷新或者手动输入 URL 按回车，那么就会向后端发起请求，如果后端没有匹配的路径，就会报 404 错误，所以后端要配置支持。&lt;br&gt;
&lt;code&gt;核心原理&lt;/code&gt;（跟使用何种模式无关）：利用的的是 history.pushState 和 history.replaceState 方法，并且在后退和前进以及跳转时利用的是 popstate 事件&lt;/p&gt;
&lt;h2 id=&#34;2-vue-router-如何做用户登录权限等&#34;&gt;2. vue-router 如何做用户登录权限等&lt;/h2&gt;
&lt;p&gt;使用 meta 来检测一个目标页面是否需要登陆权限，然后向服务器发送一个带有 Cookie 字段的请求，询问浏览器端的 cookie 中的 sessionID 是否已过期（因为 session 是保存在服务器端的），如果过期就需要重新登陆，跳转到登陆页面，否则表示已是登陆状态，进入目标页面。&lt;/p&gt;
&lt;h2 id=&#34;3-你在项目中怎么实现路由的嵌套&#34;&gt;3. 你在项目中怎么实现路由的嵌套&lt;/h2&gt;
&lt;p&gt;一个被渲染组件同样可以包含自己的&amp;lt;router-view&amp;gt;（一个出口）&lt;br&gt;
要在嵌套的出口中渲染组件，需要在 VueRouter 中使用 children 配置&lt;br&gt;
在 children 中的路由不需要以 / 开头，因为是嵌套的路由&lt;br&gt;
除此之外就像和 routes 配置一样的路由配置数组&lt;/p&gt;
&lt;h2 id=&#34;4-vue-router-有哪几种导航钩子&#34;&gt;4. vue-router 有哪几种导航钩子&lt;/h2&gt;
&lt;h3 id=&#34;1全局的&#34;&gt;1.全局的：&lt;/h3&gt;
&lt;p&gt;全局前置守卫 beforeEach&lt;br&gt;
全局解析守卫（在组件路由所有守卫之后） beforeResolve&lt;br&gt;
全局后置钩子（没有 next 参数，因为不在导航守卫队列中，此时导航被确认） afterEach&lt;br&gt;
router.beforeEach((to,from.next) =&amp;gt; {})&lt;br&gt;
单个路由独享（在路由配置上直接定义）：beforeEnter&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618320145843.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-组件级在路由组件内直接调用的守卫像调用生命周期那样&#34;&gt;2. 组件级：在路由组件内直接调用的守卫，像调用生命周期那样&lt;/h3&gt;
&lt;p&gt;beforeRouteEnter&lt;br&gt;
这是唯一可以给 next() 传递回调函数作为参数的守卫（对于所有守卫而言的）&lt;br&gt;
其他两个已经可以直接使用 this，所以不需要再传入回调&lt;/p&gt;
&lt;p&gt;beforeRouteUpdate 在重复组件中调用这个守卫，所以可以访问 this&lt;br&gt;
主要是因为在重用组件中使用了这个守卫，因此在这里请求数据可以在组件复用是更新数据&lt;/p&gt;
&lt;p&gt;beforeRouteLeave 离开失活组件时执行的守卫，所以可以访问到失活组件的 this&lt;br&gt;
当导航守卫的队列都清空时，表示导航被确认，然后调用全局的 afterEach 钩子，然后触发 DOM 更新，然后再会执行 beforeRouteEnter 中的 next 方法中的回调函数。&lt;br&gt;
只要有 next 参数的，最后都要执行 next() 才能跳转到下一个守卫&lt;/p&gt;
&lt;h2 id=&#34;5-route-和-router-的区别&#34;&gt;5. $route 和 $router 的区别：&lt;/h2&gt;
&lt;p&gt;this.&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;是&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;访&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;问&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;路&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;由&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;器&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;router 是访问路由器
this.&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;是&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;访&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;问&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;路&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;由&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;器&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;route 是访问当前路由&lt;/p&gt;
&lt;p&gt;this.$router.push会往history栈中添加一个新的记录。&lt;br&gt;
this.$route相当于当前正在跳转的路由对象。可以从里面获取name,path,params,query等。&lt;/p&gt;
&lt;h2 id=&#34;6-如何使用-vue-router&#34;&gt;6. 如何使用 vue-router&lt;/h2&gt;
&lt;p&gt;1）import 进来，然后通过 Vue.use() 明确安装路由功能&lt;br&gt;
2）定义路由组件，或者引入单文件组件&lt;br&gt;
3）定义路由配置，配置是一个数组，元素是对象&lt;br&gt;
4）创建一个 vue-router 实例，new vueRouter({})&lt;br&gt;
5）创建 vue 根实例，将 router 作为配置参数传入&lt;/p&gt;
&lt;h1 id=&#34;13-vue中v-if与v-show的区别以及使用场景&#34;&gt;13. vue中v-if与v-show的区别以及使用场景&lt;/h1&gt;
&lt;h2 id=&#34;1-区别&#34;&gt;1. 区别&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;手段：v-if是通过控制dom节点的&lt;code&gt;存在&lt;/code&gt;与否来控制元素的显隐；v-show是通过设置DOM元素的&lt;code&gt;display样式&lt;/code&gt;，block为显示，none为隐藏；&lt;/li&gt;
&lt;li&gt;编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的&lt;code&gt;基于css切换&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;编译条件：v-if是&lt;code&gt;惰性&lt;/code&gt;的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；&lt;/li&gt;
&lt;li&gt;性能消耗：v-if有更高的&lt;code&gt;切换消耗&lt;/code&gt;；v-show有更高的初始&lt;code&gt;渲染消耗&lt;/code&gt;；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;换句话说，v-if 的表达式返回值，会直接触发到&lt;code&gt;当前组件 生命周期&lt;/code&gt;，并且事件监听器和子组件会被适当地被销毁和重建。 所以，可以理解为 v-if 是惰性的，他不会在页面初始化时，被无条件渲染，而是按需响应式地渲染。&lt;/p&gt;
&lt;p&gt;而 v-show ，这是无论表达式返回值是否是 true 都会在&lt;code&gt;create 生命周期&lt;/code&gt;，无条件消耗资源生成对应的 Virtual DOM，并挂载到HTML页面中，只是再根据表达式返回值，切换 display 这个 CSS 属性。&lt;/p&gt;
&lt;h2 id=&#34;2-使用场景&#34;&gt;2. 使用场景&lt;/h2&gt;
&lt;p&gt;基于以上区别，因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。&lt;/p&gt;
&lt;h2 id=&#34;3-总结&#34;&gt;3. 总结&lt;/h2&gt;
&lt;p&gt;v-if判断是否加载，可以减轻服务器的压力，在需要时加载,但有更高的切换开销;v-show调整DOM元素的CSS的dispaly属性，可以使客户端操作更加流畅，但有更高的初始渲染开销。如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。&lt;/p&gt;
&lt;h1 id=&#34;14-vue项目中实现token验证&#34;&gt;14. Vue项目中实现token验证&lt;/h1&gt;
&lt;p&gt;在前后端完全分离的情况下，Vue项目中实现token验证大致思路如下：&lt;/p&gt;
&lt;p&gt;1、第一次登录的时候，前端调后端的登陆接口，发送用户名和密码&lt;br&gt;
2、后端收到请求，验证用户名和密码，验证成功，就给前端返回一个token&lt;br&gt;
3、前端拿到token，将token存储到localStorage和vuex中，并跳转路由页面&lt;br&gt;
4、前端每次跳转路由，就判断 localStroage 中有无 token ，没有就跳转到登录页面，有则跳转到对应路由页面&lt;br&gt;
5、每次调后端接口，都要在请求头中加token&lt;br&gt;
6、后端判断请求头中有无token，有token，就拿到token并验证token，验证成功就返回数据，验证失败（例如：token过期）就返回401，请求头中没有token也返回401&lt;br&gt;
7、如果前端拿到状态码为401，就清除token信息并跳转到登录页面&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619086516830.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;15-vue插槽v-slot&#34;&gt;15. Vue插槽（v-slot）&lt;/h1&gt;
&lt;h2 id=&#34;1-匿名插槽&#34;&gt;1. 匿名插槽&lt;/h2&gt;
&lt;p&gt;匿名插槽，我们也可以叫它单个插槽或者默认插槽。和具名插槽相对，它是不需要设置  name 属性的，它隐藏的name属性为default。&lt;/p&gt;
&lt;p&gt;在使用的时候还有一个问题要注意的 如果是有2个以上的匿名插槽是会child标签里面的内容全部都替换到每个slot；&lt;/p&gt;
&lt;h2 id=&#34;2-具名插槽&#34;&gt;2. 具名插槽&lt;/h2&gt;
&lt;p&gt;顾名思义就是slot 是带有name的 ，定义：&amp;lt;slot name=&amp;quot;header&amp;quot; /&amp;gt;  或者使用简单缩写的定义 #header&lt;br&gt;
使用：要用一个 template标签包裹&lt;/p&gt;
&lt;p&gt;这里说一下多个具名插槽的使用 &lt;code&gt;多个具名插槽，插槽的位置不是使用插槽的位置而定的，是在定义的时候的位置来替换的&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;16-vue的scoped属性&#34;&gt;16. Vue的Scoped属性&lt;/h1&gt;
&lt;h2 id=&#34;1-什么是scoped&#34;&gt;1. 什么是scoped&lt;/h2&gt;
&lt;p&gt;在Vue文件中的style标签上有一个特殊的属性，scoped。当一个style标签拥有scoped属性时候，它的css样式只能用于&lt;code&gt;当前&lt;/code&gt;的Vue组件，可以使组件的样式不相互污染。如果一个项目的&lt;code&gt;所有style标签&lt;/code&gt;都加上了scoped属性，相当于实现了样式的&lt;code&gt;模块化&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;2-scoped的实现原理&#34;&gt;2. Scoped的实现原理&lt;/h2&gt;
&lt;p&gt;Vue中的scoped属性的效果主要是通过&lt;code&gt;PostCss&lt;/code&gt;实现的。&lt;br&gt;
以下是转译前的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style scoped lang=&amp;quot;less&amp;quot;&amp;gt;
    .example{
        color:red;
    }
&amp;lt;/style&amp;gt;
&amp;lt;template&amp;gt;
    &amp;lt;div class=&amp;quot;example&amp;quot;&amp;gt;scoped测试案例&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;转译后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.example[data-v-5558831a] {
  color: red;
}
&amp;lt;template&amp;gt;
    &amp;lt;div class=&amp;quot;example&amp;quot; data-v-5558831a&amp;gt;scoped测试案例&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;PostCSS&lt;/code&gt;给一个组件中的所有&lt;code&gt;dom&lt;/code&gt;添加了一个独一无二的&lt;code&gt;动态属性&lt;/code&gt;，给&lt;code&gt;css选择器&lt;/code&gt;额外添加一个对应的&lt;code&gt;属性选择器&lt;/code&gt;，来选择组件中的dom，这种做法使得样式只作用于含有该属性的dom元素(组件内部的dom)。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;总结：scoped的渲染规则：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;给HTML的dom节点添加一个不重复的data属性(例如: data-v-5558831a)来唯一标识这个dom 元素&lt;/li&gt;
&lt;li&gt;在每句css选择器的末尾(编译后生成的css语句)加一个当前组件的data属性选择器(例如：[data-v-5558831a])来私有化样式&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-scoped穿透&#34;&gt;3. Scoped穿透&lt;/h2&gt;
&lt;p&gt;Scoped看起来很好用，当时在Vue项目中，当我们引入第三方组件库时(如使用vue-awesome-swiper实现移动端轮播)，需要在局部组件中修改第三方组件库的样式，而又不想去除scoped属性造成组件之间的样式覆盖。这时我们可以通过特殊的方式穿透scoped。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;stylus的样式穿透 使用&amp;gt;&amp;gt;&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;外层 &amp;gt;&amp;gt;&amp;gt; 第三方组件 
        样式
        
   .wrapper &amp;gt;&amp;gt;&amp;gt; .swiper-pagination-bullet-active
    background: #fff
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sass和less的样式穿透 使用/deep/&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  外层 /deep/ 第三方组件 {
        样式
    }
    .wrapper /deep/ .swiper-pagination-bullet-active{
      background: #fff;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-在组件中修改第三方组件库样式的其它方法&#34;&gt;4. 在组件中修改第三方组件库样式的其它方法&lt;/h2&gt;
&lt;p&gt;上面我们介绍了在使用scoped 属性时，通过scopd穿透的方式修改引入第三方组件库样式的方法，下面我们介绍其它方式来修改引入第三方组件库的样式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在vue组件中不使用scoped属性&lt;/li&gt;
&lt;li&gt;在vue组建中使用两个style标签，一个加上scoped属性，一个不加scoped属性，把需要覆盖的css样式写在不加scoped属性的style标签里&lt;/li&gt;
&lt;li&gt;建立一个reset.css(基础全局样式)文件，里面写覆盖的css样式，在入口文件main.js 中引入&lt;/li&gt;
&lt;/ol&gt;
">【面】前端知识点梳理（Vue）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/mian-qian-duan-zhi-shi-dian-shu-li-fu-wu-duan-yu-wang-luo/"" data-c="
          &lt;h1 id=&#34;1-常见状态码&#34;&gt;1. 常见状态码&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;1XX 信息&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;消息:&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述:&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;100 Continue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;101 Switching Protocols&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;2XX 成功&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;消息:&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述:&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;200 OK&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;请求成功（其后是对GET和POST请求的应答文档。）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;201 Created&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;请求被创建完成，同时新的资源被创建。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;202 Accepted&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;供处理的请求已被接受，但是处理未完成。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;203 Non-authoritative Information&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;204 No Content&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;3XX 重定向&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;消息:&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述:&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;300 Multiple Choices&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;301 Moved Permanently&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;所请求的页面已经转移至新的url。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;302 Found&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;所请求的页面已经临时转移至新的url。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;303 See Other&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;所请求的页面可在别的url下被找到。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;304 Not Modified&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;4XX 客户端错误&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;消息:&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述:&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;400 Bad Request&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;服务器未能理解请求。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;401 Unauthorized&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;被请求的页面需要用户名和密码。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;403 Forbidden&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对被请求页面的访问被禁止。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;404 Not Found&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;服务器无法找到被请求的页面。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;405 Method Not Allowed&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;请求中指定的方法不被允许。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;406 Not Acceptable&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;服务器生成的响应无法被客户端所接受。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;407 Proxy Authentication Required&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用户必须首先使用代理服务器进行验证，这样请求才会被处理。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;408 Request Timeout&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;请求超出了服务器的等待时间。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;409 Conflict&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;由于冲突，请求无法被完成。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;413 Request Entity Too Large&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;由于所请求的实体的太大，服务器不会接受请求。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;414 Request-url Too Long&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;5XX 服务器错误&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;消息:&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述:&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;500 Internal Server Error&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;请求未完成。服务器遇到不可预知的情况。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;501 Not Implemented&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;请求未完成。服务器不支持所请求的功能。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;502 Bad Gateway&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;请求未完成。服务器从上游服务器收到一个无效的响应。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;503 Service Unavailable&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;请求未完成。服务器临时过载或当机。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;504 Gateway Timeout&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;网关超时。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;505 HTTP Version Not Supported&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;服务器不支持请求中指明的HTTP协议版本。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;2-浏览器缓存&#34;&gt;2. 浏览器缓存&lt;/h1&gt;
&lt;h2 id=&#34;1-200-from-cache和200-ok&#34;&gt;1. 200 From cache和200 ok&lt;/h2&gt;
&lt;p&gt;为什么有的缓存是 200 OK (from cache)，有的缓存是 304 Not Modified 呢？很简单，看运维是否移除了 Entity Tag。移除了，就总是 200 OK (from cache)。没有移除，就两者交替出现。&lt;/p&gt;
&lt;p&gt;其实， 200 OK (from cache)  是浏览器没有跟服务器确认，直接用了浏览器缓存；而 304 Not Modified 是浏览器和服务器多确认了一次缓存有效性，再用的缓存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;它们都是在设置了缓存的情况下触发的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;200 OK (from cache) 是直接点击链接访问，输入网址按回车访问也能触发；而 304 Not Modified 是刷新页面时触发，或是设置了长缓存、但 Entity Tags 没有移除时触发。&lt;/p&gt;
&lt;h2 id=&#34;2-http-304状态码-浏览器缓存&#34;&gt;2. HTTP-304状态码--浏览器缓存&lt;/h2&gt;
&lt;p&gt;304状态码是在协商缓存，缓存命中的时候服务器返回的，告诉客户端，&lt;strong&gt;服务器资源没有修改，可以使用客户端自己的缓存。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;浏览器缓存分为&lt;code&gt;强缓存&lt;/code&gt;（本地缓存）和&lt;code&gt;协商缓存&lt;/code&gt;（弱缓存）。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1617850748410.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-强缓存&#34;&gt;1. 强缓存&lt;/h3&gt;
&lt;p&gt;如上图所示，在浏览器第一次发出请求之后，需要再次发送请求的时候，浏览器首先获取该资源缓存的 header 信息，然后根据 Cache-Control 和 Expires 字段判断缓存是否过期。如果没有过期，直接使用浏览器缓存，并不会与服务器通信。该过程为判断是否使用&lt;code&gt;强缓存&lt;/code&gt;，即本地缓存。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Cache-Control&lt;/strong&gt;&lt;br&gt;
该字段是 HTTP1.1 规范，一般利用该字段的 max-age 属性来判断，这个值是一个相对时间，单位为 s，代表资源的有效期。例如：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;Cache-Control:max-age=3600
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除此之外还有几个常用的值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;no-cache：表示&lt;strong&gt;不使用强缓存&lt;/strong&gt;，需要使用协商缓存&lt;/li&gt;
&lt;li&gt;no-store：禁止&lt;strong&gt;浏览器缓存&lt;/strong&gt;数据，每次请求下载完整的资源&lt;/li&gt;
&lt;li&gt;public：可以被所有用户缓存，包括终端用户和中间代理服务器&lt;/li&gt;
&lt;li&gt;private：只能被终端用户的浏览器缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;Expires&lt;/strong&gt;&lt;br&gt;
该字段是 HTTP1.0 规范，他是一个绝对时间的 GMT 格式的时间字符串。例如：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;expires:Mar, 06 Apr 2021 10:57:09 GMT
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时间代表资源的失效时间，只要发送请求的时间在这之前，都会使用强缓存。&lt;/p&gt;
&lt;p&gt;由于失效时间是一个绝对时间，因此当&lt;strong&gt;服务器时间与客户端时间偏差较大&lt;/strong&gt;时，就会导致&lt;strong&gt;缓存混乱&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;2-协商缓存&#34;&gt;2. 协商缓存&lt;/h3&gt;
&lt;p&gt;如果缓存过期，浏览器会向服务器发送请求，即使用&lt;code&gt;协商缓存&lt;/code&gt;。本次请求会带着第一次请求返回的有关缓存的 header 字段信息，比如以下两个字段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Etag/If-None-Match&lt;/strong&gt;&lt;br&gt;
判断响应头中是否存在 Etag 字段，如果存在，浏览器则发送一个带有 If-None-Match 字段的请求头的请求，该字段的值为 Etag 值。服务器通过对比&lt;strong&gt;客户端发过来的Etag值是否与服务器相同&lt;/strong&gt;。如果相同，说明缓存命中，服务器&lt;strong&gt;返回 304&lt;/strong&gt; 状态码，并将 If-None-Match 设为 false，客户端继续使用本地缓存。如果&lt;strong&gt;不相同&lt;/strong&gt;，说明缓存未命中，服务器**返回 200 **状态码，并将 If-None-Match 设为 true，并且返回请求的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Last-Modified/If-Modified-Since&lt;br&gt;
除了 Etag 字段之外，客户端还会通过服务器返回的 Last-Modified 字段判断是否继续使用缓存，该字段为服务器返回的资源的最后修改时间，为UMT时间。浏览器发送一个带有 If-Modified-Since 字段的请求头的请求给服务器，该字段的值为 Last-Modified 值。服务器收到之后，通过这个时间判断，在该时间之后，资源有无修改，如果未修改，缓存命中，返回 304 状态码；如果未命中，返回 200 状态码，并返回最新的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-知识点细节&#34;&gt;3. 知识点细节&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Cache-Control 与 Expires 的优先级：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;两者可以在服务端配置同时使用，&lt;strong&gt;Cache-Control 的优先级高于 Expires。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;为什么有了Last-Modified还要Etag&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间&lt;/li&gt;
&lt;li&gt;如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存&lt;/li&gt;
&lt;li&gt;有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Last-Modified 和 Etag 可以一起使用，&lt;strong&gt;Etag 的优先级更高。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-刷新页面的问题&#34;&gt;4. 刷新页面的问题：&lt;/h3&gt;
&lt;p&gt;F5刷新：不使用强缓存，使用协商缓存&lt;/p&gt;
&lt;p&gt;ctrl+F5：二者都不使用&lt;/p&gt;
&lt;h2 id=&#34;3-缓存的资源去哪里了&#34;&gt;3. 缓存的资源去哪里了&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;memory cache&lt;/code&gt;JS等派生资源&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MemoryCache顾名思义，就是将资源缓存到内存中，等待下次访问时不需要重新下载资源，而直接从内存中获取。Webkit早已支持memoryCache。&lt;br&gt;
目前Webkit资源分成两类，一类是主资源，比如HTML页面，或者下载项，一类是派生资源，比如HTML页面中内嵌的图片或者脚本链接，分别对应代码中两个类：MainResourceLoader和SubresourceLoader。虽然Webkit支持memoryCache，但是也只是针对派生资源，它对应的类为CachedResource，用于保存原始数据（比如CSS，JS等），以及解码过的图片数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;disk cache&lt;/code&gt;保存CSS等不频繁读取资源&lt;br&gt;
DiskCache顾名思义，就是将资源缓存到磁盘中，等待下次访问时不需要重新下载资源，而直接从磁盘中获取，它的直接操作对象为CurlCacheManager。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;*&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;memory cache&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;disk cache&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;相同点&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只能存储一些派生类资源文件&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只能存储一些派生类资源文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不同点&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;退出进程时数据会被清除&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;退出进程时数据不会被清除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;存储资源&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一般脚本、字体、图片会存在内存当中&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一般非脚本会存在内存当中，如css等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;因为CSS文件加载一次就可渲染出来,我们不会频繁读取它,所以它不适合缓存到内存中,但是js之类的脚本却随时可能会执行,如果脚本在磁盘当中,我们在执行脚本的时候需要从磁盘取到内存中来,这样IO开销就很大了,有可能导致浏览器失去响应。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三级缓存原理 (访问缓存优先级)&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先在内存中查找,如果有,直接加载。&lt;/li&gt;
&lt;li&gt;如果内存中不存在,则在硬盘中查找,如果有直接加载。&lt;/li&gt;
&lt;li&gt;如果硬盘中也没有,那么就进行网络请求。&lt;/li&gt;
&lt;li&gt;请求获取的资源缓存到硬盘和内存。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;浏览器缓存的优点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;减少了冗余的数据传输&lt;/li&gt;
&lt;li&gt;减少了服务器的负担，大大提升了网站的性能&lt;/li&gt;
&lt;li&gt;加快了客户端加载网页的速度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;br&gt;
当浏览器再次访问一个已经访问过的资源时，它会这样做：&lt;/p&gt;
&lt;p&gt;1.看看是否命中强缓存，如果命中，就直接使用缓存了。&lt;/p&gt;
&lt;p&gt;2.如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存。&lt;/p&gt;
&lt;p&gt;3.如果命中协商缓存，服务器会返回 304 告诉浏览器使用本地缓存。&lt;/p&gt;
&lt;p&gt;4.否则，返回最新的资源。&lt;/p&gt;
&lt;h1 id=&#34;3-dns解析&#34;&gt;3. DNS解析&lt;/h1&gt;
&lt;h2 id=&#34;1-什么是dns&#34;&gt;1. 什么是DNS&lt;/h2&gt;
&lt;p&gt;全称 Domain Name System ,即域名系统。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。DNS协议运行在UDP协议之上，使用端口号53。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-dns解析&#34;&gt;2. DNS解析&lt;/h2&gt;
&lt;p&gt;通过域名,最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;www.dnscache.com (域名) - DNS解析 -&amp;gt; 11.222.33.444 (IP地址)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;DNS解析步骤（缓存）&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;1） 浏览器缓存　　&lt;br&gt;
当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）；&lt;/p&gt;
&lt;p&gt;2） 系统缓存　　&lt;br&gt;
当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP；&lt;/p&gt;
&lt;p&gt;3） 路由器缓存　　&lt;br&gt;
当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查，以上三步均为客服端的DNS缓存；&lt;/p&gt;
&lt;p&gt;4） DNS缓存　　&lt;br&gt;
当在用户客服端查找不到域名对应IP地址，则将进入DNS缓存中进行查询。比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查找；&lt;/p&gt;
&lt;p&gt;5） 根域名服务器　　&lt;br&gt;
当以上均未完成，则进入根服务器进行查询。全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器IP告诉本地DNS服务器；&lt;/p&gt;
&lt;p&gt;6） 顶级域名服务器　　&lt;br&gt;
顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的IP地址告诉本地DNS服务器；&lt;/p&gt;
&lt;p&gt;7） 主域名服务器　　&lt;br&gt;
主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录；&lt;/p&gt;
&lt;p&gt;8）保存结果至缓存　　&lt;br&gt;
本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个IP地址与web服务器建立链接。&lt;/p&gt;
&lt;h1 id=&#34;4-cdn内容分发网络&#34;&gt;4. CDN（内容分发网络）&lt;/h1&gt;
&lt;h2 id=&#34;1-什么是cdn&#34;&gt;1. 什么是CDN&lt;/h2&gt;
&lt;p&gt;简单的理解CDN就是这些缓存服务器，帮助在最近的CDN节点，用最短的请求时间拿到资源，这样排队的人也就少了。也就起到分流作用，减轻服务器负载压力。&lt;/p&gt;
&lt;h2 id=&#34;2-cdn工作原理&#34;&gt;2. CDN工作原理&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;资源上传cdn之后，当用户访问cdn的资源地址之后会经历下面的步骤：&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先经过本地的dns解析，请求cname指向的那台cdn专用的dns服务器。&lt;/li&gt;
&lt;li&gt;dns服务器返回全局负载均衡的服务器ip给用户&lt;/li&gt;
&lt;li&gt;用户请求全局负载均衡服务器，服务器根据ip返回所在区域的负载均衡服务器ip给用户&lt;/li&gt;
&lt;li&gt;用户请求区域负载均衡服务器，负载均衡服务器根据用户ip选择距离近的，并且存在用户所需内容的，负载比较合适的一台缓存服务器ip给用户。当没有对应内容的时候，会去上一级缓存服务器去找，直到找到资源所在的源站服务器，并且缓存在缓存服务器中。用户下一次在请求该资源，就可以就近拿缓存了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意： 因为cdn的负载均衡和就近选择缓存都是根据用户的ip来的，服务器只能拿到local dns的ip，也就是网络设置中设置的dns ip，如果这个设置的不合理，那么可能起不到加速的效果。可能就近找到的缓存服务器实际离得很远。&lt;/p&gt;
&lt;p&gt;cdn的原理主要答出&lt;code&gt;负载均衡&lt;/code&gt;和&lt;code&gt;缓存&lt;/code&gt;再就是&lt;code&gt;dns解析&lt;/code&gt;这三部分就行了吧，通过&lt;code&gt;dns解析&lt;/code&gt;到&lt;code&gt;全局负载均衡服务器&lt;/code&gt;，然后再到&lt;code&gt;区域的负载均衡&lt;/code&gt;，之后根据一些条件来找合适的&lt;code&gt;缓存服务器&lt;/code&gt;，如果第一次访问就从源站拿过来缓存。 需要注意的是一切都是根据请求的ip来的，如果ip不合理，那么可能起不到加速效果。缓存和负载均衡的思想在减轻服务器压力方面其实是很常见的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从这个例子可以了解到：&lt;/strong&gt;&lt;br&gt;
（1）CDN的加速资源是跟域名绑定的。&lt;br&gt;
（2）通过域名访问资源，首先是通过DNS分查找离用户最近的CDN节点（边缘服务器）的IP&lt;br&gt;
（3）通过IP访问实际资源时，如果CDN上并没有缓存资源，则会到源站请求资源，并缓存到CDN节点上，这样，用户下一次访问时，该CDN节点就会有对应资源的缓存了。&lt;/p&gt;
&lt;h2 id=&#34;3-cdn缓存&#34;&gt;3. CDN缓存&lt;/h2&gt;
&lt;p&gt;关于CDN缓存,在浏览器本地缓存失效后,浏览器会向CDN边缘节点发起请求。类似浏览器缓存,CDN边缘节点也存在着一套缓存机制。CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循http标准协议，通过http响应头中的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cache-control: max-age //后面会提到
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;的字段来设置CDN边缘节点数据缓存时间。&lt;/p&gt;
&lt;h2 id=&#34;4-cdn-优势&#34;&gt;4. CDN 优势&lt;/h2&gt;
&lt;p&gt;CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低。&lt;br&gt;
大部分请求在CDN边缘节点完成，CDN起到了分流作用，减轻了源服务器的负载。&lt;/p&gt;
&lt;h1 id=&#34;5-计算机网络重点知识汇总&#34;&gt;5. 计算机网络重点知识汇总&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;层级&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;数据格式&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;功能与连接方式&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;包含的协议&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;功能&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;典型设备&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;应用层 Application&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据Data&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;网络服务与使用者应用程序间的一个接口&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;如HTTP、FTP、SMTP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;文件传输，电子邮件，文件服务，虚拟终端&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;终端设备（PC、手机、平板等）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;表示层 Presentation&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据Data&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据表示、数据安全、数据压缩&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;如XDR、ASN.1、SMB、AFP、NCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据格式化，代码转换，数据加密&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;终端设备（PC、手机、平板等）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;会话层 Session&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据Data&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;会话层连接到传输层的映射；会话连接的流量控制；数据传输；会话连接恢复与释放；会话连接管理、差错控制&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;如ASAP、TLS、SSH、ISO 8327 / CCITT X.225、RPC&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;解除或建立与别的结点的联系&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;终端设备（PC、手机、平板等）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;传输层 Transport&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据组织成数据段Segment&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用一个寻址机制来标识一个特定的应用程序（端口号）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;如TCP、UDP、RTP、SCTP、SPX、ATP、IL&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;提供端对端的接口&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;终端设备（PC、手机、平板等）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;网络层 Network&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;分割和重新组合数据包Packet&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;基于网络层地址（IP地址）进行不同网络系统间的路径选择&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;如IP、ICMP、IGMP、IPX、BGP、OSPF&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;为数据包选择路由&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;路由器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据链路层 Data Link&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将比特信息封装成数据帧Frame&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;在物理层上建立、撤销、标识逻辑链接和链路复用、以及差错校验等功能。通过使用接收系统的硬件地址或物理地址来寻址&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;如以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;传输有地址的帧以及错误检测功能&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;网桥、交换机、中继器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;物理层 Physical&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;传输比特（bit）流&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;建立、维护、取消物理连接&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;如线路、无线电、光纤、信鸽&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;以二进制数据形式在物理媒体上传输数据&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;光纤、同轴电缆、 双绞线、网卡&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616399158170.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;0-http轮询即时通讯&#34;&gt;0. HTTP轮询（即时通讯）&lt;/h2&gt;
&lt;h3 id=&#34;1-轮询&#34;&gt;1. 轮询&lt;/h3&gt;
&lt;p&gt;短轮询的基本思路就是&lt;strong&gt;浏览器每隔一段时间向浏览器发送http请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应&lt;/strong&gt;。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。&lt;/p&gt;
&lt;p&gt;这种方式的优点是比较简单，易于理解，实现起来也没有什么技术难点。缺点是显而易见的，这种方式由于需要不断的建立http连接，&lt;strong&gt;严重浪费了服务器端和客户端的资源&lt;/strong&gt;。尤其是在客户端，距离来说，如果有数量级想对比较大的人同时位于基于短轮询的应用中，那么每一个用户的客户端都会疯狂的向服务器端发送http请求，而且不会间断。人数越多，服务器端压力越大，这是很不合理的。&lt;/p&gt;
&lt;p&gt;因此短轮询不适用于那些同时在线用户数量比较大，并且很注重性能的Web应用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var xhr = new XMLHttpRequest();
    setInterval(function(){
        xhr.open(&#39;GET&#39;,&#39;/user&#39;);
        xhr.onreadystatechange = function(){

        };
        xhr.send();
    },1000)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-长轮询ajax实现&#34;&gt;2. 长轮询（ajax实现）&lt;/h3&gt;
&lt;p&gt;当服务器收到客户端发来的请求后，&lt;strong&gt;服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新&lt;/strong&gt;。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制(服务器端设置)才返回。客户端JavaScript响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。&lt;/p&gt;
&lt;p&gt;长轮询和短轮询比起来，明显减少了很多不必要的http请求次数，相比之下节约了资源。&lt;strong&gt;长轮询的缺点在于，连接挂起也会导致资源的浪费&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   function ajax(){
        var xhr = new XMLHttpRequest();
        xhr.open(&#39;GET&#39;,&#39;/user&#39;);
        xhr.onreadystatechange = function(){
              ajax();
        };
        xhr.send();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;轮询与长轮询都是基于HTTP的，两者本身存在着缺陷：轮询需要更快的处理速度；长轮询则更要求处理并发的能力；两者都是“&lt;strong&gt;被动型服务器&lt;/strong&gt;”的体现：服务器不会主动推送信息，而是在客户端发送ajax请求后进行返回的响应。而理想的模型是&amp;quot;在服务器端数据有了变化后，可以主动推送给客户端&amp;quot;，这种&amp;quot;&lt;strong&gt;主动型&lt;/strong&gt;&amp;quot;服务器是解决这类问题的很好的方案。&lt;/p&gt;
&lt;h2 id=&#34;1-http报文结构&#34;&gt;1. HTTP报文结构&lt;/h2&gt;
&lt;p&gt;HTTP报文由&lt;strong&gt;报文首部&lt;/strong&gt;和&lt;strong&gt;报文主体&lt;/strong&gt;构成，中间由一个&lt;strong&gt;空行分隔&lt;/strong&gt;。&lt;strong&gt;报文首部包含请求行和请求头部&lt;/strong&gt;，报文主体主要包含被发送的信息。&lt;/p&gt;
&lt;p&gt;报文首部是客户端或服务端需要处理请求或响应的内容及属性，可以传递额外的信息。&lt;/p&gt;
&lt;h3 id=&#34;11-http请求报文&#34;&gt;1.1 HTTP请求报文&lt;/h3&gt;
&lt;p&gt;HTTP请求报文由3部分组成（请求行+请求头+请求体）：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1617847556323.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请求行：&lt;/strong&gt;&lt;br&gt;
①是&lt;code&gt;请求方法&lt;/code&gt;，GET和POST是最常见的HTTP方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE。&lt;br&gt;
②为请求对应的&lt;code&gt;URL地址&lt;/code&gt;，它和报文头的Host属性组成完整的请求URL。&lt;br&gt;
③是&lt;code&gt;协议名称及版本号&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请求头：&lt;/strong&gt;&lt;br&gt;
④是&lt;code&gt;HTTP的报文头&lt;/code&gt;，报文头包含若干个属性，格式为“属性名:属性值”，服务端据此获取客户端的信息。&lt;br&gt;
与缓存相关的规则信息，均包含在header中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请求体：&lt;/strong&gt;&lt;br&gt;
⑤是&lt;code&gt;报文体&lt;/code&gt;，它将一个页面表单中的组件值通过param1=value1&amp;amp;param2=value2的键值对形式编码成一个格式化串，它承载多个请求参数的数据。不但报文体可以传递请求参数，请求URL也可以通过类似于“/chapter15/user.html? param1=value1&amp;amp;param2=value2”的方式传递请求参数。&lt;/p&gt;
&lt;h3 id=&#34;12-http响应报文&#34;&gt;1.2 HTTP响应报文&lt;/h3&gt;
&lt;p&gt;HTTP的响应报文也由三部分组成（响应行+响应头+响应体）&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1617847696959.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;响应行：&lt;/strong&gt;&lt;br&gt;
①报文协议及版本；&lt;br&gt;
②状态码及状态描述；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;响应头：&lt;/strong&gt;&lt;br&gt;
③响应报文头，也是由多个属性组成；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;响应体：&lt;/strong&gt;&lt;br&gt;
④响应报文体，即我们真正要的“干货”&lt;/p&gt;
&lt;h2 id=&#34;2-http首部字段&#34;&gt;2. HTTP首部字段&lt;/h2&gt;
&lt;h3 id=&#34;21-http通用首部字段&#34;&gt;2.1. HTTP通用首部字段&lt;/h3&gt;
&lt;p&gt;通用首部字段是请求报文和响应报文都会使用的字段，例如：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;通用头部字段&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;HTTP1.0&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;HTTP1.1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Date&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;表示请求和响应生成的日期，GTM时间。例如 Tue, 02 Mar 2021 12:31:25 GMT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Pragma&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;表示数据是否允许被缓存的通信选项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Cache-Control&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;控制缓存的相关信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Connection&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;设置发送响应之后 TCP 连接是否继续保持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Transfer-Encoding&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;表示消息主体的编码格式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Via&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;记录途中经过的代理和网关&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;22-http请求首部字段&#34;&gt;2.2 HTTP请求首部字段&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;请求头部字段&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;HTTP1.0&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;HTTP1.1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Host&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;接受请求的服务器IP地址和端口号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Accept&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;客户端可支持的数据类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;User-Agent&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;客户端软件的名称和版本号等相关信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;If-Modified-Since&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;UMT时间，表示该时间之后资源是否修改&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;If-None-Match&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回服务器响应头的 Etag 值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Referer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;通过点击超链接进入下一个页面时，在这里会记录上一个页面的 URI&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Accept-Encoding&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;客户端可支持的编码格式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Accept-Language&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;客户端可支持的语言&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;If-Match&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;If-Unmodified-Since&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Range&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;当只需要回去部分数据时，可通过这个字段指定要获取的数据范围&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;23-http响应首部字段&#34;&gt;2.3. HTTP响应首部字段&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;响应头部字段&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;HTTP1.0&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;HTTP1.1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Location&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;表示信息的准确位置，绝对路径&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Server&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;服务器程序的名称和版本号相关信息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;24-http实体消息体首部字段&#34;&gt;2.4 HTTP实体（消息体）首部字段&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;实体头部字段&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;HTTP1.0&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;HTTP1.1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Allow&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;表示指定的 URI 支持的方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Content-Encoding&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;消息的编码格式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Content-Length&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;消息体的长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Content-Type&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;消息体的数据类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Expires&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;消息体的有效期，UMT 时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Last-Modified&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据最后更新的日期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Etag&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;资源的唯一标识符，控制是否使用缓存&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;3-http方法&#34;&gt;3. HTTP方法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;根据 HTTP 标准，HTTP 请求可以使用多种请求方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;HTTP1.0 定义了三种请求方法：GET、POST 和 HEAD 方法&lt;br&gt;
HTTP1.1 新增了六种方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;GET&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用于从服务器获取数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;HEAD&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;类似于 GET 请求，只不过响应中没有具体的内容，&lt;strong&gt;用户获取报头&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;POST&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;向指定资源提交数据进行处理请求。数据被包含在请求体中，POST请求可能导致新的资源的建立或已有资源的修改&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;PUT&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;客户端向服务器传送的数据取代指定的文档内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;DELETE&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;请求服务器删除指定的资源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;OPTIONS&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;允许客户端查看服务器的性能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;CONNECT&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TRACE&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;回显服务器收到的请求，主要用于测试或诊断。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;PATCH&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是对 PUT 方法的补充，用来对已知资源进行局部更新 。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;GET与POST方法的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;get 是从指定的资源请求数据，post 是向指定的资源提交要处理的数据&lt;/li&gt;
&lt;li&gt;get 请求可以被缓存，post 请求不会被缓存&lt;/li&gt;
&lt;li&gt;get 请求传输的数据有长度限制，一般为 2048 字符，post 请求传输的数据没有大小限制&lt;/li&gt;
&lt;li&gt;get 请求的数据一般追加在 URL 的末尾，post 请求的数据在 http 请求体中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般不使用 GET 请求发送如密码这样的敏感信息。我认为 get 请求比 post 请求更安全。&lt;/p&gt;
&lt;h2 id=&#34;4-常见的http状态码&#34;&gt;4. 常见的HTTP状态码&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;状态码&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;200&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;请求成功&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;204&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无内容。服务器处理成功，但未返回内容。在未更新网页的情况下可确保浏览器继续显示当前文档&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;206&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;服务器成功处理了部分 GET 请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;301&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;永久移除。请求的资源已被永久移动到新 URI，返回的信息包括新的 URI，浏览器会自动定向到新 URI。今后任何请求都应该使用新的 URI 代替&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;302&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;临时移除。资源被临时移除，客户端应继续使用当前 URI&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;304&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;未修改。资源未修改，服务器不会返回任何资源，告诉浏览器使用本地缓存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;400&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;客户端请求的语法错误，服务端无法理解&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;401&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;要求用户进行身份认证&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;403&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;服务器拒绝请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;404&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;资源未找到&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;500&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;服务器内部错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;502&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;服务器作为网关或者代理，从远程服务器接收到了一个无效的响应&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;504&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;网关超时，服务器作为网关或者代理，但是没有及时从远程服务器收到请求&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;5-http与https的区别及实现方式&#34;&gt;5. HTTP与HTTPS的区别及实现方式&lt;/h2&gt;
&lt;h3 id=&#34;0-基本概念&#34;&gt;0. 基本概念&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;HTTP是超文本传输协议&lt;/strong&gt;，是一个简单的&lt;code&gt;请求-响应协议&lt;/code&gt;，它默认工作在TCP的80端口。&lt;strong&gt;它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应&lt;/strong&gt;。协议以明文的方式进行发送，不提供任何方式的数据加密。因此HTTP协议不适合传输一些敏感信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTPS是超文本传输安全协议&lt;/strong&gt;，是一种&lt;code&gt;安全通信&lt;/code&gt;的传输协议。&lt;strong&gt;HTTPS经由HTTP进行通信，但利用 SSL/TSL 来进行加密数据包&lt;/strong&gt;。HTTPS开发的主要目的是提供网站服务器的身份认证，保护数据交换的隐私与完整性。&lt;/p&gt;
&lt;p&gt;HTTPS默认工作在 TCP 的443 端口，它的工作方式如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP三次同步握手&lt;/li&gt;
&lt;li&gt;客户端验证服务端数字证书&lt;/li&gt;
&lt;li&gt;DH 算法协商对称加密加密算法的密钥、hash 算法的密钥&lt;/li&gt;
&lt;li&gt;SSL 安全加密隧道协商完成&lt;/li&gt;
&lt;li&gt;网页以加密的方式进行传输，用协商的对称加密算法和密钥加密，保障数据机密性；用协商的 hash 算法进行数据完整性保护，保证数据不被篡改。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-http的无状态&#34;&gt;1. HTTP的无状态&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;就是第二次来你无法识别它曾经来过&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;http的每次请求，在事务上和前后http请求没有任何关联，对上一次请求，下一次请求没有任何影响。这个是定义，从宏观上说的，实际上把无状态说成请求独立，无关联也对&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTTP 是一个无状态协议，这意味着&lt;code&gt;每个请求都是独立&lt;/code&gt;的，Keep-Alive 没能改变这个结果。&lt;/p&gt;
&lt;p&gt;缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。&lt;/p&gt;
&lt;p&gt;HTTP 协议这种特性有优点也有缺点，优点在于解放了服务器，每一次请求“点到为止”不会造成不必要连接占用，缺点在于每次请求会传输大量重复的内容信息。&lt;/p&gt;
&lt;p&gt;HTTP 无状态的特性严重阻碍了这些应用程序的实现，于是两种用于保持 HTTP 连接状态的技术就应运而生了，一个是 &lt;code&gt;Cookie&lt;/code&gt;，而另一个则是 &lt;code&gt;Session&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619491336853.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619491341437.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-http-与-https-的区别&#34;&gt;2. HTTP 与 HTTPS 的区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 使用明文传输，数据都是&lt;strong&gt;未加密&lt;/strong&gt;的，安全性较差；HTTPS 数据传输过程是加密的，安全性较好；&lt;/li&gt;
&lt;li&gt;使用 HTTPS 一般需要到 &lt;strong&gt;CA 申请证书&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;HTTP页面的响应比 HTTPS &lt;strong&gt;快&lt;/strong&gt;，主要是因为 HTTPS 除了 TCP 的三个包之外，还要加上 ssl 握手的 9 个包&lt;/li&gt;
&lt;li&gt;HTTP 和 HTTPS 是完全不同连接方式，用的端口也不一样， 前者是80， 后者是 443&lt;/li&gt;
&lt;li&gt;HTTPS 其实就是建构在 SSL/TSL 之上的 HTTP 协议，所以要比 HTTP &lt;strong&gt;更消耗服务器资源&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-https-的工作方式&#34;&gt;3. HTTPS 的工作方式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1617862416374.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;客户端发起 HTTPS 请求&lt;br&gt;
建立TCP连接之后，客户端发起请求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务端的配置&lt;br&gt;
服务端收到请求之后，会有一套公钥和私钥，这对公钥和私钥其实就是一套数字证书，一般都是由受信任的证书颁发机构进行签发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传送公钥&lt;br&gt;
服务端将公钥传递给客户端，里面包含很多信息，如证书的颁发机构，证书的过期时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端解析证书&lt;br&gt;
这部分工作由客户端的 TSL 来完成，首先验证证书是否有效。如果没有问题，就会随机生成一个 key，然后利用公钥对 key 的值进行加密。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传送加密的信息（key）&lt;br&gt;
将加密过后的 key 传递给服务器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用私钥解析加密信息（key）&lt;br&gt;
服务器使用自己的私钥解密加密信息得到 key&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用客户端的 key，利用对称加密加密信息，并发送给客户端&lt;br&gt;
把内容通过该 key 进行对称加密，并传输给客户端&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端使用 key 解密信息&lt;br&gt;
客户端收到信息之后利用 key 进行解密&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;重点：客户端会生成 key，key 的传输使用非对称加密，而数据的传输使用 key 进行对称加密。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对称加密：加密密钥和解密密钥是同一个，效率较高&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非对称加密：加密密钥和解密密钥不是同一个，效率较低&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;非对称加密的效率比较低&lt;/code&gt;，因此我们通常不使用非对称加密对整个文件进行加密，而采用&lt;code&gt;对称加密对文件加密&lt;/code&gt;，&lt;code&gt;非对称加密对对称加密的密钥加密&lt;/code&gt;，然后将&lt;code&gt;对称加密后的文件和非对称加密后的密钥&lt;/code&gt;一起在网上传送。&lt;/p&gt;
&lt;h3 id=&#34;4-ssl-的位置&#34;&gt;4. SSL 的位置&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1617863364032.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在发送方，SSL接受应用层的数据（如HTTP或者IMAP报文），对数据进行加密，然后把加了密的数据送往TCP套接字。&lt;/p&gt;
&lt;p&gt;在接收方，SSL从TCP套接字读取数据，解密后把数据交给应用层。&lt;/p&gt;
&lt;p&gt;使用非对称加密进行文件传输。通信双方在传输时需要交换各自的公钥。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SSL提供以下三个功能：&lt;/strong&gt;&lt;br&gt;
（1）SSL服务器鉴别：允许用户证实服务器的身份。具有SSL功能的浏览器维持一个表，上面有一些可信赖的认证中心CA（Certificate Authority）和它们的公钥。&lt;br&gt;
（2）加密的SSL会话：客户和服务器交互的所有数据都在发送方加密，在接收方解密。&lt;br&gt;
（3）SSL客户鉴别：允许服务器证实客户的身份。&lt;/p&gt;
&lt;h2 id=&#34;6-http10与http11以及http20的区别&#34;&gt;6. HTTP1.0与HTTP1.1以及HTTP2，0的区别&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;长连接&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在HTTP1.0中，TCP每建立一次连接就只能发送一个 HTTP 请求并得到一个响应，当需要再次发送请求的时候，又得重新建立 TCP 连接，这样就会很耗时间，传输效率较低。&lt;/p&gt;
&lt;p&gt;HTTP1.1中支持长连接和流水线传输，在一个 TCP 连接中可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。在 HTTP1.1 中默认开启 Connection: Keep-Alive，一定程度上弥补了 HTTP1.0 的缺点&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;缓存处理&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 HTTP1.0 中主要使用 Expires、Last-Modified、If-Modified-Since 头部字段来作为缓存判断的标准&lt;/p&gt;
&lt;p&gt;在 HTTP1.1 中增加了 Cache-Control、Etag、If-None-Match、If-Match 等头部字段来提供可选的更多的缓存策略&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;带宽优化及网络连接的使用&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了。&lt;/p&gt;
&lt;p&gt;HTTP1.1 中引入了 Range 头部字段，它允许只请求资源的某个部分，即返回状态码是 206&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;Host头处理&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 HTTP1.0 中认为每台服务器绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名。但随着虚拟技术的发展，在一台物理设备上可以存在多台虚拟主机，并且他们共享同一 IP 地址 。在 HTTP1.1 的请求消息和响应消息中都应支持 HOST 头域，且请求消息中没有 HOST 头域会报一个错误。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;错误通知的管理&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;HTTP1.1 中新增了 24 个错误状态码，如 409 表示请求的资源与资源的当前状态发生冲突；410表示服务器上的某个资源被永久性删除。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1617865423190.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;7-http20&#34;&gt;7. http2.0&lt;/h2&gt;
&lt;h3 id=&#34;1-二进制传输&#34;&gt;1. 二进制传输&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;HTTP/2传输数据量的大幅减少,主要有两个原因：以二进制方式传输和Header 压缩&lt;/strong&gt;。HTTP/2 采用二进制格式传输数据，而非HTTP/1.x 里纯文本形式的报文 ，二进制协议解析起来更高效。&lt;strong&gt;HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它把TCP协议的部分特性挪到了应用层，把原来的&amp;quot;Header+Body&amp;quot;的消息&amp;quot;打散&amp;quot;为数个小片的二进制&amp;quot;帧&amp;quot;(Frame),用&amp;quot;HEADERS&amp;quot;帧存放头数据、&amp;quot;DATA&amp;quot;帧存放实体数据。HTP/2数据分帧后&amp;quot;Header+Body&amp;quot;的报文结构就完全消失了，协议看到的只是一个个的&amp;quot;碎片&amp;quot;。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616380446582.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。&lt;strong&gt;多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;2-header-压缩&#34;&gt;2. Header 压缩&lt;/h3&gt;
&lt;p&gt;HTTP/2并没有使用传统的压缩算法，而是开发了专门的&amp;quot;HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体来说:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送；&lt;/li&gt;
&lt;li&gt;首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;&lt;/li&gt;
&lt;li&gt;每个新的首部键-值对要么被追加到当前表的末尾，要么替换表中之前的值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616380864613.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-多路复用&#34;&gt;3. 多路复用&lt;/h3&gt;
&lt;p&gt;在 HTTP/2 中引入了多路复用的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。&lt;/p&gt;
&lt;p&gt;在 HTTP/2 中，有了二进制分帧之后，HTTP /2 不再依赖 TCP 链接去实现多流并行了，在 HTTP/2中,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同域名下所有通信都在单个连接上完成。&lt;/li&gt;
&lt;li&gt;单个连接可以承载任意数量的双向数据流。&lt;/li&gt;
&lt;li&gt;数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一特性，使性能有了极大提升：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应,这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个TCP连接竞争带宽所带来的问题。&lt;/li&gt;
&lt;li&gt;并行交错地发送多个请求/响应，请求/响应之间互不影响。&lt;/li&gt;
&lt;li&gt;在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616381290207.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如上图所示，多路复用的技术可以只通过一个 TCP 连接就可以传输所有的请求数据。&lt;/p&gt;
&lt;h3 id=&#34;4-服务器推送&#34;&gt;4. 服务器推送&lt;/h3&gt;
&lt;p&gt;服务端推送是一种在客户端请求之前发送数据的机制。&lt;/p&gt;
&lt;p&gt;在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。&lt;/p&gt;
&lt;p&gt;为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1617865820470.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;8-http建立持久连接的意义&#34;&gt;8. HTTP建立持久连接的意义&lt;/h2&gt;
&lt;p&gt;在 HTTP1.0 中每发送一次请求都要重新建立 TCP 连接并且关闭连接。这样做是很耗费时间的。而在HTTP1.1 中默认开启长连接，一次TCP连接可以发送多个HTTP请求，避免了重复建立释放连接的开销，加速了数据的传输，节省了时间和带宽。&lt;/p&gt;
&lt;h3 id=&#34;1那么长连接什么时候会释放呢&#34;&gt;1.那么长连接什么时候会释放呢？&lt;/h3&gt;
&lt;p&gt;客户端的长连接不可能一直拿着，会有一个超时时间，服务器会告诉客户端超时时间，譬如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Access-Control-Allow-Origin: http://mall.sillywa.com
Connection: keep-alive
Content-Length: 43574
Content-Type: application/json; charset=utf-8
Date: Wed, 03 Mar 2021 07:34:49 GMT
Keep-Alive: timeout=5
Vary: Origin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Keep-Alive: timeout=5&lt;/strong&gt; &lt;strong&gt;表示这个 TCP 通道可以保持 5s&lt;/strong&gt;。另外还可能有 max=xxx，表示这个长连接&lt;strong&gt;最多接受xxx次请求就断开&lt;/strong&gt;。对于客户端来说，如果服务端没有告诉是客户端超时时间也没关系，服务端可能主动发起四次挥手断开TCP连接，客户端就能够知道该TCP连接已经无效。&lt;/p&gt;
&lt;h3 id=&#34;2-长连接数据传送完成识别&#34;&gt;2. 长连接数据传送完成识别：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;判断传输的数据是否达到了 Content-Length 指示的大小&lt;/li&gt;
&lt;li&gt;没有 Content-Length，由于数据是分块传输的，这时候就要根据块的编码来判断了，最后一个一个编码的数据是一个空块，表明本次传输结束&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;9-tcpip-协议分层管理&#34;&gt;9. TCP/IP 协议分层管理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1617869165303.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
传输层：可靠传输（丢包重发） 、流量控制、不可靠传输（只需要发送一个数据包）&lt;/p&gt;
&lt;p&gt;网络层：负责选择最佳路径、规划 IP 地址&lt;/p&gt;
&lt;p&gt;数据链路层：帧的开始和结束、透明传输（数据中出现了帧的结束标志，需要采用转义字符）、差错校验（循环冗余检测）&lt;/p&gt;
&lt;h2 id=&#34;10-tcp三次握手四次挥手机制及原因&#34;&gt;10. TCP三次握手四次挥手机制及原因&lt;/h2&gt;
&lt;h3 id=&#34;0-连接中怎么找到对方&#34;&gt;0. 连接中怎么找到对方？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;TCP头部为20字节&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源端口号（16位）和目的端口号（16位）：&lt;code&gt;再加上Ip首部的源IP地址和目的IP地址可以唯一确定一个TCP连接&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数据序号（16位）：表示在这个报文段中的第一个数据字节序号&lt;/li&gt;
&lt;li&gt;确认序号：仅当ACK标志为1时有效，确认号表示期望收到的下一个字节的序号&lt;/li&gt;
&lt;li&gt;偏移：就是头部长度，有4位，跟IP头部一样，以4字节为单位。最大是60个字节&lt;/li&gt;
&lt;li&gt;保留位：6位，必须为0&lt;/li&gt;
&lt;li&gt;6个标志位：URG-紧急指针有效；ACK-确认序号有效；PSH-接收方应尽快将这个报文交给应用层；RST-连接重置；SYN-同步序号用来发起一个连接；FIN-终止一个连接。&lt;/li&gt;
&lt;li&gt;窗口字段：16位，代表的是窗口的字节容量，也就是TCP的标准窗口最大为2^16 - 1 = 65535个字节&lt;/li&gt;
&lt;li&gt;校验和：源机器基于数据内容计算一个数值，收信息机要与源机器数值结果完全一样，从而证明数据的有效性。检验和覆盖了整个的TCP报文段：这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-三次握手&#34;&gt;1. 三次握手&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1617869541484.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;为什么需要三次握手，两次行不行？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设是两次握手，客户端刚开始发送第一个建立连接的请求，但是由于该请求在某一个路由器中停留时间过长，客户端一段时间没收到服务器的响应消息，就会再发一个建立连接的请求，这个请求达到服务器，并成功建立连接，之后数据传输完成，关闭连接。这时候先前发送的第一个建立连接的请求，终于通过网络传到了服务器，服务器收到请求，返回一个数据包，并立即打开连接，这是客户端已经关闭了，对服务端的数据包不予理睬，这样就会导致服务端资源的浪费。&lt;/p&gt;
&lt;p&gt;**为什么不能四次握手？**四次握手的流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送：SYN=1,ACK=0,seq=x&lt;/li&gt;
&lt;li&gt;服务端收到客户端消息，发送：ACK = 1, 确认号=x+1,seq=y&lt;/li&gt;
&lt;li&gt;服务端发送同步建立连接，发送：SYN=1，确认号=x+1，seq = w&lt;/li&gt;
&lt;li&gt;客户端收到发送：ACK=1，确认号=w+1,seq = x+1&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这个过程中，显然第二步和第三步可以合并，不需要单独发送一个 SYN&lt;/p&gt;
&lt;h3 id=&#34;2-四次挥手&#34;&gt;2. 四次挥手&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1617870529977.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
既然握手的时候，服务端发送的两个请求可以合并，&lt;strong&gt;那么释放连接的时候，是否也能合并，只需三次握手呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们的回答是不能够，因为当服务器收到客户端关闭连接的请求的时候，服务端可能还在继续发送数据，但是他又必须先给客户端一个回应，说我收到了请求。等服务端的数据发送完毕之后，再发一个数据包说我已经可以关闭请求了。客户端收到之后再作出回应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客户端为什么要有TIME-WAIT阶段&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;防止最后一个数据包丢失而导致服务器接收不到，一段时间后服务器会重新发送第三个数据包。如果此时客户端已经关闭了，则收不到第三个数据包，服务端也就无法正常关闭了。&lt;/p&gt;
&lt;h2 id=&#34;11tcpudp-的区别&#34;&gt;11.TCP/UDP 的区别&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;TCP&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;UDP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;面向连接，是指发送数据之前必须在两端建立TCP连接，连接方式为三次握手&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不面向连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可靠传输，流量控制与拥塞控制&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不可靠传输，尽最大努力交付&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;传输方式上以字节流的形式传输&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;以报文形式传输&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只能是一对一通信&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;支持一对一、一对多、多对多、多对一交互通信&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;最小20字节，最多60字节&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;首部开销较小，只有 8 字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;适用于要求可靠传输的应用&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;适用于实时应用，如视频会议、直播等&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;12-扫码登录如何实现&#34;&gt;12.  扫码登录如何实现&lt;/h2&gt;
&lt;p&gt;扫码登陆要求已经用户在手机端登录&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户在浏览器点击扫码登录，浏览器向服务端发送一个请求，服务端生成一个唯一 id，并将这个 id 写入二维码并且返回这个二维码给浏览器&lt;/li&gt;
&lt;li&gt;浏览器收到之后，开始带上这个 id 轮询后台提供的一个接口，判断用户是否扫码并确认登陆了&lt;/li&gt;
&lt;li&gt;用户拿出手机扫描二维码，得到这个 id，并确认登陆，然后会将用户信息和 id 传给服务器&lt;/li&gt;
&lt;li&gt;服务器拿到用户信息 和 id 之后，写入数据库&lt;/li&gt;
&lt;li&gt;这时候服务器轮询就会得到结果，说明用户已经确认登陆，并且得到服务器返回的 token 和用户信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;8-getpostputdeleteoptions等请求方式&#34;&gt;8. GET,POST,PUT,DELETE,OPTIONS等请求方式&lt;/h1&gt;
&lt;h2 id=&#34;1-不同请求方式区别&#34;&gt;1. 不同请求方式区别&lt;/h2&gt;
&lt;h3 id=&#34;1-get&#34;&gt;1. GET&lt;/h3&gt;
&lt;p&gt;get请求是用来获取数据的，只是用来&lt;code&gt;查询数据&lt;/code&gt;，不对服务器的数据做任何的修改，新增，删除等操作。&lt;/p&gt;
&lt;p&gt;在这里我们认为get请求是&lt;code&gt;安全的&lt;/code&gt;，以及&lt;code&gt;幂等的&lt;/code&gt;。安全就是指不影响服务器的数据，幂等是指同一个请求发送多次返回的结果应该相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;get请求会把请求的参数附加在URL后面，这样会产生安全问题，如果是系统的登陆接口采用的get请求，需要对请求的参数做一个加密。&lt;/li&gt;
&lt;li&gt;get请求其实本身HTTP协议并没有限制它的URL大小，但是不同的浏览器对其有不同的大小长度限制&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-post&#34;&gt;2. POST&lt;/h3&gt;
&lt;p&gt;post请求一般是对服务器的数据做改变，常用来数据的提交，新增操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;post请求的请求参数都是请求体中&lt;/li&gt;
&lt;li&gt;post请求本身HTTP协议也是没有限制大小的，限制它的是服务器的处理能力&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-put&#34;&gt;3. PUT&lt;/h3&gt;
&lt;p&gt;put请求与post一样都会改变服务器的数据，但是put的侧重点在于对于数据的修改操作，但是post侧重于对于数据的增加。&lt;/p&gt;
&lt;h3 id=&#34;4-delete&#34;&gt;4. DELETE&lt;/h3&gt;
&lt;p&gt;delete请求用来删除服务器的资源。&lt;/p&gt;
&lt;h3 id=&#34;5-options&#34;&gt;5. OPTIONS&lt;/h3&gt;
&lt;p&gt;options请求属于浏览器的&lt;code&gt;预检请求&lt;/code&gt;，查看服务器是否接受请求，预检通过后，浏览器才会去发get，post，put，delete等请求。至于什么情况下浏览器会发预检请求，浏览器会会将请求分为两类，简单请求与非简单请求，&lt;code&gt;非简单请求&lt;/code&gt;会产生预检options请求。(结合CORS跨域)&lt;/p&gt;
&lt;h2 id=&#34;2-浏览器的get和post&#34;&gt;2. 浏览器的GET和POST&lt;/h2&gt;
&lt;p&gt;浏览器用GET请求来获取一个html页面/图片/css/js等资源；用POST来提交一个&lt;form&gt;表单，并得到一个结果的网页。&lt;/p&gt;
&lt;h3 id=&#34;1-get-2&#34;&gt;1. GET&lt;/h3&gt;
&lt;p&gt;“读取“一个资源。比如Get到一个html文件。反复读取不应该对访问的数据有副作用。没有副作用被称为“幂等“（Idempotent)。因为GET因为是读取，就可以对GET请求的数据做缓存。这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），或者做到server端（用Etag，至少可以减少带宽消耗）&lt;/p&gt;
&lt;h3 id=&#34;2-post-2&#34;&gt;2. POST&lt;/h3&gt;
&lt;p&gt;在页面里&amp;lt;form&amp;gt; 标签会定义一个表单。点击其中的submit元素会发出一个POST请求让服务器做一件事。这件事往往是有副作用的，&lt;code&gt;不幂等&lt;/code&gt;的。不幂等也就意味着不能随意多次执行。因此也就不能缓存。&lt;/p&gt;
&lt;p&gt;此外如果尝试重新执行POST请求，浏览器也会弹一个框提示下这个刷新可能会有副作用，询问要不要继续。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618324396186.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-区别&#34;&gt;3. 区别&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;GET和POST携带数据的格式也有区别&lt;/code&gt;。当浏览器发出一个GET请求时，就意味着要么是用户自己在浏览器的地址栏输入，要不就是点击了html里a标签的href中的url。所以其实并不是GET只能用url，而是浏览器直接发出的GET只能由一个url触发。所以没办法，GET上要在url之外带一些参数就只能依靠url上附带querystring。但是HTTP协议本身并没有这个限制。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;浏览器的POST请求都来自表单提交&lt;/code&gt;。每次提交，表单的数据被浏览器用编码到HTTP请求的body里。浏览器发出的POST请求的body主要有有两种格式，一种是application/x-www-form-urlencoded用来传输简单的数据，大概就是&amp;quot;key1=value1&amp;amp;key2=value2&amp;quot;这样的格式。另外一种是传文件，会采用multipart/form-data格式。采用后者是因为application/x-www-form-urlencoded的编码方式对于文件这种二进制的数据非常低效。&lt;/p&gt;
&lt;p&gt;浏览器在POST一个表单时，url上也可以带参数，只要&amp;lt;form action=&amp;quot;url&amp;quot; &amp;gt;里的url带querystring就行。只不过表单里面的那些用&amp;lt;input&amp;gt; 等标签经过用户操作产生的数据都在会在body里。&lt;/p&gt;
&lt;h2 id=&#34;3-接口中的get和post&#34;&gt;3. 接口中的GET和POST&lt;/h2&gt;
&lt;p&gt;这里是指通过浏览器的Ajax api，或者iOS/Android的App的http client，java的commons-httpclient/okhttp或者是curl，postman之类的工具发出来的GET和POST请求。此时GET/POST不光能用在前端和后端的交互中，还能用在后端各个子服务的调用中（即当一种RPC协议使用）。尽管RPC有很多协议，比如thrift，grpc，但是http本身已经有大量的现成的支持工具可以使用，并且对人类很友好，容易debug。HTTP协议在微服务中的使用是相当普遍的。&lt;/p&gt;
&lt;p&gt;当用HTTP实现接口发送请求时，就&lt;code&gt;没有浏览器中那么多限制&lt;/code&gt;了，只要是符合HTTP格式的就可以发。HTTP请求的格式，大概是这样的一个字符串（为了美观，我在\r\n后都换行一下）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;METHOD&amp;gt; &amp;lt;URL&amp;gt; HTTP/1.1\r\n
&amp;lt;Header1&amp;gt;: &amp;lt;HeaderValue1&amp;gt;\r\n
&amp;lt;Header2&amp;gt;: &amp;lt;HeaderValue2&amp;gt;\r\n
...
&amp;lt;HeaderN&amp;gt;: &amp;lt;HeaderValueN&amp;gt;\r\n
\r\n
&amp;lt;Body Data....&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接口规范/风格。其中名气最大的当属REST。REST充分运用GET、POST、PUT和DELETE，约定了这4个接口分别获取、创建、替换和删除“资源”，REST最佳实践还推荐在请求体使用json格式。这样仅仅通过看HTTP的method就可以明白接口是什么意思，并且解析格式也得到了统一。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;json相对于x-www-form-urlencoded的优势在于&lt;br&gt;
1）可以有嵌套结构；&lt;br&gt;
2）可以支持更丰富的数据类型。通过一些框架，json可以直接被服务器代码映射为业务实体。用起来十分方便。但是如果是写一个接口支持上传文件，那么还是multipart/form-data格式更合适。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;REST中GET和POST不是随便用的。在REST中, 【GET】 + 【资源定位符】被专用于获取资源或者资源列表，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET http://foo.com/books          获取书籍列表
GET http://foo.com/books/:bookId  根据bookId获取一本具体的书
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;REST 【POST】+ 【资源定位符】则用于“创建一个资源”，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST http://foo.com/books
{
  &amp;quot;title&amp;quot;: &amp;quot;大宽宽的碎碎念&amp;quot;,
  &amp;quot;author&amp;quot;: &amp;quot;大宽宽&amp;quot;,
  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里你就能留意到&lt;strong&gt;浏览器中用来实现表单提交的POST&lt;/strong&gt;，和REST里实现创建资源的POST语义上的不同。&lt;/p&gt;
&lt;h2 id=&#34;4-关于安全性&#34;&gt;4. 关于安全性&lt;/h2&gt;
&lt;p&gt;我们常听到GET不如POST安全，因为POST用body传输数据，而GET用url传输，更加容易看到。但是从攻击的角度，无论是GET还是POST都不够安全，因为HTTP本身是&lt;code&gt;明文协议&lt;/code&gt;。&lt;code&gt;每个HTTP请求和返回的每个byte都会在网络上明文传播，不管是url，header还是body&lt;/code&gt;。这完全不是一个“是否容易在浏览器地址栏上看到“的问题。&lt;/p&gt;
&lt;p&gt;为了避免传输中数据被窃取，&lt;code&gt;必须做从客户端到服务器的端端加密。业界的通行做法就是https&lt;/code&gt;——即用SSL协议协商出的密钥加密明文的http数据。这个加密的协议和HTTP协议本身相互独立。如果是利用HTTP开发公网的站点/App，要保证安全，https是最最基本的要求。&lt;/p&gt;
&lt;p&gt;从客户端到服务器端，有大量的中间节点，包括网关，代理等。他们的access log通常会输出完整的url，比如nginx的默认access log就是如此。如果url上携带敏感数据，就会被记录下来。但请注意，&lt;code&gt;就算私密数据在body里，也是可以被记录下来的&lt;/code&gt;，因此如果请求要经过不信任的公网，避免泄密的&lt;code&gt;唯一手段就是https&lt;/code&gt;。这里说的“避免access log泄漏“仅仅是指避免可信区域中的http代理的默认行为带来的安全隐患。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618325278742.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;5-关于url的长度&#34;&gt;5. 关于URL的长度&lt;/h2&gt;
&lt;p&gt;因为上面提到了不论是GET和POST都可以使用URL传递数据，所以我们常说的“GET数据有长度限制“其实是指”URL的长度限制“。&lt;/p&gt;
&lt;p&gt;HTTP协议本身对URL长度并没有做任何规定。实际的限制是由客户端/浏览器以及服务器端决定的。&lt;/p&gt;
&lt;p&gt;先说浏览器。不同浏览器不太一样。比如我们常说的2048个字符的限制，其实是IE8的限制。并且原始文档的说的其实是“URL的最大长度是2083个字符，path的部分最长是2048个字符“。Chrome的URL限制是2MB&lt;/p&gt;
&lt;p&gt;除了浏览器，服务器这边也有限制，比如apache的LimieRequestLine指令。&lt;/p&gt;
&lt;p&gt;apache实际上限制的是HTTP请求第一行“Request Line“的长度，即&amp;lt;METHOD&amp;gt;&amp;lt;URL&amp;gt; &amp;lt;VERSION&amp;gt;那一行。再比如nginx用&lt;code&gt;large_client_header_buffers&lt;/code&gt; 指令来分配请求头中的很长数据的buffer。这个buffer可以用来处理url，header value等。&lt;/p&gt;
&lt;p&gt;为啥要限制呢？如果写过解析一段字符串的代码就能明白，解析的时候要分配内存。对于一个字节流的解析，必须分配buffer来保存所有要存储的数据。而URL这种东西必须当作一个整体看待，无法一块一块处理，于是就处理一个请求时必须分配一整块足够大的内存。如果URL太长，而并发又很高，就容易挤爆服务器的内存；同时，超长URL的好处并不多，我也只有处理老系统的URL时因为不敢碰原来的逻辑，又得追加更多数据，才会使用超长URL。&lt;/p&gt;
&lt;h1 id=&#34;9-ajax-axios库&#34;&gt;9. ajax、 axios库&lt;/h1&gt;
&lt;h2 id=&#34;1ajax&#34;&gt;1.ajax&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;创建XMLHttpRequest类型的对象&lt;/li&gt;
&lt;li&gt;准备发送，打开与网址之间的连接&lt;/li&gt;
&lt;li&gt;执行发送动作&lt;/li&gt;
&lt;li&gt;指定xhr状态变化事件处理函数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// 1.创建一个 XMLHttpRequest 类型的对象  --- 相当于打开了一个浏览器
var xhr = new XMLHttpRequest();
// 2.打开一个与网址之间的连接  --- 相当于在地址栏输入网址
xhr.open(&amp;quot;GET&amp;quot;,&amp;quot;https://jsonplaceholder.typicode.com/users&amp;quot;);
// 3.通过连接发送一次请求 --- 相当于点击回车或者超链接
xhr.send(null);
// 4.指定 xhr 状态变化事件处理函数   --- 相当于处理网页呈现后的操作
xhr.onreadystatechange = function () {
  // 通过判断 xhr 的 readyState ，确定此次请求是否完成
  if (this.readyState === 4) {
    console.log(this.responseText)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-axios-api&#34;&gt;2. Axios API&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可以通过向axios()传递相关配置来创建请求&lt;/li&gt;
&lt;li&gt;axios(config) config为对象格式的配置选项&lt;/li&gt;
&lt;li&gt;axios(url,config) config可选&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;常用配置选项&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;url 用于请求服务器的URL&lt;/li&gt;
&lt;li&gt;method 创建请求时使用的方法&lt;/li&gt;
&lt;li&gt;baseURL 传递相对URL前缀，将自动加在url前面&lt;/li&gt;
&lt;li&gt;headers 即将被发送的自定义请求头&lt;/li&gt;
&lt;li&gt;params 即将与请求一起发送的URL参数&lt;/li&gt;
&lt;li&gt;data 作为请求主体被发送的数据&lt;/li&gt;
&lt;li&gt;timeout 请求超时的毫秒数&lt;/li&gt;
&lt;li&gt;responseType 表示服务器响应的数据类型，默认json&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;axios({
  url: &amp;quot;/posts&amp;quot;,
  method: &amp;quot;get&amp;quot;,
  baseURL: &amp;quot;http://localhost:3000&amp;quot;,
  params: {
    id: 1
  }
}).then(function(res){
  console.log(res.data)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;10-前端安全xss-csrf&#34;&gt;10. 前端安全XSS、CSRF&lt;/h1&gt;
&lt;h2 id=&#34;1-xss&#34;&gt;1. XSS&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;跨网站指令码（英语：Cross-site scripting，通常简称为：XSS）XSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。有很多种方式进行 XSS 攻击，但它们的共同点为：将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。&lt;/p&gt;
&lt;p&gt;XSS 分为三种：&lt;strong&gt;反射型，存储型和 DOM-based&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-反射性&#34;&gt;1. 反射性&lt;/h3&gt;
&lt;p&gt;反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。&lt;/p&gt;
&lt;p&gt;看一个示例。我先准备一个如下的静态页：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616308450110.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当用户点击恶意链接时，页面跳转到攻击者预先准备的页面，会发现在攻击者的页面执行了 js 脚本：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616308453096.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这样就产生了反射型 XSS 攻击。攻击者可以注入任意的恶意脚本进行攻击，可能注入恶作剧脚本，或者注入能获取用户隐私数据(如cookie)的脚本，这取决于攻击者的目的。&lt;/p&gt;
&lt;h3 id=&#34;2-存储型&#34;&gt;2. 存储型&lt;/h3&gt;
&lt;p&gt;存储型 XSS 会把用户输入的数据 “存储” 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。&lt;/p&gt;
&lt;p&gt;比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。&lt;/p&gt;
&lt;p&gt;当用户点击提交按钮将输入信息提交到服务端时，服务端通过 userInput 变量保存了输入内容。当用户通过 http://localhost:8001/${id} 访问时，服务端会返回与 id 对应的内容(本示例简化了处理)。如果用户输入了恶意脚本内容，则其他用户访问该内容时，恶意脚本就会在浏览器端执行：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616308560547.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-基于dom&#34;&gt;3. 基于DOM&lt;/h3&gt;
&lt;p&gt;基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。&lt;/p&gt;
&lt;p&gt;点击 Submit 按钮后，会在当前页面插入一个链接，其地址为用户的输入内容。如果用户在输入时构造了如下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;&#39; onclick=alert(/xss/)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用户提交之后，页面代码就变成了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a href onlick=&amp;quot;alert(/xss/)&amp;quot;&amp;gt;testLink&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时，用户点击生成的链接，就会执行对应的脚本：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616308646010.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-xss攻击的防范&#34;&gt;2. XSS攻击的防范&lt;/h2&gt;
&lt;p&gt;现在主流的浏览器内置了防范 XSS 的措施，例如 CSP。但对于开发者来说，也应该寻找可靠的解决方案来防止 XSS 攻击。&lt;/p&gt;
&lt;h3 id=&#34;1-httponly-防止劫取-cookie&#34;&gt;1. HttpOnly 防止劫取 Cookie&lt;/h3&gt;
&lt;p&gt;浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。&lt;/p&gt;
&lt;p&gt;上文有说到，攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。&lt;/p&gt;
&lt;h3 id=&#34;2-输入检查&#34;&gt;2. 输入检查&lt;/h3&gt;
&lt;p&gt;不要相信用户的任何输入。 对于用户的任何输入要进行检查、过滤和转义。建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。&lt;/p&gt;
&lt;p&gt;在 XSS 防御中，输入检查一般是检查用户输入的数据中是否包含 &amp;lt;，&amp;gt; 等特殊字符，如果存在，则对特殊字符进行过滤或编码，这种方式也称为 XSS Filter。&lt;/p&gt;
&lt;p&gt;而在一些前端框架中，都会有一份 decodingMap， 用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 &amp;lt;，&amp;gt;，script，防止 XSS 攻击：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// vuejs 中的 decodingMap
// 在 vuejs 中，如果输入带 script 标签的内容，会直接过滤掉
const decodingMap = {
  &#39;&amp;amp;lt;&#39;: &#39;&amp;lt;&#39;,
  &#39;&amp;amp;gt;&#39;: &#39;&amp;gt;&#39;,
  &#39;&amp;amp;quot;&#39;: &#39;&amp;quot;&#39;,
  &#39;&amp;amp;amp;&#39;: &#39;&amp;amp;&#39;,
  &#39;
  &#39;: &#39;\n&#39;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-输出检查&#34;&gt;3. 输出检查&lt;/h3&gt;
&lt;p&gt;用户的输入会存在问题，服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。例如利用 sanitize-html 对输出内容进行有规则的过滤之后再输出到页面中。&lt;/p&gt;
&lt;h2 id=&#34;3-csrf&#34;&gt;3. CSRF&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;跨站请求伪造（英语：Cross-site request forgery），中译是跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615455801140.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-浏览器的-cookie-策略&#34;&gt;1. 浏览器的 Cookie 策略&lt;/h3&gt;
&lt;p&gt;Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。Cookie 主要用于以下两个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）&lt;/li&gt;
&lt;li&gt;个性化设置（如用户自定义设置、主题等）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而浏览器所持有的 Cookie 分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Session Cookie(会话期 Cookie)：会话期 Cookie 是最简单的Cookie，它不需要指定过期时间（Expires）或者有效期（Max-Age），它仅在会话期内有效，浏览器关闭之后它会被自动删除。&lt;/li&gt;
&lt;li&gt;Permanent Cookie(持久性 Cookie)：与会话期 Cookie 不同的是，持久性 Cookie 可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;res.setHeader(&#39;Set-Cookie&#39;, [&#39;mycookie=222&#39;, &#39;test=3333; expires=Sat, 21 Jul 2018 00:00:00 GMT;&#39;]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码创建了两个 Cookie：mycookie 和 test，前者属于会话期 Cookie，后者则属于持久性 Cookie。当我们去查看 Cookie 相关的属性时，不同的浏览器对会话期 Cookie 的 Expires 属性值会不一样：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616309731128.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
每个 Cookie 都会有与之关联的域，这个域的范围一般通过 donmain 属性指定。如果 Cookie 的域和页面的域相同，那么我们称这个 Cookie 为第一方 Cookie（first-party cookie），如果 Cookie 的域和页面的域不同，则称之为第三方 Cookie（third-party cookie）。一个页面包含图片或存放在其他域上的资源（如图片）时，第一方的 Cookie 也只会发送给设置它们的服务器。&lt;/p&gt;
&lt;h3 id=&#34;2-通过-cookie-进行-csrf-攻击&#34;&gt;2. 通过 Cookie 进行 CSRF 攻击&lt;/h3&gt;
&lt;p&gt;假设有一个 bbs 站点：http://www.c.com，当登录后的用户发起如下 GET 请求时，会删除 ID 指定的帖子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://www.c.com:8002/content/delete/:id
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如发起 http://www.c.com:8002/content/delete/87343 请求时，会删除 id 为 87343 的帖子。当用户登录之后，会设置如下 cookie：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;res.setHeader(&#39;Set-Cookie&#39;, [&#39;user=22333; expires=Sat, 21 Jul 2018 00:00:00 GMT;&#39;]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616309827160.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
user 对应的值是用户 ID。然后构造一个页面 A：&lt;/p&gt;
&lt;p&gt;CSRF 攻击者准备的网站：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;CSRF 攻击者准备的网站：&amp;lt;/p&amp;gt;
&amp;lt;img src=&amp;quot;http://www.c.com:8002/content/delete/87343&amp;quot;&amp;gt;
页面 A 使用了一个 img 标签，其地址指向了删除用户帖子的链接：
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616309871152.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看到，当登录用户访问攻击者的网站时，会向 www.c.com 发起一个删除用户帖子的请求。此时若用户在切换到 www.c.com 的帖子页面刷新，会发现ID 为 87343 的帖子已经被删除。&lt;/p&gt;
&lt;p&gt;由于 Cookie 中包含了用户的认证信息，当用户访问攻击者准备的攻击环境时，攻击者就可以对服务器发起 CSRF 攻击。在这个攻击过程中，攻击者借助受害者的 Cookie 骗取服务器的信任，但并不能拿到 Cookie，也看不到 Cookie 的内容。而对于服务器返回的结果，由于浏览器同源策略的限制，攻击者也无法进行解析。因此，攻击者无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。&lt;/p&gt;
&lt;p&gt;但若 CSRF 攻击的目标并不需要使用 Cookie，则也不必顾虑浏览器的 Cookie 策略了。&lt;/p&gt;
&lt;h2 id=&#34;4-csrf-攻击的防范&#34;&gt;4. CSRF 攻击的防范&lt;/h2&gt;
&lt;p&gt;当前，对 CSRF 攻击的防范措施主要有如下几种方式。&lt;/p&gt;
&lt;h3 id=&#34;1-验证码&#34;&gt;1. 验证码&lt;/h3&gt;
&lt;p&gt;验证码被认为是对抗 CSRF 攻击最简洁而有效的防御方法。&lt;/p&gt;
&lt;p&gt;从上述示例中可以看出，CSRF 攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。因为通常情况下，验证码能够很好地遏制 CSRF 攻击。&lt;/p&gt;
&lt;p&gt;但验证码并不是万能的，因为出于用户考虑，不能给网站所有的操作都加上验证码。因此，验证码只能作为防御 CSRF 的一种辅助手段，而不能作为最主要的解决方案。&lt;/p&gt;
&lt;h3 id=&#34;2-referer-check&#34;&gt;2. Referer Check&lt;/h3&gt;
&lt;p&gt;根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的”源”。&lt;/p&gt;
&lt;p&gt;比如，如果用户要删除自己的帖子，那么先要登录 www.c.com，然后找到对应的页面，发起删除帖子的请求。此时，Referer 的值是 http://www.c.com；当请求是从 www.a.com 发起时，Referer 的值是 http://www.a.com 了。因此，要防御 CSRF 攻击，只需要对于每一个删帖请求验证其 Referer 值，如果是以 www.c.com 开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是 CSRF 攻击，可以拒绝该请求。&lt;/p&gt;
&lt;p&gt;Referer Check 不仅能防范 CSRF 攻击，另一个应用场景是 “防止图片盗链”。&lt;/p&gt;
&lt;h3 id=&#34;3-添加-token-验证token令牌&#34;&gt;3. 添加 token 验证(token==令牌)&lt;/h3&gt;
&lt;p&gt;CSRF 攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie 中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。&lt;/p&gt;
&lt;h1 id=&#34;11-websocket&#34;&gt;11. Websocket&lt;/h1&gt;
&lt;p&gt;webSocket是一项可以让服务器将数据主动推送给客户端的技术。&lt;/p&gt;
&lt;h2 id=&#34;1-websocket简介&#34;&gt;1. Websocket简介&lt;/h2&gt;
&lt;p&gt;它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1617946374224.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;其他特点包括：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立在 TCP 协议之上，服务器端的实现比较容易。&lt;/li&gt;
&lt;li&gt;与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。&lt;/li&gt;
&lt;li&gt;数据格式比较轻量，性能开销小，通信高效。&lt;/li&gt;
&lt;li&gt;可以发送文本，也可以发送二进制数据。&lt;/li&gt;
&lt;li&gt;没有同源限制，客户端可以与任意服务器通信。&lt;/li&gt;
&lt;li&gt;协议标识符是&lt;code&gt;ws&lt;/code&gt;（如果加密，则为&lt;code&gt;wss&lt;/code&gt;），服务器网址就是 URL。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;ws://example.com:80/some/path
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1617946965265.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;2-websocket客户端示例&#34;&gt;2. Websocket客户端示例&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var ws = new WebSocket(&amp;quot;wss://echo.websocket.org&amp;quot;);

ws.onopen = function(evt) { 
  console.log(&amp;quot;Connection open ...&amp;quot;); 
  ws.send(&amp;quot;Hello WebSockets!&amp;quot;);
};

ws.onmessage = function(evt) {
  console.log( &amp;quot;Received Message: &amp;quot; + evt.data);
  ws.close();
};

ws.onclose = function(evt) {
  console.log(&amp;quot;Connection closed.&amp;quot;);
};      
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-websocket应用场景&#34;&gt;3. websocket应用场景&lt;/h2&gt;
&lt;p&gt;1、社交订阅&lt;br&gt;
2、多玩家游戏&lt;br&gt;
3、协同编辑文档&lt;br&gt;
4、数据流状态&lt;br&gt;
5、多人聊天&lt;/p&gt;
&lt;h1 id=&#34;12-http请求中的keep-alive&#34;&gt;12. Http请求中的keep-alive&lt;/h1&gt;
&lt;h2 id=&#34;1-keep-alive模式&#34;&gt;1. Keep-Alive模式&lt;/h2&gt;
&lt;p&gt;我们都知道HTTP是基于TCP的，每一个HTTP请求都需要进行三步握手。如果一个页面对某一个域名有多个请求，就会进行频繁的建立连接和断开连接。所以HTTP 1.0中出现了&lt;code&gt;Connection: keep-alive&lt;/code&gt;，用于建立长连接，即我们所说的Keep-Alive模式。下图是普通模式和长连接模式的请求对比：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615457244881.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP/1.0中默认使用Connection: close。在HTTP/1.1中已经默认使用Connection: keep-alive。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过对比可以看出，Keep-Alive模式更加高效，因为避免了连接建立和释放的开销。但是，如果一个连接是不会断开的，那么多个请求之间如何进行区分呢？也就是说浏览器是如何知道当前请求已经完成了呢？为了解决这个问题，HTTP对header中又添加了一个Content-Length字段。&lt;/p&gt;
&lt;h2 id=&#34;2-content-length解决静态&#34;&gt;2. Content-Length(解决静态)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Content-Length&lt;/code&gt;表示实体内容的长度。浏览器通过这个字段来判断当前请求的数据是否已经全部接收。所以，当浏览器请求的是一个静态资源时，即服务器能明确知道返回内容的长度时，可以设置&lt;code&gt;Content-Length&lt;/code&gt;来控制请求的结束。但当服务器并不知道请求结果的长度时，如一个动态的页面或者数据，&lt;code&gt;Content-Length&lt;/code&gt;就无法解决上面的问题，这个时候就需要用到&lt;code&gt;Transfer-Encoding&lt;/code&gt;字段。&lt;/p&gt;
&lt;h2 id=&#34;3-transfer-encoding解决动态&#34;&gt;3. Transfer-Encoding(解决动态)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;是指传输编码，还有一个类似的字段叫做：&lt;code&gt;Content-Encoding&lt;/code&gt;。两者的区别是Content-Encoding用于对实体内容的&lt;code&gt;压缩编码&lt;/code&gt;，比如Content-Encoding: gzip；Transfer-Encoding则改变了&lt;code&gt;报文的格式&lt;/code&gt;，比如上面的问题中，当服务端无法知道实体内容的长度时，就可以通过指定&lt;code&gt;Transfer-Encoding: chunked&lt;/code&gt;来告知浏览器当前的编码是将数据分成一块一块传递的。当然, 还可以指定&lt;code&gt;Transfer-Encoding: gzip, chunked&lt;/code&gt;表明实体内容不仅是gzip压缩的，还是分块传递的。最后，当浏览器接收到一个长度为&lt;code&gt;0的chunked时&lt;/code&gt;， 知道当前请求内容已全部接收。&lt;/p&gt;
&lt;h1 id=&#34;13-网络分层&#34;&gt;13. 网络分层&lt;/h1&gt;
&lt;p&gt;有两套参考模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OSI参考模型（Open Systems Interconnection Reference Model，七层）：模型过于理想化，未能在因特网上进行广泛推广。&lt;/li&gt;
&lt;li&gt;TCP/IP参考模型(或TCP/IP协议，四层)：事实上的国际标准。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615458129735.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;网际层（internet layer）&lt;/strong&gt;&lt;br&gt;
在OSI模型中，网际层使用了一个更一般的名字，称为网络层（network layer）。网络层协议定义了数据位和字节如何组织为更大的分组，称为包，还定义了寻址机制，不同的计算机要按照这个寻址机制查找对方。网际协议（IP）是世界上使用最广发的网络层协议，也是Java唯一理解的网络层协议。实际上，这是两个协议：IPv4 和 IPv6。在 IPv4 和 IPv6 中，数据按包在网际层上传输，这些包称为数据报（datagram）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传输层&lt;/strong&gt;&lt;br&gt;
传输层（transport layer）负责确保各包已发送的顺序接收，并保证没有数据对视或破坏。如果丢包，传输层会请求发送方重换这个包。为实现这个目标，IP网络会给每个数据报添加一个附加首部，其中包含有更多信息。这一层上主要有两个协议。第一个是传输控制协议（Transmission Control Protocol，TCP）,这是一个开销很高的协议，支持对丢失或破坏的数据进行重换，并按照发送时的顺序进行传送。第二个协议是用户数据报协议（User Datagram Protocol，UDP），它允许接收方检测被破坏的包，但不保证这些包以正确的顺序传送（或者包有可能根本未传送）。但是 UDP 通常比TCP 快。TCP称为可靠的（reliable）协议；UDP 是不可靠的（unreliable）协议。后面我们将看到，不可靠的协议要比听起来有用得多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;&lt;br&gt;
向用户传送数据的层称为应用层（application layer）。它下面的三层定义了数据如何从一台计算机传输到另一台计算机。应用层确定了数据传输后的操作。例如，应用层协议如 HTTP（用于国际互联网）可以确保 Web 浏览器将图像显示为图片，而不是一长串数据。你的程序中的有关网络的部分大多都是在应用层花费时间。除了用户 Web 的 HTTP ，还有用于电子邮件的 SMTP ，POP ，IMAP；用于文件传输的 FTP、FSP 和 TFTP；用于文件访问的 NFS；用于文件共享的 Gnutella 和 BitTorrent；用于语音通信的会话启动协议（Session Initiation Protocol, SIP）和 Skype 等。此外，你的程序可以在必要时自定义自己的应用层协议。&lt;/p&gt;
&lt;h1 id=&#34;14-即时通信&#34;&gt;14. 即时通信&lt;/h1&gt;
&lt;h2 id=&#34;sse&#34;&gt;SSE&lt;/h2&gt;
&lt;p&gt;ajax和JSONP 都是 client-fetch的操作. 但是有时候, 我们更需要服务器主动给我们发信息. 比如，现在的APP应用，完全可以实现服务器发送, 然后Client再处理。而SSE就是帮助我们向webapp靠近&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SSE 全称就是 Server-Sent Events&lt;/strong&gt;，，中译为 &lt;code&gt;服务器推送&lt;/code&gt;&lt;br&gt;
他的技术并不是很难，和websocket不同，他依赖原生的HTTP，所以对于开发者来说更好理解。&lt;br&gt;
比如，在nodeJS， 只要我不执行res.end()，并且一定时间持续发送信息的话，那么该连接就会持续打开(keep-alive)&lt;br&gt;
其实通俗来说，就是一个长连接。 所以，以前我们通常使用ajax，iframe长轮询来代替他。但是这样有个缺点就是，可操控性弱， 错误率高。&lt;br&gt;
所以，正对于这点W3C, 觉得需要在客户端另外指定一个机制–能够保证服务器推送, 实现连接的keep-alive，操作简单… 在这样背景下SSE诞生了&lt;/p&gt;
&lt;h1 id=&#34;15-模块化commonjses6cmdamd&#34;&gt;15. 模块化，commonJS，es6，cmd，amd&lt;/h1&gt;
&lt;h2 id=&#34;1-es6-moudle&#34;&gt;1. ES6 Moudle&lt;/h2&gt;
&lt;p&gt;这个是目前前端小伙伴接触的最多的，是浏览器和服务端通用的模块化解决方案，主要命令为：export和import&lt;br&gt;
export用于导出本模块对外的接口，import用于导入某个模块的功能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;如果单独导出一个变量或方法则是往将要导出{}对象里面添加属性。&lt;br&gt;
2.如果导出的是{}，则和已生成的导出{}对象合并。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后说一下特例&lt;code&gt;export default&lt;/code&gt;，这个是在导出对象里面加一个&lt;code&gt;default&lt;/code&gt;属性，还有一点值得注意的是&lt;code&gt;export default&lt;/code&gt;后面不能跟变量表达式。&lt;/p&gt;
&lt;h2 id=&#34;2-commonjs&#34;&gt;2. CommonJS&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;CommonJS&lt;/code&gt;最主要的代表就是&lt;code&gt;Node.js&lt;/code&gt;，主要命令：&lt;code&gt;module、exports、require&lt;/code&gt;。其中有个令人疑惑的点是exports和module.exports，其实理解起来也很简单，就是在模块里面加了一句： &lt;code&gt;exports = module.exports = {};&lt;/code&gt; exports和module.exports指向同一个内存区域，只要在exports加了属性，则module.exports会跟着变化，但是最终导出对外的接口是以module.exports为准，所以不推荐直接使用exports。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;CommonJS&lt;/code&gt;规范来说，很重要的一点是&lt;code&gt;CommonJS&lt;/code&gt;输出的是一个值拷贝，并且是运行时加载。&lt;/p&gt;
&lt;h2 id=&#34;3-commonjs和es6-module的区别&#34;&gt;3. CommonJS和ES6 Module的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;引用方式：CommonJS模块输出是值的拷贝，ES6 Module模块输出的值是引用&lt;/li&gt;
&lt;li&gt;时机：CommonJS是运行时加载，ES6 Module是编译是输出&lt;/li&gt;
&lt;li&gt;前者支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案&lt;/li&gt;
&lt;li&gt;前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响&lt;/li&gt;
&lt;li&gt;前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化&lt;/li&gt;
&lt;li&gt;后者会编译成 require/exports 来执行的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-amd&#34;&gt;4. AMD&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;AMD&lt;/code&gt;规范是采用异步方式，依赖前置必须一开始就写好，所有的依赖加载完成后才会执行回调函数里的内容，模块的加载不影响它后面语句的运行。&lt;/p&gt;
&lt;p&gt;这里异步指的是不堵塞浏览器其他任务（dom构建，css渲染等），而加载内部是同步的（加载完模块后立即执行回调）。&lt;/p&gt;
&lt;p&gt;AMD也采用require命令加载模块，但是不同于CommonJS，它要求两个参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;require([module], callback);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cmd&#34;&gt;CMD&lt;/h2&gt;
&lt;p&gt;CMD推崇&lt;code&gt;依赖就近，延迟执行&lt;/code&gt;。可以把你的依赖写进代码的任意一行，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;define(factory)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;factory为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。factory 方法在执行时，默认会传入三个参数：require、exports 和 module.&lt;/p&gt;
">【面】前端知识点梳理（服务端与网络）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/mian-qian-duan-zhi-shi-dian-shu-li-liu-lan-qi/"" data-c="
          &lt;h1 id=&#34;1-输入url到展示页面过程发生了什么详细&#34;&gt;1. 输入url到展示页面过程发生了什么？（详细）&lt;/h1&gt;
&lt;h2 id=&#34;0-梳理主干流程&#34;&gt;0. 梳理主干流程&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;1、从浏览器接收url到开启网络请求线程（涉及到：浏览器机制，线程和进程之间的关系等）

2、开启网络线程到发出一个完整的http请求（涉及到：dns查询，tcp/ip请求，5层网络协议栈等）

3、从服务器接收到请求到对应后台接收到请求（涉及到：均衡负载，安全拦截，后台内部的处理等）

4、后台和前台的http交互（涉及到：http头，响应码，报文结构，cookie等，可以提下静态资源的cookie优化，以及编码解码如gzip压缩等）

5、缓存问题：http缓存（涉及到：涉及到http缓存头部，etag，expired，cache-control等）

6、浏览器接收到http数据包后的解析流程（涉及到：html的词法分析，然后解析成dom树，同时解析css生成css规则树，合并生成render树。然后layout布局、painting渲染、复合图层的合成、GPU绘制、外链接处理、loaded和documentloaded等）

7、css可视化格式模型（涉及到：元素渲染规则，如：包含块，控制框，BFC，IFC等概念）

8、js引擎解析过程（涉及到：js解释阶段，预处理阶段，执行阶段生成执行上下文，VO（全局对象），作用域链，回收机制等）

9、其他（扩展其他模块：跨域，web安全等）
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1-从浏览器接受url到开启网络请求线程&#34;&gt;1. 从浏览器接受URL到开启网络请求线程&lt;/h2&gt;
&lt;h3 id=&#34;1-解析url&#34;&gt;1. 解析URL&lt;/h3&gt;
&lt;p&gt;输入URL后，会进行解析（URL的意思就是统一资源定位符）&lt;br&gt;
URL一般包含以下几个部分&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616400775746.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-网络请求都是单独的线程&#34;&gt;2. 网络请求都是单独的线程&lt;/h3&gt;
&lt;p&gt;每次网络请求时，都需要开辟单独的线程去进行，比如URL解析到了http协议，就会新建一个网络线程去处理资源下载。&lt;/p&gt;
&lt;p&gt;因此浏览器会根据解析得出协议，开辟一个网络线程，前往请求资源。&lt;/p&gt;
&lt;h2 id=&#34;2-开启网络线程到发出一个完整的http请求&#34;&gt;2. 开启网络线程到发出一个完整的HTTP请求&lt;/h2&gt;
&lt;p&gt;这一部分主要包括：&lt;code&gt;dns&lt;/code&gt;查询，&lt;code&gt;tcp/ip&lt;/code&gt;请求构建，&lt;code&gt;五层因特网协议栈&lt;/code&gt;等等&lt;/p&gt;
&lt;h3 id=&#34;1-dns查询得到ip&#34;&gt;1. DNS查询得到IP&lt;/h3&gt;
&lt;p&gt;如果输入的域名，需要DNS解析成IP，流程如下：&lt;br&gt;
（1）浏览器有缓存，直接用浏览器缓存，没有就去本机缓存，没有就看是不是host。&lt;br&gt;
（2）如果还没有，就向DNS域名服务器查询（这个过程经过路由，路由也有缓存），查询到对应的IP。&lt;br&gt;
（3）本地DNS服务器将ip返回给浏览器，并将ip存入缓存，方便下次访问，加快访问速度&lt;/p&gt;
&lt;p&gt;注意：1、域名查询的时候有可能经过CDN调度器（如果CDN有存储功能）；&lt;br&gt;
2、DNS解析是很耗时的，因此如果解析域名过多，首屏加载会变慢，可以考虑使用dns-prefetch优化。&lt;/p&gt;
&lt;h3 id=&#34;2-tcpip请求构建&#34;&gt;2. tcp/ip请求构建&lt;/h3&gt;
&lt;p&gt;http的本质就是tcp/ip请求构建。需要3次握手规则简历连接，以及断开连接时候的4次挥手。&lt;/p&gt;
&lt;p&gt;tcp将http长报文划分为短报文，通过3次握手与服务端建立连接，进行可靠的传输。&lt;/p&gt;
&lt;p&gt;建立成功之后，接下来就是正式传输数据。&lt;/p&gt;
&lt;p&gt;然后，等到断开连接时，需要进行4次挥手（因为是全双工的，所以需要4次握手）。&lt;/p&gt;
&lt;h3 id=&#34;3-五层网络协议栈&#34;&gt;3. 五层网络协议栈&lt;/h3&gt;
&lt;p&gt;客户端发出http请求到服务器接收，中间会经过一系列的流程。&lt;/p&gt;
&lt;p&gt;客户端发送请求具体：&lt;strong&gt;从应用层发动http请求，到传输层通过三次握手简历tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后在物理层通过物理介质传输&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;服务端接收请求具体：反过来。&lt;/p&gt;
&lt;p&gt;五层因特网协议栈其实就是：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616402062824.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;其实也有一个完整的OSI七层框架，与之相比，多了&lt;strong&gt;会话层、表示层&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示层：主要处理两个通信系统中交互信息的表示方式，包括数据格式交换，数据加密和解密，数据压缩和终端类型转换等。&lt;/li&gt;
&lt;li&gt;会话层：具体管理不同用户和进程之间的对话，如控制登录和注销过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-从服务器接收到请求到对应后台接收到请求&#34;&gt;3. 从服务器接收到请求，到对应后台接收到请求&lt;/h2&gt;
&lt;p&gt;包括：负载均衡、后台处理、&lt;/p&gt;
&lt;h3 id=&#34;1-负载均衡&#34;&gt;1. 负载均衡&lt;/h3&gt;
&lt;p&gt;对于大型项目，并发访问很大，一台服务器吃不消，一般会有若干台服务器组成一个集群，然后配合反向代理实现均衡负载。均衡负载不止一种实现方式。&lt;/p&gt;
&lt;p&gt;概括的说：&lt;strong&gt;用户发送的请求指向调度服务器（反向代理服务器，比如nginx的均衡负载），然后调度服务器根据实际的调度算法，分配不同的请求给对应的集群中的服务器执行，然后调度服务器等待实际服务器的HTTP响应，并且反馈给用户&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;2-后台处理&#34;&gt;2. 后台处理&lt;/h3&gt;
&lt;p&gt;（1）一般有的后端有统一的验证，比如安全拦截，跨域验证；&lt;br&gt;
（2）如果不符合验证规则，就直接返回相应的http报文（拒绝请求等）；&lt;br&gt;
（3）如果验证通过了，才会进入到实际的后台代码，此时程序接收到请求，然后执行查询数据库，大量计算等等；&lt;br&gt;
（4）等程序执行完毕后，会返回一个http响应包（一般这一步会经过多层封装）；&lt;br&gt;
（5）然后将这个数据包从后端返回到前端，完成交互。&lt;/p&gt;
&lt;h2 id=&#34;4-后台和前台的http交互&#34;&gt;4. 后台和前台的http交互&lt;/h2&gt;
&lt;p&gt;前后端的交互，http报文作为信息的载体。&lt;/p&gt;
&lt;h3 id=&#34;1-http报文结构&#34;&gt;1. http报文结构&lt;/h3&gt;
&lt;p&gt;报文一般包括了：&lt;code&gt;通用头部&lt;/code&gt;，&lt;code&gt;请求/响应头部&lt;/code&gt;，&lt;code&gt;请求/相应体&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1. 通用头部&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616402828678.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;比如，在跨域拒绝的时候，可能的method是options，状态码是404/405等（可能的组合有很多）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2. 请求头/响应头&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常用的请求头部（部分）：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Accept: 接收类型，表示浏览器支持的MIME类型 （对标服务端返回的Content-Type）&lt;br&gt;
Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收&lt;br&gt;
Content-Type：客户端发送出去实体内容的类型&lt;br&gt;
Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache&lt;br&gt;
If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中&lt;br&gt;
Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间&lt;br&gt;
Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中&lt;br&gt;
If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中&lt;br&gt;
Cookie: 有cookie并且同域访问时会自动带上&lt;br&gt;
Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive&lt;br&gt;
Host：请求的服务器URL&lt;br&gt;
Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私&lt;br&gt;
Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)&lt;br&gt;
User-Agent：用户客户端的一些必要信息，如UA头部等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;常用的响应头部（部分）：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Access-Control-Allow-Headers: 服务器端允许的请求Headers&lt;br&gt;
Access-Control-Allow-Methods: 服务器端允许的请求方法&lt;br&gt;
Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）&lt;br&gt;
Content-Type：服务端返回的实体内容的类型&lt;br&gt;
Date：数据从服务器发送的时间&lt;br&gt;
Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档&lt;br&gt;
Last-Modified：请求资源的最后修改时间&lt;br&gt;
Expires：应该在什么时候认为文档已经过期,从而不再缓存它&lt;br&gt;
Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效&lt;br&gt;
ETag：请求变量的实体标签的当前值&lt;br&gt;
Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端&lt;br&gt;
Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）&lt;br&gt;
Server：服务器的一些相关信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;一般来说，请求头部和响应头部是匹配分析的&lt;/strong&gt;。&lt;br&gt;
比如：&lt;br&gt;
（1）请求头部的Accept要和响应头部的Content-Type匹配，否则会报错；&lt;br&gt;
（2）跨域请求中，请求头部的Origin要匹配响应头的Access-Control-Allow-Origin，否则会报跨域错误；&lt;br&gt;
（3）使用缓存，请求头部的if-modified-since，if-none-match分别和响应头的Last-modified，etag对应。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;3. 请求/响应实体&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;http请求时，除了头部，还有消息实体。&lt;br&gt;
请求实体中会将一些需要的参数都放入进入（用于post请求）。&lt;/p&gt;
&lt;p&gt;比如：（1）实体中可以放参数的序列化形式（a=1&amp;amp;b=2这种），或者直接放表单（Form Data对象，上传时可以夹杂其他以及文件）等等。&lt;/p&gt;
&lt;p&gt;响应实体中，就是服务端需要传给客户端的内容。&lt;/p&gt;
&lt;p&gt;一般现在的接口请求时，实体中就是对应信息的json格式，而像&lt;strong&gt;页面请求&lt;/strong&gt;这种，里面就是直接放一个html的字符串，然后浏览器自己解析并渲染。&lt;/p&gt;
&lt;p&gt;下图是对某请求的http报文结构的简要分析：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616403142489.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;5-解析页面流程&#34;&gt;5. 解析页面流程&lt;/h2&gt;
&lt;p&gt;前面提到是http交互，接下来是浏览器获取到html，然后解析，渲染。&lt;/p&gt;
&lt;h3 id=&#34;1-流程简述&#34;&gt;1. 流程简述&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;（1）解析html，构建DOM树；同时解析CSS，生成CSS规则树。&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616405665707.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;（2）合并DOM树和CSS规则树，生成Render树。&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616405717426.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;（3）布局Render树（layout/reflow）,负责各元素的尺寸，位置计算。&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616405786916.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;（4）绘制render树（paint），绘制页面像素信息。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（5）浏览器会将各层的信息发给GPU。GPU会将各层合成（composite），显示在屏幕上。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-资源外链的下载&#34;&gt;2. 资源外链的下载&lt;/h3&gt;
&lt;p&gt;上面介绍了HTML解析，渲染流程。但是实际上，在解析HTML时，会遇到一些资源连接，此时就需要进行单独处理&lt;/p&gt;
&lt;p&gt;简单起见，这里将遇到的静态资源分为以下几大类（未列举所有）：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616405978122.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;（1）遇到外链的处理&lt;/strong&gt;&lt;br&gt;
当遇到上述的外链时，会单&lt;strong&gt;独开启一个下载线程去下载资源&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;（2）遇到CSS样式资源&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616406119704.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;（3）遇到JS脚本资源&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616406134535.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注意，defer和async是有区别的：** defer是延迟执行，而async是异步执行**。&lt;br&gt;
&lt;strong&gt;（4）遇到img图片类的资源&lt;/strong&gt;&lt;br&gt;
遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方&lt;/p&gt;
&lt;h1 id=&#34;2-重绘与回流&#34;&gt;2. 重绘与回流&lt;/h1&gt;
&lt;h2 id=&#34;0-浏览器的渲染原理&#34;&gt;0. 浏览器的渲染原理&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616378131657.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1-重绘与回流&#34;&gt;1. 重绘与回流&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;重绘(repaint)&lt;/code&gt;:当页面元素样式改变不影响元素在文档流中的位置时（如background-color，border-color，visibility），浏览器只会将新样式赋予元素并进行重新绘制操作。此时由于只需要UI层面的重新像素绘制，因此 &lt;strong&gt;损耗较少&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;回流(reflow)&lt;/code&gt;: 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变时，网络浏览器重新渲染部分或全部文档的过程。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;会触发回流的操作:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;添加或者删除可见的DOM元素；&lt;/li&gt;
&lt;li&gt;元素位置改变；&lt;/li&gt;
&lt;li&gt;元素尺寸改变——边距、填充、边框、宽度和高度&lt;/li&gt;
&lt;li&gt;内容变化，比如用户在input框中输入文字，文本或者图片大小改变而引起的计算值宽度和高度改变&lt;/li&gt;
&lt;li&gt;页面渲染初始化&lt;/li&gt;
&lt;li&gt;浏览器窗口尺寸改变——resize事件发生时&lt;/li&gt;
&lt;li&gt;计算 offsetWidth 和 offsetHeight 属性&lt;/li&gt;
&lt;li&gt;设置 style 属性的值&lt;/li&gt;
&lt;li&gt;页面初次渲染&lt;/li&gt;
&lt;li&gt;元素字体大小变化&lt;/li&gt;
&lt;li&gt;激活 CSS 伪类（例如：:hover）&lt;/li&gt;
&lt;li&gt;clientWidth、clientHeight、clientTop、clientLeft&lt;/li&gt;
&lt;li&gt;offsetWidth、offsetHeight、offsetTop、offsetLeft&lt;/li&gt;
&lt;li&gt;scrollWidth、scrollHeight、scrollTop、scrollLeft&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-性能优化&#34;&gt;2. 性能优化&lt;/h2&gt;
&lt;p&gt;回流比重绘的代价要更高，回流的花销跟render tree有多少节点需要重新构建有关系;浏览器本身能够进行优化，尽可能减少重绘和回流。&lt;/p&gt;
&lt;p&gt;如果每行JS代码操作DOM都需要回流重绘的话，浏览器可能就会受不了。所以很多浏览器都会优化这些操作，浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。&lt;/p&gt;
&lt;h2 id=&#34;3-如何减少回流-重绘&#34;&gt;3. 如何减少回流、重绘&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var s = document.body.style; 
s.padding = &amp;quot;2px&amp;quot;; // 回流+重绘
s.border = &amp;quot;1px solid red&amp;quot;; // 再一次 回流+重绘
s.color = &amp;quot;blue&amp;quot;; // 再一次重绘
s.backgroundColor = &amp;quot;#ccc&amp;quot;; // 再一次 重绘
s.fontSize = &amp;quot;14px&amp;quot;; // 再一次 回流+重绘
// 添加node，再一次 回流+重绘
document.body.appendChild(document.createTextNode(&#39;abc!&#39;));
///可以看到每次DOM元素的样式操作都会引发重绘，如果涉及布局还会引发回流。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一. CSS中避免回流&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;尽可能在DOM树的最末端改变class&lt;/li&gt;
&lt;li&gt;避免设置多层内联样式&lt;/li&gt;
&lt;li&gt;动画效果应用到position属性为absolute或fixed的元素上&lt;/li&gt;
&lt;li&gt;牺牲平滑度换取速度&lt;/li&gt;
&lt;li&gt;避免使用table布局&lt;/li&gt;
&lt;li&gt;避免使用CSS的JavaScript表达式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;二. JS操作避免回流&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;避免逐项更改样式。最好一次性更改style属性，或者将样式列表定义为class并一次性更改class属性。&lt;/li&gt;
&lt;li&gt;避免循环操作DOM。创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document。&lt;/li&gt;
&lt;li&gt;也可以在一个display:none的元素上进行操作，最终把它显示出来。因为display:none上的DOM操作不会引发回流和重绘。&lt;/li&gt;
&lt;li&gt;避免循环读取offsetLeft等属性。在循环之前把它们存起来。&lt;/li&gt;
&lt;li&gt;绝对定位具有复杂动画的元素。绝对定位使它脱离文档刘，否则会引起父元素及后续元素大量的回流。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;3-防抖与节流&#34;&gt;3. 防抖与节流&lt;/h1&gt;
&lt;h2 id=&#34;1-防抖debounce&#34;&gt;1. 防抖(debounce)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;返回顶部。这个按钮只会在滚动到距离顶部一定位置之后才出现，那么我们现在抽象出这个功能需求-- 监听浏览器滚动事件，返回当前滚条与顶部的距离。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基于上述场景，首先提出第一种思路：&lt;strong&gt;在第一次触发事件时，不立即执行函数，而是给出一个期限值&lt;/strong&gt;比如200ms，然后：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果在200ms内没有再次触发滚动事件，那么就执行函数&lt;/li&gt;
&lt;li&gt;如果在200ms内再次触发滚动事件，那么当前的计时取消，重新开始计时&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;效果&lt;/strong&gt;：如果短时间内大量触发同一事件，只会执行一次函数。利用计时器setTimeout和clearTimeout，只要触发事件，就会销毁上一次的计时器，重新计时，计时结束后才会触发回掉函数的事件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;：既然前面都提到了计时，那实现的关键就在于&lt;code&gt;setTimeout&lt;/code&gt;这个函数，由于还需要一个变量来保存计时，考虑维护全局纯净，可以借助闭包来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function debounce(fn,delay){
    let timer = null //借助闭包
    return function() {
        if(timer){
            clearTimeout(timer) 
        }
        timer = setTimeout(fn,delay) // 简化写法
    }
}
// 然后是旧代码
function showTop  () {
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
　　console.log(&#39;滚动条位置：&#39; + scrollTop);
}
window.onscroll = debounce(showTop,1000) // 为了方便观察效果我们取个大点的间断值，实际使用根据需要来配置
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;对于短时间内连续触发的事件（上面的滚动事件），防抖的含义就是让某个时间期限（如上面的1000毫秒）内，事件处理函数只执行一次。&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-节流throttle&#34;&gt;2. 节流(throttle)&lt;/h2&gt;
&lt;p&gt;类似&lt;strong&gt;控制阀门一样定期开放的函数，也就是让函数执行一次后，在某个时间段内暂时失效，过了这段时间后再重新激活&lt;/strong&gt;（类似于技能冷却时间）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效果&lt;/strong&gt;：如果短时间内大量触发同一事件，&lt;strong&gt;那么在函数执行一次之后，该函数在指定的时间期限内不再工作&lt;/strong&gt;，直至过了这段时间才重新生效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt; 这里借助&lt;code&gt;setTimeout&lt;/code&gt;来做一个简单的实现，加上一个状态位&lt;code&gt;valid&lt;/code&gt;来表示当前函数是否处于工作状态：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function throttle(fn,delay){
    let valid = true
    return function() {
       if(!valid){
           //休息时间 暂不接客
           return false 
       }
       // 工作时间，执行函数并且在间隔期内把状态位设为无效
        valid = false
        setTimeout(() =&amp;gt; {
            fn()
            valid = true;
        }, delay)
    }
}
/* 请注意，节流函数并不止上面这种实现方案,
   例如可以完全不借助setTimeout，可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定。
   也可以直接将setTimeout的返回的标记当做判断条件-判断当前定时器是否存在，如果存在表示还在冷却，并且在执行fn之后消除定时器表示激活，原理都一样
    */
// 以下照旧
function showTop  () {
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
　　console.log(&#39;滚动条位置：&#39; + scrollTop);
}
window.onscroll = throttle(showTop,1000) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行以上代码的结果是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一直拖着滚动条进行滚动，那么会以1s的时间间隔，持续输出当前位置和顶部的距离&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以完全&lt;code&gt;不借助setTimeout&lt;/code&gt;，可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定。&lt;/p&gt;
&lt;h2 id=&#34;3-其他场景&#34;&gt;3. 其他场景&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;搜索框input事件，例如要支持输入实时搜索可以使用节流方案（间隔一段时间就必须查询相关内容），或者实现输入间隔大于某个值（如500ms），就当做用户输入完成，然后开始搜索，具体使用哪种方案要看业务需求。&lt;/li&gt;
&lt;li&gt;页面resize事件，常见于需要做页面适配的时候。需要根据最终呈现的页面情况进行dom渲染（这种情形一般是使用防抖，因为只需要判断最后一次的变化情况）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-接受传参&#34;&gt;4. 接受传参&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;防抖&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt; window.onload = function() {
      // 1、获取这个按钮，并绑定事件
      var myDebounce = document.getElementById(&amp;quot;debounce&amp;quot;);
      myDebounce.addEventListener(&amp;quot;click&amp;quot;, debounce(sayDebounce));
    }
 
    // 2、防抖功能函数，接受传参
    function debounce(fn) {
      // 4、创建一个标记用来存放定时器的返回值
      let timeout = null;
      return function() {
        // 5、每次当用户点击/输入的时候，把前一个定时器清除
        clearTimeout(timeout);
        // 6、然后创建一个新的 setTimeout，
        // 这样就能保证点击按钮后的 interval 间隔内
        // 如果用户还点击了的话，就不会执行 fn 函数
        timeout = setTimeout(() =&amp;gt; {
          fn.call(this, arguments);
        }, 1000);
      };
    }
 
    // 3、需要进行防抖的事件处理
    function sayDebounce() {
      // ... 有些需要防抖的工作，在这里执行
      console.log(&amp;quot;防抖成功！&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;节流&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;  window.onload = function() {
      // 1、获取按钮，绑定点击事件
      var myThrottle = document.getElementById(&amp;quot;throttle&amp;quot;);
      myThrottle.addEventListener(&amp;quot;click&amp;quot;, throttle(sayThrottle));
    }
 
    // 2、节流函数体
    function throttle(fn) {
      // 4、通过闭包保存一个标记
      let canRun = true;
      return function() {
        // 5、在函数开头判断标志是否为 true，不为 true 则中断函数
        if(!canRun) {
          return;
        }
        // 6、将 canRun 设置为 false，防止执行之前再被执行
        canRun = false;
        // 7、定时器
        setTimeout( () =&amp;gt; {
          fn.call(this, arguments);
          // 8、执行完事件（比如调用完接口）之后，重新将这个标志设置为 true
          canRun = true;
        }, 1000);
      };
    }
 
    // 3、需要节流的事件
    function sayThrottle() {
      console.log(&amp;quot;节流成功！&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-区别&#34;&gt;5. 区别&lt;/h2&gt;
&lt;p&gt;函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。&lt;/p&gt;
&lt;h1 id=&#34;4-前端持久化储存-cookies-session-sessionstorage-localstorage-token&#34;&gt;4. 前端持久化储存 cookies、session、sessionStorage、localStorage、token&lt;/h1&gt;
&lt;h2 id=&#34;1-cookie&#34;&gt;1. cookie&lt;/h2&gt;
&lt;p&gt;由于HTTP是一种&lt;strong&gt;无状态的协议&lt;/strong&gt;，服务器单从网络连接上是无法知道客户身份的。这时候服务器就需要给客户端颁发一个cookie，用来确认用户的身份。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1617867098815.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-cookie的构成&#34;&gt;1. cookie的构成&lt;/h3&gt;
&lt;p&gt;Cookie用于用户识别及状态管理，为Cookie提供服务的首部字段有：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1617868823315.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当服务器准备管理客户端状态的时候，会告知各种信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; path=/; domain=.hackr.jp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cookie 相关的首部字段有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;expires&lt;/strong&gt;&lt;br&gt;
指定浏览器可发送Cookie的有效期。当省略 expires 属性的时候，其有效期仅限于维持浏览器会话期间。&lt;br&gt;
另外，一旦 Cookie 从服务器发送至客户端，服务器就不存在可以显示删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;max-age&lt;br&gt;
与expires作用相同，用来告诉浏览器此cookie多久过期（单位是秒），而不是一个固定的时间点。正常情况下，max-age的&lt;code&gt;优先级高&lt;/code&gt;于expires。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;path&lt;br&gt;
默认为 /，就是根目录。&lt;strong&gt;子路径页面能够访问父路径页面的 Cookie&lt;/strong&gt;。兄弟路径页面之间的 Cookie 不能互相访问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;domain&lt;br&gt;
可以访问该 Cookie 的域名。&lt;br&gt;
而跨域访问，如域A为http://t1.test.com，域B为http://t2.test.com，那么在域A生产一个令域A和域B都能访问的cookie就要将该cookie的domain设置为.http://test.com；如果要在域A生产一个令域A不能访问而域B能访问的cookie就要将该cookie的domain设置为http://t2.test.com。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;secure&lt;br&gt;
Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。&lt;br&gt;
发送 Cookie 时，指定 secure 属性的方法如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;Set-Cookie:name=value; secure
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;HttpOnly&lt;br&gt;
Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，&lt;strong&gt;它使得 JavaScript 脚本无法获取 Cookie&lt;/strong&gt;。其主要目的是为了防止跨站脚本攻击（XSS，Cross-site scripting）对 Cookie 的信息窃取。&lt;br&gt;
指定发送 HttpOnly 属性的 Cookie 的方法如下所示：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;Set-Cookie:name=value; HttpOnly
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;cookie的不可跨域名性&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：修改、删除Cookie时，新建的Cookie除value、maxAge之外的所有属性，例如name、path、domain等，都要与原Cookie完全一样。否则，浏览器将视为两个不同的Cookie不予覆盖，导致修改、删除失败。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-session&#34;&gt;2. Session&lt;/h2&gt;
&lt;p&gt;Session是另一种记录客户状态的机制，不同的是Cookie保存在&lt;code&gt;客户端浏览器&lt;/code&gt;中，而Session保存在&lt;code&gt;服务器上&lt;/code&gt;。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。&lt;/p&gt;
&lt;p&gt;Session 之所以可以识别不同的用户，依靠的就是Cookie，所以说&lt;strong&gt;session是基于cookie的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该Cookie是服务器自动颁发给浏览器的，不用我们手工创建的。该Cookie的&lt;code&gt;maxAge值默认是-1&lt;/code&gt;，也就是说仅当前浏览器使用，不将该Cookie存在硬盘中，并且各浏览器窗口间不共享，关闭浏览器就会失效。&lt;/p&gt;
&lt;h3 id=&#34;1-工作步骤&#34;&gt;1. 工作步骤：&lt;/h3&gt;
&lt;p&gt;将客户端称为 client，服务端称为 server&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;产生 sessionID：session 是基于 cookie 的一种方案，所以，首先要产生 cookie。client 第一次访问 server，server 生成一个随机数，命名为 sessionID，并将其放在响应头里，以 cookie 的形式返回给 client，client 以处理其他 cookie 的方式处理这段 cookie。大概是这样：cookie：sessionID=135165432165&lt;/li&gt;
&lt;li&gt;保存 sessionID： server 将要保存的数据保存在相对应的 sessionID 之下，再将 sessionID 保存到服务器端的特定的保存 session 的内存中（如 一个叫 session 的哈希表）&lt;/li&gt;
&lt;li&gt;使用 session： client 再次访问 server，会带上首次访问时获得的 值为 sessionID 的cookie，server 读取 cookie 中的 sessionID，根据 sessionID 到保存 session 的内存寻找与 sessionID 匹配的数据，若寻找成功就将数据返回给 client。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;session有效期&#34;&gt;Session有效期&lt;/h3&gt;
&lt;p&gt;Session生成后，只要用户继续访问，&lt;code&gt;服务器就会更新Session的最后访问时间，并维护该Session&lt;/code&gt;。用户每访问服务器一次，无论是否读写Session，服务器都认为该用户的Session“活跃（active）”了一次。&lt;/p&gt;
&lt;p&gt;由于会有越来越多的用户访问服务器，因此Session也会越来越多。为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了。&lt;/p&gt;
&lt;h2 id=&#34;3-cookie与session的区别&#34;&gt;3. cookie与session的区别&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;使用方式&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;cookie机制：如果不在浏览器中设置过期事件，cookie被保存在内存中，生命周期随浏览器的关闭而结束，这种cookie简称为会话cookie。如果在浏览器中设置了cookie的过期事件，cookie会被保存在硬盘中，关闭浏览器后，cookie数据仍然存在，直到过期事件结束才消失。cookie是服务端发给客户端的特殊信息，cookie是以文本的方式保存在客户端，每次请求时都带上它&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;session机制：当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含sessionid。如果有sessionid，服务器将根据该id返回对应session对象。如果客户端请求中没有sessionid，服务器会创建新的session对象，并把sessionid在本次响应中返回给客户端。通常使用cookie方式存储sessionid到客户端，在交互中浏览器按照规则将sessionid发送给服务器。如果用户禁用cookie，则要使用URL重写，可以通过response.encodeURL(url)进行实现；API对encodeURL的结束为，当浏览器支持cookie时，url不做任何处理；当浏览器不支持cookie的时候，将会重写URL将sessionid拼接到访问地址后。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;保持状态&lt;br&gt;
cookie保存在浏览器端，session保存在服务器端&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储的大小&lt;br&gt;
单个cookie保存的数据不能超过4kb；session大小没有限制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储内容&lt;br&gt;
cookie只能保存字符串类型，以文本的方式。&lt;br&gt;
session通过类似与Hashtable的数据结构来保存，能支持任何类型的对象（session中可含有多个对象）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安全性&lt;br&gt;
session的安全性大于cookie。原因如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;① sessionid存储在cookie中，若要攻破session首先要攻破cookie；
② sessionid是要有人登录，或者启动session_start才会有，所以攻破cookie也不一定能得到sessionid；
③ 第二次启动session_start后，前一次的sessionid就是失效了，session过期后，sessionid也随之失效。
④ sessionid是加密的。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;应用场景&lt;br&gt;
cookie：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;（1）判断用户是否登录过网站，以便下次登录时能够实现自动登录（或者记住密码）。
（2）保存上次登录的事件等信息。
（3）保存上次查看的页面
（4）浏览计数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;session：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;（1）网上商城中的购物车
（2）保存用户登录信息
（3）将某些数据放入session中，供同一用户的不同页面使用
（4）防止用户非法登录
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果说&lt;strong&gt;Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-token&#34;&gt;4. Token&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1617867124106.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1-token定义&#34;&gt;1. Token定义&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;令牌&lt;/strong&gt;，是用户身份的验证方式。&lt;br&gt;
最简单的token组成：&lt;strong&gt;uid(用户唯一的身份标识)、time（当前时间的时间戳）、sign（签名）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对Token认证的五点认识&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个Token就是一些信息的集合；&lt;/li&gt;
&lt;li&gt;在Token中包含足够多的信息，以便在后续请求中减少查询数据库的几率；&lt;/li&gt;
&lt;li&gt;服务端需要对cookie和HTTP Authrorization Header进行Token信息的检查；&lt;/li&gt;
&lt;li&gt;基于上一点，你可以用一套token认证代码来面对浏览器类客户端和非浏览器类客户端；&lt;/li&gt;
&lt;li&gt;因为token是被签名的，所以我们可以认为一个可以解码认证通过的token是由我们系统发放的，其中带的信息是合法有效的；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-基于token的身份验证&#34;&gt;2. 基于Token的身份验证&lt;/h3&gt;
&lt;p&gt;基于token的验证是无状态的。服务器不记录哪些用户已登陆或者已经发布了哪些JWT。对服务器的每个请求都需要带上验证请求的token。该标记既可以加在header中，可以在POST请求的主体中发送，也可以作为查询参数发送。&lt;/p&gt;
&lt;p&gt;工作流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户输入登陆凭据；&lt;/li&gt;
&lt;li&gt;服务器验证凭据是否正确，然后返回一个经过签名的token；&lt;/li&gt;
&lt;li&gt;客户端负责存储token，可以存在local storage，或者cookie中；&lt;/li&gt;
&lt;li&gt;对服务器的请求带上这个token；&lt;/li&gt;
&lt;li&gt;服务器对JWT进行解码，如果token有效，则处理该请求；&lt;/li&gt;
&lt;li&gt;一旦用户登出，客户端销毁token。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-token的优势&#34;&gt;3. Token的优势&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;无状态&lt;/strong&gt;&lt;br&gt;
基于token的验证是无状态的，这也许是它相对cookie来说最大的优点。后端服务不需要记录token。每个令牌都是独立的，包括检查其有效性所需的所有数据，并通过声明传达用户信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;服务器唯一的工作就是在成功的登陆请求上签署token，并验证传入的token是否有效。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;防跨站请求伪造（CSRF）&lt;/strong&gt;&lt;br&gt;
举个CSRF攻击的例子，在网页中有这样的一个链接&lt;br&gt;
&lt;code&gt;![](http://bank.com?withdraw=1000&amp;amp;to=tom)&lt;/code&gt;，假设你已经通过银行的验证并且cookie中存在验证信息，同时银行网站没有CSRF保护。一旦用户点了这个图片，就很有可能从银行向tom这个人转1000块钱。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是如果银行网站使用了token作为验证手段，攻击者将无法通过上面的链接转走你的钱。（因为攻击者无法获取正确的token）&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;多站点使用&lt;/strong&gt;&lt;br&gt;
cookie绑定到单个域。foo.com域产生的cookie无法被bar.com域读取。使用token就没有这样的问题。这对于需要向多个服务获取授权的单页面应用程序尤其有用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;支持移动平台&lt;/strong&gt;&lt;br&gt;
好的API可以同时支持浏览器，iOS和Android等移动平台。然而，在移动平台上，cookie是不被支持的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-localstorage&#34;&gt;5. localStorage&lt;/h2&gt;
&lt;p&gt;localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。&lt;/p&gt;
&lt;p&gt;并且不会因为刷新而释放，所以，&lt;strong&gt;可以使用 localStorage 来实现变量的持久化存储&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;localStorage的特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;localStorage 与 HTTP 没有任何关系，所以在HTTP请求时不会带上 localStorage 的值&lt;/li&gt;
&lt;li&gt;只有相同域名的页面才能互相读取 localStorage，同源策略与 cookie 一致&lt;/li&gt;
&lt;li&gt;不同的浏览器，对每个域名 localStorage 的最大存储量的规定不一样，超出存储量会被拒绝。最大存5M 超过5M的数据就会丢失。而 Chrome 10MB 左右&lt;/li&gt;
&lt;li&gt;常用来记录一些不敏感的信息&lt;/li&gt;
&lt;li&gt;localStorage 理论上永久有效，除非用户清理缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6-sessionstorage&#34;&gt;6. sessionStorage&lt;/h2&gt;
&lt;p&gt;sessionStorage 的所有性质基本上与 localStorage 一致，唯一的不同区别在于：&lt;/p&gt;
&lt;p&gt;sessionStorage 的有效期是页面会话持续，如果页面&lt;code&gt;会话（session）结束&lt;/code&gt;（关闭窗口或标签页），sessionStorage 就会&lt;code&gt;消失&lt;/code&gt;。而 localStorage 则会一直存在。&lt;/p&gt;
&lt;h2 id=&#34;7-localstorage与sessionstorage的区别&#34;&gt;7. localStorage与sessionStorage的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;localStorage生命周期是永久的，除非被清除，否则永久保存，而sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;5-浏览器内核&#34;&gt;5. 浏览器内核&lt;/h1&gt;
&lt;p&gt;浏览器内核可以分为两部分：&lt;code&gt;渲染引擎&lt;/code&gt;（Layout Engine或Rendering Engine）和&lt;code&gt;JS引擎&lt;/code&gt;。由于JS引擎越来越独立，内核就倾向于只指渲染引擎。&lt;/p&gt;
&lt;h2 id=&#34;1-浏览器构成&#34;&gt;1. 浏览器构成&lt;/h2&gt;
&lt;p&gt;浏览器一般由七个模块组成，User Interface（用户界面）、Browser engine（浏览器引擎）、Rendering engine（渲染引擎）、Networking（网络）、JavaScript Interpreter（js解释器）、UI Backend（UI 后端）、Date Persistence（数据持久化存储）&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615442013118.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户界面 －包括地址栏、后退/前进按钮、书签目录等，也就是你-所看到的除了页面显示窗口之外的其他部分&lt;/li&gt;
&lt;li&gt;浏览器引擎 －可以在用户界面和渲染引擎之间传送指令或在客户端本地缓存中读写数据等，是浏览器中各个部分之间相互通信的核心&lt;/li&gt;
&lt;li&gt;渲染引擎 －解析DOM文档和CSS规则并将内容排版到浏览器中显示有样式的界面，也有人称之为排版引擎，我们常说的浏览器内核主要指的就是渲染引擎&lt;/li&gt;
&lt;li&gt;网络 －用来完成网络调用或资源下载的模块&lt;/li&gt;
&lt;li&gt;UI 后端 －用来绘制基本的浏览器窗口内控件，如输入框、按钮、单选按钮等，根据浏览器不同绘制的视觉效果也不同，但功能都是一样的。&lt;/li&gt;
&lt;li&gt;JS解释器 －用来解释执行JS脚本的模块，如 V8 引擎、JavaScriptCore&lt;/li&gt;
&lt;li&gt;数据存储 －浏览器在硬盘中保存 cookie、localStorage等各种数据，可通过浏览器引擎提供的API进行调用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-主流浏览器的内核&#34;&gt;2. 主流浏览器的内核&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;IE内核(Trident)&lt;/strong&gt;&lt;br&gt;
Trident内核代表产品Internet Explorer，又称其为IE内核。Trident（又称为MSHTML），是微软开发的一种排版引擎。国内很多的双核浏览器其中之一就是Trident，美名其曰“兼容模式”。&lt;br&gt;
代表：IE、傲游、世界之窗浏览器、Avant、猎豹安全浏览器、360极速浏览器、百度浏览器等。&lt;br&gt;
Window10发布后，IE将其内置浏览器命名为Edge（原名斯巴达），使用了新内核Edge引擎。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Firefox（Gecko）&lt;/strong&gt;&lt;br&gt;
Gecko内核代表作品Mozilla FirefoxGecko是一套开放源代码的、以C++编写的网页排版引擎。Gecko是最流行的排版引擎之一，仅次于Trident。使用它的最著名浏览器有Firefox、Netscape6至9。可惜这几年已经没落了，比如打开速度慢、升级频繁、猪一样的队友flash、神一样的对手Chrome。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Safari（Webkit）&lt;/strong&gt;&lt;br&gt;
苹果公司自己的内核，也是苹果的Safari浏览器使用的内核。&lt;br&gt;
WebKit内核代表作品Safari、Chromewebkit 是一个开源项目，包含了来自KDE项目和苹果公司的一些组件，主要用于Mac OS系统，它的特点在于源码结构清晰、渲染速度极快。缺点是对网页代码的兼容性不高，导致一些编写不标准的网页无法正常显示。主要代表作品有Safari和Google的浏览器Chrome。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Chrome（Blink）&lt;/strong&gt;&lt;br&gt;
有Google和Opera Software开发的浏览器排版引擎，2013年4月发布，现在Chrome内核是Blink。Blink其实是webkit的分支，大部分国产浏览器最新版都采用Blink内核。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Opera（Presto）&lt;/strong&gt;&lt;br&gt;
Presto内核代表作品OperaPresto是由Opera Software开发的浏览器排版引擎，供Opera 7.0及以上使用。它取代了旧版Opera 4至6版本使用的Elektra排版引擎，包括加入动态功能，例如网页或其部分可随着DOM及Script语法的事件而重新排版。在13年之后，Opera宣布加入谷歌阵营，弃用了Presto。&lt;/p&gt;
&lt;h1 id=&#34;6-跨域问题详解&#34;&gt;6. 跨域问题详解&lt;/h1&gt;
&lt;h2 id=&#34;1-同源策略&#34;&gt;1. 同源策略&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。&lt;br&gt;
可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同源策略，它是由Netscape提出的一个著名的安全策略。现在所有支持JavaScript 的浏览器都会使用这个策略。所谓同源是指，&lt;code&gt;域名，协议，端口相同&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当一个浏览器的两个tab页中分别打开来，百度和谷歌的页面，当浏览器的百度tab页执行一个脚本的时候会检查这个脚本是属于哪个页面的，即检查是否同源，只有和百度同源的脚本才会被执行。&lt;/p&gt;
&lt;p&gt;如果非同源，那么在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同源策略的限制：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;存储在浏览器中的数据，如localStroage、Cooke和IndexedDB不能通过脚本跨域访问&lt;/li&gt;
&lt;li&gt;不能通过脚本操作不同域下的DOM&lt;/li&gt;
&lt;li&gt;不能通过ajax请求不同域的数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-什么是浏览器跨域&#34;&gt;2. 什么是浏览器跨域&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;一个域的页面去请求另一个域的资源&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;A域的页面去请求B域的资源。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1617932910598.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-jsonp实现跨域&#34;&gt;3. JSONP实现跨域&lt;/h2&gt;
&lt;p&gt;在同源策略下，在某个服务器下的页面是无法获取到该服务器以外的数据的，但img、iframe、script等标签是个例外，这些标签可以通过src属性请求到其他服务器上的数据。利用script标签的开放策略，我们可以实现跨域请求数据，当然，也需要服务端的配合。当我们正常地请求一个JSON数据的时候，服务端返回的是一串JSON类型的数据，而我们使用JSONP模式来请求数据的时候，服务端返回的是一段可执行的JavaScript代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JSONP包含两部分：回调函数和数据。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回调函数是当响应到来时要放在当前页面被调用的函数。&lt;/li&gt;
&lt;li&gt;数据就是传入回调函数中的json数据，也就是回调函数的参数了。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;function handleResponse(response){
 console.log(&#39;The responsed data is: &#39;+response.data);
}
var script = document.createElement(&#39;script&#39;);
script.src = &#39;http://www.baidu.com/json/?callback=handleResponse&#39;;
document.body.insertBefore(script, document.body.firstChild);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;/*handleResonse({&amp;quot;data&amp;quot;: &amp;quot;zhe&amp;quot;})*/
//原理如下：
//当我们通过script标签请求时
//后台就会根据相应的参数(json,handleResponse)
//来生成相应的json数据(handleResponse({&amp;quot;data&amp;quot;: &amp;quot;zhe&amp;quot;}))
//最后这个返回的json数据(代码)就会被放在当前js文件中被执行
//至此跨域通信完成
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只能使用Get请求&lt;/li&gt;
&lt;li&gt;不能注册success、error等事件监听函数，不能很容易的确定JSONP请求是否失败&lt;/li&gt;
&lt;li&gt;JSONP是从其他域中加载代码执行，容易受到跨站请求伪造的攻击，其安全性无法确保&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-使用windowname来进行跨域&#34;&gt;4. 使用window.name来进行跨域&lt;/h2&gt;
&lt;p&gt;window.name通过在iframe（一般动态创建i）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window.name。然后，请求者可以检索window.name值作为响应。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iframe标签的跨域能力；&lt;/li&gt;
&lt;li&gt;window.name属性值在文档刷新后依旧存在的能力（且最大允许2M左右）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://www.a.com/a.html和http://www.b.com/b.html
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;a.html&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
  var iframe = document.createElement(&#39;iframe&#39;);
  iframe.style.display = &#39;none&#39;; // 隐藏
 
  var state = 0; // 防止页面无限刷新
  iframe.onload = function() {
      if(state === 1) {
          console.log(JSON.parse(iframe.contentWindow.name));
          // 清除创建的iframe
          iframe.contentWindow.document.write(&#39;&#39;);
          iframe.contentWindow.close();
          document.body.removeChild(iframe);
      } else if(state === 0) {
          state = 1;
          // 加载完成，指向当前域，防止错误(proxy.html为空白页面)
          // Blocked a frame with origin &amp;quot;http://www.a.com/a.html&amp;quot; from accessing a cross-origin frame.
          iframe.contentWindow.location = &#39;http://www.a.com/a.html&#39;;
      }
  };
 
  iframe.src = &#39;http://www.b.com/b.html&#39;;
  document.body.appendChild(iframe);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;在b.com/b.html中包含：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
     window.name = &#39;要传送的内容&#39;;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-cors&#34;&gt;5. CORS&lt;/h2&gt;
&lt;p&gt;CORS是一个W3C标准，全称是&amp;quot;跨域资源共享&amp;quot;（Cross-origin resource sharing），以避开浏览器的同源策略，确保安全的跨域数据传输。现代浏览器使用CORS在API容器如XMLHttpRequest来减少HTTP请求的风险来源。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。&lt;/p&gt;
&lt;h3 id=&#34;1-服务器设置&#34;&gt;1. 服务器设置&lt;/h3&gt;
&lt;p&gt;服务器一般需要增加如下响应头的一种或几种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
Access-Control-Max-Age: 86400
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;跨域请求默认不会携带Cookie信息，如果需要携带，请配置下述参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;Access-Control-Allow-Credentials&amp;quot;: true
// Ajax设置打开
&amp;quot;withCredentials&amp;quot;: true
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-两种请求&#34;&gt;2. 两种请求&lt;/h3&gt;
&lt;p&gt;浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。&lt;br&gt;
&lt;strong&gt;只要同时满足以下两大条件，就属于简单请求。&lt;/strong&gt;&lt;br&gt;
（1) 请求方法是以下三种方法之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HEAD&lt;/li&gt;
&lt;li&gt;GET&lt;/li&gt;
&lt;li&gt;POST&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（2）HTTP的头信息不超出以下几种字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Accept&lt;/li&gt;
&lt;li&gt;Accept-Language&lt;/li&gt;
&lt;li&gt;Content-Language&lt;/li&gt;
&lt;li&gt;Last-Event-ID&lt;/li&gt;
&lt;li&gt;Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-简单请求&#34;&gt;3. 简单请求&lt;/h3&gt;
&lt;p&gt;对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，&lt;code&gt;增加一个Origin字段&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的头信息中，&lt;code&gt;Origin字段&lt;/code&gt;用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;Origin&lt;/code&gt;指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;字段（详见下文），就知道出错了，从而抛出一个错误，被&lt;code&gt;XMLHttpRequest&lt;/code&gt;的&lt;code&gt;onerror&lt;/code&gt;回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;Origin&lt;/code&gt;指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
Content-Type: text/html; charset=utf-8
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-非简单请求&#34;&gt;4. 非简单请求&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;预检请求&lt;/strong&gt;&lt;br&gt;
非简单请求是那种对服务器有特殊要求的请求，比如请求方法是&lt;code&gt;PUT&lt;/code&gt;或&lt;code&gt;DELETE&lt;/code&gt;，或者&lt;code&gt;Content-Type字段的类型是application/json&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&amp;quot;预检&amp;quot;请求（preflight）。&lt;/p&gt;
&lt;p&gt;浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的&lt;code&gt;XMLHttpRequest&lt;/code&gt;请求，否则就报错。&lt;/p&gt;
&lt;p&gt;下面是一段浏览器的JavaScript脚本。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var url = &#39;http://api.alice.com/cors&#39;;
var xhr = new XMLHttpRequest();
xhr.open(&#39;PUT&#39;, url, true);
xhr.setRequestHeader(&#39;X-Custom-Header&#39;, &#39;value&#39;);
xhr.send();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，HTTP请求的方法是&lt;code&gt;PUT&lt;/code&gt;，并且发送一个自定义头信息&lt;code&gt;X-Custom-Header&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;浏览器发现，这是一个非简单请求，就自动发出一个&amp;quot;预检&amp;quot;请求，要求服务器确认可以这样请求。下面是这个&amp;quot;预检&amp;quot;请求的HTTP头信息。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;quot;预检&amp;quot;请求用的请求方法是&lt;code&gt;OPTIONS&lt;/code&gt;，表示这个请求是用来询问的。头信息里面，关键字段是&lt;code&gt;Origin&lt;/code&gt;，表示请求来自哪个源。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;预检请求的回应&lt;/strong&gt;&lt;br&gt;
服务器收到&amp;quot;预检&amp;quot;请求以后，检查了&lt;code&gt;Origin&lt;/code&gt;、&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;和&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;字段以后，确认允许跨源请求，就可以做出回应。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的HTTP回应中，关键的是&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;字段，表示&lt;code&gt;http://api.bob.com&lt;/code&gt;可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。&lt;/p&gt;
&lt;p&gt;如果服务器否定了&amp;quot;预检&amp;quot;请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被&lt;code&gt;XMLHttpRequest&lt;/code&gt;对象的&lt;code&gt;onerror&lt;/code&gt;回调函数捕获。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;浏览器的正常请求和回应&lt;/strong&gt;&lt;br&gt;
一旦服务器通过了&amp;quot;预检&amp;quot;请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个&lt;code&gt;Origin&lt;/code&gt;头信息字段。服务器的回应，也都会有一个&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;头信息字段。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是&amp;quot;预检&amp;quot;请求之后，浏览器的正常CORS请求。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PUT /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
X-Custom-Header: value
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面是服务器正常的回应。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Access-Control-Allow-Origin: http://api.bob.com
Content-Type: text/html; charset=utf-8
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-反向代理&#34;&gt;3. 反向代理&lt;/h3&gt;
&lt;p&gt;想一下，如果我们请求的时候还是用前端的域名，然后有个东西帮我们把这个请求转发到真正的后端域名上，不就避免跨域了吗？这时候，Nginx出场了。&lt;/p&gt;
&lt;p&gt;Nginx配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server{
    # 监听9099端口
    listen 9099;
    # 域名是localhost
    server_name localhost;
    #凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:9871 
    location ^~ /api {
        proxy_pass http://localhost:9871;
    }    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前端就不用干什么事情了，除了写接口，也没后端什么事情了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 请求的时候直接用回前端这边的域名http://localhost:9099，这就不会跨域，然后Nginx监听到凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:9871 
fetch(&#39;http://localhost:9099/api/iframePost&#39;, {
  method: &#39;POST&#39;,
  headers: {
    &#39;Accept&#39;: &#39;application/json&#39;,
    &#39;Content-Type&#39;: &#39;application/json&#39;
  },
  body: JSON.stringify({
    msg: &#39;helloIframePost&#39;
  })
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-同源策略限制下dom查询的正确打开方式&#34;&gt;2. 同源策略限制下Dom查询的正确打开方式&lt;/h2&gt;
&lt;h3 id=&#34;1postmessage&#34;&gt;1.postMessage&lt;/h3&gt;
&lt;p&gt;window.postMessage() 是HTML5的一个接口，专注实现不同窗口不同页面的跨域通讯。&lt;/p&gt;
&lt;h3 id=&#34;2documentdomain&#34;&gt;2.document.domain&lt;/h3&gt;
&lt;p&gt;这种方式只适合主域名相同，但子域名不同的iframe跨域。&lt;br&gt;
比如主域名是http://crossdomain.com:9099，子域名是http://child.crossdomain.com:9099，这种情况下给两个页面指定一下document.domain即document.domain = crossdomain.com就可以访问各自的window对象了。&lt;/p&gt;
&lt;h3 id=&#34;3canvas操作图片的跨域问题&#34;&gt;3.canvas操作图片的跨域问题&lt;/h3&gt;
&lt;p&gt;这个应该是一个比较冷门的跨域问题&lt;/p&gt;
&lt;h1 id=&#34;7-从浏览器多进程到js单线程&#34;&gt;7. 从浏览器多进程到JS单线程&lt;/h1&gt;
&lt;h2 id=&#34;1-区分进程和线程&#34;&gt;1. 区分进程和线程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;进程是cpu资源分配的最小单位（系统会给它分配内存）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后，再用较为官方的术语描述一遍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）&lt;/li&gt;
&lt;li&gt;线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-浏览器是多进程的&#34;&gt;2. 浏览器是多进程的&lt;/h2&gt;
&lt;p&gt;先看下简化理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器是多进程的&lt;/li&gt;
&lt;li&gt;浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）&lt;/li&gt;
&lt;li&gt;简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于以上几点的验证，&lt;strong&gt;请再第一张图&lt;/strong&gt;：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616224931683.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
图中打开了&lt;code&gt;Chrome&lt;/code&gt;浏览器的多个标签页，然后可以在&lt;code&gt;Chrome&lt;/code&gt;的任务管理器中看到有多个进程（分别是每一个&lt;code&gt;Tab&lt;/code&gt;页面有一个独立的进程，以及一个主进程）。&lt;br&gt;
感兴趣的可以自行尝试下，如果再多打开一个Tab页，进程正常会+1以上&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了&lt;br&gt;
（所以每一个Tab标签对应一个进程并不一定是绝对的）&lt;/p&gt;
&lt;h3 id=&#34;1-浏览器都包含哪些进程&#34;&gt;1. 浏览器都包含哪些进程？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有&lt;br&gt;
负责浏览器界面显示，与用户交互。如前进，后退等&lt;br&gt;
负责各个页面的管理，创建和销毁其他进程&lt;br&gt;
将Renderer进程得到的内存中的Bitmap，绘制到用户界面上&lt;br&gt;
网络资源的管理，下载等&lt;/li&gt;
&lt;li&gt;第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建&lt;/li&gt;
&lt;li&gt;GPU进程：最多一个，用于3D绘制等&lt;/li&gt;
&lt;li&gt;浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为 &lt;strong&gt;页面渲染，脚本执行，事件处理&lt;/strong&gt;等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;强化记忆：&lt;code&gt;在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-浏览器多进程的优势&#34;&gt;2. 浏览器多进程的优势&lt;/h3&gt;
&lt;p&gt;相比于单进程浏览器，多进程有如下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免单个page crash影响整个浏览器&lt;/li&gt;
&lt;li&gt;避免第三方插件crash影响整个浏览器&lt;/li&gt;
&lt;li&gt;多进程充分利用多核优势&lt;/li&gt;
&lt;li&gt;方便使用沙盒模型隔离插件等进程，提高浏览器稳定性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单点理解：&lt;code&gt;如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-重点是浏览器内核渲染进程&#34;&gt;3. 重点是浏览器内核（渲染进程）&lt;/h3&gt;
&lt;p&gt;可以这样理解，页面的渲染，JS的执行，事件的循环，都在这个进程内进行。接下来重点分析这个进程&lt;br&gt;
请牢记，浏览器的渲染进程是&lt;strong&gt;多线程&lt;/strong&gt;的（这点如果不理解，请回头看进程和线程的区分）&lt;/p&gt;
&lt;p&gt;那么接下来看看它都包含了哪些线程（列举一些主要常驻线程）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;GUI渲染线程&lt;br&gt;
- 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。&lt;br&gt;
- 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行&lt;br&gt;
- 注意，&lt;strong&gt;GUI渲染线程与JS引擎线程是互斥的&lt;/strong&gt;，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中&lt;strong&gt;等到JS引擎空闲时&lt;/strong&gt;立即被执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JS引擎线程&lt;br&gt;
- 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）&lt;br&gt;
- JS引擎线程负责解析Javascript脚本，运行代码。&lt;br&gt;
- JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序&lt;br&gt;
- 同样注意，&lt;strong&gt;GUI渲染线程与JS引擎线程是互斥的&lt;/strong&gt;，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事件触发线程&lt;br&gt;
- 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）&lt;br&gt;
- 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程，如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中&lt;br&gt;
- 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理&lt;br&gt;
- 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定时触发器线程&lt;br&gt;
- 传说中的&lt;code&gt;setInterva&lt;/code&gt;l与&lt;code&gt;setTimeout&lt;/code&gt;所在线程&lt;br&gt;
- 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）&lt;br&gt;
- 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）&lt;br&gt;
- 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步http请求线程&lt;br&gt;
- 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求&lt;br&gt;
- 将检测到状态变更时，如果设置有回调函数，异步线程就&lt;strong&gt;产生状态变更事件&lt;/strong&gt;，将这个回调再放入事件队列中。再由JavaScript引擎执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;后续将提到的事件循环机制就是基于&lt;code&gt;事件触发线程&lt;/code&gt;的，所以如果仅仅是看某个碎片化知识，&lt;br&gt;
可能会有一种似懂非懂的感觉。要完成的梳理一遍才能快速沉淀，不易遗忘。放张图巩固下吧：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616225471604.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-browser进程和浏览器内核renderer进程的通信过程&#34;&gt;4. Browser进程和浏览器内核（Renderer进程）的通信过程&lt;/h3&gt;
&lt;p&gt;那么接下来，再谈谈浏览器的Browser进程（控制进程）是如何和内核通信的，这点也理解后，就可以将这部分的知识串联起来，从头到尾有一个完整的概念。&lt;/p&gt;
&lt;p&gt;如果自己打开任务管理器，然后打开一个浏览器，就可以看到：&lt;strong&gt;任务管理器中出现了两个进程&lt;/strong&gt;（一个是主控进程，一个则是打开Tab页的渲染进程），&lt;br&gt;
然后在这前提下，看下整个的过程：(简化了很多)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程&lt;/li&gt;
&lt;li&gt;Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染
&lt;ul&gt;
&lt;li&gt;渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染&lt;/li&gt;
&lt;li&gt;当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）&lt;/li&gt;
&lt;li&gt;最后Render进程将结果传递给Browser进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Browser进程接收到结果并将结果绘制出来&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里绘一张简单的图：（很简化）&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616226222410.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;看完这一整套流程，应该对浏览器的运作有了一定理解了，这样有了知识架构的基础后，后续就方便往上填充内容。&lt;br&gt;
这块再往深处讲的话就涉及到浏览器内核源码解析了，不属于本文范围。&lt;br&gt;
如果这一块要深挖，建议去读一些浏览器内核源码解析文章，或者可以先看看参考下来源中的第一篇文章，写的不错&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3-梳理浏览器内核中线程之间的关系&#34;&gt;3. 梳理浏览器内核中线程之间的关系&lt;/h2&gt;
&lt;h3 id=&#34;1-gui渲染线程与js引擎线程互斥&#34;&gt;1. GUI渲染线程与JS引擎线程互斥&lt;/h3&gt;
&lt;p&gt;由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。&lt;/p&gt;
&lt;p&gt;因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。&lt;/p&gt;
&lt;h3 id=&#34;2-js阻塞页面加载&#34;&gt;2. JS阻塞页面加载&lt;/h3&gt;
&lt;p&gt;从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。&lt;/p&gt;
&lt;p&gt;譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。&lt;br&gt;
然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。&lt;/p&gt;
&lt;p&gt;所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。&lt;/p&gt;
&lt;h3 id=&#34;3-webworkerjs的多线程&#34;&gt;3. WebWorker，JS的多线程？&lt;/h3&gt;
&lt;p&gt;前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？&lt;br&gt;
所以，后来HTML5中支持了&lt;code&gt;Web Worker&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面&lt;br&gt;
一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件&lt;br&gt;
这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window&lt;br&gt;
因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样理解下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）&lt;/li&gt;
&lt;li&gt;JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，只待计算出结果后，将结果通信给主线程即可，perfect!&lt;/p&gt;
&lt;p&gt;而且注意下，&lt;strong&gt;JS引擎是单线程的&lt;/strong&gt;，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。&lt;/p&gt;
&lt;h3 id=&#34;4-webworker与sharedworker&#34;&gt;4. WebWorker与SharedWorker&lt;/h3&gt;
&lt;p&gt;既然都到了这里，就再提一下&lt;code&gt;SharedWorker&lt;/code&gt;（避免后续将这两个概念搞混）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享
&lt;ul&gt;
&lt;li&gt;所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用
&lt;ul&gt;
&lt;li&gt;所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看到这里，应该就很容易明白了，本质上就是进程和线程的区别。&lt;strong&gt;SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-简单梳理下浏览器渲染流程&#34;&gt;4. 简单梳理下浏览器渲染流程&lt;/h2&gt;
&lt;p&gt;为了简化理解，前期工作直接省略成：（要展开的或完全可以写另一篇超长文）&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;浏览器输入url，浏览器主进程接管，开一个下载线程，&lt;br&gt;
然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，&lt;br&gt;
随后将内容通过RendererHost接口转交给Renderer进程&lt;br&gt;
浏览器渲染流程开始&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;解析html建立dom树&lt;/li&gt;
&lt;li&gt;解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）&lt;/li&gt;
&lt;li&gt;布局render树（Layout/reflow），负责各元素尺寸、位置的计算&lt;/li&gt;
&lt;li&gt;绘制render树（paint），绘制页面像素信息&lt;/li&gt;
&lt;li&gt;浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所有详细步骤都已经略去，渲染完毕后就是&lt;code&gt;load&lt;/code&gt;事件了，之后就是自己的JS逻辑处理了&lt;/p&gt;
&lt;p&gt;既然略去了一些详细的步骤，那么就提一些可能需要注意的细节把。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616246903018.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-css加载是否会阻塞dom树渲染&#34;&gt;1. css加载是否会阻塞dom树渲染？&lt;/h3&gt;
&lt;p&gt;这里说的是头部引入css的情况&lt;/p&gt;
&lt;p&gt;首先，我们都知道：&lt;strong&gt;css是由单独的下载线程异步下载的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;然后再说下几个现象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;css加载不会阻塞DOM树解析（异步加载时DOM照常构建）&lt;/li&gt;
&lt;li&gt;但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这可能也是浏览器的一种优化机制。&lt;/p&gt;
&lt;h2 id=&#34;5-从event-loop谈js的运行机制&#34;&gt;5. 从Event Loop谈JS的运行机制&lt;/h2&gt;
&lt;p&gt;这里会用到上文中的几个概念：（如果不是很理解，可以回头温习）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JS引擎线程&lt;/li&gt;
&lt;li&gt;事件触发线程&lt;/li&gt;
&lt;li&gt;定时触发器线程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后再理解一个概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JS分为同步任务和异步任务&lt;/li&gt;
&lt;li&gt;同步任务都在主线程上执行，形成一个&lt;code&gt;执行栈&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;主线程之外，&lt;strong&gt;事件触发线程&lt;/strong&gt;管理着一个&lt;code&gt;任务队列&lt;/code&gt;，只要异步任务有了运行结果，就在&lt;code&gt;任务队列&lt;/code&gt;之中放置一个事件。&lt;/li&gt;
&lt;li&gt;一旦&lt;code&gt;执行栈&lt;/code&gt;中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取&lt;code&gt;任务队列&lt;/code&gt;，将可运行的异步任务添加到可执行栈中，开始执行。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616247319925.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
看到这里，应该就可以理解了：为什么有时候setTimeout推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其它代码，所以自然有误差。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-事件循环机制进一步补充&#34;&gt;1. 事件循环机制进一步补充&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616247383302.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
上图大致描述就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主线程运行时会产生执行栈，&lt;br&gt;
栈中的代码调用某些api时，它们会在事件队列中添加各种事件（当满足触发条件后，如ajax请求完毕）&lt;/li&gt;
&lt;li&gt;而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调&lt;/li&gt;
&lt;li&gt;如此循环&lt;/li&gt;
&lt;li&gt;注意，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-单独说说定时器&#34;&gt;2. 单独说说定时器&lt;/h3&gt;
&lt;p&gt;上述事件循环机制的核心是：&lt;strong&gt;JS引擎线程和事件触发线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它是由&lt;strong&gt;定时器线程&lt;/strong&gt;控制（因为JS引擎自己都忙不过来，根本无暇分身）&lt;/p&gt;
&lt;p&gt;因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。&lt;/p&gt;
&lt;p&gt;当使用&lt;code&gt;setTimeout&lt;/code&gt;或&lt;code&gt;setInterval&lt;/code&gt;时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。&lt;br&gt;
譬如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setTimeout(function(){
    console.log(&#39;hello!&#39;);
}, 1000);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码的作用是当1000毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setTimeout(function(){
    console.log(&#39;hello!&#39;);
}, 0);

console.log(&#39;begin&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码的效果是最快的时间内将回调函数推入事件队列中，等待主线程执行&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行结果是：先begin后hello!&lt;/li&gt;
&lt;li&gt;虽然代码的本意是0毫秒后就推入事件队列，但是W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。&lt;br&gt;
(不过也有一说是不同浏览器有不同的最小时间设定)&lt;/li&gt;
&lt;li&gt;就算不等待4ms，就算假设0毫秒就推入事件队列，也会先执行begin（因为只有可执行栈内空了后才会主动读取事件队列）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-settimeout而不是setinterval&#34;&gt;3. setTimeout而不是setInterval&lt;/h3&gt;
&lt;p&gt;用setTimeout模拟定期计时和直接用setInterval是有区别的。&lt;/p&gt;
&lt;p&gt;因为每次&lt;code&gt;setTimeout&lt;/code&gt;计时到后就会去执行，然后执行一段时间后才会继续setTimeout，中间就多了误差（误差多少与代码执行时间有关）&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;setInterval&lt;/code&gt;则是每次都精确的隔一段时间推入一个事件（但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）&lt;/p&gt;
&lt;p&gt;而且setInterval有一些比较致命的问题就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;累计效应（上面提到的），如果setInterval代码在（setInterval）再次添加到队列之前还没有完成执行，就会导致定时器代码连续运行好几次，而之间没有间隔。就算正常间隔执行，多个setInterval的代码执行时间可能会比预期小（因为代码执行需要一定时间）&lt;/li&gt;
&lt;li&gt;而且把浏览器最小化显示等操作时，setInterval并不是不执行程序，它会把setInterval的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行时&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，鉴于这么多但问题，目前一般认为的最佳方案是：&lt;strong&gt;用setTimeout模拟setInterval，或者特殊场合直接用requestAnimationFrame&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补充：JS高程中有提到，JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加。不过，仍然是有很多问题。。。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;6-事件循环进阶macrotask与microtask&#34;&gt;6. 事件循环进阶：macrotask与microtask&lt;/h2&gt;
&lt;p&gt;上文中将JS事件循环机制梳理了一遍，在ES5的情况是够用了，但是在ES6盛行的现在，仍然会遇到一些问题，譬如下面这题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(&#39;script start&#39;);

setTimeout(function() {
    console.log(&#39;setTimeout&#39;);
}, 0);

Promise.resolve().then(function() {
    console.log(&#39;promise1&#39;);
}).then(function() {
    console.log(&#39;promise2&#39;);
});

console.log(&#39;script end&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;嗯哼，它的正确执行顺序是这样子的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;script start
script end
promise1
promise2
setTimeout
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为什么呢？因为Promise里有了一个一个新的概念：&lt;code&gt;microtask&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或者，进一步，JS中分为两种任务类型：&lt;code&gt;macrotask&lt;/code&gt;和&lt;code&gt;microtask&lt;/code&gt;，在ECMAScript中，microtask称为&lt;code&gt;jobs&lt;/code&gt;，macrotask可称为&lt;code&gt;task&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;它们的定义？区别？简单点可以按如下理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）
&lt;ul&gt;
&lt;li&gt;每一个task会从头到尾将这个任务执行完毕，不会执行其它&lt;/li&gt;
&lt;li&gt;浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;（`task-&amp;gt;渲染-&amp;gt;task-&amp;gt;...`）
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务
&lt;ul&gt;
&lt;li&gt;也就是说，在当前task任务后，下一个task之前，在&lt;code&gt;渲染之前&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;所以它的响应速度相比setTimeout（&lt;code&gt;setTimeout是task&lt;/code&gt;）会更快，因为无需等渲染&lt;/li&gt;
&lt;li&gt;也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分别很么样的场景会形成macrotask和microtask呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;macrotask：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask）&lt;/li&gt;
&lt;li&gt;microtask：Promise，process.nextTick等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再根据线程来理解下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;macrotask中的事件都是放在一个事件队列中的，而这个队列由&lt;strong&gt;事件触发线程&lt;/strong&gt;维护&lt;/li&gt;
&lt;li&gt;microtask中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前macrotask执行完毕后执行，而这个队列由&lt;strong&gt;JS引擎线程&lt;/strong&gt;维护&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，总结下运行机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行一个宏任务（栈中没有就从事件队列中获取）&lt;/li&gt;
&lt;li&gt;执行过程中如果遇到微任务，就将它添加到微任务的任务队列中&lt;/li&gt;
&lt;li&gt;宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）&lt;/li&gt;
&lt;li&gt;当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染&lt;/li&gt;
&lt;li&gt;渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616250099288.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
另外，请注意下&lt;code&gt;Promise&lt;/code&gt;的&lt;code&gt;polyfill&lt;/code&gt;与官方版本的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Promise官方版本中，是标准的microtask形式&lt;/li&gt;
&lt;li&gt;polyfill，一般都是通过setTimeout模拟的，所以是macrotask形式&lt;/li&gt;
&lt;/ul&gt;
">【面】前端知识点梳理（浏览器）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/mian-qian-duan-zhi-shi-dian-shu-li-es6/"" data-c="
          &lt;h1 id=&#34;1-声明-let-const&#34;&gt;1. 声明 let、const&lt;/h1&gt;
&lt;h2 id=&#34;1-let声明变量的特点&#34;&gt;1. let声明变量的特点:&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;变量不能重复声明&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;每个循环每执行一次都有一个大括号{}，{}内的代码属于一个代码块，let声明的变量属于块级作用域，所以看上去能重复声明。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (let i = 0; i &amp;lt; 10; i++) {
        let s = &amp;quot;a&amp;quot;;
        console.log(s);    //这里会输出10个a
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;定义的变量可以被修改&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let c = 1;
c++;
console.log(c); //2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;定义的变量是块级作用域的变量&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;必须先声明后使用&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-const-声明常量的特点&#34;&gt;2. const 声明常量的特点：&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;常量不能重复声明，同let&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;常量不能被修改&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const p  = 1;
p=2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;上面的代码浏览器会报错&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;必须先声明后使用&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;2-解构赋值&#34;&gt;2. 解构赋值&lt;/h1&gt;
&lt;h2 id=&#34;1-解构赋值的定义&#34;&gt;1. 解构赋值的定义&lt;/h2&gt;
&lt;p&gt;ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构，本质是一种模式匹配。&lt;/p&gt;
&lt;h2 id=&#34;2-数组的解构赋值&#34;&gt;2. 数组的解构赋值&lt;/h2&gt;
&lt;p&gt;按照对应位置，对变量赋值，如果解构不成功，变量的值就等于undefined。&lt;br&gt;
同时解构赋值允许指定默认值。只有当一个数组成员严格等于undefined，默认值才会生效。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let [a, b, c] = [1, 2, 3];   //a=1,b=2,c=3
let [x, , y] = [1, 2, 3];    //x=1,y=3
let [foo] = [];              //foo=undefined
let [foo = 1] = [];      //foo=1
let [foo = 1] = [null];  //foo=null
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-对象的解构赋值&#34;&gt;3. 对象的解构赋值&lt;/h2&gt;
&lt;p&gt;对象的解构是按照属性来进行解构赋值的。如果解构不成功，变量的值就等于undefined。&lt;br&gt;
对象的解构也可以指定默认值。默认值生效的条件是，对象的属性值严格等于undefined。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let { a: foo, b: bar } = { a: &amp;quot;123&amp;quot;, b: &amp;quot;456&amp;quot; }    //foo=123  bar =456
let { a: a, b: b } = { a: &amp;quot;123&amp;quot;, b: &amp;quot;456&amp;quot; }       //a=123 b=456
let { a, b } = { a: &amp;quot;123&amp;quot;, b: &amp;quot;456&amp;quot; }      //a=123 b=456   
//第三种写法等于第二种，因为es6中可以在对象中直接写入变量
let { a, c } = { a: &amp;quot;123&amp;quot;, b: &amp;quot;456&amp;quot; }     //a=123  c=undefined
let { a, c = 3 } = { a: &amp;quot;123&amp;quot;, b: &amp;quot;456&amp;quot; }    //a=123  c=3
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-其他的解构赋值&#34;&gt;4. 其他的解构赋值&lt;/h2&gt;
&lt;p&gt;解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let  { toString: s } = 123      //s是对象的toString方法
let  { toString: s } = true;     //s是对象的toString方法
let { prop: x } = undefined;   //报错
let { prop: y } = null;      //  报错
const [a, b, c, d, e] = &amp;quot;hello&amp;quot;   // a=h b=e ...
const { 0: a, 1: b, 2: c, 3: d, 4: e } = &amp;quot;hello&amp;quot;    //a=h b=e ...
//字符串被转为类数组对象，故可以使用数组和对象解构赋值
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-解构赋值的用途&#34;&gt;5. 解构赋值的用途&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;交换变量的值&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt; let x = 1
 let y = 2
 [x, y] = [y, x]
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;方便取值&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;let obj = {
  a:1,
  b:2,
  c: function(){return 1}
}
 let {a,b} = obj  //代替以前  let a= obj.a, b=obj.b 的写法
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;输入模块的指定方法&lt;/li&gt;
&lt;li&gt;遍历 Map 结构&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;3-声明类与继承class-extend&#34;&gt;3. 声明类与继承：class、extend&lt;/h1&gt;
&lt;h2 id=&#34;1-类class&#34;&gt;1. 类（Class）&lt;/h2&gt;
&lt;p&gt;基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//定义类
class Point {
  constructor(x, y) {  //constructor 构造方法
    this.x = x;
    this.y = y;
  }
  toString() {
    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
  }
}
var p = new Point(1, 2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都还是定义在类的prototype属性上面。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constructor方法&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。&lt;/p&gt;
&lt;h2 id=&#34;2-继承extends&#34;&gt;2. 继承（Extends）&lt;/h2&gt;
&lt;p&gt;Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ColorPoint extends Point {
  constructor(x, y, color) {
    super(x, y); // 调用父类的constructor(x, y)
    this.color = color;
  }
  toString() {
    return this.color + &#39; &#39; + super.toString(); // 调用父类的toString()
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。&lt;/p&gt;
&lt;p&gt;子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。&lt;/p&gt;
&lt;h2 id=&#34;3-原生构造函数继承&#34;&gt;3. 原生构造函数继承&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boolean()&lt;/li&gt;
&lt;li&gt;Number()&lt;/li&gt;
&lt;li&gt;String()&lt;/li&gt;
&lt;li&gt;Array()&lt;/li&gt;
&lt;li&gt;Date()&lt;/li&gt;
&lt;li&gt;Function()&lt;/li&gt;
&lt;li&gt;RegExp()&lt;/li&gt;
&lt;li&gt;Error()&lt;/li&gt;
&lt;li&gt;Object()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这意味着，ES6可以自定义原生数据结构（比如Array、String等）的子类，这是ES5无法做到的。&lt;/p&gt;
&lt;h2 id=&#34;4-class的generator方法&#34;&gt;4. Class的Generator方法&lt;/h2&gt;
&lt;p&gt;如果某个方法之前加上星号（*），就表示该方法是一个Generator函数。&lt;/p&gt;
&lt;h2 id=&#34;5-class的静态方法&#34;&gt;5. Class的静态方法&lt;/h2&gt;
&lt;p&gt;类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Foo {
  static classMethod() {
    return &#39;hello&#39;;
  }
}
Foo.classMethod() // &#39;hello&#39;
var foo = new Foo();
foo.classMethod()
// TypeError: foo.classMethod is not a function
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。&lt;/p&gt;
&lt;h1 id=&#34;4-promise的使用与实现&#34;&gt;4. Promise的使用与实现&lt;/h1&gt;
&lt;p&gt;Promise 是 ES6 新增的语法，解决了回调地狱的问题。&lt;/p&gt;
&lt;h2 id=&#34;1-什么是promise&#34;&gt;1. 什么是Promise？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理，让开发者不用再关注于时序和底层的结果。Promise的状态具有不受外界影响和不可逆两个特点。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;特点：&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;对象的状态不受外界影响&lt;/code&gt;。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（以失败）。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;一旦状态改变，就不会再变&lt;/code&gt;，任何时候都是可以得到这个结果的。Promise对象的状态改变只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就会凝固，不会再变了。再对Promise对象添加回调函数也会立即得到这个结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;缺点：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;首先无法取消Promise，一旦新建他就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部跑出的错误无法反应到外部。当pending的时候，无法知道进展到了哪一步。&lt;/p&gt;
&lt;h2 id=&#34;2-promise-解决的痛点是什么&#34;&gt;2. Promise 解决的痛点是什么？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;回调地狱，代码难以维护&lt;/li&gt;
&lt;li&gt;promise可以支持多个并发的请求，获取并发请求中的数据&lt;/li&gt;
&lt;li&gt;promise可以解决可读性的问题，异步的嵌套带来的可读性的问题&lt;/li&gt;
&lt;li&gt;promise可以解决信任问题，对于回调过早、回调过晚或没有调用和回调次数太少或太多，由于promise只能决议一次，决议值只能有一个，决议之后无法改变，任何then中的回调也只会被调用一次，所以这就保证了Promise可以解决信任问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-promise-如何使用&#34;&gt;3. Promise 如何使用？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;创造一个Promise实例&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可用Promise的try和catch方法预防异常&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-promise中的异步模式有哪些有什么区别&#34;&gt;4. Promise中的异步模式有哪些？有什么区别？&lt;/h2&gt;
&lt;p&gt;回到问题本身，&lt;code&gt;Promise.all()&lt;/code&gt;和&lt;code&gt;Promise.race()&lt;/code&gt;的区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;all&lt;/code&gt;（&lt;code&gt;并行执行&lt;/code&gt;）会将传入的数组中的所有promise全部决议以后，将决议值以数组的形式传入到观察回调中，任何一个promise决议为拒绝，那么就会调用拒绝回调。&lt;strong&gt;Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;race&lt;/code&gt;会将传入的数组中的所有promise中第一个决议的决议值传递给观察回调，即使决议结果是拒绝。(超时取消)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果向Promise.all()和Promise.race()传递空数组，运行结果会有什么不同？&lt;br&gt;
all会立即决议，决议结果是fullfilled，值是undefined&lt;br&gt;
race会永远都不决议，程序卡死&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;5-promise-常用的方法有哪些&#34;&gt;5. Promise 常用的方法有哪些？&lt;/h2&gt;
&lt;h3 id=&#34;1-promiseresolve的用法&#34;&gt;1. Promise.resolve的用法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;当我们在执行函数中调用resolve方法时，Promise的状态就变成fulfilled，即操作成功状态&lt;/code&gt;，还记得上面Promise.prototype上面的then和catch方法吗？当Promise状态为fullfilled状态时执行then方法里的操作，注意了，&lt;code&gt;then方法里面有两个参数&lt;/code&gt;onfulfilled(Promise为fulfilled状态时执行) 和onrejected（Promise为rejected状态时执行），步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;实例化Promise（new Promise（function（resolve,reject）））&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;用Promise的实例调用then方法&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体来看下面的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var p = new Promise(function (resolve, reject) {
            var timer = setTimeout(function () {
                console.log(&#39;执行操作1&#39;);
                resolve(&#39;这是数据1&#39;);
            }, 1000);
        });
        p.then(function (data) {
            console.log(data);
            console.log(&#39;这是成功操作&#39;);
        });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简单的理解就是&lt;code&gt;调用resolve方法，Promise变为操作成功状态（fulfilled）&lt;/code&gt;，执行then方法里面onfulfilled里的操作。其实then里面的函数就是我们平时所说的回调函数，只不过在这里只是把它分离出来而已。我们可以看到控制台上的输出结果如下所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616496390953.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-promisereject的用法&#34;&gt;2. Promise.reject的用法&lt;/h3&gt;
&lt;p&gt;调用reject方法后，Promise状态变为rejected，即操作失败状态，此时执行then方法里面onrejected操作，&lt;code&gt;上面我们提到了then方法有两个参数&lt;/code&gt;，一种是Promise状态为fulfilled时执行（onfullfilled），一种是Promise状态为rejected时执行（onrejected）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var p = new Promise(function (resolve, reject) {
          var flag = false;
          if(flag){
            resolve(&#39;这是数据2&#39;);
          }else{
            reject(&#39;这是数据2&#39;);
          }
        });
        p.then(function(data){//状态为fulfilled时执行
            console.log(data);
            console.log(&#39;这是成功操作&#39;);
        },function(reason){ //状态为rejected时执行
            console.log(reason);
            console.log(&#39;这是失败的操作&#39;);
        });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以看到输出结果：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616496519288.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-promiseprototypethen方法&#34;&gt;3. Promise.prototype.then()方法&lt;/h3&gt;
&lt;p&gt;Promise实例具有then方法，也就是说then方法时定义在原型对象上的。&lt;br&gt;
它的作用是为&lt;code&gt;Promise实例添加状态改变时的回调函数&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;链式写法的本质&lt;/code&gt;其实是一直&lt;code&gt;往下传递返回一个新的Promise&lt;/code&gt;，也就是说&lt;code&gt;then在下一步接收的是上一步返回的Promise&lt;/code&gt;!!!&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）因此可以采用链式写法，即then方法后面再调用另一个then方法。&lt;/li&gt;
&lt;li&gt;采用链式的then可以指定一组按照次序调用的回调函数。这时，前一个回调函数可能返回一个还是Promise对象（即有异步操作），这时候一个回调函数就会等该Promise对象的状态发生变化，才会被调用&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;getJSON(&#39;/post/1.json&#39;).then(function(post) {
    return getJSON(post.commentURL)
}).then(function funcA() {
    console.log(&amp;quot;resolved:&amp;quot;, comments)
}, function funcB(err) {
    console.log(&amp;quot;rejected:&amp;quot;, err)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一个then方法指定的回调函数，返回的是一个Promise对象。这时，第二个方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用funcA, 如果状态变为rejected，就调用funcB.&lt;/p&gt;
&lt;h3 id=&#34;4-promiseprototypecatch方法&#34;&gt;4. Promise.prototype.catch()方法&lt;/h3&gt;
&lt;p&gt;Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;getJSON(&#39;/post/1.json&#39;).then(function(posts) {
    //...
}).catch(function() {
    console.log(&#39;发生错误&#39;, error)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，getJSON方法返回一个Promise对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数。另外，then方法指定的回调函数，如果运行抛出错误，也会被catch方法捕获。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619485896060.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Promise对象的错误具有冒泡性质，会一直向后传递，直到被捕获为止，也就是说错误总会被下一个catch语句捕获。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;6-promise-在事件循环中的执行过程是怎样的&#34;&gt;6. Promise 在事件循环中的执行过程是怎样的？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1）事件循环&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从代码执行顺序的角度来看，程序最开始是按代码顺序执行代码的，遇到同步任务，立刻执行；遇到异步任务，则只是调用异步函数发起异步请求。此时，异步任务开始执行异步操作，执行完成后到消息队列中排队。程序按照代码顺序执行完毕后，查询消息队列中是否有等待的消息。如果有，则按照次序从消息队列中把消息放到执行栈中执行。执行完毕后，再从消息队列中获取消息，再执行，不断重复。由于主线程不断的重复获得消息、执行消息、再取消息、再执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2）promise的事件循环&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Promise在初始化时，传入的函数是同步执行的，然后注册 then 回调。注册完之后，继续往下执行同步代码，在这之前，then 中回调不会执行。同步代码块执行完毕后，才会在事件循环中检测是否有可用的 promise 回调，如果有，那么执行，如果没有，继续下一个事件循环&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;7-promise的问题解决办法&#34;&gt;7. Promise的问题？解决办法？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;promise的问题为：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;promise一旦执行，无法中途取消(停止)&lt;/li&gt;
&lt;li&gt;promise的错误无法在外部被捕捉到，只能在内部进行预判处理&lt;/li&gt;
&lt;li&gt;promise的内如何执行，监测起来很难&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;停止可以通过返回新的promise进入pending状态，但是可能导致&lt;strong&gt;内存泄漏&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;正是因为这些原因，ES7引入了更加灵活多变的async，await来处理异步&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;8-手写promise与ajax的结合&#34;&gt;8. 手写Promise与ajax的结合？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;实例代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function promiseGet (url) {
  return new Promise((resolve, reject) =&amp;gt; {
    let xhr = new XMLHttpRequest()
    xhr.open(&#39;GET&#39;, url, true)
    xhr.onreadystatechange = function () {
      if (this.readyState === 4) {
        if (this.status === 200) {
          resolve(this.responseText,this)
        } else {
          let resJson = {
            code: this.status,
            response: this.response
          }
          reject(resJson, this)
        }
      }
    }
  })
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5-generator异步编程-yield-next&#34;&gt;5. Generator（异步编程、yield、next()）&lt;/h1&gt;
&lt;h2 id=&#34;1-generator&#34;&gt;1. Generator&lt;/h2&gt;
&lt;p&gt;Generator是一个函数，可以在函数内部通过&lt;code&gt;yield&lt;/code&gt;返回一个值（此时，Generator函数的执行会暂定，直到下次触发&lt;code&gt;.next()&lt;/code&gt;）&lt;br&gt;
创建一个&lt;code&gt;Generator函数&lt;/code&gt;的方法是在&lt;code&gt;function&lt;/code&gt;关键字后添加&lt;code&gt;*&lt;/code&gt;标识。&lt;/p&gt;
&lt;p&gt;在调用一个Generator函数后，并不会立即执行其中的代码，函数会返回一个&lt;code&gt;Generator&lt;/code&gt;对象，通过调用对象的&lt;code&gt;next&lt;/code&gt;函数，可以获得&lt;code&gt;yield/return&lt;/code&gt;的返回值。&lt;br&gt;
无论是触发了&lt;code&gt;yield&lt;/code&gt;还是&lt;code&gt;return&lt;/code&gt;，&lt;code&gt;next()&lt;/code&gt;函数总会返回一个带有&lt;code&gt;value&lt;/code&gt;和&lt;code&gt;done&lt;/code&gt;属性的对象。&lt;br&gt;
&lt;code&gt;value&lt;/code&gt;为返回值，&lt;code&gt;done&lt;/code&gt;则是一个Boolean对象，用来标识Generator是否还能继续提供返回值。&lt;br&gt;
P.S. Generator函数的执行时惰性的，yield后的代码只在&lt;code&gt;触发next&lt;/code&gt;时才会执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function * oddGenerator () {
  yield 1
  yield 3

  return 5
}

let iterator = oddGenerator()

let first = iterator.next()  // { value: 1, done: false }
let second = iterator.next() // { value: 3, done: false }
let third = iterator.next()  // { value: 5, done: true  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-next的参数传递&#34;&gt;2. next的参数传递&lt;/h2&gt;
&lt;p&gt;我们可以在调用&lt;code&gt;next()&lt;/code&gt;的时候传递一个参数，可以在上次&lt;code&gt;yield&lt;/code&gt;前接收到这个参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function * outputGenerator () {
  let ret1 = yield 1
  console.log(`got ret1: ${ret1}`)
  let ret2 = yield 2
  console.log(`got ret2: ${ret2}`)
}

let iterator = outputGenerator()

iterator.next(1)
iterator.next(2) // got ret1: 2
iterator.next(3) // got ret2: 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一眼看上去可能会有些诡异，为什么第一条&lt;code&gt;log&lt;/code&gt;是在第二次调用&lt;code&gt;next&lt;/code&gt;时才进行输出的&lt;br&gt;
这就又要说到上边的&lt;code&gt;Generator&lt;/code&gt;的实现了，上边说到了，&lt;code&gt;yield&lt;/code&gt;与&lt;code&gt;return&lt;/code&gt;都是用来返回值的语法。 函数在执行时遇到这两个关键字后就会暂停执行，等待下次激活。&lt;br&gt;
然后&lt;code&gt;let ret1 = yield 1&lt;/code&gt;，这是一个赋值表达式，也就是说会先执行&lt;code&gt;=右边&lt;/code&gt;的部分，在=右边执行的过程中遇到了yield关键字，函数也就在此处&lt;code&gt;暂停&lt;/code&gt;了，在下次触发&lt;code&gt;next()&lt;/code&gt;时才被激活，此时，我们继续进行上次未完成的赋值语句&lt;code&gt;let ret1 = XXX&lt;/code&gt;，并在再次遇到yield时&lt;code&gt;暂停&lt;/code&gt;。&lt;br&gt;
这也就解释了为什么&lt;strong&gt;第二次调用next()的参数会被第一次yield赋值的变量接收到&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-用作迭代器使用for-of&#34;&gt;3. 用作迭代器使用(for of)&lt;/h2&gt;
&lt;p&gt;但是要注意的是，用作迭代器中的使用，则只会作用于yield&lt;br&gt;
return的返回值不计入迭代&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function * oddGenerator () {
  yield 1
  yield 3
  yield 5

  return &#39;won\&#39;t be iterate&#39;
}

for (let value of oddGenerator()) {
  console.log(value)
}
//  1
//  3
//  5
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-generator函数内部的generator&#34;&gt;4. Generator函数内部的Generator&lt;/h2&gt;
&lt;p&gt;除了&lt;code&gt;yield&lt;/code&gt;语法以外，其实还有一个&lt;code&gt;yield*&lt;/code&gt;语法，可以粗略的理解为是&lt;code&gt;Generator&lt;/code&gt;函数版的&lt;code&gt;[...]&lt;/code&gt;&lt;br&gt;
用来展开Generator迭代器的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function * gen1 () {
  yield 1
  yield* gen2()
  yield 5
}

function * gen2 () {
  yield 2
  yield 3
  yield 4
  return &#39;won\&#39;t be iterate&#39;
}

for (let value of gen1()) {
  console.log(value)
}
//  1
//  2
//  3
//  4
//  5
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;6-async和await&#34;&gt;6. async和await&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;async函数是Generator函数的语法糖，将Generator的&lt;code&gt;星号&lt;/code&gt;换成&lt;code&gt;async&lt;/code&gt;将&lt;code&gt;yield&lt;/code&gt;换成&lt;code&gt;await&lt;/code&gt;，async函数比Generator函数更好用。&lt;code&gt;async&lt;/code&gt; 表示函数里有异步操作，&lt;code&gt;await&lt;/code&gt; 表示紧跟在后面的表达式需要等待结果。&lt;/li&gt;
&lt;li&gt;async必须&lt;strong&gt;声明的是一个function&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;await 只能出现在 async 函数中&lt;/li&gt;
&lt;li&gt;async 函数返回的&lt;strong&gt;是一个 Promise 对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。&lt;br&gt;
如果它等到的是一个 Promise 对象，await 就会阻塞后面的代码，等着 Promise 对象 resolve或者reject方法，然后得到 resolve的值，作为 await 表达式的运算结果。&lt;/li&gt;
&lt;li&gt;一般await都会用try/catch包起来&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-作用&#34;&gt;1. 作用&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt;和&lt;code&gt;await&lt;/code&gt;是用来处理异步的。即你需要异步像同步一样执行，需要异步返回结果之后，再往下依据结果继续执行。&lt;br&gt;
&lt;code&gt;async&lt;/code&gt; 是“异步”的简写，而 &lt;code&gt;await&lt;/code&gt; 可以认为是 &lt;code&gt;async wait&lt;/code&gt; 的简写。&lt;br&gt;
&lt;code&gt;async&lt;/code&gt; 用于申明一个 &lt;code&gt;function&lt;/code&gt; 是异步的，而 &lt;code&gt;await&lt;/code&gt; 用于等待一个异步方法执行完成。&lt;/p&gt;
&lt;h2 id=&#34;2-async&#34;&gt;2. async&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;async function testAsync() {
    return &amp;quot;hello async&amp;quot;;
}

const result = testAsync();
console.log(result);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打印输出的是一个&lt;code&gt;Promise&lt;/code&gt; 对象，&lt;code&gt;async&lt;/code&gt; 函数会返回一个 &lt;code&gt;Promise&lt;/code&gt; 对象。&lt;br&gt;
在最外层不能用 &lt;code&gt;await&lt;/code&gt; 获取其返回值的情况下，使用 &lt;code&gt;then()&lt;/code&gt; 链来处理这个 &lt;code&gt;Promise&lt;/code&gt; 对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;testAsync().then(v =&amp;gt; {
    console.log(v);    // 输出 hello async
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当 &lt;code&gt;async&lt;/code&gt; 函数没有返回值时，返回 &lt;code&gt;Promise.resolve(undefined)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-awit&#34;&gt;3. awit&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;await&lt;/code&gt;只能放在&lt;code&gt;async&lt;/code&gt;函数内部使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;await&lt;/code&gt; 用于一个异步操作之前，表示要“等待”这个异步操作的返回值。&lt;br&gt;
&lt;code&gt;await&lt;/code&gt; 也可以用于一个同步的值。&lt;/p&gt;
&lt;p&gt;如果它等到的不是一个 &lt;code&gt;Promise&lt;/code&gt; 对象，那 &lt;code&gt;await&lt;/code&gt; 表达式的运算结果就是它等到的东西。&lt;br&gt;
如果它等到的是一个 &lt;code&gt;Promise&lt;/code&gt; 对象，&lt;code&gt;await&lt;/code&gt; 就会阻塞后面的代码，等着 &lt;code&gt;Promise&lt;/code&gt; 对象 &lt;code&gt;resolve&lt;/code&gt;，然后得到 &lt;code&gt;resolve&lt;/code&gt; 的值，作为 &lt;code&gt;await&lt;/code&gt; 表达式的运算结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 2s 之后返回双倍的值
function doubleAfter2seconds(num) {
    return new Promise((resolve, reject) =&amp;gt; {
        setTimeout(() =&amp;gt; {
            resolve(2 * num)
        }, 2000);
    })
}

async function testResult () {
    let result = await doubleAfter2seconds(30);
    console.log(result);
}

testResult();
// 2s 之后，输出了60. 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-执行顺序&#34;&gt;4. 执行顺序&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 2s 之后返回双倍的值
function doubleAfter2seconds(num) {
    return new Promise((resolve, reject) =&amp;gt; {
        setTimeout(() =&amp;gt; {
            resolve(2 * num)
        }, 2000);
    })
}

async function testResult () {
    console.log(&#39;内部调用前&#39;) // 2
    let result = await doubleAfter2seconds(30);
    console.log(result); // 4
    console.log(&#39;内部调用后&#39;) // 5
}

console.log(&#39;外部调用前&#39;) // 1
testResult();
console.log(&#39;外部调用后&#39;) // 3
// --- 依次输出
// 外部调用前
// 内部调用前
// 外部调用后
// --- 2s 之后输出
// 60
// 内部调用后
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析一下上面的执行顺序：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先打印输出&lt;code&gt;外部调用前&lt;/code&gt;，同步代码，顺序执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后调用方法&lt;code&gt;testResult()&lt;/code&gt;，打印输出&lt;code&gt;内部调用前&lt;/code&gt;，同步代码，顺序执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再执行异步方法&lt;code&gt;doubleAfter2seconds&lt;/code&gt;，&lt;br&gt;
　1&amp;gt;如果没用&lt;code&gt;await&lt;/code&gt;关键字，此后的执行顺序应该是&lt;br&gt;
　　&lt;code&gt;内部调用后，外部调用后，2s 之后输出60&lt;/code&gt;&lt;br&gt;
　　因为异步方法不阻塞其他代码的执行，最后再输出&lt;code&gt;60&lt;/code&gt;&lt;br&gt;
　2&amp;gt;这里使用了&lt;code&gt;await&lt;/code&gt;关键字，所以到这里后会等待异步返回结果，再往下执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当&lt;code&gt;testResult&lt;/code&gt;函数内部&lt;code&gt;await&lt;/code&gt;阻塞执行后，不会影响到&lt;code&gt;testResult&lt;/code&gt;函数外面&lt;/p&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt; &lt;strong&gt;函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，在调用&lt;code&gt;testResult&lt;/code&gt;函数后，会继续向下执行，打印输出外部调用后&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当2s之后，异步函数&lt;code&gt;doubleAfter2seconds&lt;/code&gt;执行完成，返回结果，&lt;br&gt;
打印输出&lt;code&gt;60&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为&lt;code&gt;await&lt;/code&gt;将异步变成同步，所以在输出&lt;code&gt;60&lt;/code&gt;后，同步执行，再输出&lt;code&gt;内部调用后&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-错误处理&#34;&gt;5. 错误处理&lt;/h2&gt;
&lt;p&gt;因为async函数返回的是一个Promise，所以我们可以在外面catch住错误。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 2s 之后返回双倍的值
function doubleAfter2seconds(num) {
    return new Promise((resolve, reject) =&amp;gt; {
        setTimeout(() =&amp;gt; {
            resolve(2 * num)
        }, 2000);
    })
}

async function testResult () {
    let first = await doubleAfter2seconds(10);
    let second = await doubleAfter2seconds(20);    
    let res = first + second;
    return res;
}

testResult().then(res =&amp;gt; {
    console.log(res);      
}).catch(error =&amp;gt; {
    console.log(error);     
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;连写&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const [err, data] = await fetchData().then(data =&amp;gt; [null, data] ).catch(err =&amp;gt; [err, null])
 console.log(&#39;err&#39;, err)
 console.log(&#39;data&#39;, data)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-asyncawait的中断&#34;&gt;6. async/await的中断&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619487936845.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
实质就是直接&lt;code&gt;return&lt;/code&gt;返回了一个&lt;code&gt;Promise&lt;/code&gt;，相当于&lt;code&gt;return Promise.resolve(&#39;我退出了下面不进行了&#39;)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;7-asyncawait循环获取数据串行之for循环&#34;&gt;7. async/await循环获取数据(串行)之for循环&lt;/h2&gt;
&lt;p&gt;现在就来介绍一下牛逼的async/await实战，上述的代码你是不是要看吐了，的确，我也觉得好麻烦啊，那么如果用&lt;code&gt;async/await&lt;/code&gt;能有什么改进吗？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(async ()=&amp;gt;{
    arr = [timeout(2000), timeout(1000), timeout(1000)]
    for (var i=0; i &amp;lt; arr.length; i++) {
        result = await arr[i]();
        console.log(result);
    }
})()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8在接口中使用axios&#34;&gt;8.在接口中使用(axios)&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;created () {
    this.init()
},
methods: {
    async init () {
      try {
          let first = await this.getOne();
          let second = await this.getTwo();    
          let res = first + second;
          console.log(res);
      } catch (error) {
          console.log(error);
      }        
    },
    getOne () {
        const params = {name: &#39;one&#39;}
        return new Promise((resolve, reject) =&amp;gt; {
            axios.get(&#39;/one&#39;, { params}).then((res) =&amp;gt; {
                if (res.status === 200) {
                    resolve(res)
                }
            }).catch((err) =&amp;gt; {
                reject(err)
            })
        })
    },
    getTwo () {
        const params = {name: &#39;two&#39;}
        return new Promise((resolve, reject) =&amp;gt; {
            axios.get(&#39;/two&#39;, { params}).then((res) =&amp;gt; {
                if (res.status === 200) {
                    resolve(res)
                }
            }).catch((err) =&amp;gt; {
                reject(err)
            })
        })
    },
},
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;7-箭头函数this指向问题-拓展运算符&#34;&gt;7. 箭头函数this指向问题、拓展运算符&lt;/h1&gt;
&lt;h2 id=&#34;1-箭头函数this指向&#34;&gt;1. 箭头函数this指向&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;箭头函数中的this指向的是定义时的this，而不是执行时的this。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//定义一个对象
    var obj = {
        x:100,//属性x
        show(){
            //延迟500毫秒，输出x的值
            setTimeout(
               //不同处：箭头函数
               () =&amp;gt; { console.log(this.x)},
               500
            );
        }
    };
    obj.show();//打印结果：100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当定义obj的show( )方法的时候，我们在箭头函数编写this.x，此时的this是指的obj，所以this.x指的是obj.x。而在show()被调用的时候，this依然指向的是被定义时候所指向的对象，也就是obj对象，故打印出：100。&lt;/p&gt;
&lt;h2 id=&#34;2-拓展运算符&#34;&gt;2. 拓展运算符&lt;/h2&gt;
&lt;p&gt;拓展运算符允许一个可迭代的对象（数组、类数组对象、字符串、ES6中的Set、Map等拥有默认迭代器Symbol(Symbol.iterator)属性，可以被for...of遍历的对象）去拓展函数调用的参数、数组的元素，同时也允许以Object键值对的形式去拓展另一个对象&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;化参数为数组&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;var showLambdaArgs = (...foo)=&amp;gt;{
  return foo
}
showLambdaArgs(1,2,3,4,5,6)//[1,2,3,4,5,6]

//在普通函数中也能使用，注意与arguments的区别
function showArgs(...foo){
    console.log(arguments instanceof Array)// false
    console.log(foo instanceof Array)// true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;code&gt;化数组为参数&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;function introduce(){
   console.log(arguments)//对象
   console.log(arguments.length)//参数个数
}
introduce(1,2,3,...[8,9,0])// arguments对象 和 6
introduce(4,5,...&amp;quot;abcde&amp;quot;)// arguments对象 和 7
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;code&gt;化可迭代对象为数组&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;//解构赋值也可以这么用
var [a,b,c] = [...&#39;123&#39;]//a = 1;b = 2;c = 3
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;//一行去重数组ver2:
[...new Set([1,1,2,3,3,4,4,4])] //1 , 2 , 3 ,4
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;//倒序参数
function reverseArgs(){
  return [...arguments].reverse()//现在可以调用数组方法了
}
reverseArgs(1,2,3,4,5)//[5, 4, 3, 2, 1]
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;code&gt;扩展对象&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对象的拷贝方法五花八门，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有JSON.parse(JSON.stringify(obj))的&lt;/li&gt;
&lt;li&gt;有for(var i in obj){}赋值的&lt;/li&gt;
&lt;li&gt;使用ES6的Object.assign()可能是大多数使用ES6开发者的选择：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;var o = {a:1,b:2}
var p = Object.assign({},o)
console.log(o === p) //false
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;code&gt;可变传参&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;es5中参数不确定个数的情况下&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//求参数和
function f(){
  var a = Array.prototype.slice.call(arguments);
  var sum = 0;
  a.forEach(function(item){
     sum += item*1;          
  })     
  return sum;  
};
f(1,2,3);//6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;es6中可变参数&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function f(...a){
  let sum = 0;
  a.forEach(item =&amp;gt;{
     sum += item*1;
  })    
  return sum;  
}
f(1,2,3);//6
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;8-map和set数组去重map数据结构有什么优点&#34;&gt;8. map和set数组去重，map数据结构有什么优点？&lt;/h1&gt;
&lt;h2 id=&#34;1-set数组去重&#34;&gt;1. set数组去重&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;et arr = [1, 2, 2, 3, 4]
function unique (arr) {
    return [...new Set(arr)]
}
console.log(unique(arr)) // [1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-map数组去重&#34;&gt;2. map数组去重&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;function unique(arr) {
    const res = new Map()
    return arr.filter( item =&amp;gt; !res.has(JSON.stringify(item)) &amp;amp;&amp;amp; res.set(JSON.stringify(item), 1))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3map数据结构优点&#34;&gt;3.map数据结构优点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。&lt;/li&gt;
&lt;li&gt;任何具有 Iterator接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数。&lt;/li&gt;
&lt;li&gt;Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;9-es6怎么编译成es5css-loader原理-过程&#34;&gt;9. ES6怎么编译成ES5？css-loader原理、过程&lt;/h1&gt;
&lt;h2 id=&#34;1-es6怎么编译成es5&#34;&gt;1. ES6怎么编译成ES5&lt;/h2&gt;
&lt;p&gt;Babel是一个广泛使用的转码器，babel可以将ES6代码完美地转换为ES5代码&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化项目&lt;/li&gt;
&lt;li&gt;全局安装babel工具&lt;/li&gt;
&lt;li&gt;新建.babelrc&lt;br&gt;
在项目根目录新建(.babelrc)文件输入如图所示代码：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;presets&amp;quot;:[
        &amp;quot;es2015&amp;quot;
    ],
    &amp;quot;plugins&amp;quot;:[]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-css-loader&#34;&gt;2. css-loader&lt;/h2&gt;
&lt;p&gt;webpack的一个loader，用于解释@import 和 url()，并通过import后进行解析，通常和style-loader结合使用&lt;/p&gt;
&lt;h1 id=&#34;10-使用es5模拟实现es6的class&#34;&gt;10. 使用ES5模拟实现ES6的class&lt;/h1&gt;
&lt;h2 id=&#34;1new操作符检查函数&#34;&gt;1.new操作符检查函数&lt;/h2&gt;
&lt;p&gt;解决问题：&lt;br&gt;
类必须使用new调用，否则会报错。ES的构造函数是可以当成普通函数使用的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function _checkType (obj, constructor) {
    if (!(obj instanceof constructor)) {
        throw new TypeError(&#39;Cannot call a class as a function&#39;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2内部方法不可枚举&#34;&gt;2.内部方法不可枚举&lt;/h2&gt;
&lt;p&gt;解决问题：&lt;br&gt;
类的内部所有定义的方法，都是不可枚举的。（包括内部定义的静态方法）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 修改构造函数描述符
function defineProperties (target, descriptors) {
    for (let descriptor of descriptors) {
        descriptor.enumerable = descriptor.enumerable || false

        descriptor.configurable = true
        if (&#39;value&#39; in descriptor) {
            descriptor.writable = true
        }

        Object.defineProperty(target, descriptor.key, descriptor)
    }
}

// 构造class
// constructor 表示类对应的constructor对象
// protoDesc 表示class内部定义的方法
// staticDesc 表示class内部定义的静态方法
function _createClass (constructor, protoDesc, staticDesc) {
    protoDesc &amp;amp;&amp;amp; defineProperties(constructor.prototype, protoDesc)
    staticDesc &amp;amp;&amp;amp; defineProperties(constructor, staticDesc)
    return constructor
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-真正的创建class&#34;&gt;3. 真正的创建class&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const Foo = function () {
    function Foo(name) {
        _checkType(this, Foo) // 先检查是不是new调用的

        this.name = name
    }

    _createClass (Foo, [ // 表示在class内部定义的方法
        {
            key: &#39;say&#39;,
            value: function () {
                console.log(this.name)
            }
        }
    ], [ // 表示在class内部定义的静态方法
        {
            key: &#39;say&#39;,
            value: function () {
                console.log(&#39;static say&#39;)
                console.log(this.name)
            }
        }
    ])

    return Foo
}()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;11-settimeout和setinterval的区别&#34;&gt;11. setTimeout和setInterval的区别&lt;/h1&gt;
&lt;p&gt;1.setTimeout和setInterval都属于JS中的定时器，可以规定延迟时间再执行某个操作，不同的是setTimeout在规定时间后执行完某个操作就停止了，而setInterval则可以一直循环下去。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function fun(){
  alert(&#39;hello&#39;);
}
  setTimeout(fun,1000);//参数是函数名
  setTimeout(&#39;fun()&#39;,1000);//参数是字符串
  setInterval(fun,1000);
  setInterval(&#39;fun(),1000&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上述代码中，无论是setTimeout还是setInterval，在使用函数名作为调用句柄时不能带参数，使用字符串调用时可以带参数。例如：setTimeout(‘fun(name)’,1000);&lt;/p&gt;
&lt;p&gt;2.不再单独再定义一个函数，直接将函数调用放在一个函数里面，可以使用函数名作为调用调用句柄。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function fun(name){
  alert(&#39;hello&#39;+&#39; &#39;+name);
}
setTimeout (function(){
  fun(&#39;Tom&#39;);
},1000);//参数是函数名
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上述代码中，setTimeout和setInterval的区别就是setTimeout延迟一秒弹出’hello’,之后便不再运行；而setInterval则会隔一秒弹出’hello’,直至用clear来清除定时器的语法。&lt;/p&gt;
">【面】前端知识点梳理（ES6）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/js-zhong-he-qu-bie/"" data-c="
          &lt;p&gt;简单来说： == 代表相同， ===代表严格相同, 为啥这么说呢，&lt;/p&gt;
&lt;p&gt;这么理解： 当进行双等号比较时候： 先检查两个操作数数据类型，如果相同， 则进行===比较， 如果不同， 则愿意为你进行一次类型转换， 转换成相同类型后再进行比较， 而===比较时， 如果类型不同，直接就是false.&lt;/p&gt;
&lt;p&gt;操作数1 == 操作数2，  操作数1 === 操作数2&lt;/p&gt;
&lt;p&gt;比较过程：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;双等号&lt;/strong&gt;&lt;code&gt;==&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;（1）如果两个值类型相同，再进行三个等号(===)的比较&lt;/p&gt;
&lt;p&gt;（2）如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换在比较：&lt;/p&gt;
&lt;p&gt;1）如果一个是null，一个是undefined，那么相等&lt;/p&gt;
&lt;p&gt;2）如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三等号&lt;/strong&gt;&lt;code&gt;===&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;（1）如果类型不同，就一定不相等&lt;/p&gt;
&lt;p&gt;（2）如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是NaN，那么不相等。（判断一个值是否是NaN，只能使用isNaN( ) 来判断）&lt;/p&gt;
&lt;p&gt;（3）如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等。&lt;/p&gt;
&lt;p&gt;（4）如果两个值都是true，或是false，那么相等&lt;/p&gt;
&lt;p&gt;（5）如果两个值都引用同一个对象或是函数，那么相等，否则不相等&lt;/p&gt;
&lt;p&gt;（6）如果两个值都是null，或是undefined，那么相等&lt;/p&gt;
">js中==和===区别</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/mian-qian-duan-zhi-shi-dian-shu-li-js-shang/"" data-c="
          &lt;h1 id=&#34;-1-面向对象编程基础&#34;&gt;-1. 面向对象编程基础！！&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;面向对象适合的是那些业务逻辑复杂（其实用“繁杂”更恰当一些）的大型项目。所谓繁杂，繁指多，杂指乱，项目“杂乱”，可以表现为：功能多改动多，所以代码量大、开发人员多、开发/维护跨度时间长……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1-什么是面向对象&#34;&gt;1. 什么是面向对象&lt;/h2&gt;
&lt;p&gt;面向对象 ( Object Oriented ) 是将现实问题构建关系，然后抽象成 &lt;strong&gt;类 ( class )&lt;/strong&gt;，给类定义属性和方法后，再将类实例化成 &lt;strong&gt;实例 ( instance )&lt;/strong&gt; ，通过访问实例的属性和调用方法来进行使用。&lt;/p&gt;
&lt;p&gt;在不同的语言中，对象的定义范围不同。在 Java 等静态语言中，一般把类的实例称为对象。&lt;/p&gt;
&lt;h2 id=&#34;2-面向对象的六大原则&#34;&gt;2. 面向对象的六大原则&lt;/h2&gt;
&lt;h3 id=&#34;1-单一职责原则&#34;&gt;1. 单一职责原则&lt;/h3&gt;
&lt;p&gt;一个合理的类，应该仅有一个引起它变化的原因，即单一职责,就是设计的这个类功能应该只有一个;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：消除耦合，减小因需求变化引起代码僵化。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-开-闭原则&#34;&gt;2. 开-闭原则&lt;/h3&gt;
&lt;p&gt;讲的是设计要对扩展有好的支持，而对修改要严格限制。即对扩展开放，对修改封闭。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：降低了程序各部分之间的耦合性，其适应性、灵活性、稳定性都比较好。当已有软件系统需要增加新的功能时，不需要对作为系统基础的抽象层进行修改，只需要在原有基础上附加新的模块就能实现所需要添加的功能。增加的新模块对原有的模块完全没有影响或影响很小，这样就无须为原有模块进行重新测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-里氏代换原则&#34;&gt;3. 里氏代换原则&lt;/h3&gt;
&lt;p&gt;规则是“子类必须能够替换基类，否则不应当设计为其子类。”也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：可以很容易的实现同一父类下各个子类的互换，而客户端可以毫不察觉。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-依赖倒换原则&#34;&gt;4. 依赖倒换原则&lt;/h3&gt;
&lt;p&gt;“设计要依赖于抽象而不是具体化”。换句话说就是设计的时候我们要用抽象来思考，而不是一上来就开始划分我需要哪些哪些类，因为这些是具体。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619593049456.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：人的思维本身实际上就是很抽象的，我们分析问题的时候不是一下子就考虑到细节，而是很抽象的将整个问题都构思出来，所以面向抽象设计是符合人的思维的。另外这个原则会很好的支持（开闭原则）OCP，面向抽象的设计使我们能够不必太多依赖于实现，这样扩展就成为了可能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-接口隔离原则&#34;&gt;5. 接口隔离原则&lt;/h3&gt;
&lt;p&gt;“将大的接口打散成多个小接口”，让系统解耦，从而容易重构，更改和重新部署。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：会使一个软件系统功能扩展时，修改的压力不会传到别的对象那里。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;6-迪米特法则&#34;&gt;6. 迪米特法则&lt;/h3&gt;
&lt;p&gt;它讲的是“一个对象应当尽可能少的去了解其他对象”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：消除耦合。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-面向对象的三大特性&#34;&gt;3. 面向对象的三大特性&lt;/h2&gt;
&lt;p&gt;理解了理论知识后，接着通过例子，再理解面向对象的三大特征：&lt;code&gt;封装&lt;/code&gt;、&lt;code&gt;继承&lt;/code&gt;、&lt;code&gt;多态&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;1-封装&#34;&gt;1. 封装&lt;/h3&gt;
&lt;p&gt;封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;封装&lt;/code&gt;，&lt;strong&gt;也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作&lt;/strong&gt;，对不可信的进行信息隐藏。&lt;/p&gt;
&lt;h3 id=&#34;2-继承&#34;&gt;2. 继承&lt;/h3&gt;
&lt;p&gt;面向对象编程 (OOP) 语言的一个主要功能就是“&lt;code&gt;继承&lt;/code&gt;”。继承是指这样一种能力：&lt;strong&gt;它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;通过继承创建的新类称为“子类”或“派生类”。&lt;br&gt;
被继承的类称为“基类”、“父类”或“超类”。&lt;/p&gt;
&lt;p&gt;要实现继承，可以通过“&lt;strong&gt;继承&lt;/strong&gt;”（Inheritance）和“&lt;strong&gt;组合&lt;/strong&gt;”（Composition）来实现。&lt;/p&gt;
&lt;p&gt;继承概念的实现方式有三类：&lt;code&gt;实现继承&lt;/code&gt;、&lt;code&gt;接口继承&lt;/code&gt;和&lt;code&gt;可视继承&lt;/code&gt;。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619592096963.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-多态&#34;&gt;3. 多态&lt;/h3&gt;
&lt;p&gt;多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，&lt;br&gt;
简单的说，就是一句话：&lt;code&gt;允许将子类类型的指针赋值给父类类型的指针&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;实现多态，有二种方式，覆盖，重载。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;覆盖，是指子类重新定义父类的虚函数的做法。&lt;/li&gt;
&lt;li&gt;重载，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么，多态的作用是什么呢？我们知道，&lt;code&gt;封装&lt;/code&gt;可以隐藏实现细节，使得代码模块化；&lt;code&gt;继承&lt;/code&gt;可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而&lt;code&gt;多态&lt;/code&gt;则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。&lt;/p&gt;
&lt;h1 id=&#34;0-new-与-objectcreate-区别&#34;&gt;0. new 与 Object.create() 区别&lt;/h1&gt;
&lt;h2 id=&#34;1-new的原理&#34;&gt;1. new的原理&lt;/h2&gt;
&lt;p&gt;new 大概会执行以下四个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个空对象&lt;/li&gt;
&lt;li&gt;将空对象的原型链连接到另一个对象&lt;/li&gt;
&lt;li&gt;执行构造函数中的代码并绑定 this 到这个对象&lt;/li&gt;
&lt;li&gt;如函数没有返回值，则返回该对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自己实现一个 _new(Constructor,...args):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function _new() {
     // 参数为 对象A，属性
      // 1.创建一个空对象
     let obj = {}
 
     // 2.将该空对象的原型链连接到传入的对象
     let [Con, ...args] = arguments
     obj.__proto__ = Con.prototype
 
     // 3.执行函数并绑定 this
     let res = Con.apply(obj, args)
 
     // 4.如果函数有返回值并且为object，则返回函数的返回值，否则返回obj
     return res instanceof Object ? res : obj
   }
 
   function Person(name, age) {
     this.name = name
     this.age = age
   }
   Person.prototype.getName = function() {
     return this.name
   }
 
   let p = _new(Person, &amp;quot;sillywa&amp;quot;, 23)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-objectcreate介绍&#34;&gt;2. Object.create()介绍&lt;/h2&gt;
&lt;p&gt;Object.create(null) 创建的对象是一个空对象，在该对象上没有继承 Object.prototype 原型链上的属性或者方法,例如：toString(), hasOwnProperty()等方法&lt;/p&gt;
&lt;p&gt;**Object.create()**方法接受两个参数:Object.create(&lt;code&gt;obj&lt;/code&gt;,&lt;code&gt;propertiesObject&lt;/code&gt;) ;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;obj:一个对象，应该是新创建的对象的原型。&lt;/li&gt;
&lt;li&gt;propertiesObject：可选。该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符（这些属性描述符的结构与Object.defineProperties()的第二个参数一样）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;1-原型原型链构造函数实例继承&#34;&gt;1. 原型/原型链/构造函数/实例/继承&lt;/h1&gt;
&lt;h2 id=&#34;11-创建对象的几种方法&#34;&gt;1.1 创建对象的几种方法&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot; charset=&amp;quot;utf-8&amp;quot;&amp;gt;
		//创建对象的几种方式
		//1.字面量
		var obj1 = {name: &#39;solo obj1&#39;};
		//2.new Object
		var obj2 = new Object({name: &#39;solo obj2&#39;})
		//3.构造函数创建
		var M = function(name){
			this.name = name;
		}
		var obj3 = new M(&#39;solo obj3&#39;);
		//4.Object.create
		var p = {name: &#39;p&#39;};
		var obj4 = Object.create(p);
	&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;12-原型-构造函数-实例-原型链&#34;&gt;1.2 原型、构造函数、实例、原型链&lt;/h2&gt;
&lt;p&gt;构造函数、原型对象、实例的关系可以参照下图：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614923904668.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;构造函数.prototype.constructor === 构造函数&lt;br&gt;
M.prototype.constructor === M 的结果为 true&lt;/p&gt;
&lt;p&gt;构造函数.prototype === 实例对象. proto&lt;br&gt;
M.prototype === obj3._ proto _ 的结果为 true&lt;/p&gt;
&lt;h2 id=&#34;13-instanceof-的原理&#34;&gt;1.3 instanceof 的原理&lt;/h2&gt;
&lt;p&gt;instanceof 的原理是判断&lt;strong&gt;实例对象的&lt;/strong&gt; &lt;strong&gt;proto&lt;/strong&gt; 是否与&lt;strong&gt;构造函数的prototype&lt;/strong&gt;指向同一个引用。&lt;/p&gt;
&lt;h2 id=&#34;14-instanceof-和-typeof-的区别&#34;&gt;1.4 instanceof 和 typeof 的区别&lt;/h2&gt;
&lt;p&gt;typeof 对于基本数据类型（&lt;code&gt;null, undefined, string, number, boolean, symbol&lt;/code&gt;），除了 null 都会返回正确的类型。null 会返回 object。&lt;/p&gt;
&lt;p&gt;typeof 对于对象类型，除了函数会返回 function，其他的都返回 object。&lt;/p&gt;
&lt;h2 id=&#34;15-原型链&#34;&gt;1.5 原型链&lt;/h2&gt;
&lt;p&gt;JS中每个函数都存在有一个原型对象属性prototype。并且所有函数的默认原型都是Object的实例。每个继承父函数的子函数的对象都包含一个内部属性proto。该属性包含一个指针，指向父函数的prototype。若父函数的原型对象的_proto_属性为再上一层函数。在此过程中就形成了原型链。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;原型链的作用是用来实现继承,比如我们新建一个数组,数组的方法就是从数组的原型上继承而来的&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当访问对象a.b的时候，首先会查找当前对象的b属性，如果没有，然后依次按照prototype往上找直到找到Object.prototype为止，没有则返回undefined，所以说无处不在。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619259847019.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;js的想要调用公共类的方式就是继承原型。&lt;/p&gt;
&lt;p&gt;比如原生的[].forEach()方法，之所以任意数组都能使用，是应为forEach()被定义在了数组的构造函数function Array(){}上，也就是数组的原型上；&lt;/p&gt;
&lt;h2 id=&#34;例子&#34;&gt;例子&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;function F(){} var f = new F(); // 构造器 
F.prototype.constructor === F; // true 
F.__proto__ === Function.prototype; // true 
Function.prototype.__proto__ === Object.prototype; // true Object.prototype.__proto__ === null; // true // 实例
f.__proto__ === F.prototype; // true 
F.prototype.__proto__ === Object.prototype; // true Object.prototype.__proto__ === null;// true
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614925004509.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;2-有几种方式可以实现继承&#34;&gt;2. 有几种方式可以实现继承&lt;/h1&gt;
&lt;p&gt;ES5实现继承有6种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原型链继承&lt;/li&gt;
&lt;li&gt;借用构造函数继承&lt;/li&gt;
&lt;li&gt;组合继承&lt;/li&gt;
&lt;li&gt;原型式继承&lt;/li&gt;
&lt;li&gt;寄生式继承&lt;/li&gt;
&lt;li&gt;寄生组合式继承&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;寄生组合式&lt;/strong&gt;继承是大家公认的最好的实现引用类型继承的方法。&lt;/p&gt;
&lt;h2 id=&#34;1-原型链继承&#34;&gt;1.  原型链继承&lt;/h2&gt;
&lt;p&gt;原型链继承的基本思想是&lt;strong&gt;利用原型让一个引用类型继承另一个引用类型的属性和方法&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
function SuperType() {
    this.name = &#39;Yvette&#39;;
    this.colors = [&#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;];
}
SuperType.prototype.getName = function () {
    return this.name;
}
function SubType() {
    this.age = 22;
}
SubType.prototype = new SuperType();
SubType.prototype.getAge = function() {
    return this.age;
}
SubType.prototype.constructor = SubType;
let instance1 = new SubType();
instance1.colors.push(&#39;yellow&#39;);
console.log(instance1.getName()); //&#39;Yvette&#39;
console.log(instance1.colors);//[ &#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;, &#39;yellow&#39; ]
 
let instance2 = new SubType();
console.log(instance2.colors);//[ &#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;, &#39;yellow&#39; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过原型来实现继承时，原型会变成另一个类型的实例，原先的实例属性变成了现在的原型属性，该原型的引用类型属性会被所有的实例共享。&lt;/li&gt;
&lt;li&gt;在创建子类型的实例时，没有办法在不影响所有对象实例的情况下给超类型的构造函数中传递参数。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-借用构造函数&#34;&gt;2. 借用构造函数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;借用构造函数&lt;/strong&gt;的技术，其基本思想为: 在子类型的构造函数中调用超类型构造函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function SuperType(name) {
    this.name = name;
    this.colors = [&#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;];
}
function SubType(name) {
    SuperType.call(this, name);
}
let instance1 = new SubType(&#39;Yvette&#39;);
instance1.colors.push(&#39;yellow&#39;);
console.log(instance1.colors);//[&#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;, yellow]
 
let instance2 = new SubType(&#39;Jack&#39;);
console.log(instance2.colors); //[&#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;优点:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以向超类传递参数&lt;/li&gt;
&lt;li&gt;解决了原型中包含引用类型值被所有实例共享的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;缺点:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;方法都在构造函数中定义，函数复用无从谈起，另外超类型原型中定义的方法对于子类型而言都是不可见的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-组合继承原型链-借用构造函数&#34;&gt;3. 组合继承(原型链 + 借用构造函数)&lt;/h2&gt;
&lt;p&gt;基本思路：使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承，既通过在原型上定义方法来实现了函数复用，又保证了每个实例都有自己的属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function SuperType(name) {
    this.name = name;
    this.colors = [&#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;];
}
SuperType.prototype.sayName = function () {
    console.log(this.name);
}
function SuberType(name, age) {
    SuperType.call(this, name);
    this.age = age;
}
SuberType.prototype = new SuperType();
SuberType.prototype.constructor = SuberType;
SuberType.prototype.sayAge = function () {
    console.log(this.age);
}
let instance1 = new SuberType(&#39;Yvette&#39;, 20);
instance1.colors.push(&#39;yellow&#39;);
console.log(instance1.colors); //[ &#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;, &#39;yellow&#39; ]
instance1.sayName(); //Yvette
 
let instance2 = new SuberType(&#39;Jack&#39;, 22);
console.log(instance2.colors); //[ &#39;pink&#39;, &#39;blue&#39;, &#39;green&#39; ]
instance2.sayName();//Jack
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;优点:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以向超类传递参数&lt;/li&gt;
&lt;li&gt;每个实例都有自己的属性&lt;/li&gt;
&lt;li&gt;实现了函数复用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;缺点:&lt;/strong&gt;&lt;br&gt;
无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。&lt;/p&gt;
&lt;h2 id=&#34;4-原型式继承&#34;&gt;4. 原型式继承&lt;/h2&gt;
&lt;p&gt;原型继承的基本思想：&lt;br&gt;
借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
function object(o) {
    function F() { }
    F.prototype = o;
    return new F();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 object() 函数内部，先创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例，从本质上讲，object() 对传入的对象执行了一次浅拷贝。&lt;/p&gt;
&lt;p&gt;在没有必要创建构造函数，仅让一个对象与另一个对象保持相似的情况下，原型式继承是可以胜任的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-寄生式继承&#34;&gt;5. 寄生式继承&lt;/h2&gt;
&lt;p&gt;寄生式继承是与原型式继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部已某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
function createAnother(original) {
    var clone = object(original);//通过调用函数创建一个新对象
    clone.sayHi = function () {//以某种方式增强这个对象
        console.log(&#39;hi&#39;);
    };
    return clone;//返回这个对象
}
var person = {
    name: &#39;Yvette&#39;,
    hobbies: [&#39;reading&#39;, &#39;photography&#39;]
};
 
var person2 = createAnother(person);
person2.sayHi(); //hi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;基于 person 返回了一个新对象 -—— person2，新对象不仅具有 person 的所有属性和方法，而且还有自己的 sayHi() 方法。在考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用寄生式继承来为对象添加函数，会由于不能做到函数复用而效率低下。&lt;/li&gt;
&lt;li&gt;同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;6-寄生组合式继承&#34;&gt;6. 寄生组合式继承&lt;/h2&gt;
&lt;p&gt;所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法，&lt;br&gt;
&lt;strong&gt;基本思路：&lt;/strong&gt;&lt;br&gt;
不必为了指定子类型的原型而调用超类型的构造函数，我们需要的仅是超类型原型的一个副本，本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function inheritPrototype(subType, superType) {
    var prototype = object(superType.prototype); //创建对象
    prototype.constructor = subType;//增强对象
    subType.prototype = prototype;//指定对象
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;第一步：创建超类型原型的一个副本&lt;/li&gt;
&lt;li&gt;第二步：为创建的副本添加 constructor 属性&lt;/li&gt;
&lt;li&gt;第三步：将新创建的对象赋值给子类型的原型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至此，我们就可以通过调用 inheritPrototype 来替换为子类型原型赋值的语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
function SuperType(name) {
    this.name = name;
    this.colors = [&#39;pink&#39;, &#39;blue&#39;, &#39;green&#39;];
}
//...code
function SuberType(name, age) {
    SuperType.call(this, name);
    this.age = age;
}
SuberType.prototype = new SuperType();
inheritPrototype(SuberType, SuperType);
//...code
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;优点:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只调用了一次超类构造函数，效率更高。避免在SuberType.prototype上面创建不必要的、多余的属性，与其同时，原型链还能保持不变。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此寄生组合继承是引用类型最理性的继承范式。&lt;/p&gt;
&lt;h2 id=&#34;7-es6继承&#34;&gt;7 es6继承&lt;/h2&gt;
&lt;p&gt;ES6新增class和extends语法，用来定义类和实现继承，底层也是采用了寄生组合式继承。&lt;/p&gt;
&lt;h1 id=&#34;3-用原型实现继承有什么缺点怎么解决&#34;&gt;3. 用原型实现继承有什么缺点，怎么解决&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;原型继承&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Human(){
this.name=&amp;quot;teacher&amp;quot;;
this,age=39;
}
function Man(){
}
Man.prototype=new Human();
var m=new Man();
/*此时Man.name=teacher;Man.age=39；*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;br&gt;
可以继承构造函数属性，也可继承原型属性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;br&gt;
1，在创建子类实例化时，不能向超类型的构造函数中传参&lt;br&gt;
2，子类型继承了父类型原型中的所有属性和方法，但对于引用类型属性值所有实例共享，故不能在不改变其他实例情况下改变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方式&lt;/strong&gt;&lt;br&gt;
使用混合继承。&lt;/p&gt;
&lt;h1 id=&#34;4-arguments&#34;&gt;4. arguments&lt;/h1&gt;
&lt;p&gt;arguments 是一个&lt;strong&gt;类似数组&lt;/strong&gt;的对象, 对应于传递给函数的&lt;strong&gt;参数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;arguments对象是所有函数中可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;arguments[0]
arguments[1]
arguments[2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;arguments对象不是一个 Array 。它类似于数组，但除了 长度之外没有任何数组属性。&lt;/p&gt;
&lt;p&gt;可以使用 Array.from()方法或 spread 运算符将 arguments 转换为真正的数组：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let args = Array.from(arguments);
let args = [...arguments];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你调用一个函数，当这个函数的参数数量比它显式声明的参数数量更多的时候，你就可以使用 arguments 对象。你可以用 arguments.length 来得到参数的数量，然后可以用 arguments object 来对每个参数进行处理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;arguments.callee：指向当前执行的函数。&lt;/li&gt;
&lt;li&gt;arguments.caller **：指向调用当前函数的函数。&lt;/li&gt;
&lt;li&gt;arguments.length：指向传递给当前函数的参数数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;模拟函数重载&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function add(num1, num2, num3) {
if (arguments.length === 2) {
    console.log(&amp;quot;Result is &amp;quot; + (num1 + num2));
     }
else if (arguments.length === 3) {
    console.log(&amp;quot;Result is &amp;quot; + (num1 + num2 + num3));
     }
｝
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;add(1, 2);&lt;br&gt;
add(1, 2, 3)&lt;/p&gt;
&lt;p&gt;执行结果如下：&lt;br&gt;
Result is 3&lt;br&gt;
Result is 6&lt;/p&gt;
&lt;h1 id=&#34;5-数据类型判断&#34;&gt;5. 数据类型判断&lt;/h1&gt;
&lt;h2 id=&#34;50-null和undefined的区别&#34;&gt;5.0 null和undefined的区别&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619269681622.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;51-javascript-数据类型&#34;&gt;5.1 JavaScript 数据类型&lt;/h2&gt;
&lt;p&gt;JavaScript 数据类型有两种，分别是基本数据类型和引用数据类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基本数据类型&lt;br&gt;
Number&lt;br&gt;
String&lt;br&gt;
Boolean&lt;br&gt;
Undefined&lt;br&gt;
Null&lt;br&gt;
Symbol (ES6 新增，表示独一无二的值)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引用数据类型&lt;br&gt;
Object&lt;br&gt;
Function&lt;br&gt;
Array&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;52-检验数据类型&#34;&gt;5.2 检验数据类型&lt;/h2&gt;
&lt;h3 id=&#34;521-typeof&#34;&gt;5.2.1 typeof&lt;/h3&gt;
&lt;p&gt;它返回一个表示数据类型的字符串，返回结果包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;number&lt;/li&gt;
&lt;li&gt;boolean&lt;/li&gt;
&lt;li&gt;string&lt;/li&gt;
&lt;li&gt;symbol&lt;/li&gt;
&lt;li&gt;object&lt;/li&gt;
&lt;li&gt;undefined&lt;/li&gt;
&lt;li&gt;function&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;br&gt;
除 function 以外的对象都会被识别成 object ，这样显然是不合理的，这时就需要 instanceof 来进行判断。&lt;/p&gt;
&lt;h3 id=&#34;522-instanceof&#34;&gt;5.2.2 instanceof&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上&lt;/strong&gt;&lt;br&gt;
简单来说就是 instanceof 是用来判断 A 是否为 B 的实例，表达式为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A  (object)  instanceof  B  (constructor)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果A是B的实例，则返回true,否则返回 false。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;br&gt;
1.&lt;strong&gt;是否处于原型链上的判断方法不严谨&lt;/strong&gt;&lt;br&gt;
instanceof 方法判断的是是否处于原型链上，而不是是不是处于原型链最后一位&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;无法判断字面量方式创建的基本数据类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;无法检测 null 和 undefined&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;523-objectprototypetostringcall&#34;&gt;5.2.3 Object.prototype.toString.call()&lt;/h3&gt;
&lt;p&gt;在 Number、String，Boolean，Array，RegExp、Date、Function 等对象上 toString() 方法都是被重写过了的，会按照一定的规则返回字符串。但是在 object 对象上，这个方式是返回当前方法执行的主体（方法中的this）所属类的详细信息即&amp;quot;[object Object]&amp;quot;,其中第一个object代表当前实例是对象数据类型的(这个是固定的 onject)，第二个Object代表的是this所属的类型。&lt;/p&gt;
&lt;p&gt;为了每个对象都能通过 Object.prototype.toString() 来检测，需要以 Function.prototype.call() 或者 Function.prototype.apply() 的形式来调用，传递要检查的对象作为第一个参数，称为 thisArg。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object.prototype.toString.call(&#39;&#39;) ;   // [object String]
Object.prototype.toString.call(1) ;    // [object Number]
Object.prototype.toString.call(true) ; // [object Boolean]
Object.prototype.toString.call(undefined) ; // [object Undefined]
Object.prototype.toString.call(null) ; // [object Null]
Object.prototype.toString.call(new Function()) ; // [object Function]
Object.prototype.toString.call(new Date()) ; // [object Date]
Object.prototype.toString.call([]) ; // [object Array]
Object.prototype.toString.call(new RegExp()) ; // [object RegExp]
Object.prototype.toString.call(new Error()) ; // [object Error]
Object.prototype.toString.call(document) ; // [object HTMLDocument]
Object.prototype.toString.call(window) ; //[object global] window是全局对象global的引用
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;6-作用域-作用域链和闭包的理解&#34;&gt;6. 作用域、作用域链和闭包的理解&lt;/h1&gt;
&lt;h2 id=&#34;61-作用域&#34;&gt;6.1 作用域&lt;/h2&gt;
&lt;p&gt;变量的作用域无非就是两种：&lt;strong&gt;全局变量&lt;/strong&gt;和&lt;strong&gt;局部变量&lt;/strong&gt;。&lt;br&gt;
&lt;code&gt;全局作用域&lt;/code&gt;：&lt;br&gt;
最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是可以访问的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
      var outerVar = &amp;quot;outer&amp;quot;;
      function fn(){
         console.log(outerVar);
      }
      fn();//result:outer
   &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;局部作用域&lt;/code&gt;：&lt;br&gt;
和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无法访问的，最常见的例如函数内部&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
      function fn(){
         var innerVar = &amp;quot;inner&amp;quot;;
      }
      fn();
      console.log(innerVar);// ReferenceError: innerVar is not defined
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;只要函数内定义了一个局部变量，函数在解析的时候都会将这个变量“提前声明”：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
      var scope = &amp;quot;global&amp;quot;;
      function fn(){
         var scope;//提前声明了局部变量
         console.log(scope);//result:undefined
         scope = &amp;quot;local&amp;quot;;
         console.log(scope);//result:local;
      }
      fn();
   &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;62-作用域链scope-chain&#34;&gt;6.2 作用域链（Scope Chain）&lt;/h2&gt;
&lt;p&gt;作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。&lt;/p&gt;
&lt;h3 id=&#34;621-执行环境execution-context&#34;&gt;6.2.1 执行环境（execution context）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;js为每一个执行环境关联了一个变量对象。环境中定义的所有变量和函数都保存在这个对象中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;全局执行环境是最外围的执行环境，全局执行环境被认为是window对象，因此所有的全局变量和函数都作为window对象的属性和方法创建的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;script&amp;gt;
      var scope = &amp;quot;global&amp;quot;; 
      function fn1(){
         return scope; 
      }
      function fn2(){
         return scope;
      }
      fn1();
      fn2();
   &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码执行情况演示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614938134873.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;622-作用域链&#34;&gt;6.2.2 作用域链&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
name=&amp;quot;lwy&amp;quot;;
function t(){
    var name=&amp;quot;tlwy&amp;quot;;
    function s(){
        var name=&amp;quot;slwy&amp;quot;;
        console.log(name);
    }
    function ss(){
        console.log(name);
    }
    s();
    ss();
}
t();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当执行s时，将创建函数s的执行环境(调用对象),并将该对象置于链表开头，然后将函数t的调用对象链接在之后，最后是全局对象。然后从链表开头寻找变量name,很明显name是&amp;quot;slwy&amp;quot;。&lt;/p&gt;
&lt;p&gt;但执行ss()时，作用域链是： ss()-&amp;gt;t()-&amp;gt;window,所以name是”tlwy&amp;quot;&lt;/p&gt;
&lt;h2 id=&#34;63-闭包&#34;&gt;6.3 闭包&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614941970240.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1-闭包的定义&#34;&gt;1. 闭包的定义&lt;/h3&gt;
&lt;p&gt;一个函数对其周围状态(变量)的&lt;strong&gt;引用&lt;/strong&gt;并&lt;strong&gt;保存&lt;/strong&gt;周围变量，乃至函数执行完成后仍然可以访问的现象称之为闭包。&lt;/p&gt;
&lt;h3 id=&#34;2-闭包的原理&#34;&gt;2. 闭包的原理&lt;/h3&gt;
&lt;p&gt;闭包的实现原理，其实是利用了作用域链的特性，我们都知道作用域链就是在当前执行环境下访问某个变量时，如果不存在就一直向外层寻找，最终寻找到最外层也就是全局作用域，这样就形成了一个链条。&lt;/p&gt;
&lt;h3 id=&#34;3-闭包的特点&#34;&gt;3. 闭包的特点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;函数嵌套函数。&lt;/li&gt;
&lt;li&gt;函数内部可以引用外部的参数和变量。&lt;/li&gt;
&lt;li&gt;参数和变量不会被垃圾回收机制回收。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-闭包的优缺点&#34;&gt;4. 闭包的优缺点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;希望一个变量长期存储在内存中。&lt;/li&gt;
&lt;li&gt;避免全局变量的污染。&lt;/li&gt;
&lt;li&gt;私有成员的存在。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;导致变量不会被垃圾回收机制回收，造成内存消耗&lt;/li&gt;
&lt;li&gt;不恰当的使用闭包可能会造成内存泄漏的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-闭包的作用&#34;&gt;5. 闭包的作用&lt;/h3&gt;
&lt;p&gt;闭包有两个&lt;code&gt;作用&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个就是读取及操作外部函数的私有变量（沿着作用域链寻找）&lt;/li&gt;
&lt;li&gt;第二个就是让这些外部变量始终保存在内存中&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
      function outer(){
         var result = new Array();
         for(var i = 0; i &amp;lt; 2; i++){//注：i是outer()的局部变量
            result[i] = function(){
               return i;
            }
         }
         return result;//返回一个函数对象数组
         //这个时候会初始化result.length个关于内部函数的作用域链
      }
      var fn = outer();
      console.log(fn[0]());//result：2
      console.log(fn[1]());//result：2
   &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;js函数内的变量值不是在编译的时候就确定的，而是等在运行时期再去寻找的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;闭包让外部访问函数内部的变量成为可能（私有属性），因为被引用的数据常驻内存，可能会造成内存泄露（一块内存长期被变量占据而不进行释放），闭包可以让你在一个内层函数中访问到其外层函数的作用域的状态并保存，在js中每当创建一个函数，闭包环境就在函数创建时产生，闭包环境相互独立，如果闭包环境引用外部函数作用域的一个变量a，即使当外部函数作用域的变量被销毁释放内存，但变量a不会被删除。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; function outer(){
         var result = new Array();
         for(var i = 0; i &amp;lt; 2; i++){
            //定义一个带参函数
            result[i] = function(num){
               function innerarg(){
                  return num;
               }
               return innerarg;
            }(i);//预先执行函数写法
            //把i当成参数传进去
         }
         return result;
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6-闭包变量回收&#34;&gt;6. 闭包变量回收&lt;/h3&gt;
&lt;p&gt;当闭包函数无外链引用时，闭包函数被垃圾回收机制标记，&lt;code&gt;闭包自身呗回收，里边的变量自然就一起被回收了&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;7-ajax的原生写法&#34;&gt;7. Ajax的原生写法&lt;/h1&gt;
&lt;h2 id=&#34;71-ajax-是什么&#34;&gt;7.1 Ajax 是什么？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;全称Asynchronous JavaScript and XML；&lt;/li&gt;
&lt;li&gt;异步的 JavaScript 和 XML；&lt;/li&gt;
&lt;li&gt;可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页内容；&lt;/li&gt;
&lt;li&gt;能够实现局部刷新，大大降低了资源的浪费；&lt;/li&gt;
&lt;li&gt;不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;72-ajax的使用&#34;&gt;7.2 Ajax的使用&lt;/h2&gt;
&lt;p&gt;Ajax的使用分为四部分：&lt;br&gt;
1.） 创建一个XMLHttpRequest对象；&lt;/p&gt;
&lt;p&gt;2.） 配置请求信息；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求的方式；&lt;/li&gt;
&lt;li&gt;请求文件的路径；&lt;/li&gt;
&lt;li&gt;是否异步，默认为true；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.）发送请求；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;get与post的区别；&lt;/li&gt;
&lt;li&gt;get与post的使用场景；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4.） 监听状态变化，执行相应回调函数；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;http状态码都有哪些？&lt;/li&gt;
&lt;li&gt;不同状态码代表的含义？&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;721-创建xmlhttprequest对象&#34;&gt;7.2.1 创建XMLHttpRequest对象&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;var xhr = new XMLHttpRequest()&lt;/code&gt;;&lt;/p&gt;
&lt;h3 id=&#34;722-连接服务器&#34;&gt;7.2.2 连接服务器&lt;/h3&gt;
&lt;p&gt;使用 XMLHttpRequest 对象的open() 方法：&lt;/p&gt;
&lt;h3 id=&#34;723-向服务器发送请求&#34;&gt;7.2.3 向服务器发送请求&lt;/h3&gt;
&lt;p&gt;使用 XMLHttpRequest 对象的send() 方法：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614951772130.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;724-监听事件变化&#34;&gt;7.2.4 监听事件变化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如果是同步请求的话，不需要写监听事件变化函数；&lt;/li&gt;
&lt;li&gt;一般默认都是异步请求，才写监听函数；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0: 请求未初始化&lt;/li&gt;
&lt;li&gt;1: 服务器连接已建立&lt;/li&gt;
&lt;li&gt;2: 请求已接收&lt;/li&gt;
&lt;li&gt;3: 请求处理中&lt;/li&gt;
&lt;li&gt;4: 请求已完成，且响应已就绪&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;73-ajax原生写法&#34;&gt;7.3 Ajax原生写法&lt;/h2&gt;
&lt;h3 id=&#34;731-get请求&#34;&gt;7.3.1 Get请求&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;const xhr = new XMLHttpRequest()
        xhr.open(&amp;quot;GET&amp;quot;, &amp;quot;http://localhost:3000/users?id=1&amp;quot;)
        xhr.send(null)

        xhr.onreadystatechange = function () {
            if (this.readyState === 4) {
                console.log(this.responseText);
            }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;732-post请求&#34;&gt;7.3.2 Post请求&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;const xhr = new XMLHttpRequest()
        xhr.open(&amp;quot;POST&amp;quot;, &amp;quot;http://localhost:3000/users&amp;quot;)
        xhr.setRequestHeader(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)
        // 转换为json传递
        xhr.send(JSON.stringify({
            &amp;quot;name&amp;quot;: &amp;quot;luke&amp;quot;,
            &amp;quot;age&amp;quot; : 19,
            &amp;quot;class&amp;quot;: 2
        }))

        xhr.onreadystatechange = function () {
            if (this.readyState === 4) {
                console.log(this.responseText);
            }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;8-对象深拷贝-浅拷贝&#34;&gt;8. 对象深拷贝、浅拷贝&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;let a = {
    age: 1
}
let b = a
a.age = 2
console.log(b.age) // 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上述例子中我们可以发现，如果给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;如果是基本数据类型，名字和值都会储存在栈内存中&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;如果是引用数据类型，名字存在栈内存中，值存在堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;81-浅拷贝&#34;&gt;8.1 浅拷贝&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1617331269019.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先可以通过 &lt;code&gt;Object.assign&lt;/code&gt; 来解决这个问题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a = {
    age: 1
}
let b = Object.assign({}, a)
a.age = 2
console.log(b.age) // 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然我们也可以通过展开运算符&lt;code&gt;（…）&lt;/code&gt;来解决&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a = {
    age: 1
}
let b = {...a}
a.age = 2
console.log(b.age) // 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就需要使用到深拷贝了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a = {
    age: 1,
    jobs: {
        first: &#39;FE&#39;
    }
}
let b = {...a}
a.jobs.first = &#39;native&#39;
console.log(b.jobs.first) // native
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到刚开始的话题了，两者享有相同的引用。要解决这个问题，我们需要引入深拷贝。&lt;/p&gt;
&lt;h2 id=&#34;82-深拷贝&#34;&gt;8.2 深拷贝&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1617331301932.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这个问题通常可以通过 &lt;code&gt;JSON.parse(JSON.stringify(object))&lt;/code&gt; 来解决。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a = {
    age: 1,
    jobs: {
        first: &#39;FE&#39;
    }
}
let b = JSON.parse(JSON.stringify(a))
a.jobs.first = &#39;native&#39;
console.log(b.jobs.first) // FE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是该方法也是有局限性的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会忽略 undefined&lt;/li&gt;
&lt;li&gt;会忽略 symbol&lt;/li&gt;
&lt;li&gt;不能序列化函数&lt;/li&gt;
&lt;li&gt;不能解决循环引用的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;9-图片懒加载-预加载&#34;&gt;9. 图片懒加载、预加载&lt;/h1&gt;
&lt;h2 id=&#34;91-懒加载&#34;&gt;9.1 懒加载&lt;/h2&gt;
&lt;h3 id=&#34;911-什么是懒加载&#34;&gt;9.1.1 什么是懒加载&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;懒加载又称延迟加载&lt;/strong&gt;。当访问一个页面的时候，需要先把img元素或者其他元素的背景图先用一张默认的图片代替（占位图），这样浏览器渲染页面的时候就只需请求一次。当图片出现在浏览器可视区域的时候，才设置图片的真实路径，把图片显示出来。&lt;/p&gt;
&lt;h3 id=&#34;912-为什么要使用图片懒加载&#34;&gt;9.1.2 为什么要使用图片懒加载？&lt;/h3&gt;
&lt;p&gt;当页面中图片的数量多到一定数量的时候，并且图片大小比较大，比如各种商场网站，图片素材网等等。如果在页面一加载的时候就加载全部图片，显然会影响网站加载速度和加大服务器负担，而且用户体验也必然不好，那么这时候可以采用懒加载。&lt;/p&gt;
&lt;h3 id=&#34;913-懒加载具体实现原理&#34;&gt;9.1.3 懒加载具体实现原理&lt;/h3&gt;
&lt;p&gt;页面中的img元素之所以会发送http请求的原因是设置了src属性，否则浏览器就不会发送请求去下载这个图片。&lt;br&gt;
首先在页面中把所有的图片用一张占位图进行占位，并且在元素下设置data-src自定义属性，存放图片的真实路径，当需要用到的时候取出该真实路径动态添加给src。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;懒加载具体实现方式&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离便开始加载，这样能保证用户拉下时正好能看到图片。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;92-预加载&#34;&gt;9.2 预加载&lt;/h2&gt;
&lt;h3 id=&#34;921-什么是预加载&#34;&gt;9.2.1 什么是预加载&lt;/h3&gt;
&lt;p&gt;预加载就是提前加载图片，当用户需要查看时可直接从本地缓存中渲染。&lt;/p&gt;
&lt;h3 id=&#34;922-为什么要使用图片预加载&#34;&gt;9.2.2 为什么要使用图片预加载？&lt;/h3&gt;
&lt;p&gt;当页面中图片比较大的时候，页面加载的时候会出现该区域空白的效果或者看到图片正在慢慢地加载出来，为了提高用户体验，需要把这些图片提前加载到缓存中，当用户一打开页面的时候，这些图片就会快速的呈现出来，获得更好的用户体验效果。&lt;/p&gt;
&lt;h3 id=&#34;923-实现方式有哪些&#34;&gt;9.2.3 实现方式有哪些？&lt;/h3&gt;
&lt;p&gt;方法1：使用css和JavaScript实现预加载&lt;br&gt;
方法2：只使用JavaScript实现预加载&lt;br&gt;
方法3：使用ajax实现预加载&lt;/p&gt;
&lt;p&gt;常用的是&lt;code&gt;new Image()&lt;/code&gt;;设置其src来实现预载，再使用onload方法回调预载完成事件。只要浏览器把图片下载到本地，同样的src就会使用缓存，这是最基本也是最实用的预载方法。当Image下载完图片头后，会得到宽和高，因此可以在预载前得到图片的大小(方法是用记时器轮循宽高变化。)&lt;/p&gt;
&lt;h1 id=&#34;10-实现页面加载进度条&#34;&gt;10. 实现页面加载进度条&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615011309891.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;101-html结构&#34;&gt;10.1 html结构：&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;div id=&amp;quot;progressBox&amp;quot;&amp;gt;
        &amp;lt;div id=&amp;quot;progressBar&amp;quot;&amp;gt;0%&amp;lt;/div&amp;gt;
        &amp;lt;!-- 设定第二个层以便当进度超过文字的时候，修改文字的颜色 --&amp;gt;
        &amp;lt;div id=&amp;quot;progressText&amp;quot;&amp;gt;0%&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;102-css结构&#34;&gt;10.2 CSS结构：&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
        #progressBox {
            width: 300px;
            height: 40px;
            border: 1px solid #C8C8C8;
            background: white;
            position: relative;
            margin: 0 auto;
            margin-top: 100px;
        }
 
        #progressBar {
            position: absolute;
            left: 0;
            top: 0;
            z-index: 2;
            height: 40px;
            width: 100%;
            line-height: 40px;
            color: white;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            font-family: Georgia;
            clip: rect(0px, 0, 40px, 0px);
            background: #00A1F5;
        }
 
        #progressText {
            position: absolute;
            left: 0;
            top: 0;
            z-index: 1;
            width: 100%;
            height: 40px;
            line-height: 40px;
            color: black;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            font-family: Georgia;
        }
    &amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;103-javascript-部分&#34;&gt;10.3 JavaScript 部分&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
        window.onload = function () {
            // 设定当前起始状态值,
            // 真实情况中用html5的onprogress和onload来完成
            // 还可以跟后台配合，通过ajax实时的返回数据
            var iNow = 0;
            // 设定定时器
            var timer = setInterval(function () {
                // 如果当前的值为100
                if (iNow == 100) {
                    // 清除定时器
                    clearInterval(timer);
                }else {
                    // 将当前状态值累加1
                    iNow += 1;
                    // 调用执行状态的函数,传入状态值
                    progressFn(iNow);
                }
 
            }, 30);
 
 
            function progressFn(cent) {
                // 获取最外层的div
                var oDiv1 = document.getElementById(&#39;progressBox&#39;);
                // 获取内层进度条的div
                var oDiv2 = document.getElementById(&#39;progressBar&#39;);
                // 获取内层文字发生变化时的div
                var oDiv3 = document.getElementById(&#39;progressText&#39;);
 
                // 获取总进度条的宽度
                var allWidth = parseInt(getStyle(oDiv1, &#39;width&#39;));
 
                // 设定内层两个div的文字内容一样
                oDiv2.innerHTML = cent + &#39;%&#39;;
                oDiv3.innerHTML = cent + &#39;%&#39;;
 
                // 修改clip的的宽度值
                oDiv2.style.clip = &#39;rect(0px, &#39; + cent / 100 * allWidth + &#39;px, 40px, 0px)&#39;;
 
                // 获取当前元素的属性值
                function getStyle(obj, attr) {
                    // 兼容IE
                    if (obj.currentStyle) {
                        return obj.currentStyle[attr];
                    }else {
                        // 第二个参数为false是通用的写法，目的是为了兼容老版本
                        return getComputedStyle(obj, false)[attr];
                    }
                }
            }
        };
    &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;11-this关键字&#34;&gt;11. this关键字&lt;/h1&gt;
&lt;p&gt;首先我们需要得出一个非常重要一定要牢记于心的结论，&lt;code&gt;this的指向，是在函数被调用的时候确定的&lt;/code&gt;。也就是执行上下文被创建时确定的。因此，一个函数中的this指向，可以是非常灵活的。比如下面的例子中，同一个函数由于调用方式的不同，this指向了不一样的对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = 10;
var obj = {
    a: 20
}
function fn () {
    console.log(this.a);
}
fn(); // 10
fn.call(obj); // 20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除此之外，&lt;code&gt;在函数执行过程中，this一旦被确定，就不可更改了。&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;情况1：如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window，这里需要说明的是在js的严格版中this指向的不是window，但是我们这里不探讨严格版的问题，你想了解可以自行上网查找。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;情况2：如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;情况3：如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象，&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;111-全局对象中的this&#34;&gt;11.1 全局对象中的this&lt;/h2&gt;
&lt;p&gt;关于全局对象的this，我之前在总结变量对象的时候提到过，它是一个比较特殊的存在。全局环境中的this，指向它本身。&lt;/p&gt;
&lt;h2 id=&#34;112-函数中的this&#34;&gt;11.2 函数中的this&lt;/h2&gt;
&lt;p&gt;在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。&lt;strong&gt;如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined&lt;/strong&gt;。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = 20;
var foo = {
    a: 10,
    getA: function () {
        return this.a;
    }
}
console.log(foo.getA()); // 10

var test = foo.getA;
console.log(test());  // 20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;foo.getA()&lt;/code&gt;中，getA是调用者，他不是独立调用，被对象foo所拥有，因此它的this指向了foo。而&lt;code&gt;test()&lt;/code&gt;作为调用者，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined，在非严格模式，自动转向全局window。&lt;/p&gt;
&lt;h2 id=&#34;113-使用callapply显示指定this&#34;&gt;11.3 使用call，apply显示指定this&lt;/h2&gt;
&lt;p&gt;JavaScript内部提供了一种机制，让我们可以自行手动设置this的指向。它们就是call与apply。所有的函数都具有着两个方法。它们除了参数略有不同，其功能完全一样。它们的第一个参数都为this将要指向的对象。&lt;/p&gt;
&lt;p&gt;而call与applay后面的参数，都是向将要执行的函数传递参数。其中call以一个一个的形式传递，apply以数组的形式传递。这是他们唯一的不同。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function fn(num1, num2) {
    console.log(this.a + num1 + num2);
}
var obj = {
    a: 20
}

fn.call(obj, 100, 10); // 130
fn.apply(obj, [20, 10]); // 50
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;114-构造函数与原型方法上的this&#34;&gt;11.4 构造函数与原型方法上的this&lt;/h2&gt;
&lt;p&gt;通过new操作符调用构造函数，会经历以下4个阶段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个新的对象；&lt;/li&gt;
&lt;li&gt;将构造函数的this指向这个新对象；&lt;/li&gt;
&lt;li&gt;指向构造函数的代码，为这个对象添加属性，方法等；&lt;/li&gt;
&lt;li&gt;返回新对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;function Person(name, age) {

    // 这里的this指向了谁?
    this.name = name;
    this.age = age;   
}

Person.prototype.getName = function() {

    // 这里的this又指向了谁？
    return this.name;
}

// 上面的2个this，是同一个吗，他们是否指向了原型对象？

var p1 = new Person(&#39;Nick&#39;, 20);
p1.getName();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因此，当new操作符调用构造函数时，this其实指向的是这个新创建的对象，最后又将新的对象返回出来，被实例对象p1接收。因此，我们可以说，这个时候，构造函数的this，指向了新的实例对象，p1。&lt;/p&gt;
&lt;h1 id=&#34;12-函数式编程&#34;&gt;12. 函数式编程&lt;/h1&gt;
&lt;p&gt;函数式编程是一种编程范式，是一种构建计算机程序结构和元素的风格，它把计算看作是对数学函数的评估，&lt;strong&gt;避免了状态的变化和数据的可变&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;纯函数&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果给定相同的参数，则返回相同的结果(也称为确定性)。&lt;/li&gt;
&lt;li&gt;它不会引起任何副作用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;函数是一等公民&lt;/li&gt;
&lt;li&gt;只用表达式不用语句&lt;/li&gt;
&lt;li&gt;没有副作用(side effect)&lt;/li&gt;
&lt;li&gt;不修改状态&lt;/li&gt;
&lt;li&gt;引用透明&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;优势&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代码简洁，开发快速&lt;/li&gt;
&lt;li&gt;接近自然语言，易于理解&lt;/li&gt;
&lt;li&gt;更方便的代码管理&lt;/li&gt;
&lt;li&gt;易于&amp;quot;并发编程&amp;quot;&lt;/li&gt;
&lt;li&gt;代码的热升级&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;13-手动实现parseint&#34;&gt;13. 手动实现parseInt&lt;/h1&gt;
&lt;p&gt;主要用到的ES5中的&lt;code&gt;map&lt;/code&gt;函数和&lt;code&gt;reduce&lt;/code&gt;函数，还有利用了javascript是弱类型转换的特点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function str2num(str) {
  var strArr = str.split(&#39;&#39;)
  var strArrNum = strArr.map(function (str) {
    return +str
  })
  var num = strArrNum.reduce(function (x, y) {
    return x * 10 + y
  })
  return num
}
str2num(&#39;123&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;14-为什么会有同源策略&#34;&gt;14. 为什么会有同源策略&lt;/h1&gt;
&lt;h2 id=&#34;141-什么是同源策略&#34;&gt;14.1 什么是同源策略&lt;/h2&gt;
&lt;p&gt;两个页面地址中的协议，域名，端口号一致，则表示同源&lt;/p&gt;
&lt;h2 id=&#34;142-为什么浏览器要使用同源策略&#34;&gt;14.2 为什么浏览器要使用同源策略&lt;/h2&gt;
&lt;p&gt;设置同源策略的主要目的是为了安全，如果没有同源限制，在浏览器中的cookie等其他数据可以任意读取，不同域下的DOM任意操作，ajax任意请求其他网站的数据，包括隐私数据。&lt;/p&gt;
&lt;h1 id=&#34;15-怎么判断两个对象是否相等&#34;&gt;15. 怎么判断两个对象是否相等&lt;/h1&gt;
&lt;p&gt;方法一：通过&lt;code&gt;JSON.stringify(obj)&lt;/code&gt;来判断两个对象转后的字符串是否相等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：用法简单，对于顺序相同的两个对象可以快速进行比较得到结果&lt;/li&gt;
&lt;li&gt;缺点：这种方法有限制就是当两个对比的对象中key的顺序不是完全相同时会比较出错&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方法二：&lt;code&gt;getOwnPropertyNames&lt;/code&gt;该方法可以将Object对象的第一层key获取到并返回一个由第一层key组成的数组。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：相对方法一进行了优化，可以应对不同顺序的Object进行比较，不用担心顺序不同而对比出错&lt;/li&gt;
&lt;li&gt;缺点：从方法中可以看到只能获取到第一层的key组成的数组，当对象是复合对象时无法进行多层对象的比较&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// 对Object扩展一个方法chargeObjectEqual
Object.prototype.chargeObjectEqual = function(obj){
    // 当前Object对象
    var propsCurr = Object.getOwnPropertyNames(this);
    // 要比较的另外一个Object对象
    var propsCompare = Object.getOwnPropertyNames(obj);
    if (propsCurr.length != propsCompare.length) {
        return false;
    }
    for (var i = 0,max = propsCurr.length; i &amp;lt; max; i++) {
        var propName = propsCurr[i];
        if (this[propName] !== obj[propName]) {
            return false;
        }
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;16-事件模型&#34;&gt;16. 事件模型&lt;/h1&gt;
&lt;h2 id=&#34;1基本概念&#34;&gt;1.基本概念&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;事件代理&lt;/strong&gt;（Event Delegation），又称之为事件委托。是JavaScript中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定在子元素的响应事件（click、keydown......）委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。&lt;/p&gt;
&lt;h2 id=&#34;2-事件传播&#34;&gt;2. 事件传播&lt;/h2&gt;
&lt;p&gt;一个事件触发后，会在子元素和父元素之间&lt;strong&gt;传播&lt;/strong&gt;（propagation）。这种传播分成三个阶段&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615169023216.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如上图所示，事件传播分成三个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;捕获阶段：从window对象传导到目标节点（上层传到底层）称为“捕获阶段”（capture phase），捕获阶段不会响应任何事件；&lt;/li&gt;
&lt;li&gt;目标阶段：在目标节点上触发，称为“目标阶段”&lt;/li&gt;
&lt;li&gt;冒泡阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。&lt;strong&gt;事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-事件冒泡和捕获&#34;&gt;3. 事件冒泡和捕获&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;冒泡&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;就是从事件 目标 的事件处理函数开始，依次向外，直到 window 的事件处理函数触发（先执行目标元素事件，再依次执行父元素事件）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;捕获&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;就是从 window 的事件处理函数开始，依次向内，直到事件 目标 的事件处理函数执行（最后才执行目标元素）&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619616013812.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;阻止事件传播&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果想只触发当前点击对象的事件，不想让外层的事件触发 ，可以使用不冒泡&lt;strong&gt;e.cancelBubble=true&lt;/strong&gt;或不传播 &lt;strong&gt;e.stopPropagation()&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;var box = document.querySelector(&#39;.box&#39;)
    var atr = document.querySelector(&#39;.atr&#39;)
    box.onclick = function (e) {
        e.stopPropagation() // 不传播
        console.log(&#39;我被点击了box&#39;)
    }
    atr.onclick = function (e) {
        e.cancelBubble=true //不冒泡
        console.log(&#39;我被点击了atr&#39;)
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-事件委托&#34;&gt;4. 事件委托&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;因为我们的冒泡机制，点击子元素的时候，也会同步触发父元素的相同事件 ，所以我们就可以把子元素的事件委托给父元素来做&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;点击子元素的时候，不管子元素有没有点击事件，只要父元素有点击事件，那么就可以触发父元素的点击事件&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt; atr.onclick = function (e) {
        // e.stopPropagation()
        var e = e || window.event //event兼容写法
        var target = e.target || e.srcElement //target兼容写法
        console.log(target,&#39;执行子盒子的点击事件&#39;)
    }
box.onclick = function (e) {
        var e = e || window.event //event兼容写法
        var target = e.target || e.srcElement //target兼容写法
        console.log(target,&#39;执行父盒子的点击事件&#39;)
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;target&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;target 这个属性是事件对象里面的属性，表示你点击的目标&lt;/li&gt;
&lt;li&gt;当你触发点击事件的时候，你点击在哪个元素上，target 就是哪个元素&lt;/li&gt;
&lt;li&gt;这个 target 也不兼容，在 IE 下要使用 srcElement&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;委托&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个时候，当我们点击 box里面的元素的时候，也可以触发 box 的点事件&lt;/li&gt;
&lt;li&gt;并且在事件内部，我们也可以拿到你点击的到底是哪个对象&lt;/li&gt;
&lt;li&gt;这个时候，我们就可以把 li 的事件委托给 box 父级来做&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;var box = document.querySelector(&#39;.box&#39;)
    var atr = document.querySelector(&#39;.atr&#39;)
    
    atr.onclick = function (e) {
        var e = e || window.event //event兼容写法
        var target = e.target || e.srcElement //target兼容写法
        if(target.className==&#39;atr&#39;){
            //这里面就找到需要操作的元素
            console.log(111)
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-事件委托的优点&#34;&gt;5. 事件委托的优点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;【1】可以大量节省内存占用，减少事件注册，比如在ul上代理所有li的click事件就非常棒&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【2】可以实现当新增子对象时无需再次对其绑定（动态绑定事件）&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;6-事件的默认行为&#34;&gt;6. 事件的默认行为&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;默认行为，就是不用我们注册，它自己就存在的事情&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比如我们点击鼠标右键的时候，会自动弹出一个菜单&lt;/li&gt;
&lt;li&gt;比如我们点击 a 标签的时候，我们不需要注册点击事件，他自己就会跳转页面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;这些不需要我们注册就能实现的事情，我们叫做默认事件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;阻止默认行为&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619617595767.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var oA = document.querySelector(&#39;a&#39;)
    a.addEventListener(&#39;click&#39;, function (e) {
        e = e || window.event
        console.log(this.href)
        //下面这个是兼容写法
        e.preventDefault ? e.preventDefault() : e.returnValue = false
    })
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7-如何让事件先冒泡后捕获&#34;&gt;7. 如何让事件先冒泡后捕获&lt;/h2&gt;
&lt;p&gt;若要实现先冒泡后捕获，给一个元素绑定两个addEventListener，其中一个第三个参数设置为false（即冒泡），另一个第三个参数设置为true（即捕获），调整它们的代码顺序，将设置为false的监听事件放在设置为true的监听事件前面即可。&lt;/p&gt;
&lt;h1 id=&#34;17-dom基本操作获取元素-节点的创建和添加-节点的替换和删除&#34;&gt;17. DOM基本操作（获取元素、节点的创建和添加、节点的替换和删除）&lt;/h1&gt;
&lt;h2 id=&#34;1-获取元素&#34;&gt;1. 获取元素&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;document.getElementById&lt;/code&gt;通过id名字获取节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
        &amp;lt;ul&amp;gt;
            &amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;document.getElementsByClassName&lt;/code&gt;通过class名字获取节点 获取的是一个数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;
        &amp;lt;ul&amp;gt;
            &amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementsByClassName(&amp;quot;box&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在HTML与CSS里.class类名是&lt;code&gt;可以重复&lt;/code&gt;使用的，在页面上可能出现多个重复的.class类名，他是获取到多个把获取到多个放在数组里&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementsByClassName(&amp;quot;box&amp;quot;)[0]
 //通过下标来换取索引0的值也可以获取别的索引值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;document.getElementsByTagName&lt;/code&gt; 通过标签名字获取节点 获取的是一个数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;
        &amp;lt;ul&amp;gt;
            &amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var aBox = document.getElementsByTagName(&amp;quot;div&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618115504124.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;那么如何获取数组里面的值呢？？？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;var aBox = document.getElementsByTagName(&amp;quot;div&amp;quot;)[2];//通过下标来换取索引2的值
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618115545753.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;document.querySelectorAll&lt;/code&gt; 通过复合（层级）选择器获取节点 获取的是一个数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;
        &amp;lt;ul&amp;gt;
            &amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; var  aLi = document.querySelectorAll(&amp;quot;.box ul li&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618115797303.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;那么如何获取数组里面的值呢？？？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;var aLi  = document.querySelectorAll(&amp;quot;.box ul li&amp;quot;)[1];
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618115827067.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;document.querySelector&lt;/code&gt; 通过复合（层级）选择器获取符合条件的第一个节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var oLi = document.querySelector(&amp;quot;.box ul li&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618115873612.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;document.getElementsByName&lt;/code&gt; 通过name属性获取节点 获取的是一个数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;sex&amp;quot; value=&amp;quot;男&amp;quot;&amp;gt;男
&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;sex&amp;quot; value=&amp;quot;女&amp;quot;&amp;gt;女
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var aInput = document.getElementsByName(&amp;quot;sex&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618116016375.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;获取特殊元素的方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;document.head&lt;/code&gt; 获取&lt;code&gt;head&lt;/code&gt;标签&lt;/li&gt;
&lt;li&gt;&lt;code&gt;document.body&lt;/code&gt; 获取&lt;code&gt;body&lt;/code&gt;标签&lt;/li&gt;
&lt;li&gt;&lt;code&gt;document.documentElement&lt;/code&gt; 获取&lt;code&gt;html&lt;/code&gt;标签&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618116077529.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-节点的创建和添加创建完一定要添加&#34;&gt;2. 节点的创建和添加（创建完一定要添加）&lt;/h2&gt;
&lt;h3 id=&#34;1-节点的创建&#34;&gt;1. 节点的创建&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;document.createElement&lt;/code&gt; 创建元素节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; var oDiv = document.createElement(&amp;quot;div&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如何把这个属性节点添加到DOM树中?&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
        &amp;lt;span&amp;gt;我是haven&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
var oDiv = document.createElement(&amp;quot;div&amp;quot;);
oBox.appendChild(oDiv); 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618116529080.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;document.createTextNode&lt;/code&gt;创建文本节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var oText = document.createTextNode(&amp;quot;heaven&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如何把这个文本节点添加到DOM树中?&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
    &amp;lt;span&amp;gt;我是haven&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
var oText = document.createTextNode(&amp;quot;heaven&amp;quot;);
oBox.appendChild(oText);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618116715791.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;document.createComment&lt;/code&gt; 创建注释节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var oComment = document.createComment(&amp;quot;我是注释节点&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如何把这个注释节点添加到DOM树中?&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
    &amp;lt;span&amp;gt;我是haven&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var obox = document.getElementById(&amp;quot;box&amp;quot;);
var oComment = document.createComment(&amp;quot;我是注释节点&amp;quot;);
obox.appendChild(oComment);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618117356273.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-节点的添加-剪切操作&#34;&gt;2. 节点的添加、剪切操作&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;parentNode.appendChild(子节点)&lt;/code&gt; 把子节点插入到父节点的最后面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
   &amp;lt;span&amp;gt;我是haven&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
var oDiv = document.createElement(&amp;quot;div&amp;quot;);
oBox.appendChild(oDiv);//把oDiv插入到oBox的最后面是以字符串形式添加的
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618117728592.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;parentNode.insertBefore(A,B)&lt;/code&gt; 把节点A添加到节点B之前&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
        &amp;lt;h2&amp;gt;我是标题&amp;lt;/h2&amp;gt;
        &amp;lt;span&amp;gt;我是haven&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; var oBox = document.getElementById(&amp;quot;box&amp;quot;);
 var oSpan = document.getElementsByTagName(&amp;quot;span&amp;quot;)[0];
 var oDiv = document.createElement(&amp;quot;div&amp;quot;);
 oBox.insertBefore(oDiv,oSpan);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618117898677.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;结论：无论是appendChild方法还是insertBefore方法都可以对节点的 添加、剪切操作，都可以操作一次不能操作多次&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-节点的替换和删除&#34;&gt;3. 节点的替换和删除&lt;/h2&gt;
&lt;h3 id=&#34;1节点的替换&#34;&gt;1.节点的替换&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;parentNode.replaceChild(A,B)&lt;/code&gt; 用节点A替换节点B&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
    &amp;lt;h2&amp;gt;我是标题2&amp;lt;/h2&amp;gt;
    &amp;lt;span&amp;gt;我是heaven&amp;lt;/span&amp;gt;
    &amp;lt;h3&amp;gt;我是标题3&amp;lt;/h3&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
var oH3 = document.getElementsByTagName(&amp;quot;h3&amp;quot;)[0]
var oDiv = document.createElement(&amp;quot;div&amp;quot;);
oBox.replaceChild(oDiv,oH3);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618119399959.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-节点的删除-删除子节点&#34;&gt;2. 节点的删除 、删除子节点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;parentNode.removeChild(子节点)&lt;/code&gt; 删除子节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
    &amp;lt;h2&amp;gt;我是标题2&amp;lt;/h2&amp;gt;
    &amp;lt;span&amp;gt;我是heaven&amp;lt;/span&amp;gt;
    &amp;lt;h3&amp;gt;我是标题3&amp;lt;/h3&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
var oH3 = document.getElementsByTagName(&amp;quot;h3&amp;quot;);
oBox.removeChild(oH3[0]);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618119515957.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;4-动态获取与静态获取&#34;&gt;4. 动态获取与静态获取&lt;/h2&gt;
&lt;h3 id=&#34;1-get系列获取元素的方式是动态获取&#34;&gt;1. get系列获取元素的方式是动态获取&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;动态获取指的是：在获取节点之后还可以检测出符合条件的节点、并放置到集合中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;  &amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
        &amp;lt;h3&amp;gt;1&amp;lt;/h3&amp;gt;
        &amp;lt;h3&amp;gt;2&amp;lt;/h3&amp;gt;
        &amp;lt;h3&amp;gt;3&amp;lt;/h3&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
var oH3 = document.getElementsByTagName(&amp;quot;h3&amp;quot;);
var h3 = document.createElement(&amp;quot;h3&amp;quot;);
oBox.appendChild(h3);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618119951624.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;动态获取的方式是能再次感知到用js的方法添加新的标签的&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-query系列获取元素的方式是静态态获取&#34;&gt;2. query系列获取元素的方式是静态态获取&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;静态获取指的是：在获取节点之后无法检测出符合条件的节点、不能放置到集合中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
var oH3 = document.querySelectorAll(&amp;quot;h3&amp;quot;);
var h3 = document.createElement(&amp;quot;h3&amp;quot;);
oBox.appendChild(h3);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618120005689.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
静态获取的方式是不能能再次感知到用js的方法添加新的标签的&lt;/p&gt;
&lt;h2 id=&#34;5-如何在创建空节点的时候添加内容&#34;&gt;5. 如何在创建空节点的时候添加内容&lt;/h2&gt;
&lt;h3 id=&#34;1-元素节点&#34;&gt;1. 元素节点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;innerText&lt;/code&gt; 可以设置节点的文本内容、也可以读取节点的内容、&lt;code&gt;不可以解析&lt;/code&gt;标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
    &amp;lt;h3&amp;gt;1&amp;lt;/h3&amp;gt;
    &amp;lt;h3&amp;gt;2&amp;lt;/h3&amp;gt;
    &amp;lt;h3&amp;gt;3&amp;lt;/h3&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
var oH3 = document.createElement(&amp;quot;h3&amp;quot;);
oBox.appendChild(oH3);
oH3.innerText = &amp;quot;我是h3节点&amp;quot;;//创建h3标签添加文本内容
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618120681297.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;那么如何读取元素节点的内容呢？？&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
var oH3 = document.querySelectorAll(&amp;quot;h3&amp;quot;);
console.log(oH3[2].innerText);//读取节点的文本内容
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618121295691.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;修改并赋值&lt;/strong&gt;&lt;code&gt;innerText&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
var oH3 = document.querySelectorAll(&amp;quot;h3&amp;quot;);
oH3[0].innerText = &amp;quot;我是修改并赋值的节点&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618121299074.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-元素节点&#34;&gt;2. 元素节点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;innerHTML&lt;/code&gt;可以设置节点的文本内容、也可以读取节点的内容、可以&lt;code&gt;解析&lt;/code&gt;标签&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;怎么样innerHTML方法解析字符串中的标签&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
var oH3 = document.querySelectorAll(&amp;quot;h3&amp;quot;);
oH3[0].innerHTML = &amp;quot;&amp;lt;a&amp;gt;我是修改后的文本节点的内容&amp;lt;/a&amp;gt;&amp;quot;;
console.log(oH3[0].innerHTML);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打印的结果是用&lt;code&gt;innerHTML&lt;/code&gt;替换的结果&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618121585550.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;6-元素节点的常用方法&#34;&gt;6. 元素节点的常用方法&lt;/h2&gt;
&lt;h3 id=&#34;1-属性集合&#34;&gt;1. 属性集合&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
    &amp;lt;h3 class=&amp;quot;no&amp;quot;&amp;gt;测试标题&amp;lt;/h3&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如何拿到&lt;code&gt;h3&lt;/code&gt;标签的属性集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
        console.log(oBox.children[0].attributes);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618123899949.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-设置属性节点&#34;&gt;2. 设置属性节点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;setAttribute&lt;/code&gt;(属性节点名,属性节点值)、设置指定的属性节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
    &amp;lt;h3 class=&amp;quot;no&amp;quot;&amp;gt;测试标题&amp;lt;/h3&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
oBox.children[0].setAttribute(&amp;quot;id&amp;quot;, &amp;quot;title&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618124020361.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;3-获取属性节点&#34;&gt;3. 获取属性节点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;getAttribute&lt;/code&gt;(属性节点名)、获取指定属性节点名称的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
console.log(oBox.children[0].getAttribute(&amp;quot;class&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618124061317.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;4-删除属性节点&#34;&gt;4. 删除属性节点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;removeAttribute&lt;/code&gt;(属性节点名)、删除指定属性节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;box&amp;quot;&amp;gt;
    &amp;lt;h3 class=&amp;quot;no&amp;quot;&amp;gt;测试标题&amp;lt;/h3&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
oBox.children[0].removeAttribute(&amp;quot;class&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618124130227.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;5-判断有没有子节点&#34;&gt;5. 判断有没有子节点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;hasChildNodes&lt;/code&gt; 判断元素节点有没有子节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var oBox = document.getElementById(&amp;quot;box&amp;quot;);
console.log(oBox.children[0].hasChildNodes());
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618124186614.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;如果有则返回返回结果是true&lt;/li&gt;
&lt;li&gt;如果没有则返回结果是是false&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;18-js遍历dom树&#34;&gt;18. js遍历dom树&lt;/h1&gt;
&lt;h2 id=&#34;1-遍历dom树&#34;&gt;1. 遍历dom树&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
  &amp;lt;title&amp;gt;遍历DOM树&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;遍历 DOM 树&amp;lt;/h1&amp;gt;
&amp;lt;p style=&amp;quot;color: green;&amp;quot;&amp;gt;Tip: 可以在遍历的回调函数中任意定制需求&amp;lt;/p&amp;gt;
&amp;lt;div&amp;gt;
  &amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;123&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;456&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;789&amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;div&amp;gt;
      &amp;lt;span&amp;gt;haha&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;demo_node&amp;quot;&amp;gt;
  &amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;123&amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
  &amp;lt;p&amp;gt;hello&amp;lt;/p&amp;gt;
  &amp;lt;h2&amp;gt;world&amp;lt;/h2&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;dsa&amp;lt;/p&amp;gt;
    &amp;lt;h3&amp;gt;
      &amp;lt;span&amp;gt;dsads&amp;lt;/span&amp;gt;
    &amp;lt;/h3&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;

  //获取页面中的根节点--根标签
  var root=document.documentElement;//html
  //函数遍历DOM树
  //根据根节点,调用fn的函数,显示的是根节点的名字
  function forDOM(root1) {
    //调用f1,显示的是节点的名字
   // f1(root1);
    //获取根节点中所有的子节点
    var children=root1.children;
    //调用遍历所有子节点的函数
    forChildren(children);
  }
  //给我所有的子节点,我把这个子节点中的所有的子节点显示出来
  function forChildren(children) {
    //遍历所有的子节点
    for(var i=0;i&amp;lt;children.length;i++){
      //每个子节点
      var child=children[i];
      //显示每个子节点的名字
      f1(child);
      //判断child下面有没有子节点,如果还有子节点,那么就继续的遍历
      child.children&amp;amp;&amp;amp;forDOM(child);
    }
  }
  //函数调用,传入根节点
  forDOM(root);
  function f1(node) {
    console.log(&amp;quot;节点的名字:&amp;quot;+node.nodeName);
  }
  //节点:nodeName,nodeType,nodeValue

&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-多叉-dom-树的遍历&#34;&gt;2. 多叉 DOM 树的遍历&lt;/h2&gt;
&lt;h3 id=&#34;1-广度优先遍历&#34;&gt;1. 广度优先遍历&lt;/h3&gt;
&lt;p&gt;首先遍历根节点，然后访问第一层节点，第二层节点，....,直到访问到最后一层。&lt;br&gt;
借助于队列，用非递归的方式对多叉树进行遍历&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Tree.prototype.BFSearch =  function(node,callback){  
    var queue=[];  
    while(node!=null){          
           callback(node);  
       if(node.children.length!=0){  
        for (var i=0;i&amp;lt;node.children.length;i++){  
            queue.push(node.children[i]);//借助于队列,暂存当前节点的所有子节点  
        }   
        }  
            node=queue.shift();//先入先出，借助于数据结构：队列  
    }         
};  
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-深度优先遍历&#34;&gt;2. 深度优先遍历&lt;/h3&gt;
&lt;p&gt;首先遍历根节点，然后沿着一条路径遍历到最深的一层，最后在逐层返回。&lt;br&gt;
借助于栈,实现多叉 DOM树 的深度优先遍历。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Tree.prototype.DFSearch =  function(node,callback){  
        var stack=[];         
        while(node!=null){  
        callback(node);  
        if(node.children.length!=0){  
        for (var i=node.children.length-1;i&amp;gt;=0;i--){//按照相反的子节点顺序压入栈  
            stack.push(node.children[i]);//将该节点的所有子节点压入栈  
        }  
        }  
            node = stack.pop();//弹出栈的子节点顺序就是原来的正确顺序(因为栈是先入后出的)        
    }     
};  
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;19-面试查缺补漏&#34;&gt;19. 面试查缺补漏&lt;/h1&gt;
&lt;h2 id=&#34;1-js页面跳转方式&#34;&gt;1. JS页面跳转方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;window.location.href= &#39;url&#39;: 比较常用的方法，直接跟指定要跳转的地方。&lt;/li&gt;
&lt;li&gt;window.history.back(-1);: 参见的浏览器返回上一个已访问的页面，直到访问最初访问的页面。&lt;/li&gt;
&lt;li&gt;window.navigate(&amp;quot;url&amp;quot;);: navigate对象包含有关浏览器的信息，也可以作为页面跳转，后面直接加要跳转的地方。&lt;/li&gt;
&lt;li&gt;top.location= &#39;url&#39;;: 当页面中有内嵌框架时，指定最顶层的窗口跳转，及包含框架的最外层浏览器&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618478544386.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;2-js弹出框有哪些&#34;&gt;2. JS弹出框有哪些&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;第一种：alert()方法&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618479050149.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;第二种：confirm()方法&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618479053584.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;第三种： prompt()方法&lt;/strong&gt;&lt;br&gt;
不但可以显示信息，而且还提供了一个文本框要求用户使用键盘输入自己的信息，同时她还包含“确认”或“取消”两个按钮，如果用户“确认”按钮，则prompt()方法返回用户在文本框中输入的内容（是字符串类型)或者初始值(如果用户没有输入信息);如果用户单击“取消”按钮，则prompt()方法返回null&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618479103065.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618479124548.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-url编码和解码的方式&#34;&gt;3. url编码和解码的方式&lt;/h2&gt;
&lt;h3 id=&#34;1-为什么要url编码&#34;&gt;1. 为什么要URL编码？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在因特网上传送URL，只能采用ASCII字符集&lt;/strong&gt;&lt;br&gt;
只有字母和数字[0-9a-zA-Z]、一些特殊符号$-_.+!*&#39;()[不包括双引号]、以及某些保留字（空格转换为+），才可以不经过编码直接用于URL&lt;/p&gt;
&lt;p&gt;这意味着 如果URL中有汉字，就必须编码后使用。&lt;/p&gt;
&lt;h3 id=&#34;2-js编码函数&#34;&gt;2. JS编码函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;encodeURI函数(推荐使用)&lt;/strong&gt;&lt;br&gt;
这个函数才是javascript中真正用来对URL编码的函数&lt;/p&gt;
&lt;p&gt;它着眼于对整个URL进行编码，因此除了常见的符号以外，对其他一些在网址中有特殊含义的符号&amp;quot;; / ? : @ &amp;amp; = + $ , #&amp;quot;，也不进行编码。编码后，它输出符号的utf-8形式，并且在每个字节前加上%。&lt;br&gt;
需要注意的是，它不对单引号’编码&lt;/p&gt;
&lt;p&gt;它对应的解码函数是decodeURI()。&lt;/p&gt;
&lt;h3 id=&#34;3-为什么两次编码&#34;&gt;3. 为什么两次编码&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618481823390.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;4-meta常用属性&#34;&gt;4. meta常用属性&lt;/h2&gt;
&lt;h3 id=&#34;1-charset属性&#34;&gt;1. charset属性&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 定义网页文档的字符集 --&amp;gt;
&amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-name-content属性&#34;&gt;2. name + content属性&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 网页作者 --&amp;gt;
&amp;lt;meta name=&amp;quot;author&amp;quot; content=&amp;quot;开源技术团队&amp;quot;/&amp;gt;
&amp;lt;!-- 网页地址 --&amp;gt;
&amp;lt;meta name=&amp;quot;website&amp;quot; content=&amp;quot;https://sanyuan0704.github.io/frontend_daily_question/&amp;quot;/&amp;gt;
&amp;lt;!-- 网页版权信息 --&amp;gt;
 &amp;lt;meta name=&amp;quot;copyright&amp;quot; content=&amp;quot;2018-2019 demo.com&amp;quot;/&amp;gt;
&amp;lt;!-- 网页关键字, 用于SEO --&amp;gt;
&amp;lt;meta name=&amp;quot;keywords&amp;quot; content=&amp;quot;meta,html&amp;quot;/&amp;gt;
&amp;lt;!-- 网页描述 --&amp;gt;
&amp;lt;meta name=&amp;quot;description&amp;quot; content=&amp;quot;网页描述&amp;quot;/&amp;gt;
&amp;lt;!-- 搜索引擎索引方式，一般为all，不用深究 --&amp;gt;
&amp;lt;meta name=&amp;quot;robots&amp;quot; content=&amp;quot;all&amp;quot; /&amp;gt;
&amp;lt;!-- 移动端常用视口设置 --&amp;gt;
&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1.0,maximum-scale=1.0, user-scalable=no&amp;quot;/&amp;gt;
&amp;lt;!-- 
  viewport参数详解：
  width：宽度（数值 / device-width）（默认为980 像素）
  height：高度（数值 / device-height）
  initial-scale：初始的缩放比例 （范围从&amp;gt;0 到10）
  minimum-scale：允许用户缩放到的最小比例
  maximum-scale：允许用户缩放到的最大比例
  user-scalable：用户是否可以手动缩 (no,yes)
 --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-http-equiv属性&#34;&gt;3. http-equiv属性&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- expires指定网页的过期时间。一旦网页过期，必须从服务器上下载。 --&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;expires&amp;quot; content=&amp;quot;Fri, 12 Jan 2020 18:18:18 GMT&amp;quot;/&amp;gt;
&amp;lt;!-- 等待一定的时间刷新或跳转到其他url。下面1表示1秒 --&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;refresh&amp;quot; content=&amp;quot;1; url=https://www.baidu.com&amp;quot;/&amp;gt;
&amp;lt;!-- 禁止浏览器从本地缓存中读取网页，即浏览器一旦离开网页在无法连接网络的情况下就无法访问到页面。 --&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;pragma&amp;quot; content=&amp;quot;no-cache&amp;quot;/&amp;gt;
&amp;lt;!-- 也是设置cookie的一种方式，并且可以指定过期时间 --&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;set-cookie&amp;quot; content=&amp;quot;name=value expires=Fri, 12 Jan 2001 18:18:18 GMT,path=/&amp;quot;/&amp;gt;
&amp;lt;!-- 使用浏览器版本 --&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=edge,chrome=1&amp;quot; /&amp;gt;
&amp;lt;!-- 针对WebApp全屏模式，隐藏状态栏/设置状态栏颜色，content的值为default | black | black-translucent --&amp;gt;
&amp;lt;meta name=&amp;quot;apple-mobile-web-app-status-bar-style&amp;quot; content=&amp;quot;black-translucent&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-a标签实现打电话&#34;&gt;5. a标签实现打电话&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;最常用WEB页面JS实现一键拨号的电话拨打功能：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;tel:13764567708&amp;quot;&amp;gt;移动WEB页面JS一键拨打号码咨询功能&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在拨号界面，显示号码，并提示拨打。支持大部分的浏览器，但是在QQ浏览器上支持不好。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;最常用WEB页面JS实现一键发送短信功能：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;sms:13764567708&amp;quot;&amp;gt;移动WEB页面JS一键发送短信咨询功能&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在信息录入界面，显示发送号码，并提示录入信息。&lt;/p&gt;
&lt;p&gt;支持大部分的浏览器，但是在QQ浏览器上支持不好。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;最常用WEB页面发邮件：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;mailto:youemail@mail.com?subject=邮件标题&amp;amp;body=邮件内容&amp;quot;&amp;gt;告诉我们&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-css哪些属性可以继承&#34;&gt;6. CSS哪些属性可以继承？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;css继承特性主要是指文本方面的继承，盒模型相关的属性基本没有继承特性&lt;/strong&gt;。&lt;br&gt;
&lt;code&gt;不可继承的&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、top、bottom、left、right、z-index、float、clear、 table-layout、vertical-align、page-break-after&lt;/p&gt;
&lt;p&gt;&lt;code&gt;所有元素可继承的&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;visibility和cursor&lt;/p&gt;
&lt;p&gt;&lt;code&gt;终极块级元素可继承的&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;text-indent和text-align&lt;/p&gt;
&lt;p&gt;&lt;code&gt;内联元素可继承的&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction&lt;/p&gt;
&lt;p&gt;&lt;code&gt;列表元素可继承的&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;list-style、list-style-type、list-style-position、list-style-image&lt;/p&gt;
&lt;h2 id=&#34;7-windowscroll方法&#34;&gt;7. window.scroll方法&lt;/h2&gt;
&lt;h3 id=&#34;1-windowscroll到&#34;&gt;1. window.scroll（到）&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618490087718.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2windowscrollto&#34;&gt;2.window.scrollTo&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618490106662.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;与scroll一样&lt;/p&gt;
&lt;h3 id=&#34;3-windowscrollby距离&#34;&gt;3. window.scrollBy（距离）&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1618490176094.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;8-head头包含哪些标签&#34;&gt;8. head头包含哪些标签？&lt;/h2&gt;
&lt;p&gt;head标签是所有头部元素的容器。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;head&amp;gt;内的元素可包含脚本，指示浏览器在何处可以找到样式表，提供元信息等。
可添加到head部分的标签：&amp;lt;title&amp;gt;、&amp;lt;base&amp;gt;、&amp;lt;meta&amp;gt;、&amp;lt;link&amp;gt;、&amp;lt;script&amp;gt;、&amp;lt;style&amp;gt;:
&amp;lt;title&amp;gt;：指定整个网页的标题，在浏览器最上方显示。
&amp;lt;base&amp;gt;:为页面上的所有链接规定默认地址或默认目标(target)。
&amp;lt;meta&amp;gt;：提供有关页面的基本信息。
&amp;lt;link&amp;gt;：定义文档与外部资源的关系。
&amp;lt;script&amp;gt;:定义客户端脚本，如JavaScript。
&amp;lt;style&amp;gt;:定义内部样式表与网页的关系。
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;17-window的onload事件和domcontentloaded&#34;&gt;17. window的onload事件和domcontentloaded&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;DOMContentLoaded方法是当DOM加载完成，不包括样式表，图片，flash触发的事件&lt;/li&gt;
&lt;li&gt;onload事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了，用于检测一个加载完全的页面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开发中我们经常需要给一些元素的事件绑定处理函数。但问题是，如果那个元素还没有加载到页面上，但是绑定事件已经执行完了，是没有效果的。这两个事件大致就是用来避免这样一种情况，将绑定的函数放在这两个事件的回调中，保证能在页面的某些元素加载完毕之后再绑定事件的函数。&lt;/p&gt;
&lt;p&gt;当然DOMContentLoaded机制更加合理，因为我们可以容忍图片，flash延迟加载，却不可以容忍看见内容后页面不可交互。&lt;/p&gt;
&lt;h1 id=&#34;18-forin迭代和forof有什么区别&#34;&gt;18. for...in迭代和for...of有什么区别&lt;/h1&gt;
&lt;h2 id=&#34;1-forin&#34;&gt;1. for…in&lt;/h2&gt;
&lt;p&gt;for…in 循环返回的值是数据的结构的&lt;strong&gt;key&lt;/strong&gt;(类比键值名)&lt;br&gt;
&lt;code&gt;遍历对象&lt;/code&gt;返回的对象&lt;code&gt;key&lt;/code&gt;值，&lt;code&gt;遍历数组&lt;/code&gt;返回的数组的&lt;code&gt;下标&lt;/code&gt;（key）&lt;br&gt;
for…in 不仅可以遍历数字 键名，还会遍历原型上的值和手动添加其他的键&lt;br&gt;
for…in 循环出的是（key）&lt;br&gt;
总结：&lt;br&gt;
for…in 循环特别适合遍历对象&lt;/p&gt;
&lt;h2 id=&#34;2-forof&#34;&gt;2. for…of&lt;/h2&gt;
&lt;p&gt;for…of 是ES6新引入的特性。修复了ES5引入的for…in的不足支持set().map()&lt;br&gt;
for…of不能循环普通的对象，需要通过和OBject.Keys()搭配使用&lt;br&gt;
for…of不同与forEach&lt;br&gt;
它可以与break.continue和return 配合使用&lt;br&gt;
for…of 循环可以随时推出循环&lt;br&gt;
for…of 循环出的是（&lt;strong&gt;value&lt;/strong&gt;）&lt;br&gt;
总结：&lt;br&gt;
for…of 循环特别适合&lt;code&gt;遍历数组&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;19-函数柯里化-和-高阶函数&#34;&gt;19. 函数柯里化 和 高阶函数&lt;/h1&gt;
&lt;h2 id=&#34;1-函数柯里化&#34;&gt;1. 函数柯里化&lt;/h2&gt;
&lt;p&gt;柯里化，是函数式编程的一个重要概念。它既能减少代码冗余，也能增加可读性。&lt;br&gt;
&lt;strong&gt;定义&lt;/strong&gt;：在数学和计算机科学中，柯里化是一种将使用&lt;strong&gt;多个参数&lt;/strong&gt;的一个函数转换成一系列使用&lt;strong&gt;一个参数&lt;/strong&gt;的函数的技术。&lt;br&gt;
&lt;code&gt;简单版：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function add(a) {
  function sum(b) { // 使用闭包
      a = a + b; // 累加
      return sum;
   }
   sum.toString = function() { // 重写toString()方法
      return a;
  }
   return sum; // 返回一个函数
}

add(1); // 1
add(1)(2);  // 3
add(1)(2)(3) // 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;完整版：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function add() {
  // 第一次执行时，定义一个数组专门用来存储所有的参数
  var _args = [].slice.call(arguments);

  // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值
  var adder = function () {
      var _adder = function() {
          _args.push(...arguments);
          return _adder;
      };

      // 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回
      _adder.toString = function () {
          return _args.reduce(function (a, b) {
              return a + b;
          });
      }

      return _adder;
  }
  return adder(..._args);
}

var a = add(1)(2)(3)(4);   // f 10
var b = add(1, 2, 3, 4);   // f 10
var c = add(1, 2)(3, 4);   // f 10
var d = add(1, 2, 3)(4);   // f 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数的柯里化，是 Javascript 中函数式编程的一个重要概念。&lt;code&gt;它返回的，是一个函数的函数&lt;/code&gt;。其实现方式，需要依赖&lt;code&gt;参数以及递归&lt;/code&gt;，通过&lt;code&gt;拆分参数&lt;/code&gt;的方式，来调用一个多参数的函数方法，以达到减少代码冗余，增加可读性的目的。&lt;/p&gt;
&lt;h2 id=&#34;2-高阶函数&#34;&gt;2. 高阶函数&lt;/h2&gt;
&lt;h3 id=&#34;1-arrayprototypemap&#34;&gt;1. Array.prototype.map&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;map()&lt;/code&gt;(映射)方法最后生成一个新数组，不改变原始数组的值。其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array.map(callback,[ thisObject]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;callback(回调函数)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[].map(function(currentValue, index, array) {
    // ...
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;传递给&lt;code&gt;map&lt;/code&gt;的回调函数（&lt;code&gt;callback&lt;/code&gt;）接受三个参数，分别是&lt;code&gt;currentValue&lt;/code&gt;——正在遍历的元素；&lt;code&gt;index&lt;/code&gt;（可选）——元素索引；&lt;code&gt;array&lt;/code&gt;（可选）——原数组本身，除了 callback 之外还可以接受 this 值（可选），用于执行 callback 函数时使用的this 值。&lt;/p&gt;
&lt;p&gt;来个简单的例子方便理解，现在有一个数组[1,2,3,4]，我们想要生成一个新数组，其每个元素皆是之前数组的两倍&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const arr1 = [1, 2, 3, 4];
const arr2 = arr1.map(item =&amp;gt; item * 2);

console.log( arr2 );
// [2, 4, 6, 8]
console.log( arr1 );
// [1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;map高阶函数注意点&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;callback需要有return值，否则会出现所有项映射为undefind；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;].map(parseInt);
//输出结果为  [1,NaN,NaN]

[&amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;3&amp;quot;].map(x=&amp;gt;parseInt(x));
//输出结果为  [1,2,3]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-arrayprototypereduce&#34;&gt;2. Array.prototype.reduce&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;reduce()&lt;/code&gt;方法对数组中的每个元素执行一个提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值。传递给 reduce 的回调函数（callback）接受四个参数，分别是累加器 &lt;code&gt;accumulator&lt;/code&gt;；&lt;code&gt;currentValue&lt;/code&gt;——正在操作的元素；&lt;code&gt;currentIndex&lt;/code&gt;（可选）——元素索引，但是它的开始会有特殊说明；&lt;code&gt;array&lt;/code&gt;（可选）——原始数组本身，除了 callback 之外还可以接受初始值 initialValue 值（可选）。&lt;/p&gt;
&lt;p&gt;例子，现在有一个数组 [0, 1, 2, 3, 4]，需要计算数组元素的和，需求比较简单，来看下代码实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const arr = [0, 1, 2, 3, 4];
let sum = arr.reduce((accumulator, currentValue, currentIndex, array) =&amp;gt; {
  return accumulator + currentValue;
});

console.log( sum );
// 10
console.log( arr );
// [0, 1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615256323803.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;3-arrayprototypefilter&#34;&gt;3. Array.prototype.filter&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;filter&lt;/code&gt;(过滤，筛选) 方法创建一个新数组,原始数组不发生改变。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array.filter(callback,[ thisObject]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接收的参数和 map 是一样的，filter的&lt;code&gt;callback&lt;/code&gt;函数需要返回布尔值true或false. 如果为true则表示通过啦！如果为false则失败，其返回值是一个新数组，由通过测试为true的所有元素组成，如果没有任何数组元素通过测试，则返回空数组。&lt;/p&gt;
&lt;p&gt;来个例子介绍下，现在有一个数组 [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]，我们想要生成一个新数组，这个数组要求没有重复的内容，即为去重。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const arr1 = [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4];
const arr2 = arr1.filter( (element, index, self) =&amp;gt; {
    return self.indexOf( element ) === index;
});

console.log( arr2 );
// [1, 2, 3, 5, 4]
console.log( arr1 );
// [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;20-call-与-apply区别原生实现bind&#34;&gt;20.  call 与 apply区别，原生实现bind&lt;/h1&gt;
&lt;h2 id=&#34;1-call-和-apply-的共同点&#34;&gt;1. call 和 apply 的共同点&lt;/h2&gt;
&lt;p&gt;它们的共同点是，都能够&lt;strong&gt;改变函数执行时的上下文&lt;/strong&gt;，将一个对象的方法交给另一个对象来执行，并且是立即执行的。&lt;/p&gt;
&lt;p&gt;为何要改变执行上下文？举一个生活中的小例子：平时没时间做饭的我，周末想给孩子炖个腌笃鲜尝尝。但是没有适合的锅，而我又不想出去买。所以就问邻居借了一个锅来用，这样既达到了目的，又节省了开支，一举两得。&lt;/p&gt;
&lt;p&gt;改变执行上下文也是一样的，A 对象有一个方法，而 B 对象因为某种原因，也需要用到同样的方法，那么这时候我们是单独为 B 对象扩展一个方法呢，还是借用一下 A 对象的方法呢？当然是借用 A 对象的啦，既完成了需求，又减少了内存的占用。&lt;/p&gt;
&lt;p&gt;另外，它们的写法也很类似，&lt;strong&gt;调用 call 和 apply 的对象，必须是一个函数 Function&lt;/strong&gt;。接下来，就会说到具体的写法，那也是它们区别的主要体现。&lt;/p&gt;
&lt;h2 id=&#34;2-call-和-apply-的区别&#34;&gt;2. call 和 apply 的区别&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;call 的写法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Function.call(obj,[param1[,param2[,…[,paramN]]]])
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;调用 call 的对象，必须是个函数 Function。&lt;/li&gt;
&lt;li&gt;call 的第一个参数，是一个对象。 Function 的调用者，将会指向这个对象。如果不传，则默认为全局对象 window。&lt;/li&gt;
&lt;li&gt;第二个参数开始，可以接收任意个参数。每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;function func (a,b,c) {}

func.call(obj, 1,2,3)
// func 接收到的参数实际上是 1,2,3

func.call(obj, [1,2,3])
// func 接收到的参数实际上是 [1,2,3],undefined,undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;apply 的写法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Function.apply(obj[,argArray])
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;它的调用者必须是函数 Function，并且只接收两个参数，第一个参数的规则与 call 一致。&lt;/li&gt;
&lt;li&gt;第二个参数，必须是数组或者类数组，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。这也是 call 和 apply 之间，很重要的一个区别。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;func.apply(obj, [1,2,3])
// func 接收到的参数实际上是 1,2,3

func.apply(obj, {
    0: 1,
    1: 2,
    2: 3,
    length: 3
})
// func 接收到的参数实际上是 1,2,3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;类数组无法使用 forEach、splice、push 等数组原型链上的方法&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-call-和-apply-的用途&#34;&gt;3 call 和 apply 的用途&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;call 的使用场景&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;对象的继承&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;function superClass () {
    this.a = 1;
    this.print = function () {
        console.log(this.a);
    }
}

function subClass () {
    superClass.call(this);
    this.print();
}

subClass();
// 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;subClass 通过 call 方法，继承了 superClass 的 print 方法和 a 变量。此外，subClass 还可以扩展自己的其他方法。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;借用方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;let domNodes = Array.prototype.slice.call(document.getElementsByTagName(&amp;quot;*&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;apply 的一些妙用&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Math.max&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;let max = Math.max.apply(null, array);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同理，要获取数组中最小的一项，可以这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let min = Math.min.apply(null, array);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;实现两个数组合并&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];

Array.prototype.push.apply(arr1, arr2);
console.log(arr1); // [1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-bind-的使用&#34;&gt;4. bind 的使用&lt;/h2&gt;
&lt;p&gt;bind() 方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。&lt;/p&gt;
&lt;p&gt;它的语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Function.bind(thisArg[, arg1[, arg2[, ...]]])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bind 方法 与 apply 和 call 比较类似，也能改变函数体内的 this 指向。不同的是，&lt;code&gt;bind 方法的返回值是函数，并且需要稍后调用，才会执行&lt;/code&gt;。而 apply 和 call 则是&lt;code&gt;立即调用&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;来看下面这个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function add (a, b) {
    return a + b;
}

function sub (a, b) {
    return a - b;
}

add.bind(sub, 5, 3); // 这时，并不会返回 8
add.bind(sub, 5, 3)(); // 调用后，返回 8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果 bind 的第一个参数是 null 或者 undefined，this 就指向全局对象 window。&lt;/p&gt;
&lt;h2 id=&#34;5-总结&#34;&gt;5. 总结&lt;/h2&gt;
&lt;p&gt;call 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。&lt;/p&gt;
&lt;p&gt;bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;原生实现bind函数&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 原生js实现bind函数
// 所有的函数都要有bind方法，所以要定义在Function的原型对象上
Function.prototype.myBind = function(objThis,...params){
    // objThis是要绑定的this对象，...params是因为参数数量不确定才用解构语法
    const thisFn = this;//当前调用的函数，例如fn.myBind()就把fn保存到thisFn
    let funcForBind = function(...secondParams){ // 要返回的函数
        // 判断函数是否是用new function生成的
        const isNew = this instanceof funcForBind
        const thisArg = isNew?this:objThis //this的指向
        // 绑定好this和参数返回到外层，暂时用call绑定，call也可以原生实现
        return thisFn.call(thisArg,...params,...secondParams)
    }
    // 绑定原型
    funcForBind.prototype = Object.create(thisFn)
    return funcForBind //返回绑定好的函数
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;21-立即执行函数和使用场景与闭包结合&#34;&gt;21. 立即执行函数和使用场景（与闭包结合）&lt;/h1&gt;
&lt;h2 id=&#34;1-什么是立即执行函数&#34;&gt;1. 什么是立即执行函数？&lt;/h2&gt;
&lt;p&gt;声明一个函数，并马上调用这个匿名函数就叫做立即执行函数；也可以说立即执行函数是一种语法，让你的函数在定义以后立即执行；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615271995138.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-立即执行函数的写法&#34;&gt;2. 立即执行函数的写法：&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;(function(){
//code
}())

(function (){
//code
})()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上边的两种写法，都是以圆括号开头，引擎会意味后面跟的是表达式，而不是一个函数定义语句，所以就避免了错误，这就叫做&amp;quot;立即调用的函数表达式&amp;quot;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(function () {alert(&amp;quot;我是匿名函数&amp;quot;)}())   //用括号把整个表达式包起来
(function () {alert(&amp;quot;我是匿名函数&amp;quot;)})()  //用括号把函数包起来
!function () {alert(&amp;quot;我是匿名函数&amp;quot;)}()  //求反，我们不在意值是多少，只想通过语法检查
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-立即执行函数的作用&#34;&gt;3. 立即执行函数的作用：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不必为函数命名，避免了污染全局变量&lt;/li&gt;
&lt;li&gt;立即执行函数内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量&lt;/li&gt;
&lt;li&gt;封装变量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总而言之：&lt;strong&gt;立即执行函数会形成一个单独的作用域，我们可以封装一些临时变量或者局部变量，避免污染全局变量&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-使用场景&#34;&gt;4. 使用场景&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;怎样使以下alert的结果为0,1,2：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;ul id=&amp;quot;list&amp;quot;&amp;gt;
        &amp;lt;li&amp;gt;公司简介&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;联系我们&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;营销网络&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
    &amp;lt;script&amp;gt;
       var list = document.getElementById(&amp;quot;list&amp;quot;);
      var li = list.children;
      for(var i = 0 ;i&amp;lt;li.length;i++){
       ( function(j){
            li[j].onclick = function(){
              alert(j);
          })(i); //把实参i赋值给形参j
        }
      }
     &amp;lt;/script&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结合闭包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (var i = 1; i &amp;lt;= 5; i++) {
  (function(j) {
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })(i);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;如何避免了污染全局变量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;某些代码只需要执行一次，比如只需要显示一个时间，但是这些代码也需要一些临时的变量，但是初始化过程结束之后，就再也不会被用到，如果将这些变量作为全局变量，不是一个好的主意，我们可以用立即执行函数——去将我们所有的代码包裹在它的局部作用域中，不会让任何变量泄露成全局变量，看如下代码：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615273235393.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
比如上面的代码，如果没有被包裹在立即执行函数中，而是直接以非函数的形式直接写在&amp;lt;script&amp;gt;&lt;/script&gt;标签里面，虽然也会立即执行，但是临时变量todaydom,days,today,year,month,date,day,msg都将成为全局变量（初始化代码遗留的产物）。&lt;br&gt;
而用立即执行函数之后，这些变量都不会在全局变量中存在，以后也不会其他地方使用，有效的避免了污染全局变量。&lt;/p&gt;
&lt;h1 id=&#34;22-设计模式要求说出如何实现应用优缺点单例模式实现&#34;&gt;22. 设计模式(要求说出如何实现,应用,优缺点)/单例模式实现&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;31&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615273736555.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1-创建型模式&#34;&gt;1. 创建型模式&lt;/h2&gt;
&lt;h3 id=&#34;1-工厂模式&#34;&gt;1. 工厂模式&lt;/h3&gt;
&lt;p&gt;工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象，用工厂方法代替new操作的一种模式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Animal(opts){
    var obj = new Object();
    obj.color = opts.color;
    obj.name= opts.name;
    obj.getInfo = function(){
        return &#39;名称：&#39;+ onj.name+&#39;， 颜色：&#39;+ obj.color;
    }
    return obj;
}
var cat = Animal({name: &#39;波斯猫&#39;, color: &#39;白色&#39;});
cat.getInfo();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;小结:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造函数和创建者分离，对new操作进行封装&lt;/li&gt;
&lt;li&gt;符合开放封闭原则&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-单例模式&#34;&gt;2. 单例模式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615274155679.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var Single = (function(){
    var instance;
    function init() {
        // 定义私有方法和属性
        // 操作逻辑
        return {
           // 定义公共方法和属性
        };
    }
    return {
        // 获取实例
        getInstance:function(){
            if(!instance){
                instance = init();
            }
            return instance;
        }
    }
})();

var obj1 = Single.getInstance();
var obj2 = Single.getInstance();
console.log(obj1 === obj2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;小结:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单例模式的主要思想就是，实例如果已经创建，则直接返回&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;function creatSingleton() {
    var obj = null
    // 实例如已经创建过，直接返回
    if (!obj) {
        obj = xxx
    }
    return obj
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;符合开放封闭原则&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-原型模式&#34;&gt;3. 原型模式&lt;/h3&gt;
&lt;p&gt;用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。&lt;/p&gt;
&lt;p&gt;在JavaScript中，实现原型模式是在ECMAScript5中，提出的Object.create方法，使用现有的对象来提供新创建的对象的__proto__。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var prototype = {
    name: &#39;Jack&#39;,
    getName: function() {
        return this.name
    }
}

var obj = Object.create(prototype, {
    job: {
        value: &#39;IT&#39;
    }
})

console.log(obj.getName())  // Jack
console.log(obj.job)  // IT
console.log(obj.__proto__ === prototype)  //true
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-结构型模式&#34;&gt;2. 结构型模式&lt;/h2&gt;
&lt;h3 id=&#34;1-适配器模式&#34;&gt;1. 适配器模式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;32&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615274391311.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;class GooleMap {
    show() {
        console.log(&#39;渲染谷歌地图&#39;)
    }
}

class BaiduMap {
    display() {
        console.log(&#39;渲染百度地图&#39;)
    }
}


// 定义适配器类, 对BaiduMap类进行封装
class BaiduMapAdapter {
    show() {
        var baiduMap = new BaiduMap()
        return baiduMap.display() 
    }
}

function render(map) {
    if (map.show instanceof Function) {
        map.show()
    }
}

render(new GooleMap())         // 渲染谷歌地图
render(new BaiduMapAdapter())  // 渲染百度地图
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;小结:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;适配器模式主要解决两个接口之间不匹配的问题，不会改变原有的接口，而是由一个对象对另一个对象的包装。&lt;/li&gt;
&lt;li&gt;适配器模式符合开放封闭原则&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-行为型模式&#34;&gt;3. 行为型模式&lt;/h2&gt;
&lt;h3 id=&#34;1-观察者模式订阅-发布模式&#34;&gt;1. 观察者模式(订阅-发布模式)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615274507790.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;发布者发出通知 =&amp;gt;主题对象收到通知并推送给订阅者 =&amp;gt; 订阅者执行相应的操作。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; // 一个发布者 publisher，功能就是负责发布消息 - publish
        var pub = {
            publish: function () {
                dep.notify();
            }
        }
        // 多个订阅者 subscribers， 在发布者发布消息之后执行函数
        var sub1 = { 
            update: function () {
                console.log(1);
            }
        }
        var sub2 = { 
            update: function () {
                console.log(2);
            }
        }
        var sub3 = { 
            update: function () {
                console.log(3);
            }
        }
        // 一个主题对象
        function Dep() {
            this.subs = [sub1, sub2, sub3];
        }
        Dep.prototype.notify = function () {
            this.subs.forEach(function (sub) {
                sub.update();
            });
        }

        // 发布者发布消息， 主题对象执行notify方法，进而触发订阅者执行Update方法
        var dep = new Dep();
        pub.publish();
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;23-iframe的缺点有哪些&#34;&gt;23. iframe的缺点有哪些&lt;/h1&gt;
&lt;h2 id=&#34;1-iframe的优点&#34;&gt;1. iframe的优点：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;iframe能够原封不动的把嵌入的网页展现出来。&lt;/li&gt;
&lt;li&gt;如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。&lt;/li&gt;
&lt;li&gt;网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。&lt;/li&gt;
&lt;li&gt;如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-iframe的缺点&#34;&gt;2. iframe的缺点：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;会产生很多页面，&lt;code&gt;不容易管理&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，&lt;code&gt;用户体验度差&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会&lt;code&gt;不利于搜索引擎优化&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;很多的移动设备（PDA手机）无法完全显示框架，&lt;code&gt;设备兼容性差&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;iframe框架页面会&lt;code&gt;增加服务器的http请求&lt;/code&gt;，对于大型网站是不可取的。&lt;br&gt;
分析了这么多，现在基本上都是用&lt;code&gt;Ajax来代替iframe&lt;/code&gt;，所以iframe已经渐渐的退出了前端开发。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;24-数组问题&#34;&gt;24. 数组问题&lt;/h1&gt;
&lt;h2 id=&#34;1-数组去重&#34;&gt;1. 数组去重&lt;/h2&gt;
&lt;h3 id=&#34;1-利用es6-set去重es6中最常用&#34;&gt;1. 利用ES6 Set去重（ES6中最常用）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function unique (arr) {
  return Array.from(new Set(arr))
}
var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,{},{}];
console.log(unique(arr))
 //[1, &amp;quot;true&amp;quot;, true, 15, false, undefined, null, NaN, &amp;quot;NaN&amp;quot;, 0, &amp;quot;a&amp;quot;, {}, {}]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不考虑兼容性，这种去重的方法代码最少。这种方法还无法去掉“{}”空对象，后面的高阶方法会添加去掉重复“{}”的方法。&lt;/p&gt;
&lt;h3 id=&#34;2-利用for嵌套for然后splice去重es5中最常用&#34;&gt;2. 利用for嵌套for，然后splice去重（ES5中最常用）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function unique(arr){            
  for(var i=0; i&amp;lt;arr.length; i++){
      for(var j=i+1; j&amp;lt;arr.length; j++){
          if(arr[i]===arr[j]){         //第一个等同于第二个，splice方法删除第二个
              arr.splice(j,1);
              j--;
          }
      }
  }
return arr;
}
var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,{},{}];
console.log(unique(arr))
//  [1, &#39;true&#39;,true, 15,false,undefined,null, NaN,NaN, &#39;NaN&#39;,0, &#39;a&#39;,{}, {}]  //NaN和{}没有去重
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。&lt;/p&gt;
&lt;h3 id=&#34;3-利用indexof去重&#34;&gt;3. 利用indexOf去重&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function unique(arr) {
  if (!Array.isArray(arr)) {
      console.log(&#39;type error!&#39;)
      return
  }
  var array = [];
  for (var i = 0; i &amp;lt; arr.length; i++) {
      if (array .indexOf(arr[i]) === -1) {
          array .push(arr[i])
      }
  }
  return array;
}
var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,{},{}];
console.log(unique(arr))
 // [1, &amp;quot;true&amp;quot;, true, 15, false, undefined, null, NaN, NaN, &amp;quot;NaN&amp;quot;, 0, &amp;quot;a&amp;quot;, {…}, {…}]  //NaN、{}没有去重
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组。&lt;/p&gt;
&lt;h3 id=&#34;4-利用sort&#34;&gt;4. 利用sort()&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function unique(arr) {
  if (!Array.isArray(arr)) {
      console.log(&#39;type error!&#39;)
      return;
  }
  arr = arr.sort()
  var arrry= [arr[0]];
  for (var i = 1; i &amp;lt; arr.length; i++) {
      if (arr[i] !== arr[i-1]) {
          arrry.push(arr[i]);
      }
  }
  return arrry;
}
   var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,{},{}];
      console.log(unique(arr))
// [0, 1, 15, &amp;quot;NaN&amp;quot;, NaN, NaN, {…}, {…}, &amp;quot;a&amp;quot;, false, null, true, &amp;quot;true&amp;quot;, undefined]      //NaN、{}没有去重
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对。&lt;/p&gt;
&lt;h3 id=&#34;5-利用includes&#34;&gt;5. 利用includes&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log(&#39;type error!&#39;)
        return
    }
    var array =[];
    for(var i = 0; i &amp;lt; arr.length; i++) {
            if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值
                    array.push(arr[i]);
              }
    }
    return array
}
var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,{},{}];
    console.log(unique(arr))
    //[1, &amp;quot;true&amp;quot;, true, 15, false, undefined, null, NaN, &amp;quot;NaN&amp;quot;, 0, &amp;quot;a&amp;quot;, {…}, {…}]     //{}没有去重
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6-利用filter&#34;&gt;6. 利用filter&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function unique(arr) {
  return arr.filter(function(item, index, arr) {
    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素
    return arr.indexOf(item, 0) === index;
  });
}
    var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,{},{}];
        console.log(unique(arr))
//[1, &amp;quot;true&amp;quot;, true, 15, false, undefined, null, &amp;quot;NaN&amp;quot;, 0, &amp;quot;a&amp;quot;, {…}, {…}]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;7-利用map数据结构去重&#34;&gt;7. 利用Map数据结构去重&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function arrayNonRepeatfy(arr) {
  let map = new Map();
  let array = new Array();  // 数组用于返回结果
  for (let i = 0; i &amp;lt; arr.length; i++) {
    if(map.has(arr[i])) {  // 如果有该key值
      map.set(arr[i], true); 
    } else { 
      map.set(arr[i], false);   // 如果没有该key值
      array.push(arr[i]);
    }
  } 
  return array ;
}
 var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,{},{}];
    console.log(arrayNonRepeatfy(arr))
//[1, &amp;quot;a&amp;quot;, &amp;quot;true&amp;quot;, true, 15, false, 1, {…}, null, NaN, NaN, &amp;quot;NaN&amp;quot;, 0, &amp;quot;a&amp;quot;, {…}, undefined]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-数组常用方法&#34;&gt;2. 数组常用方法&lt;/h2&gt;
&lt;h3 id=&#34;1-arraymap&#34;&gt;1. Array.map()&lt;/h3&gt;
&lt;p&gt;此方法是将数组中的每个元素调用一个提供的函数，结果作为一个新的数组返回，并&lt;code&gt;没有改变原来的数组&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5]
    let newArr = arr.map(x =&amp;gt; x*2)
    //arr= [1, 2, 3, 4, 5]   原数组保持不变
    //newArr = [2, 4, 6, 8, 10] 返回新数组
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-arrayforeach&#34;&gt;2. Array.forEach()&lt;/h3&gt;
&lt;p&gt;此方法是将数组中的每个元素执行传进提供的函数，没有返回值，&lt;code&gt;改变原数组&lt;/code&gt;，注意和map方法区分&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5]
   num.forEach(x =&amp;gt; x*2)
   // arr = [1, 2, 3, 4, 5]  数组改变,注意和map区分
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-arrayfilter&#34;&gt;3. Array.filter()&lt;/h3&gt;
&lt;p&gt;此方法是将所有元素进行判断，将满足条件的元素作为一个新的数组返回&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5]
    const isBigEnough = value =&amp;gt; value &amp;gt;= 3
    let newArr = arr.filter(isBigEnough )
    //newNum = [3, 4, 5] 满足条件的元素返回为一个新的数组
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-arrayevery&#34;&gt;4. Array.every()&lt;/h3&gt;
&lt;p&gt;此方法是将所有元素进行判断返回一个布尔值，如果&lt;code&gt;所有元素&lt;/code&gt;都满足判断条件，则返回true，否则为false：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5]
    const isLessThan4 = value =&amp;gt; value &amp;lt; 4
    const isLessThan6 =&amp;gt; value =&amp;gt; value &amp;lt; 6
    arr.every(isLessThan4 ) //false
    arr.every(isLessThan6 ) //true
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-arraysome&#34;&gt;5. Array.some()&lt;/h3&gt;
&lt;p&gt;此方法是将所有元素进行判断返回一个布尔值，如果&lt;code&gt;存在&lt;/code&gt;元素都满足判断条件，则返回true，若所有元素都不满足判断条件，则返回false：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr= [1, 2, 3, 4, 5]
    const isLessThan4 = value =&amp;gt; value &amp;lt; 4
    const isLessThan6 = value =&amp;gt; value &amp;gt; 6
    arr.some(isLessThan4 ) //true
    arr.some(isLessThan6 ) //false
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6-arrayreduce&#34;&gt;6. Array.reduce()&lt;/h3&gt;
&lt;p&gt;此方法是所有元素调用返回函数，返回值为最后结果,传入的值必须是函数类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5]
   const add = (a, b) =&amp;gt; a + b
   let sum = arr.reduce(add)
   //sum = 15  相当于累加的效果
   与之相对应的还有一个 Array.reduceRight() 方法，区别是这个是从右向左操作的
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;7-arraypush&#34;&gt;7. Array.push()&lt;/h3&gt;
&lt;p&gt;此方法是在数组的后面添加新加元素，此方法改变了数组的长度：&lt;/p&gt;
&lt;h3 id=&#34;8-arraypop&#34;&gt;8. Array.pop()&lt;/h3&gt;
&lt;p&gt;此方法在数组后面删除&lt;code&gt;最后一个元素&lt;/code&gt;，并返回数组，此方法改变了数组的长度：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5]
    arr.pop()
    console.log(arr) //[1, 2, 3, 4]
    console.log(arr.length) //4
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;9-arrayshift&#34;&gt;9. Array.shift()&lt;/h3&gt;
&lt;p&gt;此方法在数组后面删除&lt;code&gt;第一个元素&lt;/code&gt;，并返回数组，此方法改变了数组的长度：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5]
    arr.shift()
    console.log(arr) //[2, 3, 4, 5]
    console.log(arr.length) //4 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;10-arrayunshift&#34;&gt;10. Array.unshift()&lt;/h3&gt;
&lt;p&gt;此方法是将一个或多个元素添加到数组的开头，并返回新数组的长度：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5]
    arr.unshift(6, 7)
    console.log(arr) //[6, 7, 1, 2, 3, 4, 5]
    console.log(arr.length) //7 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;11-arrayisarray&#34;&gt;11. Array.isArray()&lt;/h3&gt;
&lt;p&gt;判断一个对象是不是数组，返回的是布尔值&lt;/p&gt;
&lt;h3 id=&#34;12-arrayconcat&#34;&gt;12. Array.concat()&lt;/h3&gt;
&lt;p&gt;此方法是一个可以将多个数组拼接成一个数组：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr1 = [1, 2, 3]
      arr2 = [4, 5]
  let arr = arr1.concat(arr2)
  console.log(arr)//[1, 2, 3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;13-arraytostring&#34;&gt;13. Array.toString()&lt;/h3&gt;
&lt;p&gt;此方法将数组转化为字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5];
   let str = arr.toString()
   console.log(str)// 1,2,3,4,5
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;14-arrayjoin&#34;&gt;14. Array.join()&lt;/h3&gt;
&lt;p&gt;此方法也是将数组转化为字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5];
  let str1 = arr.join()
  let str2 = arr.join(&#39;,&#39;)
  let str3 = arr.join(&#39;##&#39;)
  console.log(str1)// 1,2,3,4,5
  console.log(str2)// 1,2,3,4,5
  console.log(str3)// 1##2##3##4##5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;可以设置元素之间的间隔&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;15-arraysplice开始位置-删除的个数元素&#34;&gt;15. Array.splice(开始位置， 删除的个数，元素)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;万能方法，可以实现增删改：&lt;/strong&gt;&lt;code&gt;0增，3删，1改&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3, 4, 5];
     let arr1 = arr.splice(2, 0 &#39;haha&#39;)
     let arr2 = arr.splice(2, 3)
     let arr1 = arr.splice(2, 1 &#39;haha&#39;)
     console.log(arr1) //[1, 2, &#39;haha&#39;, 3, 4, 5]新增一个元素
     console.log(arr2) //[1, 2] 删除三个元素
     console.log(arr3) //[1, 2, &#39;haha&#39;, 4, 5] 替换一个元素
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-查找数组重复项&#34;&gt;3. 查找数组重复项&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;let arr= [1,2,3,4,5,1,2];
let rep = [];
arr.forEach((item,index)=&amp;gt;{
	if(arr.indexOf(item)!=index){ // 匹配数组元素第一个item位置和当前循环的index
        let obj = {};
        obj.key = (arr.indexOf(item) + 1) + &#39;|&#39; + (index + 1); // 用&#39;|&#39;分隔两个重复项的下标   
		obj.value = item;
        rep.push(obj);
	}
});
console.log(rep)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-扁平化数组flatten&#34;&gt;4. 扁平化数组（flatten）&lt;/h2&gt;
&lt;p&gt;扁平化就是将嵌套的数组变成一维数组的过程。&lt;/p&gt;
&lt;p&gt;通常有几种方法可以实现扁平化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;迭代递归法&lt;/li&gt;
&lt;li&gt;曲线救国法&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-迭代递归&#34;&gt;1. 迭代递归&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;var array = [[1,2,3],4,5,6,[[7]],[]]
var result = flatten(array)

console.log(result)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;for...of 实现&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function flatten(arr, result = []) {
    for (let item of arr) {
        if (Array.isArray(item))
            flatten(item, result)
        else
            result.push(item)
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们使用 result 变量存储结果，然后迭代当前数组，如果值也是数组则继续扁平化，否则将值放入 result 里。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;生成器实现&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;迭代器的升级版就是生成器（Generator），其实这种扁平化最适合用生成器来做了，因为我们的目的就是生成一个个的值，然后把它们组织成一维数组：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function* flat(arr) {
    for (let item of arr) {
        if (Array.isArray(item))
            yield* flat(item)
        else
            yield item
    }
}

function flatten(arr) {
    let result = []
    for (let val of flat(arr)) {
        result.push(val)
    }
    return result
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里有两点需要注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;嵌套 yield 需要再加一个星号，这被称为生成器委托。&lt;/li&gt;
&lt;li&gt;不能使用 forEach 代替 for...of 但可以用 for 循环，因为 for 循环和for...of 可以中断迭代去执行 yield，forEach 不行&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;reduce 三句实现法&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function flatten(arr) {
  return arr.reduce((flat, toFlatten) =&amp;gt; {
    return flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten);
  }, []);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-曲线救国法&#34;&gt;2. 曲线救国法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;降维打击法&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function flatten(arr){
    let str = arr.toString()
    return str.split(&#39;,&#39;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;转成字符串，之后再复原成数组，不过这个方法有个缺点，就是原来的空数组转的空字符串也会被放入新生成的数组里去。&lt;/p&gt;
&lt;h1 id=&#34;25-dom和bom相关&#34;&gt;25. DOM和BOM相关&lt;/h1&gt;
&lt;h2 id=&#34;1dom&#34;&gt;1.DOM&lt;/h2&gt;
&lt;h3 id=&#34;1-dom是什么&#34;&gt;1. DOM是什么：&lt;/h3&gt;
&lt;p&gt;DOM（Document Object Model）&lt;code&gt;文档对象模型&lt;/code&gt;，是&lt;strong&gt;处理可扩展标志语言&lt;/strong&gt;的标准编程接口。&lt;/p&gt;
&lt;p&gt;DOM 是 &lt;strong&gt;W3C&lt;/strong&gt; 的标准&lt;/p&gt;
&lt;h3 id=&#34;2-dom0级和dom2级有什么区别&#34;&gt;2. DOM0级和DOM2级有什么区别：&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;DOM0&lt;/code&gt;级中为某个dom元素绑定多个事件时，只有最后一个事件有效。&lt;code&gt;onclick&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DOM2&lt;/code&gt;级中可以为单个元素绑定多个事件，每个事件都可以被触发。&lt;code&gt;addEventListener&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-textcontent-innertext-innnerhtml-value的区别&#34;&gt;3. textContent、innerText、innnerHTML、value的区别：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;textContent用来获取和设置文本内容，与innerText的差别是:&lt;code&gt;textContent&lt;/code&gt;获取到的内容包括了元素中的&lt;code&gt;style标签&lt;/code&gt;和&lt;code&gt;script标签&lt;/code&gt;的内容。&lt;/li&gt;
&lt;li&gt;innerText只能获取和设置&lt;code&gt;文本&lt;/code&gt;内容，不能获取和设置html代码&lt;/li&gt;
&lt;li&gt;innerHTML可以获取和设置&lt;code&gt;html&lt;/code&gt;代码&lt;/li&gt;
&lt;li&gt;value获取的是&lt;code&gt;表单元素&lt;/code&gt;的值&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-关于dom的api有什么&#34;&gt;4. 关于dom的api有什么：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;节点创建型api：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;document.createElement()&lt;/li&gt;
&lt;li&gt;document.createTextNode()&lt;/li&gt;
&lt;li&gt;parent.cloneNode(true)&lt;/li&gt;
&lt;li&gt;document.createDocumentFragment() &lt;code&gt;创建文档片段,解决大量添加节点造成的回流问题&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;页面修改型API：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;parent.appendChild(child)&lt;/li&gt;
&lt;li&gt;parent.insertBefore(newNode,referenceNode) &lt;code&gt;将新元素添加到父元素中指定的子元素前面&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;parent.removeChild(child)&lt;/li&gt;
&lt;li&gt;parent.replcaeChild(newChild,oldChild)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;节点查询型API：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;document.getElementById()&lt;/li&gt;
&lt;li&gt;document.getElementsByTagName() 返回的是一个即时的HTMLCollection类型&lt;/li&gt;
&lt;li&gt;document.getElementsByName() 根据指定的name属性获取元素,返回的是一个即时的NodeList&lt;/li&gt;
&lt;li&gt;document.getElementsByClassName() 返回的是一个即时的HTMLCollection&lt;/li&gt;
&lt;li&gt;document.querySelector() 获取匹配到的第一个元素，采用的是深度优先搜索。&lt;/li&gt;
&lt;li&gt;docuemnt.querySelectorAll()&lt;br&gt;
返回的是一个非即时的NodeList，也就是说结果不会随着文档树的变化而变化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;节点关系型api：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;父关系型：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;node.parentNode()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;兄弟关系型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;node.previouSibling() 返回节点的前一个节点（包括元素节点，文本节点，注释节点）&lt;/li&gt;
&lt;li&gt;node.previousElementSibling() 返回前一个元素节点&lt;/li&gt;
&lt;li&gt;node.nextSibling() 返回下一个节点&lt;/li&gt;
&lt;li&gt;node.nextElementSibling() 返回下一个元素节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;子关系型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;parent.childNodes() 返回一个即时的NodeList，包括了文本节点和注释节点&lt;/li&gt;
&lt;li&gt;parent.children() 一个即时的HTMLCollection，子节点都是Element&lt;/li&gt;
&lt;li&gt;parent.firsrtNode()&lt;/li&gt;
&lt;li&gt;parent.lastNode()&lt;/li&gt;
&lt;li&gt;hasChildNodes()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;元素属性型api：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;element.setAttribute(“name”,“value”) 为元素添加属性&lt;/li&gt;
&lt;li&gt;element.getAtrribute(“name”) 获取元素的属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;元素样式型api：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;window.getComputedStyle(element) 返回一个CSSStyleDeclaration,可以从中访问元素的任意样式属性。&lt;/li&gt;
&lt;li&gt;element.getBoundingClientRect() 返回一个DOMRect对象，里面&lt;strong&gt;包括了元素相对于可视区的位置top,left&lt;/strong&gt;,以及元素的大小,单位为纯数字。可用于判断某元素是否出现在了可视区域。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5什么是事件监听&#34;&gt;5.什么是事件监听:&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;addEventListener()方法&lt;/code&gt;，用于向指定元素添加事件句柄，它可以更简单的控制事件，语法为&lt;/p&gt;
&lt;p&gt;element.addEventListener(event, function, useCapture);&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个参数是事件的类型(如 “click” 或 “mousedown”).&lt;/li&gt;
&lt;li&gt;第二个参数是事件触发后调用的函数。&lt;/li&gt;
&lt;li&gt;第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事件传递有两种方式，&lt;code&gt;冒泡&lt;/code&gt;和&lt;code&gt;捕获&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;事件传递定义了元素事件触发的顺序，如果你将P元素插入到div元素中，用户点击P元素，&lt;/p&gt;
&lt;p&gt;在冒泡中，内部元素先被触发，然后再触发外部元素，&lt;br&gt;
捕获中，外部元素先被触发，在触发内部元素，&lt;/p&gt;
&lt;h3 id=&#34;6-说说前端中的事件流&#34;&gt;6. 说说前端中的事件流&lt;/h3&gt;
&lt;p&gt;事件发生时会在元素节点之间按照特定的顺序传播，整个过程分为&lt;code&gt;捕获阶段，目标阶段和冒泡阶段&lt;/code&gt;，这个&lt;code&gt;传播过程&lt;/code&gt;叫做Dom事件流。&lt;/p&gt;
&lt;p&gt;事件冒泡：从事件源逐级向上传播到DOM最顶层节点的过程。&lt;/p&gt;
&lt;p&gt;事件捕获：从DOM最顶层节点逐级向下传播到事件源的过程。&lt;/p&gt;
&lt;p&gt;addEventListener用于指定事件处理程序，共接收三个参数。分别是触发事件，事件处理程序函数以及一个布尔值。第三个参数默认为false，表示在该事件的处理函数会在冒泡阶段被调用。若改为true，则表示事件处理函数会在捕获阶段被调用。&lt;/p&gt;
&lt;h3 id=&#34;7-如何让事件先冒泡后捕获-2&#34;&gt;7. 如何让事件先冒泡后捕获&lt;/h3&gt;
&lt;p&gt;对于&lt;code&gt;目标元素&lt;/code&gt;来说，如果DOM节点通过addEventListener同时绑定了两个事件监听函数，一个用于捕获，一个用于冒泡，那么两个事件的执行顺序是按照代码添加的顺序执行的。所以，先绑定冒泡的函数，再绑定捕获的函数，即可实现。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;非目标元素&lt;/code&gt;来说，可以给捕获事件的处理程序添加一个定时器，将处理程序推入下一个宏任务执行。&lt;/p&gt;
&lt;h3 id=&#34;8-说一下事件代理&#34;&gt;8. 说一下事件代理：&lt;/h3&gt;
&lt;p&gt;事件委托是指 不在子节点单独设置事件监听器，而将事件&lt;code&gt;监听器设置在父节点上&lt;/code&gt;，再利用&lt;code&gt;冒泡原理&lt;/code&gt;使每一个子节点都能触发该事件。&lt;/p&gt;
&lt;p&gt;事件委托的优点：只操作一次Dom，提高了程序的性能。&lt;/p&gt;
&lt;p&gt;常用于&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ul和li标签的事件监听，一般采用事件委托机制将事件监听器绑定在ul上。&lt;/li&gt;
&lt;li&gt;还适合动态元素的绑定，新添加的子元素不需单独添加事件处理程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;（1）了解事件代理吗，这样做有什么好处&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事件代理就是说我们将事件添加到本来要添加的事件的父节点，将事件委托给父节点来触发处理函数，这通常会使用在大量的同级元素需要添加同一类事件的时候，比如一个动态的非常多的列表，需要为每个列表项都添加点击事件，这时就可以使用事件代理，通过判断e.target.nodeName来判断发生的具体元素，这样做的好处是减少事件绑定，同事动态的DOM结构任然可以监听，事件代理发生在冒泡阶段&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）事件代理在捕获阶段的实际应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以在父元素层面阻止事件向子元素传播，也可代替子元素执行某些操作。&lt;/p&gt;
&lt;h3 id=&#34;9-事件类型相关&#34;&gt;9. 事件类型相关：&lt;/h3&gt;
&lt;p&gt;（1）&lt;code&gt;mouseover和mouseenter的区别&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移出事件是mouseout。&lt;/li&gt;
&lt;li&gt;mouseenter：鼠标移入子元素时不会再次触发mouseenter事件，对应的移出事件是mouseleave。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（2）&lt;code&gt;三种键盘事件的区别：&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;keyup: 松开键盘触发&lt;/li&gt;
&lt;li&gt;keydown:按下键盘触发&lt;/li&gt;
&lt;li&gt;keypress:不能识别功能键，比如ctrl,alt,shift,左右箭头。可以区分大小写。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在输入框中按下一个键的全过程：触发keydown/keypress事件-&amp;gt;文字键入输入框中-&amp;gt;触发keyup事件&lt;/p&gt;
&lt;p&gt;按下按键后&lt;code&gt;自动对焦&lt;/code&gt;输入框，应该使用&lt;code&gt;keyup&lt;/code&gt;，不应该使用keydown/keypress,因为后者会使按键落入输入框中,对于回车键的话还不能使用keypress。&lt;/p&gt;
&lt;h3 id=&#34;10-静态绑定事件与动态绑定事件的区别&#34;&gt;10. 静态绑定事件与动态绑定事件的区别：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;静态绑定&lt;/strong&gt;事件是指直接在Html标签上通过οnclick=&amp;quot;hide()&amp;quot;来绑定事件。&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;html和js文件存在耦合，不符合结构和行为分离的原则。&lt;/li&gt;
&lt;li&gt;可能存在引发错误，如果js代码还没加载就触发该事件则会抛出错误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;动态绑定&lt;/strong&gt;事件是指通过js动态绑定事件，element.onclick() element.addEventListener()。&lt;/p&gt;
&lt;h3 id=&#34;11-元素的位置和大小&#34;&gt;11. 元素的位置和大小&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;① offset系列：&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;offsetTop（获取元素位置）: 相对于带有‘定位’的父元素的偏移量&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;offsetHeight: content+padding+border&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;② cilent系列：&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;clientHeight(获取元素宽高): content+padding,不包含border&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;③ scroll系列：&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;scrollTop（获取滚动的距离）&lt;/strong&gt;: 向下滚动后，上面被卷去的距离，即隐藏的高度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;④ document.clientWidth与document.style.width的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;区别1：前者可以获取任意样式表中的width样式值，包括行内样式的，内嵌样式的，外部样式的；后者只能获取行内的样式。&lt;/li&gt;
&lt;li&gt;区别2：clientWidth获取的是数字型的，style获取的带有px后缀&lt;/li&gt;
&lt;li&gt;区别3：clientWidth包含了padding,而style.width只包含content。&lt;/li&gt;
&lt;li&gt;区别4：clientWidth是只读属性，所以一般用于获取元素的大小；而style.width是可读可写的，可用于获取，也可用于修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;⑤ 判断一个元素是否已经出现在了可视区域：(此问题可应用在懒加载中)&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;使用element.getBoundingClientRect().top获取在可视区的位置。&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;window.addEventListener(&amp;quot;scroll&amp;quot;, function () {
    let viewPortHeight = window.pageYOffset;
    let offset = box2.getBoundingClientRect().top;
    if (offset &amp;lt; viewPortHeight) {
        if (offset + box2.offsetHeight &amp;lt; 0) {
            console.log(&amp;quot;他走了&amp;quot;);
        } else {
            console.log(&amp;quot;他来啦他来啦&amp;quot;);
        }
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;12-js拖动及拖拽功能的实现&#34;&gt;12. js拖动及拖拽功能的实现&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;（1）拖动功能的实现：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;前置条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;拖动事件的三个过程：鼠标按下mousedown,鼠标移动mousemove,鼠标松开mouseup&lt;br&gt;
鼠标按下后执行mousemove事件。&lt;/li&gt;
&lt;li&gt;盒子采用绝对定位，通过left和top属性来修改位置。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;方法一：（直接根据鼠标移动的距离确定元素移动的距离）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;鼠标的坐标通过clientX,clientY获取：&lt;/li&gt;
&lt;li&gt;盒子的定位信息：鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的offetLeft.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;（2）拖拽功能的实现：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用html5提供的拖拽API（Drag 和 drop）&lt;/p&gt;
&lt;h2 id=&#34;2-bom浏览器对象模型&#34;&gt;2. (BOM)浏览器对象模型：&lt;/h2&gt;
&lt;h3 id=&#34;1-实用的bom属性对象方法&#34;&gt;1. 实用的BOM属性对象方法：&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;location对象&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;location.href– 返回或设置当前文档的URL&lt;/li&gt;
&lt;li&gt;location.search – 返回URL中的查询字符串部分。例如 http://www.dreamdu.com/dreamdu.php?id=5&amp;amp;name=dreamdu 返回包括(?)后面的内容?id=5&amp;amp;name=dreamdu&lt;/li&gt;
&lt;li&gt;location.hash – 返回URL#后面的内容，如果没有#，返回空&lt;/li&gt;
&lt;li&gt;location. – 返回URL中的域名部分，例如www.dreamdu.com&lt;/li&gt;
&lt;li&gt;location.hostname – 返回URL中的主域名部分，例如dreamdu.com&lt;/li&gt;
&lt;li&gt;location.pathname – 返回URL的域名后的部分。例如 http://www.dreamdu.com/xhtml/ 返回/xhtml/&lt;/li&gt;
&lt;li&gt;location.port – 返回URL中的端口部分。例如 http://www.dreamdu.com:8080/xhtml/ 返回8080&lt;/li&gt;
&lt;li&gt;location.protocol – 返回URL中的协议部分。例如 http://www.dreamdu.com:8080/xhtml/ 返回(//)前面的内容http:&lt;/li&gt;
&lt;li&gt;location.assign() – 重定向页面，与location.href一样，会记录历史，能后退页面&lt;/li&gt;
&lt;li&gt;location.replace() – 设置当前文档的URL，不记录历史，不能后退页面&lt;/li&gt;
&lt;li&gt;location.reload() – 重载当前页面,相当于F5。添加参数true则表示强制刷新，直接从服务器获取数据，不从浏览器缓存中取数据，相当于Ctrl+F5&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;history对象&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;history.go(n) – 前进或后退指定的页面数;&lt;/li&gt;
&lt;li&gt;history.back() – 后退一页&lt;/li&gt;
&lt;li&gt;history.forward() – 前进一页&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;navigator对象&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;navigator包含了用户浏览器的信息&lt;/li&gt;
&lt;li&gt;navigator.userAgent – 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)&lt;/li&gt;
&lt;li&gt;navigator.cookieEnabled – 返回浏览器是否支持(启用)cookie&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-settimeoutfn100100毫秒是如何权衡的&#34;&gt;2. setTimeout(fn,100);100毫秒是如何权衡的：&lt;/h3&gt;
&lt;p&gt;100ms指的是将回调函数加入到任务队列所花的时间。至于具体什么时候执行，需要看主线程的执行栈中是否还有任务在执行。&lt;/p&gt;
&lt;h3 id=&#34;3-requestanimationframe&#34;&gt;3. requestAnimationFrame&lt;/h3&gt;
&lt;p&gt;特点：requestAnimationFrame采用系统时间间隔，保证了最佳的绘制效率。&lt;/p&gt;
&lt;p&gt;使用方法：requestAnimationFrame接收一个回调函数，这个回调函数会在下一次浏览器重绘之前调用。&lt;/p&gt;
&lt;h3 id=&#34;4-分别用setintervalsettimeoutrequestanimationframe制作有个简单的进度条效果&#34;&gt;4. 分别用setInterval,setTimeout,requestAnimationFrame制作有个简单的进度条效果：&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;setInterval:&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div
     style=&amp;quot;width: 0; height: 20px; background-color: orange&amp;quot;
     id=&amp;quot;div&amp;quot;
     &amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
    let timer = setInterval(() =&amp;gt; {
        if (parseInt(div.style.width) &amp;gt;= 500) {
            return clearInterval(timer);
        }
        console.log(div.style.width);
        div.style.width = parseInt(div.style.width) + 5 + &amp;quot;px&amp;quot;;
        div.innerHTML = parseInt(div.style.width) / 5 + &amp;quot;%&amp;quot;;
    }, 16);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;setTimeout:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div
     style=&amp;quot;width: 0; height: 20px; background-color: orange&amp;quot;
     id=&amp;quot;div&amp;quot;
     &amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
    let timer = setTimeout(function fn() {
        if (parseInt(div.style.width) &amp;lt; 500) {
            div.style.width = parseInt(div.style.width) + 5 + &amp;quot;px&amp;quot;;
            div.innerHTML = parseInt(div.style.width) / 5 + &amp;quot;%&amp;quot;;
            timer = setTimeout(fn, 16);
        } else {
            clearTimeout(timer);
        }
    }, 16);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;requestAnimationFrame:类似于setTimeout,需要一次次的调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div
     style=&amp;quot;width: 0; height: 20px; background-color: orange&amp;quot;
     id=&amp;quot;div&amp;quot;
     &amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
    let timer = requestAnimationFrame(function fn() {
        if (parseInt(div.style.width) &amp;lt; 500) {
            div.style.width = parseInt(div.style.width) + 5 + &amp;quot;px&amp;quot;;
            div.innerHTML = parseInt(div.style.width) / 5 + &amp;quot;%&amp;quot;;
            requestAnimationFrame(fn);
        } else {
            cancelAnimationFrame(timer);
        }
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-js中的轮播实现原理假如一个页面上有两个轮播你会怎么实现&#34;&gt;5. js中的轮播实现原理？假如一个页面上有两个轮播，你会怎么实现？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;让图片存在一个数组中，然后将最后一张图片重复添加在数组的头部，将第一张图片重复添加在数组的最后。&lt;/li&gt;
&lt;li&gt;然后准备一个只能显示一张图片的盒子，对盒子做溢出隐藏处理。&lt;/li&gt;
&lt;li&gt;通过定时器增减索引，显示对应的图片，实现轮播功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果有两个轮播，可封装一个轮播组件，将需要轮播的图片作为参数传递。&lt;/p&gt;
&lt;h1 id=&#34;26-服务端渲染server-side-render&#34;&gt;26. 服务端渲染（server side render）&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;服务端渲染(SSR)&lt;/code&gt;：页面上的内容是由服务器上的代码决定的。即，页面上的内容在服务器上已经生成好了，服务器把这个内容给到浏览器，浏览器拿到这个内容直接显示在页面上即可。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;客户端渲染(CSR)&lt;/code&gt; ：一个网页是由JS文件渲染出来的，而不是服务器直接返回回来的。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615364099956.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-ssr的优势&#34;&gt;1. SSR的优势&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;更利于SEO&lt;br&gt;
服务端渲染返回给客户端的是已经获取了异步数据并执行JavaScript脚本的最终HTML，网络爬中就可以抓取到完整页面的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更利于首屏渲染&lt;br&gt;
首屏的渲染是node发送过来的html字符串，并不依赖于js文件了，这就会使用户更快的看到页面的内容。尤其是针对大型单页应用，打包后文件体积比较大，普通客户端渲染加载所有所需文件时间较长，首页就会有一个很长的白屏等待时间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-ssr的劣势&#34;&gt;2. SSR的劣势&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;服务端压力较大&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开发条件受限&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;学习成本相对较高&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;27-js-垃圾回收机制&#34;&gt;27.  JS 垃圾回收机制&lt;/h1&gt;
&lt;h2 id=&#34;1-垃圾回收&#34;&gt;1. 垃圾回收&lt;/h2&gt;
&lt;p&gt;JavaScript 中的内存管理是自动执行的，而且是不可见的。我们创建基本类型、对象、函数……所有这些都需要内存。&lt;/p&gt;
&lt;h2 id=&#34;2-可达性&#34;&gt;2. 可达性&lt;/h2&gt;
&lt;p&gt;JavaScript 中内存管理的主要概念是可达性。&lt;/p&gt;
&lt;p&gt;简单地说，“可达性” 值就是那些以某种方式&lt;code&gt;可访问&lt;/code&gt;或&lt;code&gt;可用&lt;/code&gt;的值，它们被保证存储在内存中。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有一组基本的固有可达值，由于显而易见的原因无法删除。例如:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;本地函数的局部变量和参数&lt;/li&gt;
&lt;li&gt;当前嵌套调用链上的其他函数的变量和参数&lt;/li&gt;
&lt;li&gt;全局变量&lt;/li&gt;
&lt;li&gt;还有一些其他的，内部的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;这些值称为根。&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;如果局部变量中有对象，并且该对象具有引用另一个对象的属性，则该对象被视为&lt;strong&gt;可达性&lt;/strong&gt;， 它引用的那些也是可以访问的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;下面是最简单的例子:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// user 具有对象的引用
let user = {
  name: &amp;quot;John&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615366337580.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里箭头表示一个对象引用。全局变量&lt;code&gt;“user”&lt;/code&gt;引用对象 &lt;code&gt;{name:“John”}&lt;/code&gt;(为了简洁起见，我们将其命名为John)。John 的 &lt;code&gt;“name”&lt;/code&gt;属性存储一个基本类型，因此它被绘制在对象中。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;user&lt;/code&gt; 的值被覆盖，则引用丢失:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user = null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615366388527.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
现在 John 变成不可达的状态，没有办法访问它，没有对它的引用。垃圾回收器将丢弃 John 数据并释放内存。&lt;/p&gt;
&lt;h2 id=&#34;3两个引用&#34;&gt;3.两个引用&lt;/h2&gt;
&lt;p&gt;现在让我们假设我们将引用从 &lt;code&gt;user&lt;/code&gt;复制到 &lt;code&gt;admin&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// user具有对象的引用
let user = {
  name: &amp;quot;John&amp;quot;
};
let admin = user;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615366454334.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
现在如果我们做同样的事情:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user = null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该对象仍然可以通过 &lt;code&gt;admin&lt;/code&gt; 全局变量访问，所以它在内存中。如果我们也覆盖&lt;code&gt;admin&lt;/code&gt;，那么它可以被释放。&lt;/p&gt;
&lt;h2 id=&#34;4-相互关联的对象&#34;&gt;4. 相互关联的对象&lt;/h2&gt;
&lt;p&gt;现在来看一个更复杂的例子， family 对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function marry (man, woman) {
  woman.husban = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman
  }
}

let family = marry({
  name: &amp;quot;John&amp;quot;
}, {
  name: &amp;quot;Ann&amp;quot;
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;产生的内存结构:&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615366611256.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
现在让我们删除两个引用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;delete family.father;
delete family.mother.husband;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615366634406.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
仅仅删除这两个引用中的一个是不够的，因为所有对象仍然是可访问的。&lt;/p&gt;
&lt;p&gt;但是如果我们把这两个都删除，那么我们可以看到 John 不再有传入的引用:&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615366651083.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
输出引用无关紧要。只有传入的对象才能使对象可访问，因此，John 现在是不可访问的，并将从内存中删除所有不可访问的数据。&lt;/p&gt;
&lt;p&gt;垃圾回收之后：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615366668995.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;5-内部算法&#34;&gt;5. 内部算法&lt;/h2&gt;
&lt;p&gt;基本的垃圾回收算法称为“&lt;strong&gt;标记-清除&lt;/strong&gt;”，定期执行以下“垃圾回收”步骤:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;垃圾回收器获取根并“&lt;strong&gt;标记&lt;/strong&gt;”(记住)它们。&lt;/li&gt;
&lt;li&gt;然后它访问并“标记”所有来自它们的引用。&lt;/li&gt;
&lt;li&gt;然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。&lt;/li&gt;
&lt;li&gt;以此类推，直到有未访问的引用(可以从根访问)为止。&lt;/li&gt;
&lt;li&gt;除标记的对象外，所有对象都被删除。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如，对象结构如下:&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615366772644.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
我们可以清楚地看到右边有一个“不可到达的块”。现在让我们看看“&lt;strong&gt;标记并清除&lt;/strong&gt;”垃圾回收器如何处理它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步标记根&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615367324843.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;然后标记他们的引用&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615367344647.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;以及子孙代的引用:&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615367365917.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
现在进程中不能访问的对象被认为是不可访问的，将被删除:&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615367388777.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;这就是垃圾收集的工作原理。JavaScript引擎应用了许多优化，使其运行得更快，并且不影响执行。&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;6面试怎么回答&#34;&gt;6.面试怎么回答&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1）问什么是垃圾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般来说没有被引用的对象就是垃圾，就是要被清除， 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）如何检垃圾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一种算法是标记 标记-清除 算法&lt;/p&gt;
&lt;h1 id=&#34;28-eventloop&#34;&gt;28. eventloop&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Event Loop&lt;/code&gt;即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用&lt;strong&gt;异步&lt;/strong&gt;的原理。&lt;/p&gt;
&lt;h2 id=&#34;1-进程和线程&#34;&gt;1. 进程和线程&lt;/h2&gt;
&lt;p&gt;线程，是程序执行流的最小单位。线程可与同属一个进程的其他线程共享所拥有的全部资源，同一进程中的多个线程之间可以并发执行。线程有&lt;code&gt;就绪&lt;/code&gt;，&lt;code&gt;阻塞&lt;/code&gt;，&lt;code&gt;运行&lt;/code&gt;三种基本状态。&lt;/p&gt;
&lt;p&gt;阮一峰大神针对进程和线程的类比，很是形象：&lt;code&gt;计算机的核心CPU&lt;/code&gt;，是个工厂，时刻运转着，工厂里有很多个车间（进程），一个车间开工其他车间不能开工，就是说：&lt;code&gt;单核CPU一次只能运行一个进程。任何时候，CPU总是运行一个进程&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;而一个车间里面有很多工人（线程），协同完成一个任务。所以：&lt;code&gt;一个进程可以包括多个线程&lt;/code&gt;。车间空间是工人共享的，&lt;code&gt;一个进程中的内存空间是所有线程共享的&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是房间大小不同个，容纳量不同，有些线程进去了，其他线程就不能再进去使用了。这就是：&lt;code&gt;一个线程使用某些共享内存时，其他线程得等它结束后才能使用共享内存&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;内存可以上锁，防止其他线程进来，【互斥锁】也就是防止多个线程读写同一块内存区域。&lt;/p&gt;
&lt;p&gt;还有些共享内存比较大，可以容纳多个线程，但是也是有限的，只能容纳固定数目的线程使用。如何保证多个线程不冲突呢？内存门口有个钥匙架，如果发现钥匙架空了，那就不能再进去了【信号量】。&lt;/p&gt;
&lt;h2 id=&#34;2-函数调用栈与任务队列&#34;&gt;2. 函数调用栈与任务队列&lt;/h2&gt;
&lt;p&gt;Javascript有一个main thread 主进程和call-stack（一个调用堆栈），在对一个调用堆栈中的task处理的时候，其他的都要等着。当在执行过程中遇到一些类似于setTimeout等异步操作的时候，会交给浏览器的其他模块(以webkit为例，是webcore模块)进行处理，当到达setTimeout指定的延时执行的时间之后，task(回调函数)会放入到任务队列之中。一般不同的异步任务的回调函数会放入不同的任务队列之中。等到调用栈中所有task执行完毕之后，接着去执行任务队列之中的task(回调函数)。&lt;/p&gt;
&lt;p&gt;任务队列是“先进先出”的数据结构，先来的优先被主线程读取。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615368924655.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上图中，调用栈中遇到DOM操作、ajax请求以及setTimeout等WebAPIs的时候就会交给浏览器内核的其他模块进行处理，webkit内核在Javasctipt执行引擎之外，有一个重要的模块是webcore模块。对于图中WebAPIs提到的三种API，webcore分别提供了DOM Binding、network、timer模块来处理底层实现。等到这些模块处理完这些操作的时候将回调函数放入任务队列中，之后等栈中的task执行完之后再去执行任务队列之中的回调函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小结：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有的代码都要通过函数调用栈中调用执行。&lt;/li&gt;
&lt;li&gt;当遇到前文中提到的APIs的时候，会交给浏览器内核的其他模块进行处理。&lt;/li&gt;
&lt;li&gt;任务队列中存放的是回调函数。&lt;/li&gt;
&lt;li&gt;等到调用栈中的task执行完之后再回去执行任务队列之中的task。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-宏任务与微任务&#34;&gt;3. 宏任务与微任务&lt;/h2&gt;
&lt;p&gt;其中setTimeout叫做macro-task(宏任务)，当然如我们所想，还有如promise的micro-task(微任务)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;micro-task包括：process.nextTick, Promise, Object.observe, MutationObserver&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;事件循环的顺序是从script开始第一次循环，随后全局上下文进入函数调用栈，碰到macro-task就将其交给处理它的模块处理完之后将回调函数放进macro-task的队列之中，碰到micro-task也是将其回调函数放进micro-task的队列之中。直到函数调用栈清空只剩全局执行上下文，然后开始执行所有的micro-task。当所有可执行的micro-task执行完毕之后。循环再次执行macro-task中的一个任务队列，执行完之后再执行所有的micro-task，就这样一直循环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不同的任务会放进不同的任务队列之中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;先执行macro-task，等到函数调用栈清空之后再执行所有在队列之中的micro-task。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等到所有micro-task执行完之后再从macro-task中的一个任务队列开始执行，就这样一直循环。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当有多个macro-task(micro-task)队列时，事件循环的顺序是按上文macro-task(micro-task)的分类中书写的顺序执行的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4事件循环event-loop&#34;&gt;4.事件循环（Event Loop）&lt;/h2&gt;
&lt;p&gt;JavaScript是单线程的，单线程意味着需要一个任务队列来管理任务事件，任务分为两种：&lt;code&gt;同步任务&lt;/code&gt;和&lt;code&gt;异步任务&lt;/code&gt;。同步任务是在主线程上面排队执行的任务，只有前面任务完成，下一个任务才能执行。异步任务是不进入主线程，而是进入任务队列中，只有通知主线程某个异步任务可以执行了，该任务方可执行。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1615368575238.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们的同步任务在主线程上运行会形成一个执行栈&lt;/li&gt;
&lt;li&gt;如果碰到异步任务，比如setTimeout、onClick等等的一些操作，我们会将他的执行结果放入队列，此期间主线程不阻塞&lt;/li&gt;
&lt;li&gt;等到主线程中的所有同步任务执行完毕，就会通过event loop在队列里面从头开始取，在执行栈中执行&lt;/li&gt;
&lt;li&gt;event loop永远不会断&lt;/li&gt;
&lt;li&gt;以上的这一整个流程就是Event Loop（事件循环机制）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;29-如何快速让字符串变成以千为精度的数字&#34;&gt;29. 如何快速让字符串变成以千为精度的数字&lt;/h1&gt;
&lt;h2 id=&#34;1-字符串转换成数字的三种方法&#34;&gt;1. 字符串转换成数字的三种方法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;转换函数、强制类型转换、利用js变量弱类型转换&lt;/code&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;转换函数：&lt;br&gt;
js提供了parseInt()和parseFloat()两个转换函数。前者把值转换成整数，后者把值转换成浮点数。只有对String类型调用这些方法，这两个函数才能正确运行；对其他类型返回的都是NaN(Not a Number)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;parseInt()方法还有基模式，可以把二进制、八进制、十六进制或其他任何进制的字符串转换成整数。基是由parseInt()方法的第二个参数指定的，示例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;parseInt(&amp;quot;AF&amp;quot;,   16);   //returns   175
parseInt(&amp;quot;10&amp;quot;,   2);   //returns   2
parseInt(&amp;quot;10&amp;quot;,   8);   //returns   8
parseInt(&amp;quot;10&amp;quot;,   10);   //returns   10
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;强制类型转换&lt;br&gt;
ECMAScript中可用的3种强制类型转换如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Boolean(value)——把给定的值转换成Boolean型；&lt;/li&gt;
&lt;li&gt;Number(value)——把给定的值转换成数字（可以是整数或浮点数）；&lt;/li&gt;
&lt;li&gt;String(value)——把给定的值转换成字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;利用js变量弱类型转换&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-数字千位符格式化&#34;&gt;2. 数字千位符格式化&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;function toThousands(num) {
    var result = &#39;&#39;, counter = 0;
    num = (num || 0).toString();
    for (var i = num.length - 1; i &amp;gt;= 0; i--) {
        counter++;
        result = num.charAt(i) + result;
        if (!(counter % 3) &amp;amp;&amp;amp; i != 0) { result = &#39;,&#39; + result; }
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;30-js中v8引擎的详解&#34;&gt;30. js中v8引擎的详解&lt;/h1&gt;
&lt;h2 id=&#34;1-v8引擎出现的原因&#34;&gt;1. v8引擎出现的原因&lt;/h2&gt;
&lt;p&gt;这里先说一下什么是&lt;code&gt;编译型语言&lt;/code&gt;和&lt;code&gt;解释性语言&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;编译型&lt;/code&gt;语言： 在程序执行之前必须进行专门的编译过程，有如下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;只须编译一次&lt;/code&gt;就可以把源代码&lt;code&gt;编译成机器语言&lt;/code&gt;，后面的执行&lt;code&gt;无须重新编译&lt;/code&gt;，直接使用之前的编译结果就可以；因此其执行的&lt;code&gt;效率比较高&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;编译性语言代表：C、C++、Java、Pascal/Object Pascal（Delphi）&lt;/li&gt;
&lt;li&gt;程序执行效率比较高，但比较依赖编译器，因此跨平台性差一些&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;解释型&lt;/code&gt;语言 - 解释型语言，支持动态类型，弱类型，在&lt;code&gt;程序运行&lt;/code&gt;的时候&lt;code&gt;才进行编译&lt;/code&gt;，而编译前需要确定变量的类型，效率比较低，对不同系统平台有较大的兼容性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源代码&lt;code&gt;不能直接&lt;/code&gt;翻译成机器语言，而是先翻译成&lt;code&gt;中间代码&lt;/code&gt;，再由&lt;code&gt;解释器&lt;/code&gt;对中间代码进行&lt;code&gt;解释运行&lt;/code&gt; 源代码—&amp;gt;中间代码—&amp;gt;机器语言&lt;/li&gt;
&lt;li&gt;程序&lt;code&gt;不需要编译&lt;/code&gt;，程序在运行时才翻译成机器语言，&lt;code&gt;每执行一次都要翻译一次&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;解释型语言代表：Python、JavaScript、Shell、Ruby、MATLAB等&lt;/li&gt;
&lt;li&gt;运行效率一般相对&lt;code&gt;比较低&lt;/code&gt;，&lt;code&gt;依赖解释器&lt;/code&gt;，跨平台性好&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;比较：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一般，&lt;code&gt;编译型语言的运行效率比解释型语言更高&lt;/code&gt;；但是不能一概而论，部分解释性语言的解释器通过在运行时动态优化代码，甚至能使解释性语言的性能超过编译性语言；&lt;/li&gt;
&lt;li&gt;编译性语言的跨平台特性比解释性语言差一些；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进过以上说明，解释型语言，&lt;code&gt;运行效率低&lt;/code&gt;，随着Web相关技术的发展，JavaScript所要承担的工作也越来越多，早就超越了“表单验证”的范畴，&lt;code&gt;这就更需要快速的解析和执行JavaScript脚本&lt;/code&gt;。&lt;code&gt;V8引擎&lt;/code&gt;就是为解决这一问题而生，在node中也是采用该引擎来解析JavaScript&lt;/p&gt;
&lt;h2 id=&#34;2-渲染引擎及网页渲染&#34;&gt;2. 渲染引擎及网页渲染&lt;/h2&gt;
&lt;p&gt;为用户提供网页浏览服务无疑是最重要的功能，如下介绍：&lt;/p&gt;
&lt;h3 id=&#34;1-渲染引擎&#34;&gt;1. 渲染引擎&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;渲染引擎&lt;/code&gt; - 能够能够将HTML/CSS/JavaScript文本及相应的&lt;code&gt;资源文件&lt;/code&gt;转换成&lt;code&gt;图像&lt;/code&gt;结果.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;作用&lt;/code&gt; - 将&lt;code&gt;资源文件&lt;/code&gt;转化为&lt;code&gt;用户可见&lt;/code&gt;的结果。&lt;/li&gt;
&lt;li&gt;渲染引擎的种类 - Tridend(IE)、Gecko(FF),WebKit(Safari,Chrome,Andriod浏览器)等.&lt;/li&gt;
&lt;li&gt;介绍 - WebKit是由苹果2005年发起的一个开源项目，引起了众多公司的重视，几年间被很多公司所采用，在移动端更占据了垄断地位。更有甚者，开发出了基于WebKit的支持HTML5的web操作系统(如：Chrome OS、Web OS)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;WebKit的大致结构&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616375134643.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616375172770.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-网页渲染流程&#34;&gt;2. 网页渲染流程&lt;/h3&gt;
&lt;p&gt;上面介绍了渲染引擎的各个模块，那么一张网页，要经历怎样的过程，才能展示给用户。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616375416528.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;过程&lt;/code&gt; - 首先是网页内容，输入到HTML解析器，HTML解析器解析，然后构建DOM树，在这期间如果遇到JavaScript代码则交给JavaScript引擎处理；如果来自CSS解析器的样式信息，构建一个内部绘图模型。该模型由布局模块计算模型内部各个元素的位置和大小信息，最后由绘图模块完成从该模型到图像的绘制。在网页渲染的过程中，大致可分为下面3个阶段：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616375499789.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;上述是一个完整的渲染过程，现代网页很多都是动态的，随着网页与用户的交互，浏览器需要不断的重复渲染过程。&lt;/p&gt;
&lt;h3 id=&#34;3-javascript引擎&#34;&gt;3. JavaScript引擎&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616376387769.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
JavaScript本质上是一种&lt;code&gt;解释型语言&lt;/code&gt;，与编译型语言不同的是它需要&lt;code&gt;一边执行一边解析&lt;/code&gt;，而编译型语言在执行时已经完成编译，可直接执行，有更快的执行速度(如上图所示)。JavaScript代码是在浏览器端解析和执行的，如果需要时间太长，会影响用户体验。那么&lt;code&gt;提高JavaScript的解析速度&lt;/code&gt;就是当务之急。JavaScript引擎和渲染引擎的关系如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616376459980.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
avaScript语言是解释型语言，为了&lt;code&gt;提高性能&lt;/code&gt;，引入了J&lt;code&gt;ava虚拟机&lt;/code&gt;和&lt;code&gt;C++编译器&lt;/code&gt;中的众多&lt;code&gt;技术&lt;/code&gt;。现在JavaScript引擎的执行过程大致是:&lt;br&gt;
&lt;code&gt;源代码&lt;/code&gt;-→&lt;code&gt;抽象语法树&lt;/code&gt;-→&lt;code&gt;字节码&lt;/code&gt;-→&lt;code&gt;JIT&lt;/code&gt;-→&lt;code&gt;本地代码&lt;/code&gt;(V8引擎没有中间字节码)。&lt;/p&gt;
&lt;p&gt;V8更加直接的将&lt;code&gt;抽象语法树&lt;/code&gt;通过&lt;code&gt;JIT技术&lt;/code&gt;转换成&lt;code&gt;本地代码&lt;/code&gt;，&lt;code&gt;放弃了&lt;/code&gt;在&lt;code&gt;字节码&lt;/code&gt;阶段可以进行的一些性能优化，但保证了执行速度。在V8生成本地代码后，也会通过Profiler采集一些信息，来优化本地代码。虽然，少了生成字节码这一阶段的性能优化，但极大减少了转换时间。&lt;/p&gt;
&lt;h2 id=&#34;3-v8引擎&#34;&gt;3. V8引擎&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;V8引擎是一个&lt;code&gt;JavaScript引擎&lt;/code&gt;实现，最初由一些语言方面专家设计，后被谷歌收购，随后谷歌对其进行了&lt;code&gt;开源&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;V8使用&lt;code&gt;C++开发&lt;/code&gt;，在运行JavaScript之前，相比其它的JavaScript的引擎转换成字节码或解释执行，&lt;code&gt;V8将其编译成原生机器码&lt;/code&gt;（IA-32, x86-64, ARM, or MIPS CPUs），并且使用了如&lt;code&gt;内联缓存&lt;/code&gt;（inline caching）等方法来&lt;code&gt;提高性能&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;有了这些功能，JavaScript程序在V8引擎下的运行速度媲美二进制程序。&lt;/li&gt;
&lt;li&gt;V8支持&lt;code&gt;众多操作系统&lt;/code&gt;，如windows、linux、android等，也支持其他硬件架构，如IA32,X64,ARM等，具有很好的&lt;code&gt;可移植&lt;/code&gt;和&lt;code&gt;跨平台特性&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-数据表示&#34;&gt;4. 数据表示&lt;/h2&gt;
&lt;p&gt;JavaScript是一种动态类型语言，&lt;code&gt;在编译时并不能准确知道变量的类型&lt;/code&gt;，&lt;code&gt;只可以在运行时确定&lt;/code&gt;，这就不像c++或者java等静态类型语言，在编译时候就可以确切知道变量的类型。然而，&lt;code&gt;在运行时计算和决定类型，会严重影响语言性能&lt;/code&gt;，这也就是JavaScript运行效率比C++或者JAVA低很多的原因之一。&lt;/p&gt;
&lt;p&gt;在C++中，源代码需要经过编译才能执行，在生成本地代码的过程中，变量的地址和类型已经确定，运行本地代码时利用数组和位移就可以存取变量和方法的地址，不需要再进行额外的查找，几个机器指令即可完成，节省了确定类型和地址的时间。由于JavaScript是无类型语言，那就不能像c++那样在执行时已经知道变量的类型和地址，需要临时确定。JavaScript 和C++有以下几个区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;编译确定位置&lt;/code&gt; -&lt;code&gt;C++&lt;/code&gt;编译阶段确定位置偏移信息，在&lt;code&gt;执行时直接存取&lt;/code&gt;，&lt;code&gt;JavaScript&lt;/code&gt;在&lt;code&gt;执行阶段确定&lt;/code&gt;，而且执行期间可以修改对象属性；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;偏移信息共享&lt;/code&gt; - &lt;code&gt;C++&lt;/code&gt;有类型定义，执行时&lt;code&gt;不能动态改变&lt;/code&gt;，可共享偏移信息，&lt;code&gt;JavaScript&lt;/code&gt;每个对象都是&lt;code&gt;自描述&lt;/code&gt;，属性和位置偏移信息都包含在自身的结构中；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;偏移信息查找&lt;/code&gt; - &lt;code&gt;C++&lt;/code&gt;查找偏移地址很简单，在编译代码阶段，对使用的某类型成员变量&lt;code&gt;直接设置偏移位置&lt;/code&gt;，&lt;code&gt;JavaScript&lt;/code&gt;中使用一个对象，需要通过&lt;code&gt;属性名匹配&lt;/code&gt;才能找到相应的值，需要更多的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;33&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616377366139.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;5-工作过程&#34;&gt;5. 工作过程&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;34&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616377457407.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;编译阶段&#34;&gt;编译阶段&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;35&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616377563413.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;运行阶段&#34;&gt;运行阶段&lt;/h3&gt;
&lt;p&gt;由于&lt;code&gt;V8缺少了生成中间代码这一环节&lt;/code&gt;，缺少了必要的优化，为了提升性能，V8会在&lt;code&gt;生成本地代码后&lt;/code&gt;，使用&lt;code&gt;数据分析器&lt;/code&gt;(profiler)&lt;code&gt;采集一些信息&lt;/code&gt;，然后根据这些数据将本地代码进行优化，生成更高效的本地代码，这是一个逐步改进的过程。同时，当发现优化后代码的性能还不如未优化的代码，V8将退回原来的代码，也就是优化回滚。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616377618319.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;优化回滚&#34;&gt;优化回滚&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;36&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1616377669446.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">【面】前端知识点梳理（JS）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/mian-23-tiao-qian-duan-xing-neng-you-hua/"" data-c="
          &lt;h1 id=&#34;1-减少http请求次数&#34;&gt;1. 减少HTTP请求次数&lt;/h1&gt;
&lt;p&gt;尽量合并图片、CSS、JS。比如加载一个页面，如果有5个css文件的话，那么会发出5次http请求，这样会让用户第一次访问你的页面的时候会长时间等待。而如果把这个5个文件合成一个的话，就只需要发出一次http请求，节省网络请求时间，加快页面的加载。&lt;/p&gt;
&lt;h1 id=&#34;2-使用cdn&#34;&gt;2. 使用CDN&lt;/h1&gt;
&lt;p&gt;网站上静态资源即css、js全都使用cdn分发，图片亦然。&lt;/p&gt;
&lt;h1 id=&#34;3-避免空的src和href&#34;&gt;3. 避免空的src和href&lt;/h1&gt;
&lt;p&gt;当link标签的href属性为空、script标签的src属性为空的时候，浏览器渲染的时候会把当前页面的URL作为它们的属性值，从而把页面的内容加载进来作为它们的值。所以要避免犯这样的疏忽。&lt;/p&gt;
&lt;h1 id=&#34;4-为文件头指定expires&#34;&gt;4. 为文件头指定Expires&lt;/h1&gt;
&lt;p&gt;Expires是用来设置文件的过期时间的，一般对css、js、图片资源有效。 他可以使内容具有缓存性，这样下回再访问同样的资源时就通过浏览器缓存区读取，不需要再发出http请求。如下例子：&lt;/p&gt;
&lt;p&gt;新浪微博的这个css文件的Expires时间是2016-5-04 09:14:14.&lt;/p&gt;
&lt;h1 id=&#34;5-使用gzip压缩内容&#34;&gt;5. 使用gzip压缩内容&lt;/h1&gt;
&lt;p&gt;gzip能够压缩任何一个文本类型的响应，包括html，xml，json。大大缩小请求返回的数据量。&lt;/p&gt;
&lt;h1 id=&#34;6-把css放到顶部&#34;&gt;6. 把CSS放到顶部&lt;/h1&gt;
&lt;p&gt;网页上的资源加载时从上网下顺序加载的，所以css放在页面的顶部能够优先渲染页面，让用户感觉页面加载很快。&lt;/p&gt;
&lt;h1 id=&#34;7-把js放到底部&#34;&gt;7. 把JS放到底部&lt;/h1&gt;
&lt;p&gt;加载js时会对后续的资源造成阻塞，必须得等js加载完才去加载后续的文件 ，所以就把js放在页面底部最后加载。&lt;/p&gt;
&lt;h1 id=&#34;8-避免使用css表达式&#34;&gt;8. 避免使用CSS表达式&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;font-color: expression( (new Date()).getHours()%3 ? “#FFFFFF&amp;quot; : “#AAAAAA&amp;quot; );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个表达式会持续的在页面上计算样式，影响页面的性能。并且css表达式只被IE支持。&lt;/p&gt;
&lt;h1 id=&#34;9-将css和js放到外部文件中&#34;&gt;9. 将CSS和JS放到外部文件中&lt;/h1&gt;
&lt;p&gt;目的是缓存文件，可以参考原则4。 但有时候为了减少请求，也会直接写到页面里，需根据PV和IP的比例权衡。&lt;/p&gt;
&lt;h1 id=&#34;10-权衡dns查找次数&#34;&gt;10. 权衡DNS查找次数&lt;/h1&gt;
&lt;p&gt;减少主机名可以节省响应时间。但同时，需要注意，减少主机会减少页面中并行下载的数量。&lt;/p&gt;
&lt;p&gt;IE浏览器在同一时刻只能从同一域名下载两个文件。当在一个页面显示多张图片时，IE 用户的图片下载速度就会受到影响。所以新浪会搞N个二级域名来放图片。&lt;/p&gt;
&lt;p&gt;下面是新浪微博的图片域名，我们可以看到他有多个域名，这样可以保证这些不同域名能够同时去下载图片，而不用排队。不过如果当使用的域名过多时，响应时间就会慢，因为不用响应域名时间不一致。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614914780547.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;11-精简css和js&#34;&gt;11.  精简CSS和JS&lt;/h1&gt;
&lt;p&gt;这里就涉及到css和js的压缩了。比如下面的新浪的一个css文件，把空格回车全部去掉，减少文件的大小。现在的压缩工具有很多，基本主流的前端构建工具都能进行css和js文件的压缩，如grunt，glup等。&lt;/p&gt;
&lt;h1 id=&#34;12-避免跳转&#34;&gt;12. 避免跳转&lt;/h1&gt;
&lt;p&gt;有种现象会比较坑爹，看起来没什么差别，其实多次了一次页面跳转。比如当URL本该有斜杠（/）却被忽略掉时。例如，当我们要访问 http://baidu.com 时，实际上返回的是一个包含301代码的跳转，它指向的是 http://baidu.com/（注意末尾的斜杠）。在&lt;code&gt;nginx服务器&lt;/code&gt;可以使用rewrite；&lt;code&gt;Apache服务器&lt;/code&gt;中可以使用Alias 或者 mod_rewrite或者the DirectorySlash来避免。&lt;/p&gt;
&lt;p&gt;另一种是不用域名之间的跳转， 比如访问 http://baidu.com/bbs 跳转到http://bbs.baidu.com/。那么可以通过使用Alias或者mod_rewirte建立CNAME（保存一个域名和另外一个域名之间关系的DNS记录）来替代。&lt;/p&gt;
&lt;h1 id=&#34;13-删除重复的js和css&#34;&gt;13. 删除重复的JS和CSS&lt;/h1&gt;
&lt;p&gt;重复调用脚本，除了增加额外的HTTP请求外，多次运算也会浪费时间。在IE和Firefox中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。&lt;/p&gt;
&lt;h1 id=&#34;14-配置etags&#34;&gt;14. 配置ETags&lt;/h1&gt;
&lt;p&gt;它用来判断浏览器缓存里的元素是否和原来服务器上的一致。比last-modified date更具有弹性，例如某个文件在1秒内修改了10次，Etag可以综合Inode(文件的索引节点(inode)数)，MTime(修改时间)和Size来精准的进行判断，避开UNIX记录MTime只能精确到秒的问题。 服务器集群使用，可取后两个参数。使用ETags减少Web应用带宽和负载&lt;/p&gt;
&lt;h1 id=&#34;15-可缓存的ajax&#34;&gt;15. 可缓存的AJAX&lt;/h1&gt;
&lt;p&gt;异步请求同样的造成用户等待，所以使用ajax请求时，要主动告诉浏览器如果该请求有缓存就去请求缓存内容。如下代码片段, cache:true就是显式的要求如果当前请求有缓存的话，直接使用缓存&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614914923304.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;16-使用get来完成ajax请求&#34;&gt;16. 使用GET来完成AJAX请求&lt;/h1&gt;
&lt;p&gt;当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数据。因此使用GET获取数据时更加有意义。&lt;/p&gt;
&lt;h1 id=&#34;17-减少dom元素数量&#34;&gt;17. 减少DOM元素数量&lt;/h1&gt;
&lt;p&gt;这是一门大学问，这里可以引申出一堆优化的细节。想要具体研究的可以看后面推荐书籍。总之大原则减少DOM数量，就会减少浏览器的解析负担。&lt;/p&gt;
&lt;h1 id=&#34;18-避免404&#34;&gt;18. 避免404&lt;/h1&gt;
&lt;p&gt;比如外链的css、js文件出现问题返回404时，会破坏浏览器的并行加载。&lt;/p&gt;
&lt;h1 id=&#34;19-减少cookie的大小&#34;&gt;19. 减少Cookie的大小&lt;/h1&gt;
&lt;p&gt;Cookie里面别塞那么多东西，因为每个请求都得带着他跑。&lt;/p&gt;
&lt;h1 id=&#34;20-使用无cookie的域&#34;&gt;20. 使用无cookie的域&lt;/h1&gt;
&lt;p&gt;比如CSS、js、图片等，客户端请求静态文件的时候，减少了 Cookie 的反复传输对主域名的影响。&lt;/p&gt;
&lt;h1 id=&#34;21-不要使用滤镜&#34;&gt;21. 不要使用滤镜&lt;/h1&gt;
&lt;p&gt;IE独有属性AlphaImageLoader用于修正7.0以下版本中显示PNG图片的半透明效果。这个滤镜的问题在于浏览器加载图片时它会终止内容的呈现并且冻结浏览器。在每一个元素（不仅仅是图片）它都会运算一次，增加了内存开支，因此它的问题是多方面的。&lt;/p&gt;
&lt;p&gt;完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。&lt;/p&gt;
&lt;h1 id=&#34;22-不要在html中缩放图片&#34;&gt;22. 不要在HTML中缩放图片&lt;/h1&gt;
&lt;p&gt;比如你需要的图片尺寸是50* 50&lt;/p&gt;
&lt;p&gt;那就不用用一张500*500的大尺寸图片，影响加载&lt;/p&gt;
&lt;h1 id=&#34;23-缩小faviconico并缓存&#34;&gt;23. 缩小favicon.ico并缓存&lt;/h1&gt;
">【面】23条前端性能优化</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/mian-qian-duan-zhi-shi-dian-shu-li-html/"" data-c="
          &lt;h1 id=&#34;1-语义化&#34;&gt;1. 语义化&lt;/h1&gt;
&lt;h2 id=&#34;11-语义化作用&#34;&gt;1.1 语义化作用&lt;/h2&gt;
&lt;p&gt;见标签知其意，让代码结构清晰，方便阅读，有利于其他设备解析。&lt;/p&gt;
&lt;p&gt;循W3规范以语义化标签渲染网页更利于搜索引擎的优化（SEO），网络不佳时（无样式），网页也更具可读性。&lt;/p&gt;
&lt;h2 id=&#34;12-常见语义化标签&#34;&gt;1.2 常见语义化标签&lt;/h2&gt;
&lt;p&gt;&amp;lt;title&amp;gt;：页面主体内容。&lt;/p&gt;
&lt;p&gt;&amp;lt;hn&amp;gt;：h1~h6，分级标题，&amp;lt;h1&amp;gt; 与 &amp;lt;title&amp;gt; 协调有利于搜索引擎优化。&lt;/p&gt;
&lt;p&gt;&amp;lt;ul&amp;gt;：无序列表。&lt;/p&gt;
&lt;p&gt;&amp;lt;ol&amp;gt;：有序列表。&lt;/p&gt;
&lt;p&gt;&amp;lt;header&amp;gt;：页眉通常包括网站标志、主导航、全站链接以及搜索框。&lt;/p&gt;
&lt;p&gt;&amp;lt;nav&amp;gt;：标记导航，仅对文档中重要的链接群使用。&lt;/p&gt;
&lt;p&gt;&amp;lt;main&amp;gt;：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。&lt;/p&gt;
&lt;p&gt;&amp;lt;article&amp;gt;：定义外部的内容，其中的内容独立于文档的其余部分。&lt;/p&gt;
&lt;p&gt;&amp;lt;section&amp;gt;：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。&lt;/p&gt;
&lt;h2 id=&#34;13-html对seo的优化&#34;&gt;1.3 html对SEO的优化&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;meta标签，这个是重中之重&lt;/li&gt;
&lt;li&gt;img标签，img标签增加alt属性&lt;/li&gt;
&lt;li&gt;页面结构清晰，使用语义化标签比如header、footer、content、section，js、css使用外部文件&lt;/li&gt;
&lt;li&gt;增加外部链接&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;2-html新特性新标签&#34;&gt;2. Html新特性新标签&lt;/h1&gt;
&lt;h2 id=&#34;21-新特性&#34;&gt;2.1 新特性&lt;/h2&gt;
&lt;p&gt;1）语义化&lt;br&gt;
2）本地存储&lt;br&gt;
3）设备兼容&lt;br&gt;
4）连接特性，能够帮助我们将数据推送到客户端&lt;br&gt;
5）网页多媒体特性&lt;br&gt;
6）三维、图形及特效特性&lt;br&gt;
7）性能与集成特性&lt;br&gt;
8）css3特性&lt;/p&gt;
&lt;h2 id=&#34;22-新标签&#34;&gt;2.2 新标签&lt;/h2&gt;
&lt;p&gt;1）结构标签&lt;br&gt;
&amp;lt;head&amp;gt;定义页面或者区域头部&lt;br&gt;
&amp;lt;main&amp;gt;规定文档主要内容&lt;br&gt;
&amp;lt;footer&amp;gt;定义页面或者区域底部&lt;br&gt;
&amp;lt;article&amp;gt;定义一篇文章&lt;br&gt;
&amp;lt;nav&amp;gt;定义导航链接&lt;br&gt;
&amp;lt;scetion&amp;gt;定义一个区域&lt;br&gt;
&amp;lt;aside&amp;gt;定义页面内容部分侧边栏&lt;br&gt;
&amp;lt;hgroup&amp;gt;用于对网页或者区域段的标题组合&lt;br&gt;
&amp;lt;figure&amp;gt;定义一组媒体内容以及标题&lt;br&gt;
&amp;lt;figcaption&amp;gt;定义figure元素标题&lt;br&gt;
&amp;lt;address&amp;gt;定义文章拥有者的联系信息&lt;br&gt;
2）行标记&lt;br&gt;
&amp;lt;time&amp;gt;定义时间、日期&lt;br&gt;
&amp;lt;mark&amp;gt;高亮显示文字&lt;br&gt;
3）多媒体交互标签&lt;br&gt;
&amp;lt;video&amp;gt;定义一个视频&lt;br&gt;
&amp;lt;audio&amp;gt;定义一个音频&lt;br&gt;
&amp;lt;source&amp;gt;定义媒体资源标签&lt;br&gt;
&amp;lt;canvas&amp;gt;定义图形&lt;br&gt;
&amp;lt;embed&amp;gt;定义可交互的内容或者插件&lt;br&gt;
4）web应用标签&lt;br&gt;
&amp;lt;progress&amp;gt;状态标签、进度条&lt;br&gt;
&amp;lt;mark&amp;gt;定义有标记的文本（默认是黄色选中内容）&lt;br&gt;
&amp;lt;output&amp;gt;定义一些输出内容，计算表单结果配合oninput事件&lt;br&gt;
&amp;lt;datalist&amp;gt;为input标记定义一个下拉option&lt;/p&gt;
&lt;h1 id=&#34;3-input和textarea的区别&#34;&gt;3. input和textarea的区别&lt;/h1&gt;
&lt;p&gt;&amp;lt;input&amp;gt;是&lt;code&gt;单行文本框&lt;/code&gt;，不会换行。通过size属性指定显示字符的长度，注意：当使用css限定了宽高，那么size属性就不再起作用。&lt;br&gt;
value属性指定初始值，Maxlength属性指定文本框可以输入的最长长度。可以通过width和height设置宽高，但是也不会增加行数。&lt;/p&gt;
&lt;p&gt;&amp;lt;textarea&amp;gt;是&lt;code&gt;多行文本输入框&lt;/code&gt;，文本区中可容纳无限数量的文本，无value属性，其中的文本的默认字体是等宽字体（通常是Courier） ，可以通 过 cols 和 rows 属性来规定 textarea 的尺寸，不过更好的办法是使用 CSS 的 height 和 width 属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
	input:&amp;lt;input value=&amp;quot;啦啦啦啦啦&amp;quot; style=&amp;quot;height:200px;width: 500px;&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div style=&amp;quot;margin-top: 20px;&amp;quot;&amp;gt;
	textarea:&amp;lt;/textarea&amp;gt;&amp;lt;textarea  value=&amp;quot;嘻嘻嘻&amp;quot; style=&amp;quot;height:200px;width: 500px;&amp;quot;&amp;gt; 
   &amp;lt;/textarea&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到：textarea中设置的value并没有显示，同时input文本依然只有一行，并且居中显示。&lt;/p&gt;
&lt;h1 id=&#34;4-用div模拟textarea&#34;&gt;4. 用div模拟textarea&lt;/h1&gt;
&lt;p&gt;作为多行文本域功能来讲，textarea满足了我们大部分的需求。然而，textarea有一个不足就是不能像普通div标签一样高度可以跟随内容自适应。textarea总是很自信地显摆它的滚动条，高度固执地岿然不动。&lt;/p&gt;
&lt;p&gt;要解决这个问题很简单，一个普通的block元素上加个&lt;code&gt;contenteditable=&amp;quot;true&amp;quot;&lt;/code&gt;就ok了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div contenteditable=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614862550654.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
给div设置了一个最小高度，当超过最小高度但不超过最大高度时，div的高度根据文本自适应，当超过最大高度时，出现滚动条。&lt;/p&gt;
&lt;h1 id=&#34;5-html页面动态加载js文件&#34;&gt;5. html页面动态加载js文件&lt;/h1&gt;
&lt;p&gt;下面介绍三种异步执行加载Js 脚本的方法：&lt;/p&gt;
&lt;h2 id=&#34;1-直接documentwrite&#34;&gt;1. 直接document.write&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script language=&amp;quot;javascript&amp;quot;&amp;gt;
document.write(&amp;quot;&amp;lt;script src=&#39;test.js&#39;&amp;gt;&amp;lt;\/script&amp;gt;&amp;quot;);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-动态改变已有script的src属性&#34;&gt;2. 动态改变已有script的src属性&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&#39;&#39; id=&amp;quot;s1&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script language=&amp;quot;javascript&amp;quot;&amp;gt;
s1.src=&amp;quot;test.js&amp;quot;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-动态创建-script元素&#34;&gt;3. 动态创建 script元素&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var script = document.createElement(&#39;script&#39;);
script.type = &amp;quot;text/javascript&amp;quot;;
script.src = &amp;quot;abc.js&amp;quot;;
document.body.appendChild(script);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;6-移动设备忽略将页面中的数字识别为电话号码的方法&#34;&gt;6. 移动设备忽略将页面中的数字识别为电话号码的方法&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;标准的电话号码格式是这样的:&amp;lt;a  href=&amp;quot;tel:1-408-555-5555&amp;quot;&amp;gt;1-408-555-5555&amp;lt;/a&amp;gt;，点击后会自动打开电话功能；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但有时候不是电话号码的数字也会被浏览器自动解析为电话号码, 并把数字的颜色和样式都改了；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果忽略页面中的数字识别为电话号码, 只要把这个默认行为关闭就行，只要一行代码:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta name = &amp;quot;format-detection&amp;quot; content = &amp;quot;telephone=no&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;这个关闭不会影响真正电话号码的识别；&lt;/li&gt;
&lt;/ol&gt;
">【面】前端知识点梳理（Html）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/mian-qian-duan-zhi-shi-dian-shu-li-css-xia/"" data-c="
          &lt;h1 id=&#34;0-行内元素与块级元素的区别&#34;&gt;0. 行内元素与块级元素的区别&lt;/h1&gt;
&lt;h2 id=&#34;1-区别&#34;&gt;1. 区别&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;行内元素和其他行内元素都会在一条水平线上排列，都是在同一行的；块级元素却总是会在新的一行开始排列，各个块级元素独占一行，垂直向下排列，若想使其水平方向排序，可使用左右浮动（float：left/right）让其水平方向排列。&lt;/li&gt;
&lt;li&gt;行内元素不可以设置宽高，宽度高度随文本内容的变化而变化，但是可以设置行高（line-height），同时在设置外边距margin上下无效，左右有效，内填充padding上下无效，左右有效；块级元素可以设置宽高，并且宽度高度以及外边距，内填充都可随意控制。&lt;/li&gt;
&lt;li&gt;块级元素可以包含行内元素和块级元素，还可以容纳内联元素和其他元素；行内元素不能包含块级元素，只能容纳文本或者其他行内元素。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-css样式继承&#34;&gt;2. Css样式继承&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619598673120.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;1-盒模型box-model&#34;&gt;1. 盒模型（box model）&lt;/h1&gt;
&lt;h2 id=&#34;1基本概念&#34;&gt;1.基本概念&lt;/h2&gt;
&lt;p&gt;盒子模型，个人的理解，就是一个来装html标签的矩形容器，由四部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内容区（content）&lt;/li&gt;
&lt;li&gt;内边距（padding）&lt;/li&gt;
&lt;li&gt;外框（border）&lt;/li&gt;
&lt;li&gt;外边距（margin）&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614738716059.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2标准模型与ie模型的区别&#34;&gt;2.标准模型与IE模型的区别&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;标准模型&lt;/strong&gt;与&lt;strong&gt;IE 模型&lt;/strong&gt;的区别在于宽高的计算方式不同。&lt;br&gt;
标准模型计算元素的宽高只算 content 的宽高，IE模型是 content + padding + border 的总尺寸。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614739310471.jfif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
从上图可以看到标准 &lt;code&gt;W3C 盒子模型的范围包括 margin、border、padding、content，并且 content 部分不包含其他部分。&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614739313417.jfif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
从上图可以看到&lt;code&gt;IE 盒子模型的范围也包括 margin、border、padding、content，和标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 pading。&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-如何设置这两种模型&#34;&gt;3、如何设置这两种模型&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;//设置标准模型
box-sizing: content-box;
//设置IE模型
box-sizing: border-box;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-外边距合并&#34;&gt;4. 外边距合并&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619602593954.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;2flex布局&#34;&gt;2.flex布局&lt;/h1&gt;
&lt;p&gt;flex，即弹性布局。一个由css3引入，为我们的盒子属性带来灵活性的一种布局方式。一旦父级采用了flex布局，里边的子控件将收flex布局限制，部分原本的样式（如float:left）也会失效。&lt;/p&gt;
&lt;p&gt;特别注意： flex:0 0 30%的意义： 等于flex-grow=0（默认不放大）+flex-shrink=0（不缩小）+flex-basis=30%（ 项目占据主轴的空间）&lt;/p&gt;
&lt;h2 id=&#34;1flex布局使用&#34;&gt;1.flex布局使用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;任何一个容器都可以指定为 Flex 布局。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.box{
  display: flex;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;行内元素也可以使用 Flex 布局。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.box{
  display: inline-flex;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，设为 Flex 布局以后，子元素的&lt;code&gt;float&lt;/code&gt;、&lt;code&gt;clear&lt;/code&gt;和&lt;code&gt;vertical-align&lt;/code&gt;属性将失效。&lt;/p&gt;
&lt;h2 id=&#34;2基本概念&#34;&gt;2.基本概念&lt;/h2&gt;
&lt;p&gt;采用 Flex 布局的元素，称为 Flex 容器（flex container），简称&amp;quot;容器&amp;quot;。它的所有&lt;strong&gt;子元素&lt;/strong&gt;自动成为容器成员，称为 Flex 项目（flex item），简称&amp;quot;项目&amp;quot;。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614742656456.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做&lt;code&gt;main start&lt;/code&gt;，结束位置叫做&lt;code&gt;main end&lt;/code&gt;；交叉轴的开始位置叫做&lt;code&gt;cross start&lt;/code&gt;，结束位置叫做&lt;code&gt;cross end&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;项目默认沿主轴排列。单个项目占据的主轴空间叫做&lt;code&gt;main size&lt;/code&gt;，占据的交叉轴空间叫做&lt;code&gt;cross size&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;3容器的属性&#34;&gt;3.容器的属性&lt;/h2&gt;
&lt;h3 id=&#34;31-主轴的方向flex-direction&#34;&gt;3.1 &lt;strong&gt;主轴的方向(flex-direction)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;flex-direction&lt;/code&gt;: row | row-reverse | column | column-reverse;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;row（默认值）：主轴为水平方向，起点在左端。&lt;/li&gt;
&lt;li&gt;row-reverse：主轴为水平方向，起点在右端。&lt;/li&gt;
&lt;li&gt;column：主轴为垂直方向，起点在上沿。&lt;/li&gt;
&lt;li&gt;column-reverse：主轴为垂直方向，起点在下沿。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614742821013.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-换行属性flex-wrap&#34;&gt;3.2 &lt;strong&gt;换行属性(flex-wrap)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;flex-wrap&lt;/code&gt;: nowrap | wrap | wrap-reverse;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nowrap（默认）：不换行。&lt;/li&gt;
&lt;li&gt;wrap：换行，第一行在上方。&lt;/li&gt;
&lt;li&gt;wrap-reverse：换行，第一行在下方。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;简写&lt;/code&gt;：&lt;strong&gt;方向 + 换行&lt;/strong&gt;&lt;br&gt;
flex-flow: &lt;code&gt;&amp;lt;flex-direction&amp;gt;&lt;/code&gt; || &lt;code&gt;&amp;lt;flex-wrap&amp;gt;&lt;/code&gt;;&lt;/p&gt;
&lt;h3 id=&#34;33-主轴对齐方式justify-content&#34;&gt;3.3 &lt;strong&gt;主轴对齐方式(justify-content)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;justify-content&lt;/code&gt;: flex-start | flex-end | center | space-between | space-around;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex-start（默认值）：左对齐&lt;/li&gt;
&lt;li&gt;flex-end：右对齐&lt;/li&gt;
&lt;li&gt;center： 居中&lt;/li&gt;
&lt;li&gt;space-between：两端对齐，项目之间的间隔都相等。&lt;/li&gt;
&lt;li&gt;space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614743145091.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;34-交叉轴对齐方式align-items&#34;&gt;3.4 &lt;strong&gt;交叉轴对齐方式(align-items)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;align-items&lt;/code&gt;: flex-start | flex-end | center | baseline | stretch;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex-start：交叉轴的起点对齐。&lt;/li&gt;
&lt;li&gt;flex-end：交叉轴的终点对齐。&lt;/li&gt;
&lt;li&gt;center：交叉轴的中点对齐。&lt;/li&gt;
&lt;li&gt;baseline: 项目的第一行文字的基线对齐。&lt;/li&gt;
&lt;li&gt;stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614743221850.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;35-多根轴线对齐方式align-content&#34;&gt;3.5 &lt;strong&gt;多根轴线对齐方式(align-content)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;align-content&lt;/code&gt;: flex-start | flex-end | center | space-between | space-around | stretch;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex-start：与交叉轴的起点对齐。&lt;/li&gt;
&lt;li&gt;flex-end：与交叉轴的终点对齐。&lt;/li&gt;
&lt;li&gt;center：与交叉轴的中点对齐。&lt;/li&gt;
&lt;li&gt;space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。&lt;/li&gt;
&lt;li&gt;space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。&lt;/li&gt;
&lt;li&gt;stretch（默认值）：轴线占满整个交叉轴。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614743313971.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4项目的属性&#34;&gt;4.项目的属性&lt;/h2&gt;
&lt;p&gt;排列顺序，数值越小，排列越靠前，默认为0。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;order: &amp;lt;integer&amp;gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;项目的放大比例,默认为0，即如果存在剩余空间，也不放大。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex-grow: &amp;lt;number&amp;gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;项目的缩小比例,默认为1，即如果空间不足，该项目将缩小。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex-shrink: &amp;lt;number&amp;gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;项目占据的空间,默认值为auto，即项目的本来大小&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex-basis: &amp;lt;length&amp;gt; | auto;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;简写flex:&lt;/code&gt;：&lt;strong&gt;flex-grow, flex-shrink 和 flex-basis&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;flex&lt;/code&gt;属性是&lt;code&gt;flex-grow&lt;/code&gt;, &lt;code&gt;flex-shrink&lt;/code&gt; 和&lt;code&gt;flex-basis&lt;/code&gt;的简写，默认值为&lt;code&gt;0 1 auto&lt;/code&gt;。后两个属性可选。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;独立的对齐方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;align-self: auto | flex-start | flex-end | center | baseline | stretch;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614743733611.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;3css单位&#34;&gt;3.CSS单位&lt;/h1&gt;
&lt;p&gt;CSS 有几个不同的单位用于表示长度。&lt;/p&gt;
&lt;p&gt;一些设置 CSS 长度的属性有 width, margin, padding, font-size, border-width, 等。&lt;/p&gt;
&lt;p&gt;长度有一个数字和单位组成如 10px, 2em, 等。&lt;/p&gt;
&lt;p&gt;数字与单位之间不能出现空格。如果长度值为 0，则可以省略单位。&lt;/p&gt;
&lt;p&gt;对于一些 CSS 属性，长度可以是负数。&lt;/p&gt;
&lt;p&gt;有两种类型的长度单位：&lt;strong&gt;相对和绝对&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;31-相对长度&#34;&gt;3.1 相对长度&lt;/h2&gt;
&lt;p&gt;相对长度单位指定了一个长度相对于另一个长度的属性。对于&lt;strong&gt;不同的设备&lt;/strong&gt;相对长度更适用。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;单位&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;em&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;它是描述相对于应用在当前元素的字体尺寸，所以它也是相对长度单位。一般浏览器字体大小默认为16px，则2em == 32px；&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ex&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;依赖于英文字母小 x 的高度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ch&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数字 0 的宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;rem&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;rem 是根 em（root em）的缩写，rem作用于非根元素时，相对于根元素字体大小；rem作用于根元素字体大小时，相对于其出初始字体大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;vw&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;viewpoint width，视窗宽度，1vw=视窗宽度的1%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;vh&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;viewpoint height，视窗高度，1vh=视窗高度的1%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;vmin&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;vw和vh中较小的那个。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;vmax&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;vw和vh中较大的那个。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;提示: rem与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-绝对长度&#34;&gt;3.2 绝对长度&lt;/h2&gt;
&lt;p&gt;绝对长度单位是一个固定的值，它反应一个真实的物理尺寸。绝对长度单位视输出介质而定，不依赖于环境（显示器、分辨率、操作系统等）。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;单位&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;cm&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;厘米&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;mm&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;毫米&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;in&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;英寸 (1in = 96px = 2.54cm)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;px&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;像素 (1px = 1/96th of 1in)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pt&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;point，大约1/72英寸； (1pt = 1/72in)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pc&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pica，大约 12pt，1/6英寸； (1pc = 12 pt)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;4css选择器&#34;&gt;4.css选择器&lt;/h1&gt;
&lt;h2 id=&#34;40-伪类和伪元素的区别&#34;&gt;4.0 伪类和伪元素的区别？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档数外的元素。&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;41基础选择器&#34;&gt;4.1基础选择器&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614746568376.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
“选择器”指明了{}中的“样式”的作用对象，也就是“样式”作用于网页中的哪些元素&lt;br&gt;
1.&lt;strong&gt;通配选择器&lt;/strong&gt; *: 所有的标签都变色&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;标签(元素)选择器&lt;/strong&gt;：匹配所有使用p标签的样式 p{color:red}&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;id选择器&lt;/strong&gt;：匹配指定的标签  #p2{color:red}&lt;/p&gt;
&lt;p&gt;4.&lt;strong&gt;class类选择器&lt;/strong&gt;：谁指定class谁的变色，可选多个  .c1{color:red} 或者 div.c1{color:red}&lt;/p&gt;
&lt;h2 id=&#34;42-复合选择器&#34;&gt;4.2 复合选择器&lt;/h2&gt;
&lt;p&gt;1.&lt;strong&gt;交集选择器&lt;/strong&gt;（合着写）&lt;br&gt;
&lt;strong&gt;作用&lt;/strong&gt;：选中同时复合多个条件的元素&lt;br&gt;
&lt;strong&gt;语法&lt;/strong&gt;：选择器1选择器2选择器3选择器n{}&lt;br&gt;
&lt;strong&gt;注意点&lt;/strong&gt;：交集选择器中如果有元素选择器，必须使用元素选择器开头&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;并集选择器&lt;/strong&gt;（逗号隔开）&lt;br&gt;
&lt;strong&gt;作用&lt;/strong&gt;：同时选择多个选择器对应的元素&lt;br&gt;
&lt;strong&gt;语法&lt;/strong&gt;：选择器1,选择器2,选择器3,选择器n{}&lt;br&gt;
&lt;strong&gt;例子&lt;/strong&gt;：#b1,.p1,h1,span,div.red{}&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;关系选择器&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;(1)子元素选择器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用：选中指定父元素的指定子元素&lt;/li&gt;
&lt;li&gt;语法：父元素 &amp;gt; 子元素&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;div.box &amp;gt; span{
        color: orange;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;(2)后代元素选择器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用：选中指定元素内的指定后代元素&lt;/li&gt;
&lt;li&gt;语法：祖先 后代&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;div span{
      color: skyblue
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;(3)兄弟元素选择器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择下一个兄弟&lt;br&gt;
语法：前一个 + 下一个&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;p + span{
     color: red;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;选择下边所有的兄弟&lt;br&gt;
语法：兄 ~ 弟&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt; p ~ span{
      color: red;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.&lt;strong&gt;属性选择器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[属性名] 选择含有指定属性的元素&lt;/li&gt;
&lt;li&gt;[属性名=属性值] 选择含有指定属性和属性值的元素&lt;/li&gt;
&lt;li&gt;[属性名^=属性值] 选择属性值以指定值开头的元素&lt;/li&gt;
&lt;li&gt;[属性名$=属性值] 选择属性值以指定值结尾的元素&lt;/li&gt;
&lt;li&gt;[属性名*=属性值] 选择属性值中含有某值的元素的元素&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt; p[title*=e]{
      color: orange;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.&lt;strong&gt;伪类选择器&lt;/strong&gt;&lt;br&gt;
伪类一般情况下都是使用&lt;code&gt;:&lt;/code&gt;开头&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;:first-child 第一个子元素&lt;/li&gt;
&lt;li&gt;:last-child 最后一个子元素&lt;/li&gt;
&lt;li&gt;:nth-child() 选中第n个子元素&lt;/li&gt;
&lt;li&gt;:first-of-type&lt;/li&gt;
&lt;li&gt;:last-of-type&lt;/li&gt;
&lt;li&gt;:nth-of-type()          - 他们是在同类型元素中进行排序&lt;/li&gt;
&lt;li&gt;:not() 否定伪类        - 将符合条件的元素从选择器中去除&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;ul &amp;gt; li:nth-child(2n+1){
      color: red;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;43-css优先级&#34;&gt;4.3 CSS优先级&lt;/h2&gt;
&lt;p&gt;当两个规则都作用到了同一个html元素上时，如果定义的属性有冲突，那么应该用谁的值的，CSS有一套优先级的定义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不同级别&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。&lt;/li&gt;
&lt;li&gt;作为style属性写在元素内的样式&lt;/li&gt;
&lt;li&gt;id选择器&lt;/li&gt;
&lt;li&gt;类选择器&lt;/li&gt;
&lt;li&gt;标签选择器&lt;/li&gt;
&lt;li&gt;通配符选择器&lt;/li&gt;
&lt;li&gt;浏览器自定义或继承&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;总结排序：!important &amp;gt; 行内样式&amp;gt;ID选择器 &amp;gt; 类选择器 &amp;gt; 标签 &amp;gt; 通配符 &amp;gt; 继承 &amp;gt; 浏览器默认属性&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同一级别&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同一级别中后写的会覆盖先写的样式&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619086185333.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;5bfc-清除浮动&#34;&gt;5.bfc 清除浮动&lt;/h1&gt;
&lt;p&gt;BFC(Block Formatting Context) 块级格式化环境&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;BFC是一个CSS中的一个隐含的属性，可以为一个元素开启BFC&lt;br&gt;
开启BFC该元素会变成一个独立的布局区域&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;元素开启BFC后的特点：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;开启BFC的元素不会被浮动元素所覆盖&lt;/li&gt;
&lt;li&gt;开启BFC的元素子元素和父元素外边距不会重叠&lt;/li&gt;
&lt;li&gt;开启BFC的元素可以包含浮动的子元素&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;可以通过一些特殊方式来开启元素的BFC：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;设置元素的浮动（不推荐）&lt;/li&gt;
&lt;li&gt;将元素设置为行内块元素（不推荐）&lt;/li&gt;
&lt;li&gt;将元素的overflow设置为一个非visible的值&lt;br&gt;
&lt;code&gt;常用的方式 为元素设置 overflow:hidden 开启其BFC&lt;/code&gt; 以使其可以包含浮动元素&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，除了BFC，还有IFC、GFC、FFC的概念。我们简单了解一下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GFC：可简单理解为grid布局&lt;/li&gt;
&lt;li&gt;FFC：可简单理解为flex布局。&lt;/li&gt;
&lt;li&gt;IFC:内联格式化上下文，简单理解为：inline-block。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;水平方向上的 margin，border 和 padding在框之间得到保留。框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐。包含那些框的长方形区域，会形成一行，叫做行框。 inline-block的元素的内部是一个BFC，但是它本身可以和其它inline元素一起形成IFC。&lt;/p&gt;
&lt;h1 id=&#34;6层叠上下文&#34;&gt;6.层叠上下文&lt;/h1&gt;
&lt;h2 id=&#34;1层叠上下文stacking-context&#34;&gt;1.层叠上下文(Stacking Context)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614762081794.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
层叠上下文1 (Stacking Context 1)是由文档根元素形成的， 层叠上下文2和3 (Stacking Context 2, 3) 都是层叠上下文1 (Stacking Context 1) 上的层叠层。 他们各自也都形成了新的层叠上下文，其中包含着新的层叠层。&lt;/p&gt;
&lt;p&gt;在层叠上下文中，其子元素按照上面解释的规则进行层叠。形成层叠上下文的方法有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根元素 &amp;lt;html&amp;gt;&amp;lt;/html&amp;gt;&lt;/li&gt;
&lt;li&gt;position值为 absolute|relative，且 z-index值不为 auto&lt;/li&gt;
&lt;li&gt;position 值为 fixed|sticky&lt;/li&gt;
&lt;li&gt;z-index 值不为 auto 的flex元素，即：父元素 display:flex|inline-flex&lt;/li&gt;
&lt;li&gt;opacity 属性值小于 1 的元素&lt;/li&gt;
&lt;li&gt;transform 属性值不为 none的元素&lt;/li&gt;
&lt;li&gt;mix-blend-mode 属性值不为 normal 的元素&lt;/li&gt;
&lt;li&gt;filter、 perspective、 clip-path、 mask、 mask-image、 mask-border、 motion-path 值不为none 的元素&lt;/li&gt;
&lt;li&gt;perspective 值不为 none 的元素&lt;/li&gt;
&lt;li&gt;isolation 属性被设置为 isolate 的元素&lt;/li&gt;
&lt;li&gt;will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值&lt;/li&gt;
&lt;li&gt;-webkit-overflow-scrolling 属性被设置 touch的元素&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总结:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;层叠上下文可以包含在其他层叠上下文中，并且一起组建了一个有层级的层叠上下文&lt;/li&gt;
&lt;li&gt;每个层叠上下文完全独立于它的兄弟元素，当处理层叠时只考虑子元素，这里类似于BFC&lt;/li&gt;
&lt;li&gt;每个层叠上下文是自包含的：当元素的内容发生层叠后，整个该元素将会&lt;strong&gt;在父级叠上下文&lt;/strong&gt;中按顺序进行层叠&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-层叠等级-stacking-level&#34;&gt;2. 层叠等级 (Stacking Level)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;层叠等级&lt;/strong&gt; (层叠水平, Stacking Level) 决定了同一个层叠上下文中元素在z轴上的显示顺序的&lt;strong&gt;概念&lt;/strong&gt;；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通元素的层叠等级优先由其所在的层叠上下文决定&lt;/li&gt;
&lt;li&gt;层叠等级的比较只有在同一个层叠上下文元素中才有意义&lt;/li&gt;
&lt;li&gt;在同一个层叠上下文中，层叠等级描述定义的是该层叠上下文中的元素在Z轴上的上下顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;，层叠等级并不一定由 z-index 决定，只有定位元素的层叠等级才由 z-index 决定，其他类型元素的层叠等级由层叠顺序、他们在HTML中出现的顺序、他们的父级以上元素的层叠等级一同决定，详细的规则见下面层叠顺序的介绍。&lt;/p&gt;
&lt;h2 id=&#34;3-z-index&#34;&gt;3. z-index&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在 CSS 2.1 中, 所有的盒模型元素都处于三维坐标系中。 除了我们常用的横坐标和纵坐标， 盒模型元素还可以沿着&amp;quot;z 轴&amp;quot;层叠摆放， 当他们相互覆盖时， z 轴顺序就变得十分重要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;z-index 只适用于定位的元素，对非定位元素无效，它可以被设置为正整数、负整数、0、auto，如果一个定位元素没有设置 z-index，那么默认为auto；&lt;/p&gt;
&lt;p&gt;元素的 z-index 值只在同一个层叠上下文中有意义。如果父级层叠上下文的层叠等级低于另一个层叠上下文的，那么它 z-index 设的再高也没用。所以如果你遇到 z-index 值设了很大，但是不起作用的话，就去看看它的父级层叠上下文是否被其他层叠上下文盖住了。&lt;/p&gt;
&lt;h2 id=&#34;4-层叠顺序-stacking-order&#34;&gt;4. 层叠顺序 (Stacking Order)&lt;/h2&gt;
&lt;p&gt;这里其实是涉及了所谓的层叠水平（stacking level)，有一张图可以很好的诠释：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614774762413.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;形成堆叠上下文环境的元素的背景与边框&lt;/li&gt;
&lt;li&gt;拥有负 z-index 的子堆叠上下文元素 （负的越高越堆叠层级越低）&lt;/li&gt;
&lt;li&gt;正常流式布局，非 inline-block，无 position 定位（static除外）的子元素&lt;/li&gt;
&lt;li&gt;无 position 定位（static除外）的 float 浮动元素&lt;/li&gt;
&lt;li&gt;正常流式布局， inline-block元素，无 position 定位（static除外）的子元素（包括 display:table 和 display:inline ）&lt;/li&gt;
&lt;li&gt;拥有 z-index:0 的子堆叠上下文元素&lt;/li&gt;
&lt;li&gt;拥有正 z-index: 的子堆叠上下文元素（正的越低越堆叠层级越低）&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;7-常见页面布局&#34;&gt;7. 常见页面布局&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;三栏布局&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目：假设高度已知，请写出三栏布局，其中左栏、右栏宽度各为 300px，中间自适应。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解答：可以有很多种布局方式，这里列出五种：float布局，absolute布局，flex布局，table布局，grid布局，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
	&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
	&amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=edge&amp;quot;&amp;gt;
	&amp;lt;title&amp;gt;三栏布局&amp;lt;/title&amp;gt;
	&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;&amp;quot;&amp;gt;
	&amp;lt;style type=&amp;quot;text/css&amp;quot; media=&amp;quot;screen&amp;quot;&amp;gt;
		html *{
			margin: 0;
			padding: 0;
		}
	&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
	&amp;lt;section class=&amp;quot;layout float&amp;quot;&amp;gt;
		&amp;lt;style type=&amp;quot;text/css&amp;quot; media=&amp;quot;screen&amp;quot;&amp;gt;
			.layout.float .wrapper&amp;gt;div{
				min-height: 100px;
			}
			.layout.float .left{
				float: left;
				width: 300px;
				background: red;
			}
			.layout.float .center{
				background: yellow;
			}
			.layout.float .right{
				float: right;
				width: 300px;
				background: blue;
			}
			
		&amp;lt;/style&amp;gt;
		&amp;lt;article class=&amp;quot;wrapper&amp;quot;&amp;gt;
			&amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt;
				&amp;lt;h1&amp;gt;float布局&amp;lt;/h1&amp;gt;
				1.我是float布局的中间部分
				2.我是float布局的中间部分
			&amp;lt;/div&amp;gt;
		&amp;lt;/article&amp;gt;
	&amp;lt;/section&amp;gt;


	&amp;lt;section class=&amp;quot;layout absolute&amp;quot;&amp;gt;
		&amp;lt;style type=&amp;quot;text/css&amp;quot; media=&amp;quot;screen&amp;quot;&amp;gt;
			.layout.absolute .wrapper{
				width: 100%;
				margin-top: 20px;
			}
			.layout.absolute .wrapper&amp;gt;div{
				min-height: 100px;
			}
			.layout.absolute .left{
				position: absolute;
				left: 0;
				width: 300px;
				background: red;
			}
			.layout.absolute .center{
				position: absolute;
				left: 300px;
				right: 300px;
				background: yellow;
			}
			.layout.absolute .right{
				position: absolute;
				right: 0;
				width: 300px;
				background: blue;
			}
		&amp;lt;/style&amp;gt;
		&amp;lt;article class=&amp;quot;wrapper&amp;quot;&amp;gt;
			&amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt;
				&amp;lt;h1&amp;gt;absolute布局&amp;lt;/h1&amp;gt;
				1.我是absolute布局的中间部分
				2.我是absolute布局的中间部分
			&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
		&amp;lt;/article&amp;gt;
	&amp;lt;/section&amp;gt;


	&amp;lt;section class=&amp;quot;layout flex&amp;quot;&amp;gt;
		&amp;lt;style type=&amp;quot;text/css&amp;quot; media=&amp;quot;screen&amp;quot;&amp;gt;
			.layout.flex .wrapper{
				width: 100%;
				min-height: 100px;
				display: flex;
				margin-top: 140px;
			}
			.layout.flex .left{
				width: 300px;
				background: red;
			}
			.layout.flex .center{
				flex: 1;
				background: yellow;
			}
			.layout.flex .right{
				width: 300px;
				background: blue;
			}
		&amp;lt;/style&amp;gt;
		&amp;lt;article class=&amp;quot;wrapper&amp;quot;&amp;gt;
			&amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt;
				&amp;lt;h1&amp;gt;flex布局&amp;lt;/h1&amp;gt;
				1.我是flex布局的中间部分
				2.我是flex布局的中间部分
			&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
		&amp;lt;/article&amp;gt;
	&amp;lt;/section&amp;gt;


	&amp;lt;section class=&amp;quot;layout table&amp;quot;&amp;gt;
		&amp;lt;style type=&amp;quot;text/css&amp;quot; media=&amp;quot;screen&amp;quot;&amp;gt;
			.layout.table .wrapper{
				display: table;
				width: 100%;
				min-height: 100px;
				margin-top: 20px;
			}
			.layout.table .left{
				display: table-cell;
				width: 300px;
				background: red;
			}
			.layout.table .center{
				display: table-cell;
				background: yellow;
			}
			.layout.table .right{
				display: table-cell;
				width: 300px;
				background: blue;
			}
			
		&amp;lt;/style&amp;gt;
		&amp;lt;article class=&amp;quot;wrapper&amp;quot;&amp;gt;
			&amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt;
				&amp;lt;h1&amp;gt;table布局&amp;lt;/h1&amp;gt;
				1.我是table布局的中间部分
				2.我是table布局的中间部分
			&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
		&amp;lt;/article&amp;gt;
	&amp;lt;/section&amp;gt;


	&amp;lt;section class=&amp;quot;layout grid&amp;quot;&amp;gt;
		&amp;lt;style type=&amp;quot;text/css&amp;quot; media=&amp;quot;screen&amp;quot;&amp;gt;
			.layout.grid .wrapper{
				display: grid;
				grid-template-columns: 300px auto 300px;
				grid-template-rows: 100px;
				width: 100%;
				margin-top: 20px;
			}
			.layout.grid .left{
				background: red;
			}
			.layout.grid .center{
				background: yellow;
			}
			.layout.grid .right{
				background: blue;
			}
			
		&amp;lt;/style&amp;gt;
		&amp;lt;article class=&amp;quot;wrapper&amp;quot;&amp;gt;
			&amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt;
				&amp;lt;h1&amp;gt;grid布局&amp;lt;/h1&amp;gt;
				1.我是grid布局的中间部分
				2.我是grid布局的中间部分
			&amp;lt;/div&amp;gt;
			&amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
		&amp;lt;/article&amp;gt;
	&amp;lt;/section&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;71-每种布局的优缺点&#34;&gt;7.1 每种布局的优缺点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;float 布局&lt;/code&gt;&lt;br&gt;
优点： 比较简单，兼容性也比较好。只要清除浮动做的好，是没有什么问题的&lt;br&gt;
缺点：浮动元素是脱离文档流，要做清除浮动，这个处理不好的话，会带来很多问题，比如高度塌陷等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;绝对布局&lt;/code&gt;&lt;br&gt;
优点：很快捷，设置很方便，而且也不容易出问题&lt;br&gt;
缺点：绝对定位是脱离文档流的，意味着下面的所有子元素也会脱离文档流，这就导致了这种方法的有效性和可使用性是比较差的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;flex 布局&lt;/code&gt;&lt;br&gt;
优点：简单快捷&lt;br&gt;
缺点：不支持 IE8 及以下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;table布局&lt;/code&gt;&lt;br&gt;
优点：实现简单，代码少&lt;br&gt;
缺点：当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的，而有时候这种效果不是我们想要的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;grid布局&lt;/code&gt;&lt;br&gt;
跟 flex 相似。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;72-水平垂直居中&#34;&gt;7.2 水平垂直居中&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;absolute + 负margin&lt;/strong&gt;&lt;br&gt;
这种方式比较好理解，兼容性也很好，缺点是需要知道子元素的宽高&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;out&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;inner&amp;quot;&amp;gt;12345&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
  .out{
    position: relative;
    width: 300px;
    height: 300px;
    background: red;
  }

  .inner{
    position: absolute;
    width: 100px;
    height: 100px;
    background: yellow;
    left: 50%;
    top: 50%;
    margin-left: -50px;
    margin-top: -50px;
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;absolute + auto margin&lt;/strong&gt;&lt;br&gt;
这种方法兼容性也很好，缺点是需要知道子元素的宽高&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
  .out{
    position: relative;
    width: 300px;
    height: 300px;
    background: red;
  }

  .inner{
    position: absolute;
    width: 100px;
    height: 100px;
    background: yellow;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    margin: auto;
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;absolute + calc&lt;/strong&gt;&lt;br&gt;
这种方法的兼容性依赖于 calc，且也需要知道宽高&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
  .out{
    position: relative;
    width: 300px;
    height: 300px;
    background: red;
  }

  .inner{
    position: absolute;
    width: 100px;
    height: 100px;
    background: yellow;
    left: calc(50% - 50px);
    top: calc(50% - 50px);
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;absolute + transform&lt;/strong&gt;&lt;br&gt;
兼容性依赖 translate，不需要知道子元素宽高&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
  .out{
    position: relative;
    width: 300px;
    height: 300px;
    background: red;
  }

  .inner{
    position: absolute;
    background: yellow;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;table&lt;/strong&gt;&lt;br&gt;
css新增的table属性，可以让我们把普通元素，变为table元素的显示效果，通过这个特性也可以实现水平垂直居中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种方法兼容性也不错。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
  .out{
    display: table-cell;
    width: 300px;
    height: 300px;
    text-align: center;
    vertical-align: middle;
    background: red;
  }

  .inner{
    display: inline-block;
    background: yellow;
    width: 100px;
    height: 100px;
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;strong&gt;flex&lt;/strong&gt;&lt;br&gt;
flex 实现起来比较简单，三行代码即可搞定。可通过父元素指定子元素的对齐方式，也可通过 子元素自己指定自己的对齐方式来实现。第二种方式见 grid 布局。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
  .out{
    display: flex;
    justify-content: center;
    align-items: center;
    width: 300px;
    height: 300px;
    background: red;
  }

  .inner{
    background: yellow;
    width: 100px;
    height: 100px;
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;&lt;strong&gt;grid&lt;/strong&gt;&lt;br&gt;
grid 布局也很强大，大体上属性跟 flex 差不多。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
  .out{
    display: grid;
    width: 300px;
    height: 300px;
    background: red;
  }

  .inner{
    background: yellow;
    width: 100px;
    height: 100px;
    align-self: center;
    justify-self: center;
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;页面布局小结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语义化掌握到位&lt;/li&gt;
&lt;li&gt;页面布局理解深刻&lt;/li&gt;
&lt;li&gt;CSS基础知识扎实&lt;/li&gt;
&lt;li&gt;思维灵活且积极上进&lt;/li&gt;
&lt;li&gt;代码书写规范&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;8-响应式布局&#34;&gt;8. 响应式布局&lt;/h1&gt;
&lt;p&gt;响应式设计与自适应设计的区别：响应式开发一套界面，通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容；自适应需要开发多套界面，通过检测视口分辨率，来判断当前访问的设备是pc端、平板、手机，从而请求服务层，返回不同的页面。&lt;/p&gt;
&lt;h2 id=&#34;81-媒体查询&#34;&gt;8.1 媒体查询&lt;/h2&gt;
&lt;p&gt;CSS3媒体查询可以让我们针对不同的媒体类型定义不同的样式，当重置浏览器窗口大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。&lt;/p&gt;
&lt;p&gt;不管是移动优先还是PC优先，都是依据当随着屏幕宽度增大或减小的时候，后面的样式会覆盖前面的样式。因此，移动端优先首先使用的是min-width，PC端优先使用的max-width。&lt;/p&gt;
&lt;h2 id=&#34;82-百分比布局&#34;&gt;8.2 百分比布局&lt;/h2&gt;
&lt;p&gt;通过百分比单位，可以使得浏览器中组件的宽和高随着浏览器的高度的变化而变化，从而实现响应式的效果。Bootstrap里面的栅格系统就是利用百分比来定义元素的宽高，CSS3支持最大最小高，可以将百分比和max(min)一起结合使用来定义元素在不同设备下的宽高。&lt;/p&gt;
&lt;p&gt;计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。&lt;/p&gt;
&lt;p&gt;各个属性中如果使用百分比，相对父元素的属性并不是唯一的。比如width和height相对于父元素的width和height，而margin、padding不管垂直还是水平方向都相对比父元素的宽度、border-radius则是相对于元素自身等等，造成我们使用百分比单位容易使布局问题变得复杂。&lt;/p&gt;
&lt;h2 id=&#34;83-rem布局&#34;&gt;8.3 rem布局&lt;/h2&gt;
&lt;p&gt;REM是CSS3新增的单位，并且移动端的支持度很高，Android2.x+,ios5+都支持。rem单位都是相对于根元素html的font-size来决定大小的,根元素的font-size相当于提供了一个基准，当页面的size发生变化时，只需要改变font-size的值，那么以rem为固定单位的元素的大小也会发生响应的变化。 因此，如果通过rem来实现响应式的布局，只需要根据视图容器的大小，动态的改变font-size即可（而em是相对于父元素的）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rem响应式的布局思想：&lt;/strong&gt;&lt;br&gt;
一般不要给元素设置具体的宽度，但是对于一些小图标可以设定具体宽度值&lt;/p&gt;
&lt;p&gt;高度值可以设置固定值，设计稿有多大，我们就严格有多大&lt;/p&gt;
&lt;p&gt;所有设置的固定值都用rem做单位（首先在HTML总设置一个基准值：px和rem的对应比例，然后在效果图上获取px值，布局的时候转化为rem值)&lt;/p&gt;
&lt;p&gt;js获取真实屏幕的宽度，让其除以设计稿的宽度，算出比例，把之前的基准值按照比例进行重新的设定，这样项目就可以在移动端自适应了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rem布局的缺点：&lt;/strong&gt;&lt;br&gt;
在响应式布局中，必须通过js来动态控制根元素font-size的大小，也就是说css样式和js代码有一定的耦合性，且必须将改变font-size的代码放在css样式之前&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;REM布局也是目前多屏幕适配的最佳方式&lt;/strong&gt;。默认情况下我们html标签的font-size为16px,我们利用媒体查询，设置在不同设备下的字体大小。&lt;/p&gt;
&lt;h2 id=&#34;84-视口单位&#34;&gt;8.4 视口单位&lt;/h2&gt;
&lt;p&gt;css3中引入了一个新的单位vw/vh，与视图窗口有关，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。各个单位具体的含义如下：&lt;/p&gt;
&lt;p&gt;用视口单位度量，视口宽度为100vw，高度为100vh（左侧为竖屏情况，右侧为横屏情况）。例如，在桌面端浏览器视口尺寸为650px，那么 1vw = 650 * 1% = 6.5px（这是理论推算的出，如果浏览器不支持0.5px，那么实际渲染结果可能是7px）。&lt;/p&gt;
&lt;p&gt;使用视口单位来实现响应式有两种做法：&lt;/p&gt;
&lt;p&gt;1.仅使用vw作为CSS单位&lt;br&gt;
2.搭配vw和rem&lt;/p&gt;
&lt;h2 id=&#34;85-图片响应式&#34;&gt;8.5 图片响应式&lt;/h2&gt;
&lt;p&gt;这里的图片响应式包括两个方面，一个就是大小自适应，这样能够保证图片在不同的屏幕分辨率下出现压缩、拉伸的情况；一个就是根据不同的屏幕分辨率和设备像素比来尽可能选择高分辨率的图片，也就是当在小屏幕上不需要高清图或大图，这样我们用小图代替，就可以减少网络带宽了。&lt;/p&gt;
&lt;p&gt;1.使用max-width（图片自适应）:&lt;br&gt;
图片自适应意思就是图片能随着容器的大小进行缩放&lt;/p&gt;
&lt;p&gt;2.使用srcset    &amp;lt;img srcset=&amp;quot;photo_w350.jpg 1x, photo_w640.jpg 2x&amp;quot; src=&amp;quot;photo_w350.jpg&amp;quot; alt=&amp;quot;&amp;quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;3.使用background-image&lt;/p&gt;
&lt;p&gt;4.使用picture标签&lt;/p&gt;
&lt;h2 id=&#34;86响应式布局的要点&#34;&gt;8.6响应式布局的要点&lt;/h2&gt;
&lt;p&gt;在实际项目中，我们可能需要综合上面的方案，比如用rem来做字体的适配，用srcset来做图片的响应式，宽度可以用rem，flex，栅格系统等来实现响应式，然后可能还需要利用媒体查询来作为响应式布局的基础，因此综合上面的实现方案，项目中实现响应式布局需要注意下面几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置viewport&lt;/li&gt;
&lt;li&gt;媒体查询&lt;/li&gt;
&lt;li&gt;字体的适配（字体单位）&lt;/li&gt;
&lt;li&gt;百分比布局&lt;/li&gt;
&lt;li&gt;图片的适配（图片的响应式）&lt;/li&gt;
&lt;li&gt;结合flex，grid，BFC，栅格系统等已经成型的方案&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;9-css预处理后处理&#34;&gt;9. css预处理，后处理&lt;/h1&gt;
&lt;h2 id=&#34;91-css-预处理器&#34;&gt;9.1 CSS 预处理器&lt;/h2&gt;
&lt;p&gt;CSS 预处理器用一种专门的编程语言，进行 Web 页面样式设计，然后再编译成正常的 CSS 文件，以供项目使用。&lt;strong&gt;CSS 预处理器为 CSS 增加一些编程的特性，无需考虑浏览器的兼容性问题。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CSS语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器；&lt;/li&gt;
&lt;li&gt;没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Sass、LESS、Stylus 是目前最主流的 CSS 预处理器。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现原理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取到 &lt;strong&gt;DSL&lt;/strong&gt; 源代码 的 &lt;strong&gt;分析树&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将含有 &lt;strong&gt;动态生成&lt;/strong&gt; 相关节点的 &lt;strong&gt;分析树&lt;/strong&gt; 转换为 &lt;strong&gt;静态分析树&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将 &lt;strong&gt;静态分析树&lt;/strong&gt; 转换为 CSS 的 &lt;strong&gt;静态分析树&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将 CSS 的** 静态分析树** 转换为 &lt;strong&gt;CSS 代码&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现实中的 &lt;strong&gt;CSS 预处理器&lt;/strong&gt; 更复杂一点儿，因为大多功能要同时支持 &lt;strong&gt;特有 DSL 与 原生 CSS&lt;/strong&gt;，一件事情要同时考虑两种情况下的处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：语言级逻辑处理，动态特性，改善项目结构&lt;/li&gt;
&lt;li&gt;缺点：采用特殊语法，框架耦合度高，复杂度高&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;92-css-后处理器&#34;&gt;9.2 CSS 后处理器&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;CSS 后处理器&lt;/strong&gt; 是对 CSS 进行处理，并最终生成 CSS 的 &lt;code&gt;预处理器&lt;/code&gt;，它属于广义上的 &lt;strong&gt;CSS 预处理器&lt;/strong&gt;。 我们很久以前就在用 &lt;strong&gt;CSS 后处理器&lt;/strong&gt; 了，最典型的例子是 &lt;strong&gt;CSS 压缩工具&lt;/strong&gt;（如 &lt;code&gt;clean-css&lt;/code&gt;），只不过以前没单独拿出来说过。 还有最近比较火的 &lt;code&gt;Autoprefixer&lt;/code&gt;，以 Can I Use 上的 &lt;strong&gt;浏览器支持数据&lt;/strong&gt;为基础，自动处理兼容性问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现原理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 &lt;strong&gt;源代码&lt;/strong&gt; 做为 &lt;strong&gt;CSS&lt;/strong&gt; 解析，获得 &lt;strong&gt;分析树&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;对 &lt;strong&gt;CSS&lt;/strong&gt; 的 &lt;strong&gt;分析树&lt;/strong&gt; 进行 &lt;strong&gt;后处理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将 &lt;strong&gt;CSS&lt;/strong&gt; 的 &lt;strong&gt;分析树&lt;/strong&gt; 转换为 &lt;strong&gt;CSS 代码&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;优缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：使用 CSS 语法，容易进行模块化，贴近 CSS 的未来标准&lt;/li&gt;
&lt;li&gt;缺点：逻辑处理能力有限&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;10-css3新特性&#34;&gt;10. css3新特性&lt;/h1&gt;
&lt;h2 id=&#34;1-transition的属性&#34;&gt;1. transition的属性&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;CSS3的过渡功能就像是一种黄油，可以让CSS的一些变化变得平滑。因为原生的CSS过渡在客户端需要处理的资源要比用JavaScript和Flash少的多，所以才会更平滑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614826493004.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;transition-property&lt;br&gt;
不是所有属性都能过渡，只有属性具有一个中间点值才具备过渡效果。&lt;/li&gt;
&lt;li&gt;transition-duration&lt;br&gt;
指定从一个属性到另一个属性过渡所要花费的时间。默认值为0，为0时，表示变化是瞬时的，看不到过渡效果。&lt;/li&gt;
&lt;li&gt;transiton-timing-function&lt;br&gt;
过渡函数，有如下几种：&lt;br&gt;
liner ：匀速&lt;br&gt;
ease-in：减速&lt;br&gt;
ease-out：加速&lt;br&gt;
ease-in-out：先加速再减速&lt;br&gt;
cubic-bezier：三次贝塞尔曲线&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;触发过渡&lt;/code&gt;&lt;br&gt;
单纯的代码不会触发任何过渡操作，需要通过用户的行为（如点击，悬浮等）触发，可触发的方式有：&lt;br&gt;
&lt;strong&gt;:hoever :focus :checked 媒体查询触发 JavaScript触发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;局限性&lt;/code&gt;&lt;br&gt;
transition的优点在于简单易用，但是它有几个很大的局限。 &lt;br&gt;
（1）transition需要事件触发，所以没法在网页加载时自动发生。 &lt;br&gt;
（2）transition是一次性的，不能重复发生，除非一再触发。 &lt;br&gt;
（3）transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。 &lt;br&gt;
（4）一条transition规则，只能定义一个属性的变化，不能涉及多个属性。 &lt;br&gt;
CSS Animation就是为了解决这些问题而提出的。&lt;/p&gt;
&lt;h2 id=&#34;2-animation的属性&#34;&gt;2. animation的属性&lt;/h2&gt;
&lt;p&gt;CSS3的animation属性可以像Flash制作动画一样，通过控制关键帧来控制动画的每一步，实现更为复杂的动画效果。ainimation实现动画效果主要由两部分组成：&lt;br&gt;
1）通过类似Flash动画中的帧来声明一个动画；&lt;br&gt;
2）在animation属性中调用关键帧声明的动画。&lt;br&gt;
&lt;code&gt;动画属性&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614826993212.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
（1）animation-name：none为默认值，将没有任何动画效果，其可以用来覆盖任何动画 &lt;br&gt;
（2）animation-duration：默认值为0，意味着动画周期为0，也就是没有任何动画效果 &lt;br&gt;
（3）animation-timing-function：与transition-timing-function一样 &lt;br&gt;
（4）animation-delay：在开始执行动画时需要等待的时间 &lt;br&gt;
（5）animation-iteration-count：定义动画的播放次数，默认为1，如果为infinite，则无限次循环播放 &lt;br&gt;
（6）animation-direction：默认为nomal，每次循环都是向前播放，（0-100），另一个值为alternate，动画播放为偶数次则向前播放，如果为基数词就反方向播放 &lt;br&gt;
（7）animation-state：默认为running，播放，paused，暂停 &lt;br&gt;
（8）animation-fill-mode：定义动画开始之前和结束之后发生的操作，默认值为none，动画结束时回到动画没开始时的状态；forwards，动画结束后继续应用最后关键帧的位置，即保存在结束状态；backwards，让动画回到第一帧的状态；both：轮流应用forwards和backwards规则。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@keyframes&lt;/code&gt;&lt;br&gt;
CSS3的animation制作动画效果主要包括两部分：1. 用关键帧声明一个动画，2.在animation调用关键帧声明的的动画。&lt;/p&gt;
&lt;h2 id=&#34;3区别&#34;&gt;3.区别&lt;/h2&gt;
&lt;p&gt;animation属性类似于transition，他们都是随着时间改变元素的属性值，其主要区别在于：transition需要触发一个事件才会随着时间改变其CSS属性；animation在不需要触发任何事件的情况下，也可以显式的随时间变化来改变元素CSS属性，达到一种动画的效果。&lt;/p&gt;
&lt;h1 id=&#34;11display哪些取值&#34;&gt;11.display哪些取值&lt;/h1&gt;
&lt;h2 id=&#34;111-none-此元素不会被显示&#34;&gt;11.1 none ：此元素不会被显示&lt;/h2&gt;
&lt;p&gt;（1） none此单词的意思是没有一个、毫无的意思；所以当display的属性值设置为none的时候，表示的是没有框类型，没有框类型的元素，是无法在浏览器中显示的，就实现隐藏元素的作用了；&lt;br&gt;
（2）有很多标签，display的属性值默认是none，比如 &lt;code&gt;head&lt;/code&gt; &lt;code&gt;meta&lt;/code&gt; &lt;code&gt;style&lt;/code&gt; &lt;code&gt;link&lt;/code&gt;等等；&lt;br&gt;
（3）项目应用中，做二级导航效果或者鼠标悬停效果动态时，会经常用到这个属性值，下次我们写一个好玩的二级效果再来展示这个属性值的作用；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614838389050.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;112-block此元素将显示为块级元素此元素前后会带有换行符&#34;&gt;11.2 block：此元素将显示为块级元素，此元素前后会带有换行符。&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614838392829.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;113-inline-默认此元素会被显示为内联元素元素前后没有换行符&#34;&gt;11.3 inline 默认此元素会被显示为内联元素，元素前后没有换行符。&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614838421481.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;114-inline-block-行内块元素css21-新增的值&#34;&gt;11.4 inline-block 行内块元素（CSS2.1 新增的值）&lt;/h2&gt;
&lt;p&gt;说明：行内块元素既具备行内元素的特性也具备块状元素的特性，具备行内元素前后没有换行符可以在一行内并列显示的特性，具备块状元素可以正确解释盒模型属性的特性。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614838503882.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;115-list-item-此元素会作为列表显示&#34;&gt;11.5 list-item 此元素会作为列表显示。&lt;/h2&gt;
&lt;p&gt;(1) 此属性值表示将元素显示为列表项标签，li标签默认的display的属性值是list-item，display的属性值为list-item的标签也属于块状元素；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614838546316.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
(2) li标签作为列表项标签，前面会有列表项标记，下面给div标签设置为list-item，div也会有列表项标记&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614838588128.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;116-run-in-此元素会根据上下文作为块级元素或内联元素显示&#34;&gt;11.6 run-in 此元素会根据上下文作为块级元素或内联元素显示。&lt;/h2&gt;
&lt;h2 id=&#34;117-table-此元素会作为块级表格来显示表格前后带有换行符&#34;&gt;11.7 table 此元素会作为块级表格来显示，表格前后带有换行符。&lt;/h2&gt;
&lt;p&gt;（1）table标签默认的元素类型是table，显示为块级表格，可以设置大小并且单独占据一行；&lt;br&gt;
（2）当table标签的元素类型是table时，并且设置宽度和高度之后，后代td标签的宽度和高度，默认是由table根据内容的多少去分配的；&lt;br&gt;
(3) table属于块状元素，但是对比别的块状元素，有自己的特点， table会单独占据一行，但是在没有设置width的情况下，不会与父元素同宽，而是根据内容而定；&lt;br&gt;
(4) 其他标签设置display的属性值为table，也不会具有表格的特性；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;总结&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过以上的测试，可以总结出：&lt;br&gt;
display的属性值为&lt;strong&gt;block，table&lt;/strong&gt;的标签都为&lt;code&gt;块状元素&lt;/code&gt;；&lt;br&gt;
display的属性值为&lt;strong&gt;inline，inline-table，inline-block&lt;/strong&gt;的标签为&lt;code&gt;行内级元素&lt;/code&gt;；&lt;/p&gt;
&lt;h1 id=&#34;12-相邻的两个inline-block节点为什么会出现间隔该如何解决&#34;&gt;12. 相邻的两个inline-block节点为什么会出现间隔，该如何解决&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614841169302.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;121-原因&#34;&gt;12.1 原因&lt;/h2&gt;
&lt;p&gt;其实，html的原因。我们回顾一下这段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;看这里➡️&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;⬅️看这里➡️&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;⬅️看这里&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们不仅看到元素节点，属性节点还有文本节点，问题就是处在文本节点的渲染导致3px(chrome)的间隔。那如何解决它？&lt;/p&gt;
&lt;h2 id=&#34;122-解决办法&#34;&gt;12.2 解决办法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;方法一、删除空白节点&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;看这里➡️&amp;lt;/div
&amp;gt;&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;⬅️看这里➡️&amp;lt;/div
&amp;gt;&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;⬅️看这里&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上的这些方法，无一列外破坏了代码的可读性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法二、负的marigin值&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.box {
    margin: -3px; /*左右缩小3px*/
    display: inline-block;
    width: 100px;
    height: 50px;
    background-color: #ddd;
    text-align: center;
    line-height: 50px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样的方式，可以解决chrome下面的问题。但是不建议使用。因为在某些游览器上面，这个文本节点可能设置成4px的间隔。因为解决问题，引入了新的问题，那就尴尬！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法三、font-size: 0&lt;/strong&gt;&lt;br&gt;
既然是文本节点导致的，那我们就把文本节点设置成0不就ok?顺着这个思路，我们这些写： 我们先给div加一个父级节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;wrapper&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;看这里➡️&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;⬅️看这里➡️&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;⬅️看这里&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.wrapper{
    font-size: 0;
}
.box {
    font-size: 14px;
    display: inline-block;
    width: 100px;
    height: 50px;
    background-color: #ddd;
    text-align: center;
    line-height: 50px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主要： 因为font-size是默认继承的属性。所以父级给了0，子级要重新设置font-size： 14px。&lt;/p&gt;
&lt;h1 id=&#34;13-meta-viewport-移动端适配&#34;&gt;13. meta viewport 移动端适配&lt;/h1&gt;
&lt;h2 id=&#34;131-什么是viewport&#34;&gt;13.1 什么是Viewport?&lt;/h2&gt;
&lt;p&gt;手机浏览器会把页面放入到一个虚拟的“视口”（viewpoint）中，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域大，也可能比浏览器的可视区域小。通常这个虚拟的“视口”（viewport）比屏幕宽，会把网页挤到一个很小的窗口。&lt;br&gt;
如果不显示地设置viewport，那么浏览器就会把width默认设置为980。但后果是浏览器出现横向滚动条，因为浏览器可视区域的宽度比默认的viewport的宽度小。&lt;br&gt;
然后浏览器引进了 viewport 这个 meta tag，让网页开发者来控制 viewport 的大小和缩放。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;132-meta-viewport-的6个属性&#34;&gt;13.2 meta viewport 的6个属性：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;width ： 设置viewport 的宽度&lt;/li&gt;
&lt;li&gt;height： 设置viewport 的高度&lt;/li&gt;
&lt;li&gt;initial-scale ： 设置页面的初始缩放值&lt;/li&gt;
&lt;li&gt;minimum-scale ：允许用户的最小缩放值&lt;/li&gt;
&lt;li&gt;maximum-scale：允许用户的最大缩放值&lt;/li&gt;
&lt;li&gt;user-scalable： 是否允许用户进行缩放，值为&amp;quot;no&amp;quot;或&amp;quot;yes&amp;quot;, no 代表不允许，yes代表允许&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;133-3个viewport&#34;&gt;13.3 3个viewport：&lt;/h2&gt;
&lt;p&gt;（1）&lt;strong&gt;布局视口 layout viewport&lt;/strong&gt;&lt;br&gt;
如果把移动设备上浏览器的可视区域设为viewport的话，某些网站会因为viewport太窄而显示错乱，所以这些浏览器就默认会把viewport设为一个较宽的值，比如980px，使得即使是那些为PC浏览器设计的网站也能在移动设备浏览器上正常显示。这个浏览器默认的viewport叫做 layout viewport。layout viewport的宽度可以通过 document.documentElement.clientWidth来获取。&lt;/p&gt;
&lt;p&gt;（2）&lt;strong&gt;视觉视口 visual viewport&lt;/strong&gt;&lt;br&gt;
layout viewport的宽度是大于浏览器可视区域的宽度的，所以还需要一个viewport来代表浏览器可视区域的大小，这个viewport叫做 visual viewport。visual viewport的宽度可以通过 document.documentElement.innerWidth来获取。&lt;/p&gt;
&lt;p&gt;（3）&lt;strong&gt;理想视口 ideal viewport&lt;/strong&gt;&lt;br&gt;
ideal viewport是一个能完美适配移动设备的viewport。首先，不需要缩放和横向滚动条就能正常查看网站的所有内容；其次，显示的文字、图片大小合适，如14px的文字不会因为在一个高密度像素的屏幕里显示得太小而无法看清，无论是在何种密度屏幕，何种分辨率下，显示出来的大小都差不多。这个viewport叫做 ideal viewport。&lt;/p&gt;
&lt;p&gt;ideal viewport并没有一个固定的尺寸，不同的设备有不同的ideal viewport。例如，所有的iphone的ideal viewport宽度都是320px，无论它的屏幕宽度是320还是640。&lt;br&gt;
ideal viewport 的意义在于，无论在何种分辨率的屏幕下，针对ideal viewport 而设计的网站，不需要缩放和横向滚动条都可以完美地呈现给用户。&lt;/p&gt;
&lt;h2 id=&#34;134-终极方案&#34;&gt;13.4  终极方案：&lt;/h2&gt;
&lt;p&gt;将&lt;code&gt;meta:vp&lt;/code&gt;标签的属性值设置为&lt;code&gt;width=device-width, initial-scale=1&lt;/code&gt;就不仅能够将页面的布局视口自动设置为各个移动设备的理想视口，还能够同时兼容iphone、ipad的Safari以及WP7 IE浏览器的横屏问题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;14-动画和过渡animation-和-transition&#34;&gt;14. 动画和过渡（Animation 和 Transition）&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;animation：CSS 动画，将元素的样式配置转换到另一个CSS配置。包括动画所使用的样式规则，以及用于指定动画开始、结束以及中间多个节点的关键帧；&lt;/li&gt;
&lt;li&gt;transition：CSS过渡属性，为一个元素在不同状态切换的时候定义不同的过渡效果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CSS 中，如果按一秒24帧的画法来写代码，未免太过繁琐。所以我们把动画拆解为&lt;code&gt;动作(transition)&lt;/code&gt;，一个动作表示从一个状态到另一个状态的变化，然后把一组动作串起来，即是 CSS 中的&lt;code&gt;动画(animation)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-transition&#34;&gt;1. Transition&lt;/h2&gt;
&lt;p&gt;transition 直译为过渡，即&lt;strong&gt;给属性变化添加过渡效果&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们知道，如果两个样式属性被赋在同一个元素上，后一个样式属性会覆盖前一个，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.blueball {
  ...
  opacity: 1; /* 不透明 */
}
.blueball:hover {
  opacity: 0.3; /* 透明度 30% */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我们把鼠标放在蓝球上时，蓝球会&lt;strong&gt;立刻&lt;/strong&gt;变透明&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619149280679.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
而如果我们给蓝球增加 transition 属性，其透明度变化会有一个过渡&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.blueball {
  ...
  opacity: 1;
  transition: opacity 1s;  /* 改变 opacity 属性，持续1秒 */
}
.blueball:hover {
  opacity: 0.3;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619149305472.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里的 transition 属性其实是一个简写形式，它由&lt;strong&gt;四部分组成&lt;/strong&gt;，分别是（冒号后为默认值）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;transition-property: all; /* 过渡属性 */
transition-duration: 0; /* 耗时 */
transition-timing-function: ease; /* 效果，默认 ease（缓入缓出） */
transition-delay: 0; /* 延迟 */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果考虑到默认值，上面过渡效果的例子中，可以进一步简写成&lt;code&gt;transition: 1s&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;transition 可以同时给多个属性添加过渡效果，比如可以在移动元素的同时，改变其透明度。&lt;code&gt;但不管有多少个属性同时在变化，这种过渡效果只能是一次性的，也就是单个动作&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;2-animation&#34;&gt;2. Animation&lt;/h2&gt;
&lt;p&gt;transition 只能做单个动作，如果动画包含多个动作，这时候就需要 animation&lt;/p&gt;
&lt;p&gt;我们先来看个例子：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619150620116.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这个动画明显由两个动作组成：蓝变绿，绿变橙。&lt;/p&gt;
&lt;p&gt;两个连续的线段有三个关键点，两个连续的动作必然也有三个&lt;strong&gt;关键帧&lt;/strong&gt;（keyframe），我们通过定义这三个关键帧（起点，蓝变绿，终点）来定义这两个动作。&lt;/p&gt;
&lt;p&gt;我们来看一下这个动画的 CSS 代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.blueball {
  ...
  background-color: #0080ff; /* 蓝色 */
  position: relative;
  animation: forward 4s; /* 执行 forward 动画，耗时 4s */
}

/* 三个关键帧： 起点（蓝色），蓝变绿，终点（橙色） */
@keyframes forward {
  0% {left: 0; }
  50% {left: 200px; background-color: #009a61;}
  100% {left: 400px; background-color: orange;}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;@keyframes中的百分比，代表时间尺度上的百分比 ，后面跟着的是此时间点的样式。&lt;/p&gt;
&lt;p&gt;同样的，animation: forward 4s;也是简写形式，完整的 animation 属性包括（冒号后为默认值）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;animation-name: none; /* 动画名称 */
animation-duration: 0; /* 耗时 */
animation-timing-function: ease; /* 效果，默认缓入缓出 */
animation-delay: 0; /* 延迟 */
animation-iteration-count: 1; /* 循环次数 */
animation-direction: normal; /* 正放 or 倒放 */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CSS 动画的知识点，就这么些，但目前看来，我们只能动动元素的大小，位置，透明度，颜色什么的，有点单调。为了给动画加点料，下面介绍一下 &lt;code&gt;transform&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-transform&#34;&gt;3. transform&lt;/h2&gt;
&lt;p&gt;transform 直译为变换，虽然名字和 transition 有点像，但是它和动画无关。transition 是一个状态到另一个状态的变化过程，而 transform 仅仅是&lt;strong&gt;静止的最终状态&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如：如果想把蓝球从水平排列中，向下移动100px&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619151581634.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;即可以使用&lt;strong&gt;相对定位&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.blueball {
  ...
  position: relative;
  top: 100px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以使用 &lt;strong&gt;transform&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.blueball {
  ...
  transform: translateY(100px);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它们的效果是一致的，都是把蓝球向下移动 100px&lt;/p&gt;
&lt;p&gt;除了位移，tranform 还可以做很多变换&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;matrix 矩阵变换&lt;/li&gt;
&lt;li&gt;translate 位移&lt;/li&gt;
&lt;li&gt;scale 缩放&lt;/li&gt;
&lt;li&gt;rotate 绕轴旋转&lt;/li&gt;
&lt;li&gt;skew 倾斜&lt;/li&gt;
&lt;li&gt;perspective 透视距离&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;这里有几点需要说明:&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-transform-原点位于元素中心&#34;&gt;1. transform 原点位于元素中心&lt;/h3&gt;
&lt;p&gt;我们知道 CSS 元素默认的坐标系，原点在左上角；而 transform 变换的原点位于元素中心&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619151713261.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
图中亦标识了绕轴旋转（rotate）时的默认方向，为了便于记忆，你可以理解为：你站在原点位置，看向正轴方向，默认旋转方向为&lt;strong&gt;逆时针旋转&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-理解-skew倾斜&#34;&gt;2. 理解 skew（倾斜）&lt;/h3&gt;
&lt;p&gt;skew 倾斜变换并不直观，为了便于记忆，你可以这样想像：&lt;br&gt;
你拉住了矩形的&lt;code&gt;右下角&lt;/code&gt;，左右横拉，即是沿X轴倾斜&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619151914829.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
同样的，skewY 即是抓住右下角上下拉&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619151918106.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-理解-perspective透视&#34;&gt;3. 理解 perspective（透视）&lt;/h3&gt;
&lt;p&gt;perspective 表示透视距离，可简单理解为眼睛离屏幕的距离&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;transform: translateZ(100x); /* 向Z轴正向移动 100px */
perspective: 200px; /* 透视距离 200px */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们用一张图来说明一下&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619151963081.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;d 为透视距离 200px&lt;/li&gt;
&lt;li&gt;Z 为元素在Z轴上移动的距离 100px&lt;/li&gt;
&lt;li&gt;虚线的圆表示元素实际的位置&lt;/li&gt;
&lt;li&gt;而蓝色的圆，是元素在屏幕上的投影，也是最终展示的效果&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;15-css实现宽度自适应100宽高169的比例的矩形&#34;&gt;15. CSS实现宽度自适应100%，宽高16:9的比例的矩形&lt;/h1&gt;
&lt;p&gt;第一步先计算高度，假设宽100%，那么高为h=9/16=56.25%&lt;/p&gt;
&lt;p&gt;第二步利用之前所说设置padding-bottom方法实现矩形&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;scale&amp;quot;&amp;gt;
      &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
   .box {
        width: 20%;
    }
    .scale {
        width: 100%;
        height: 0px;
        /* scale 用来实现宽高等比例 1:1 padding-bottom:100%; 4:3 padding-bottom:75%; 16:9 padding-bottom:56.25%; */
        padding-bottom: 56.25%;
        position: relative;
        background-color: pink;
    }
  &amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;16-rem布局的优缺点&#34;&gt;16. rem布局的优缺点&lt;/h1&gt;
&lt;h2 id=&#34;161-rem布局原理&#34;&gt;16.1 Rem布局原理&lt;/h2&gt;
&lt;p&gt;rem布局的本质是什么？这是我问过很多人的一个问题，但得到的回答都差强人意。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其实rem布局的本质是等比缩放，一般是基于宽度&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;162-rem布局优点&#34;&gt;16.2 Rem布局优点&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;rem的优点就是可以通过修改html里的文字大小来改变页面中元素的大小，可以整体进行控制。&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;163-rem布局缺点&#34;&gt;16.3 Rem布局缺点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;目前ie不支持 对pc页面来讲使用次数不多；&lt;/li&gt;
&lt;li&gt;数据量大：所有的图片，盒子都需要我们去给一个准确的值；才能保证不同机型的适配；&lt;/li&gt;
&lt;li&gt;字体的问题：字体的大小和字体宽度，并不成线性关系，所以字体大小不能使用rem&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;17-css画一个三角形&#34;&gt;17. CSS画一个三角形&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;CSS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
        /* css3绘制三角形 */
        .triangle{
            width: 0px;                           /*设置宽高为0，所以div的内容为空，从才能形成三角形尖角*/
            height: 0px;
            border-bottom: 200px solid #00a3af;
            border-left: 200px solid transparent;    /*transparent 表示透明*/
            border-right: 200px solid transparent;
        }
    &amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Html&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;div class=&amp;quot;triangle&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614860077842.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;18-1像素边框问题&#34;&gt;18. 1像素边框问题&lt;/h1&gt;
&lt;h2 id=&#34;181-为什么1px变粗了&#34;&gt;18.1 为什么1px变粗了？&lt;/h2&gt;
&lt;p&gt;UI设计师要求的1px是指设备的物理像素1px，而CSS里记录的像素是逻辑像素，它们之间存在一个比例关系，可以用javascript中的window.devicePixelRatio来获取&lt;/p&gt;
&lt;p&gt;移动端开发常需要在html的header里添加如下一句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这句话定义了本页面的viewport的宽度为设备宽度，初始缩放值和最大缩放值都为1，并禁止了用户缩放。&lt;/p&gt;
&lt;h2 id=&#34;182-修改方案&#34;&gt;18.2 修改方案&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;viewport + rem 方案&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;该方案是对上述方案的优化，整体思路就是利用viewport + rem + js 动态的修改页面的缩放比例，实现小于1像素的显示。在页面初始化时，在头部引入原始默认状态如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html;charset=UTF-8&amp;quot;&amp;gt;  
&amp;lt;meta name=&amp;quot;viewport&amp;quot; id=&amp;quot;WebViewport&amp;quot; content=&amp;quot;initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&amp;quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来的任务就是js的动态修改缩放比 以及 实现rem根元素字体大小的设置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var viewport = document.querySelector(&amp;quot;meta[name=viewport]&amp;quot;)
if (window.devicePixelRatio == 1) {
    viewport.setAttribute(&#39;content&#39;, &#39;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&#39;)
} 
if (window.devicePixelRatio == 2) {
    viewport.setAttribute(&#39;content&#39;, &#39;width=device-width, initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&#39;)
} 
if (window.devicePixelRatio == 3) {
    viewport.setAttribute(&#39;content&#39;, &#39;width=device-width, initial-scale=0.333333333, maximum-scale=0.333333333, minimum-scale=0.333333333, user-scalable=no&#39;)
} 

var docEl = document.documentElement;
var fontsize = 10 * (docEl.clientWidth / 320) + &#39;px&#39;;
docEl.style.fontSize = fontsize;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;transform: scale(0.5) 方案 - 推荐: 很灵活&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置height: 1px，根据媒体查询结合&lt;code&gt;transform&lt;/code&gt;缩放为相应尺寸。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;div {
    height:1px;
    background:#000;
    -webkit-transform: scaleY(0.5);
    -webkit-transform-origin:0 0;
    overflow: hidden;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;用&lt;code&gt;::after&lt;/code&gt;和&lt;code&gt;::befor&lt;/code&gt;,设置&lt;code&gt;border-bottom：1px solid #000&lt;/code&gt;,然后在缩放&lt;code&gt;-webkit-transform: scaleY(0.5)&lt;/code&gt;;可以实现两根边线的需求&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;div::after{
    content:&#39;&#39;;width:100%;
    border-bottom:1px solid #000;
    transform: scaleY(0.5);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;用&lt;code&gt;::after&lt;/code&gt;设置&lt;code&gt;border：1px solid #000; width:200%; height:200%&lt;/code&gt;,然后再缩放&lt;code&gt;scaleY(0.5)&lt;/code&gt;; 优点可以实现圆角，京东就是这么实现的，缺点是按钮添加active比较麻烦。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;.div::after {
    content: &#39;&#39;;
    width: 200%;
    height: 200%;
    position: absolute;
    top: 0;
    left: 0;
    border: 1px solid #bfbfbf;
    border-radius: 4px;
    -webkit-transform: scale(0.5,0.5);
    transform: scale(0.5,0.5);
    -webkit-transform-origin: top left;
}
&lt;/code&gt;&lt;/pre&gt;
">【面】前端知识点梳理（CSS）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/javascript-shi-xian-pai-xu-suan-fa/"" data-c="
          &lt;h1 id=&#34;0-算法的时间与空间复杂度&#34;&gt;0. 算法的时间与空间复杂度&lt;/h1&gt;
&lt;p&gt;主要还是从算法所占用的「时间」和「空间」两个维度去考量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。&lt;/li&gt;
&lt;li&gt;空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-时间复杂度&#34;&gt;1. 时间复杂度&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;「 大O符号表示法 」，即 T(n) = O(f(n))&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常见的时间复杂度量级有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常数阶O(1)：&lt;code&gt;没有循环&lt;/code&gt;等复杂结构&lt;/li&gt;
&lt;li&gt;对数阶O(logN)：在&lt;code&gt;while&lt;/code&gt;循环里面，每次都&lt;code&gt;将 i 乘以 2&lt;/code&gt;，乘完之后，i 距离 n 就越来越近了。&lt;/li&gt;
&lt;li&gt;线性阶O(n)：&lt;code&gt;for循环里面&lt;/code&gt;的代码会执行n遍&lt;/li&gt;
&lt;li&gt;线性对数阶O(nlogN)：将时间复杂度为O(logn)的代码循环N遍&lt;/li&gt;
&lt;li&gt;平方阶O(n²)：如果把 O(n) 的代码&lt;code&gt;再嵌套循环一遍&lt;/code&gt;，它的时间复杂度就是 O(n²)&lt;/li&gt;
&lt;li&gt;立方阶O(n³)&lt;/li&gt;
&lt;li&gt;K次方阶O(n^k)&lt;/li&gt;
&lt;li&gt;指数阶(2^n)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-空间复杂度&#34;&gt;2. 空间复杂度&lt;/h2&gt;
&lt;p&gt;空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。&lt;/p&gt;
&lt;p&gt;空间复杂度比较常用的有：O(1)、O(n)、O(n²)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;空间复杂度 O(1)&lt;br&gt;
如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空间复杂度 O(n)&lt;br&gt;
第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;1大o表示法&#34;&gt;1.大O表示法&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;大O表示法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在计算机中采用&lt;strong&gt;粗略的度量&lt;/strong&gt;来描述计算机算法的&lt;strong&gt;效率&lt;/strong&gt;，这种方法被称为**“大O”表示法**&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;数据项个数&lt;/strong&gt;发生改变时，&lt;strong&gt;算法的效率&lt;/strong&gt;也会跟着改变。所以说算法A比算法B快两倍，这样的比较是&lt;strong&gt;没有意义&lt;/strong&gt;的。&lt;/li&gt;
&lt;li&gt;因此我们通常使用&lt;strong&gt;算法的速度&lt;/strong&gt;随着&lt;strong&gt;数据量的变化&lt;/strong&gt;会如何变化的方式来表示算法的效率，大O表示法就是方式之一。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;常见的大O表示形式&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;符号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;名称&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;O(1)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;常数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;O(log(n))&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;对数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;O(n)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;线性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;O(nlog(n))&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;线性和对数乘积&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;O(n²)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;平方&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;O(2n)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;指数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;不同大O形式的时间复杂度：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614691100516.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到效率从大到小分别是：O(1)&amp;gt;O(logn)&amp;gt; O(n)&amp;gt; O(nlog(n))&amp;gt;O(n²)&amp;gt;O(2^n)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推导大O表示法的三条规则：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;规则一&lt;/strong&gt;：用常量1取代运行时间中所有的加法常量。如7 + 8 = 15，用1表示运算结果15，大O表示法表示为O（1）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规则二&lt;/strong&gt;：运算中只保留最高阶项。如N^3 + 3n +1，大O表示法表示为：O（N^3）;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规则三&lt;/strong&gt;：若最高阶项的常数不为1，可将其省略。如4N&lt;sup&gt;2，大O表示法表示为：O（N&lt;/sup&gt;2）;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2排序算法&#34;&gt;2.排序算法&lt;/h1&gt;
&lt;p&gt;这里主要介绍几种简单排序和高级排序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;简单排序&lt;/strong&gt;：冒泡排序、选择排序、插入排序；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高级排序&lt;/strong&gt;：希尔排序、快速排序；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此处创建一个列表类ArrayList并添加一些属性和方法，用于存放这些排序方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //创建列表类
    function ArrayList() {
      //属性
      this.array = []

      //方法
      //封装将数据插入到数组中方法
      ArrayList.prototype.insert = function(item){
        this.array.push(item)
      }

      //toString方法
      ArrayList.prototype.toString = function(){
        return this.array.join(&#39;-&#39;)
      }

      //交换两个位置的数据
      ArrayList.prototype.swap = function(m, n){
        let temp  = this.array[m]
        this.array[m] = this.array[n]
        this.array[n] = temp
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;排序算法&#34;&gt;排序算法！！&lt;/h1&gt;
&lt;h2 id=&#34;21冒泡排序&#34;&gt;2.1.冒泡排序&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;冒泡排序的思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对未排序的各元素&lt;strong&gt;从头到尾&lt;/strong&gt;依次比较&lt;strong&gt;相邻的两个元素&lt;/strong&gt;大小关系；&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;左边的人员高&lt;/strong&gt;，则将两人&lt;strong&gt;交换位置&lt;/strong&gt;。比如1比2矮，不交换位置；&lt;/li&gt;
&lt;li&gt;向&lt;strong&gt;右移动一位&lt;/strong&gt;，继续比较2和3，最后比较 length - 1 和 length - 2这两个数据；&lt;/li&gt;
&lt;li&gt;当到达&lt;strong&gt;最右端&lt;/strong&gt;时，&lt;strong&gt;最高的人&lt;/strong&gt;一定被放在了&lt;strong&gt;最右边&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;按照这个思路，从最左端重新开始时，只需要走到&lt;strong&gt;倒数第二个位置&lt;/strong&gt;即可；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614691535117.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两层循环：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外层循环控制冒泡趟数：&lt;br&gt;
- 第一次：j = length - 1，比较到倒数第一个位置 ；&lt;br&gt;
- 第二次：j = length - 2，比较到倒数第二个位置 ；&lt;/li&gt;
&lt;li&gt;内层循环控制每趟比较的次数：&lt;br&gt;
- 第一次比较： i = 0，比较 0 和 1 位置的两个数据；&lt;br&gt;
- 最后一次比较：i = length - 2,比较length - 2和 length - 1两个数据；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详细过程如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614691654684.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
动态过程：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614691678173.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; //冒泡排序
      ArrayList.prototype.bubblesor = function(){
        //1.获取数组的长度
        let length = this.array.length

        //外层循环控制冒泡趟数
        for(let j = length - 1; j &amp;gt;= 0; j--){
          //内层循环控制每趟比较的次数
          for(let i = 0; i &amp;lt; j; i++){
          if (this.array[i] &amp;gt; this.array[i+1]) {
            //交换两个数据
            let temp  = this.array[i]
        	this.array[i] = this.array[i+1]
        	this.array[i+1] = temp
          }
        }
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; //测试类
    let list = new ArrayList()

    //插入元素
    list.insert(66)
    list.insert(88)
    list.insert(12)
    list.insert(87)
    list.insert(100)
    list.insert(5)
    list.insert(566)
    list.insert(23)
    
    //验证冒泡排序
    list.bubblesor()
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614691724569.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;冒泡排序的效率：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上面所讲的对于7个数据项，比较次数为：6 + 5 + 4 + 3 + 2 + 1;&lt;/li&gt;
&lt;li&gt;对于N个数据项，&lt;strong&gt;比较次数&lt;/strong&gt;为：(N - 1) + (N - 2) + (N - 3) + ... + 1 = N * (N - 1) / 2；如果两次比较交换一次，那么&lt;strong&gt;交换次数&lt;/strong&gt;为：N * (N - 1) / 4；&lt;/li&gt;
&lt;li&gt;使用大O表示法表示比较次数和交换次数分别为：O（ N * (N - 1) / 2）和O（ N * (N - 1) / 4），根据大O表示法的三条规则都化简为：&lt;strong&gt;O（N^2）&lt;/strong&gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;22选择排序&#34;&gt;2.2.选择排序&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;选择排序改进了冒泡排序：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将&lt;strong&gt;交换次数&lt;/strong&gt;由&lt;strong&gt;O（N^2）&lt;strong&gt;减小到&lt;/strong&gt;O（N）&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;但是&lt;strong&gt;比较次数&lt;/strong&gt;依然是&lt;strong&gt;O（N^2）&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;选择排序的思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选定&lt;strong&gt;第一个索引的位置&lt;/strong&gt;比如1，然后依次和后面的元素&lt;strong&gt;依次进行比较&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;如果后面的元素，&lt;strong&gt;小于&lt;/strong&gt;索引1位置的元素，则&lt;strong&gt;交换位置&lt;/strong&gt;到索引1处；&lt;/li&gt;
&lt;li&gt;经过一轮的比较之后，可以确定一开始指定的索引1位置的元素是&lt;strong&gt;最小的&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;随后使用同样的方法除索引1以外&lt;strong&gt;逐个比较剩下的元素&lt;/strong&gt;即可；&lt;/li&gt;
&lt;li&gt;可以看出选择排序，&lt;strong&gt;第一轮&lt;/strong&gt;会选出&lt;strong&gt;最小值&lt;/strong&gt;，&lt;strong&gt;第二轮&lt;/strong&gt;会选出&lt;strong&gt;第二小的值&lt;/strong&gt;，直到完成排序。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614691924469.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两层循环：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外层循环控制指定的索引：&lt;br&gt;
- 第一次：j = 0，指定第一个元素 ；&lt;br&gt;
- 最后一次：j = length - 1，指定最后一个元素 ；&lt;/li&gt;
&lt;li&gt;内层循环负责将指定索引（i）的元素与剩下（i - 1）的元素进行比较；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;动态过程：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614691958714.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; //选择排序
      ArrayList.prototype.selectionSort = function(){
        //1.获取数组的长度
        let length = this.array.length

        //2.外层循环：从0开始获取元素
        for(let j = 0; j &amp;lt; length - 1; j++){
          let min = j
          //内层循环：从i+1位置开始，和后面的元素进行比较
        for(let i = min + 1; i &amp;lt; length; i++){
          if (this.array[min] &amp;gt; this.array[i]) {
            min = i
          }
        }
        this.swap(min, j)
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  //测试类
    let list = new ArrayList()

    //插入元素
    list.insert(66)
    list.insert(88)
    list.insert(12)
    list.insert(87)
    list.insert(100)
    list.insert(5)
    list.insert(566)
    list.insert(23)
    
    //验证选择排序
    list.selectionSort()
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614691999487.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;选择排序的效率：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择排序的&lt;strong&gt;比较次数&lt;/strong&gt;为：N * (N - 1) / 2，用大O表示法表示为：&lt;strong&gt;O（N^2）&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;选择排序的&lt;strong&gt;交换次数&lt;/strong&gt;为：(N - 1) / 2，用大O表示法表示为：&lt;strong&gt;O（N）&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;所以选择排序的效率高于冒泡排序；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;23插入排序&#34;&gt;2.3.插入排序&lt;/h2&gt;
&lt;p&gt;插入排序是简单排序中效率最高的一种排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;插入排序的思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入排序思想的核心是&lt;strong&gt;局部有序&lt;/strong&gt;。如图所示，X左边的人称为&lt;strong&gt;局部有序&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;首先指定一数据X（从第一个数据开始），并将数据X的左边变成局部有序状态；&lt;/li&gt;
&lt;li&gt;随后将X右移一位，再次达到局部有序之后，继续右移一位，重复前面的操作直至X移至最后一个元素。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692091547.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
插入排序的详细过程：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692103001.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
动态过程：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692113197.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;   //插入排序
      ArrayList.prototype.insertionSort = function(){
        //1.获取数组的长度
        let length = this.array.length

        //2.外层循环:从第二个数据开始，向左边的已经局部有序数据进行插入
        for(let i = 1; i &amp;lt; length; i++){
          //3.内层循环：获取i位置的元素，使用while循环(重点)与左边的局部有序数据依次进行比较
          let temp = this.array[i]
          let j = i
          while(this.array[j - 1] &amp;gt; temp &amp;amp;&amp;amp; j &amp;gt; 0){
            this.array[j] = this.array[j - 1]//大的数据右移
            j--
          }
          //4.while循环结束后，index = j左边的数据变为局部有序且array[j]最大。此时将array[j]重置为排序前的数据array[i]，方便下一次for循环
          this.array[j] = temp
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试类
    let list = new ArrayList()

    //插入元素
    list.insert(66)
    list.insert(88)
    list.insert(12)
    list.insert(87)
    list.insert(100)
    list.insert(5)
    list.insert(566)
    list.insert(23)
    // console.log(list);

    //验证插入排序
    list.insertionSort()
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692171244.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;插入排序的效率：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;比较次数&lt;/strong&gt;：第一趟时，需要的最大次数为1；第二次最大为2；以此类推，最后一趟最大为N-1；所以，插入排序的总比较次数为N * (N - 1) / 2；但是，实际上每趟发现插入点之前，平均只有全体数据项的一半需要进行比较，所以比较次数为：&lt;strong&gt;N * (N - 1) / 4&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;交换次数&lt;/strong&gt;：指定第一个数据为X时交换0次，指定第二个数据为X最多需要交换1次，以此类推，指定第N个数据为X时最多需要交换N - 1次，所以一共需要交换N * (N - 1) / 2次，平均次数为&lt;strong&gt;N * (N - 1) / 2&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;虽然用大O表示法表示插入排序的效率也是&lt;strong&gt;O（N^2）&lt;/strong&gt;，但是插入排序整体操作次数更少，因此，在简单排序中，插入排序&lt;strong&gt;效率最高&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;24希尔排序&#34;&gt;2.4.希尔排序&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;希尔排序&lt;/strong&gt;是&lt;strong&gt;插入排序&lt;/strong&gt;的一种高效的&lt;strong&gt;改进版&lt;/strong&gt;，效率比插入排序要高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;希尔排序的历史背景：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;希尔排序按其设计者希尔（Donald Shell）的名字命名，该算法由&lt;strong&gt;1959年公布&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;希尔算法首次突破了计算机界一直认为的**算法的时间复杂度都是O（N^2）**的大关，为了纪念该算法里程碑式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;意义，用&lt;strong&gt;Shell&lt;/strong&gt;来命名该算法；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;插入排序的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设一个&lt;strong&gt;很小的数据项&lt;/strong&gt;在&lt;strong&gt;很靠近右端的位置&lt;/strong&gt;上，这里本应该是&lt;strong&gt;较大的数据项的位置&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;将这个&lt;strong&gt;小数据项移动到左边&lt;/strong&gt;的正确位置，所有的&lt;strong&gt;中间数据项都必须向右移动一位&lt;/strong&gt;，这样效率非常低；&lt;/li&gt;
&lt;li&gt;如果通过&lt;strong&gt;某种方式&lt;/strong&gt;，不需要&lt;strong&gt;一个个移动所有中间的数据项&lt;/strong&gt;，就能把较小的数据项移到左边，那么这个算法的执行速度就会有很大的改进。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;希尔排序的实现思路&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;希尔排序主要通过对数据进行&lt;strong&gt;分组&lt;/strong&gt;实现快速排序；&lt;/li&gt;
&lt;li&gt;根据设定的增量（gap）将数据分为gap个组（&lt;strong&gt;组数等于gap&lt;/strong&gt;），再在每个分组中进行局部排序；&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;假如有数组有10个数据，第1个数据为黑色，增量为5。那么第二个为黑色的数据index=5，第3个数据为黑色的数据index = 10（不存在）。所以黑色的数据每组只有2个，10 / 2 = 5一共可分5组，即&lt;strong&gt;组数等于增量gap&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;排序之后，减小增量，继续分组，再次进行局部排序，直到增量gap=1为止。随后只需进行微调就可完成数组的排序；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;具体过程如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排序之前的，储存10个数据的原始数组为：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692424549.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;设初始增量gap = length / 2 = 5，即数组被分为了5组，如图所示分别为：[8, 3]、[9, 5]、[1, 4]、[7, 6]、[2, 0]：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692441093.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;随后分别在每组中对数据进行局部排序，5组的顺序如图所示，变为：[3, 8]、[5, 9]、[1, 4]、[6, 7]、[0, 2]：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692472580.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;然后缩小增量gap = 5 / 2 = 2，即数组被分为了2组，如图所示分别为：[3，1，0，9，7]、[5，6，8，4，2]：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692484750.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;随后分别在每组中对数据进行局部排序，两组的顺序如图所示，变为：[0，1，3，7，9]、[2，4，5，6，8]：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692502384.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;然后然后缩小增量gap = 2 / 1 = 1，即数组被分为了1组，如图所示为：[0，2，1，4，3，5，7，6，9，8]：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692651803.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;最后只需要对该组数据进行插入排序即可完成整个数组的排序：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692674191.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
动态过程：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692702587.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
图中d表示增量gap。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;增量的选择：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原稿&lt;/strong&gt;中希尔建议的初始间距为&lt;strong&gt;N / 2&lt;/strong&gt;，比如对于N = 100的数组，增量序列为：50，25，12，6，3，1，可以发现不能整除时向下取整。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hibbard增量序列&lt;/strong&gt;：增量序列算法为：2^k - 1，即1，3，5，7... ...等；这种情况的最坏复杂度为O（N&lt;sup&gt;3/2）**,平均复杂度为**O（N&lt;/sup&gt;5/4）但未被证明；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sedgewcik增量序列&lt;/strong&gt;：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692851848.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下代码实现中采用希尔排序原稿中建议的增量即&lt;strong&gt;N / 2&lt;/strong&gt; 。&lt;br&gt;
&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   //希尔排序
      ArrayList.prototype.shellSort = function(){
        //1.获取数组的长度
        let length = this.array.length

        //2.初始化增量
        let gap = Math.floor(length / 2)

        //3.第一层循环：while循环(使gap不断减小)
        while(gap &amp;gt;= 1 ){
          //4.第二层循环：以gap为增量，进行分组，对分组进行插入排序
          //重点为：将index = gap作为选中的第一个数据
          for(let i = gap; i &amp;lt; length; i++){
            let temp = this.array[i]
            let j = i
            //5.第三层循环:寻找正确的插入位置
            while(this.array[j - gap] &amp;gt; temp &amp;amp;&amp;amp; j &amp;gt; gap - 1){
              this.array[j] = this.array[j - gap]
              j -= gap
            }
          //6.将j位置的元素设置为temp
          this.array[j] = temp
          }

          gap = Math.floor(gap / 2)
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里解释一下上述代码中的三层循环：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第一层循环&lt;/strong&gt;：while循环，控制gap递减到1；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二层循环&lt;/strong&gt;：分别取出根据g增量gap分成的gap组数据：将index = gap的数据作为选中的第一个数据，如下图所示，gap=5，则index = gap的数据为3，index = gap - 1的数据为8，两个数据为一组。随后gap不断加1右移，直到gap &amp;lt; length，此时实现了将数组分为5组。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692920473.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三层循环&lt;/strong&gt;：对每一组数据进行插入排序；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; //测试类
    let list = new ArrayList()

    //插入元素
    list.insert(66)
    list.insert(88)
    list.insert(12)
    list.insert(87)
    list.insert(100)
    list.insert(5)
    list.insert(566)
    list.insert(23)
    // console.log(list);

    //验证希尔排序
    list.shellSort()
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614692964709.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;希尔排序的效率：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;希尔排序的效率和增量有直接关系，即使使用原稿中的增量效率都高于简单排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;25快速排序&#34;&gt;2.5.快速排序&lt;/h2&gt;
&lt;p&gt;快速排序的介绍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;快速排序&lt;/strong&gt;可以说是&lt;strong&gt;目前所有排序算法&lt;/strong&gt;中，&lt;strong&gt;最快&lt;/strong&gt;的一种排序算法。当然，没有任何一种算法是在任意情况下都是最优的。但是，大多数情况下快速排序是比较好的选择。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;快速排序&lt;/strong&gt;其实是&lt;strong&gt;冒泡排序&lt;/strong&gt;的升级版；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;快速排序的核心思想是&lt;strong&gt;分而治之&lt;/strong&gt;，先选出一个数据（比如65），将比其小的数据都放在它的左边，将比它大的数据都放在它的右边。这个数据称为&lt;strong&gt;枢纽&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和冒泡排序的不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们选择的65可以一次性将它放在最正确的位置，之后就不需要做任何移动；&lt;/li&gt;
&lt;li&gt;而冒泡排序即使已经找到最大值，也需要继续移动最大值，直到将它移动到最右边；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614693046918.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;快速排序的枢纽：&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第一种方案&lt;/strong&gt;：直接选择第一个元素作为枢纽。但是，当第一个元素就是最小值的情况下，效率不高；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二种方案&lt;/strong&gt;：使用随机数。随机数本身十分消耗性能，不推荐；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优秀的解决方法&lt;/strong&gt;：取index为头、中、位的三个数据排序后的中位数；如下图所示，按下标值取出的三个数据为：92，31，0，经排序后变为：0，31，92，取其中的中位数31作为&lt;strong&gt;枢纽&lt;/strong&gt;（当（length-1）/2不整除时可向下或向上取整）：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614693609653.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现枢纽选择：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//交换两个位置的数据
let swap = function(arr, m, n){
    let temp  = arr[m]
    arr[m] = arr[n]
    arr[n] = temp
}

//快速排序
//1.选择枢纽
let median = function(arr){
  //1.取出中间的位置
  let center = Math.floor(arr.length / 2)
  let right = arr.length - 1 
  let left = 0

  //2.判断大小并进行交换
  if (arr[left] &amp;gt; arr[center]) {
    swap(arr, left, center)
  }
  if (arr[center] &amp;gt; arr[right]){
    swap(arr, center, right)
  }
  if (arr[left] &amp;gt; arr[right]) {
    swap(arr, left, right)
  }
  //3.返回枢纽
  return center
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组经过获取枢纽函数操作之后，选出的3个下标值对应的数据位置变为：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614693640946.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;动态过程：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614693653899.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;快速排序代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//2.快速排序
let QuickSort = function(arr){
  if (arr.length == 0) {
    return []
  }
  let center = median(arr)
  let c = arr.splice(center, 1)
  let l = []
  let r = []

  for (let i = 0; i &amp;lt; arr.length; i++) {
      if (arr[i] &amp;lt; c) {
        l.push(arr[i])
      }else{
        r.push(arr[i])
      }        
  }
  return QuickSort(l).concat(c, QuickSort(r))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;算法的巧妙之处在于通过:&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;QuickSort(l).concat(c, QuickSort(r))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;递归调用&lt;code&gt;QuickSort&lt;/code&gt;函数实现了枢纽&lt;code&gt;Center&lt;/code&gt;左边数据&lt;code&gt;l&lt;/code&gt;和右边数据&lt;code&gt;r&lt;/code&gt;的排序；&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [0, 13, 81, 43, 31, 27, 56, 92]
console.log(QuickSort(arr));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614693906304.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快速排序的效率：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快速排序最坏情况下的效率：每次选择的枢纽都是最左边或最右边的数据，此时效率等同于冒泡排序，时间复杂度为&lt;strong&gt;O(n^2)&lt;/strong&gt;。可根据不同的枢纽选择避免这一情况；&lt;/li&gt;
&lt;li&gt;快速排序的平均效率：为&lt;strong&gt;O(N*logN)&lt;/strong&gt;，虽然其他算法效率也可达到O(N*logN)，但是其中快速排序是&lt;strong&gt;最好的&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;26-归并排序&#34;&gt;2.6 归并排序&lt;/h2&gt;
&lt;p&gt;归并排序采用的是分治的思想，首先是“分”，将一个数组反复二分为两个小数组，直到每个数组只有一个元素；其次是“治”，从最小数组开始，两两按大小顺序合并，直到并为原始数组大小，下面是图解：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619613292190.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;观察下“治”的过程，可以看出，“治”实际上是将已经有序的数组合并为更大的有序数组。那么怎样将已经有序的数组合并为更大的有序数组？很简单，创建一个临时数组C，比较A[0]，B[0]，将较小值放到C[0]，再比较A[1]与B[0]（或者A[0]，B[1]），将较小值放到C[1]，直到对A，B都遍历一遍。可以看出数组A，B都只需遍历一遍，所以对两个有序数组的排序的时间复杂度为O(n)。&lt;/p&gt;
&lt;p&gt;而“分”就是将原始数组逐次二分，直到每个数组只剩一个元素，一个元素的数组自然是有序的，所以就可以开始“治”的过程了。时间复杂度为 O(nlogn)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;实现分析：
将数组从中间切分为两个数组
切分到最小之后，开始归并操作，即合并两个已排序的数组
递归合并的过程，由于是从小到大合并，所以待合并的两个数组总是已排序的，一直做同样的归并操作就可以
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;对比归并排序与快速排序&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;都用了分治的思想。相比选择排序和冒泡排序，归并排序与快速排序使用了切分而不是直接遍历，这有效减少了交换次数。&lt;/li&gt;
&lt;li&gt;归并排序是先切分、后排序，过程可以描述为：切分、切分、切分……排序、排序、排序……&lt;/li&gt;
&lt;li&gt;快速排序是分区、排序交替进行，过程可以描述为：分区、排序、分区、排序……&lt;/li&gt;
&lt;li&gt;上两条所说的“排序”，在归并排序与快速排序中并非同样的操作，归并排序中的操作是将两个数组合并为一（归并操作），而快速排序中的操作是交换。&lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av86801505?from=search&amp;amp;seid=4967761411915016256&#34;&gt;参考资料：JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现排序算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/javascript-shi-xian-tu-jie-gou/"" data-c="
          &lt;h1 id=&#34;1图论&#34;&gt;1.图论&lt;/h1&gt;
&lt;h2 id=&#34;11图的简介&#34;&gt;1.1.图的简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;什么是图？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;图结构&lt;/strong&gt;是一种与&lt;strong&gt;树结构&lt;/strong&gt;有些相似的数据结构；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;图论&lt;/strong&gt;是数学的一个分支，并且，在数学中，树是图的一种；&lt;/li&gt;
&lt;li&gt;图论以图为研究对象，研究&lt;strong&gt;顶点&lt;/strong&gt;和&lt;strong&gt;边&lt;/strong&gt;组成的&lt;strong&gt;图形&lt;/strong&gt;的数学理论和方法；&lt;/li&gt;
&lt;li&gt;主要的研究目的为：&lt;strong&gt;事物之间的联系&lt;/strong&gt;，&lt;strong&gt;顶点&lt;/strong&gt;代表&lt;strong&gt;事物&lt;/strong&gt;，&lt;strong&gt;边&lt;/strong&gt;代表两个事物间的&lt;strong&gt;关系&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;图的特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一组顶点&lt;/strong&gt;：通常用&lt;strong&gt;V&lt;/strong&gt;（Vertex）表示顶点的集合；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一组边&lt;/strong&gt;：通常用 &lt;strong&gt;E&lt;/strong&gt;（Edge）表示边的集合；&lt;br&gt;
1. 边是顶点和顶点之间的连线；&lt;br&gt;
2. 边可以是有向的，也可以是无向的。比如A----B表示无向，A ---&amp;gt; B 表示有向；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;图的常用术语：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;顶点&lt;/strong&gt;：表示图中的一个&lt;strong&gt;节点&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;边&lt;/strong&gt;：表示&lt;strong&gt;顶点和顶点&lt;/strong&gt;给之间的&lt;strong&gt;连线&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;相邻顶点&lt;/strong&gt;：由一条边连接在一起的顶点称为&lt;strong&gt;相邻顶点&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;度&lt;/strong&gt;：一个顶点的&lt;strong&gt;度&lt;/strong&gt;是&lt;strong&gt;相邻顶点的数量&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路径&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;简单路径：简单路径要求不包含重复的顶点；&lt;/li&gt;
&lt;li&gt;回路：第一个顶点和最后一个顶点&lt;strong&gt;相同&lt;/strong&gt;的路径称为回路；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无向图&lt;/strong&gt;：图中的所有边都是&lt;strong&gt;没有&lt;/strong&gt;方向的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有向图&lt;/strong&gt;：图中的所有边都是&lt;strong&gt;有&lt;/strong&gt;方向的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无权图&lt;/strong&gt;：无权图中的边没有任何权重意义；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;带权图&lt;/strong&gt;：带权图中的边有一定的权重含义；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12图的表示&#34;&gt;1.2.图的表示&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;邻接矩阵&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;表示图的常用方式为：&lt;strong&gt;邻接矩阵&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以使用二维数组来表示邻接矩阵；&lt;/li&gt;
&lt;li&gt;邻接矩阵让&lt;strong&gt;每个节点&lt;/strong&gt;和&lt;strong&gt;一个整数相关联&lt;/strong&gt;，该&lt;strong&gt;整数作为数组的下标值&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;使用一个&lt;strong&gt;二维数组&lt;/strong&gt;来表示顶点之间的&lt;strong&gt;连接&lt;/strong&gt;；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614605612152.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如上图所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二维数组中的0表示没有连线，1表示有连线；&lt;/li&gt;
&lt;li&gt;如：A[ 0 ] [ 3 ] = 1，表示 A 和 C 之间有连接；&lt;/li&gt;
&lt;li&gt;邻接矩阵的对角线上的值都为0，表示A - A ，B - B，等自回路都没有连接（自己与自己之间没有连接）；&lt;/li&gt;
&lt;li&gt;若为无向图，则邻接矩阵应为对角线上元素全为0的对称矩阵；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;邻接矩阵的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果图是一个&lt;strong&gt;稀疏图&lt;/strong&gt;，那么邻接矩阵中将存在&lt;strong&gt;大量的 0&lt;/strong&gt;，造成存储空间的浪费；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;邻接表&lt;/code&gt;&lt;br&gt;
另外一种表示图的常用方式为：&lt;strong&gt;邻接表。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邻接表由图中&lt;strong&gt;每个顶点&lt;/strong&gt;以及&lt;strong&gt;和顶点相邻的顶点列表&lt;/strong&gt;组成；&lt;/li&gt;
&lt;li&gt;这个列表可用多种方式存储，比如：**数组/链表/字典(哈希表)**等都可以；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614605685712.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如上图所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图中可清楚看到&lt;strong&gt;A&lt;/strong&gt;与&lt;strong&gt;B、C、D&lt;/strong&gt;相邻，假如要表示这些与A顶点相邻的顶点（边），可以通过将它们作为A的值（value）存入到对应的&lt;strong&gt;数组/链表/字典&lt;/strong&gt;中。&lt;/li&gt;
&lt;li&gt;之后，通过键（key）A可以十分方便地取出对应的数据；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;邻接表的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邻接表可以简单地得出&lt;strong&gt;出度&lt;/strong&gt;，即某一顶点指向其他顶点的个数；&lt;/li&gt;
&lt;li&gt;但是，邻接表计算&lt;strong&gt;入度&lt;/strong&gt;（指向某一顶点的其他顶点的个数称为该顶点的入度）十分困难。此时需要构造&lt;strong&gt;逆邻接表&lt;/strong&gt;才能有效计算入度；&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2封装图结构&#34;&gt;2.封装图结构&lt;/h1&gt;
&lt;p&gt;在实现过程中采用&lt;strong&gt;邻接表&lt;/strong&gt;的方式来表示边，使用&lt;strong&gt;字典类&lt;/strong&gt;来存储邻接表。&lt;/p&gt;
&lt;h2 id=&#34;21添加字典类和队列类&#34;&gt;2.1.添加字典类和队列类&lt;/h2&gt;
&lt;p&gt;首先需要引入之前实现的，之后会用到的字典类和队列类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//封装字典类
function Dictionary(){
  //字典属性
  this.items = {}

  //字典操作方法
  //一.在字典中添加键值对
  Dictionary.prototype.set = function(key, value){
    this.items[key] = value
  }

  //二.判断字典中是否有某个key
  Dictionary.prototype.has = function(key){
    return this.items.hasOwnProperty(key)
  }

  //三.从字典中移除元素
  Dictionary.prototype.remove = function(key){
    //1.判断字典中是否有这个key
    if(!this.has(key)) return false

    //2.从字典中删除key
    delete this.items[key]
    return true
  }

  //四.根据key获取value
  Dictionary.prototype.get = function(key){
    return this.has(key) ? this.items[key] : undefined
  }

  //五.获取所有keys
  Dictionary.prototype.keys = function(){
    return Object.keys(this.items)
  }

  //六.size方法
  Dictionary.prototype.keys = function(){
    return this.keys().length
  }

  //七.clear方法
  Dictionary.prototype.clear = function(){
    this.items = {}
  }
}

   // 基于数组封装队列类
    function Queue() {
    // 属性
      this.items = []
    // 方法
    // 1.将元素加入到队列中
    Queue.prototype.enqueue = element =&amp;gt; {
      this.items.push(element)
    }

    // 2.从队列中删除前端元素
    Queue.prototype.dequeue = () =&amp;gt; {
      return this.items.shift()
    }

    // 3.查看前端的元素
    Queue.prototype.front = () =&amp;gt; {
      return this.items[0]
    }

    // 4.查看队列是否为空
    Queue.prototype.isEmpty = () =&amp;gt; {
      return this.items.length == 0;
    }

    // 5.查看队列中元素的个数
    Queue.prototype.size = () =&amp;gt; {
      return this.items.length
    }

    // 6.toString方法
    Queue.prototype.toString = () =&amp;gt; {
      let resultString = &#39;&#39;
        for (let i of this.items){
          resultString += i + &#39; &#39;
        }
        return resultString
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;22创建图类&#34;&gt;2.2.创建图类&lt;/h2&gt;
&lt;p&gt;先创建图类Graph，并添加基本属性，再实现图类的常用方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //封装图类
    function Graph (){
      //属性：顶点(数组)/边(字典)
      this.vertexes = []  //顶点
      this.edges = new Dictionary() //边
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;23添加顶点与边&#34;&gt;2.3.添加顶点与边&lt;/h2&gt;
&lt;p&gt;如图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614685887261.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;创建一个数组对象vertexes存储图的顶点；创建一个字典对象edges存储图的边，其中key为顶点，value为存储key顶点相邻顶点的数组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     //添加方法
      //一.添加顶点
      Graph.prototype.addVertex = function(v){
        this.vertexes.push(v)
        this.edges.set(v, []) //将边添加到字典中，新增的顶点作为键，对应的值为一个存储边的空数组
      }
      //二.添加边
      Graph.prototype.addEdge = function(v1, v2){//传入两个顶点为它们添加边
        this.edges.get(v1).push(v2)//取出字典对象edges中存储边的数组，并添加关联顶点
        this.edges.get(v2).push(v1)//表示的是无向表，故要添加互相指向的两条边
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;24转换为字符串输出&#34;&gt;2.4.转换为字符串输出&lt;/h2&gt;
&lt;p&gt;为图类Graph添加toString方法，实现以邻接表的形式输出图中各顶点。&lt;br&gt;
&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; //三.实现toString方法:转换为邻接表形式
      Graph.prototype.toString = function (){
        //1.定义字符串，保存最终结果
        let resultString = &amp;quot;&amp;quot;

        //2.遍历所有的顶点以及顶点对应的边
        for (let i = 0; i &amp;lt; this.vertexes.length; i++) {//遍历所有顶点
          resultString += this.vertexes[i] + &#39;--&amp;gt;&#39;
          let vEdges = this.edges.get(this.vertexes[i])
          for (let j = 0; j &amp;lt; vEdges.length; j++) {//遍历字典中每个顶点对应的数组
            resultString += vEdges[j] + &#39;  &#39;;
          }
          resultString += &#39;\n&#39;
        }
        return resultString
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试代码
    //1.创建图结构
    let graph = new Graph()

    //2.添加顶点
    let myVertexes = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;]
    for (let i = 0; i &amp;lt; myVertexes.length; i++) {
      graph.addVertex(myVertexes[i])
    }

    //3.添加边
    graph.addEdge(&#39;A&#39;, &#39;B&#39;)
    graph.addEdge(&#39;A&#39;, &#39;C&#39;)
    graph.addEdge(&#39;A&#39;, &#39;D&#39;)
    graph.addEdge(&#39;C&#39;, &#39;D&#39;)
    graph.addEdge(&#39;C&#39;, &#39;G&#39;)
    graph.addEdge(&#39;D&#39;, &#39;G&#39;)
    graph.addEdge(&#39;D&#39;, &#39;H&#39;)
    graph.addEdge(&#39;B&#39;, &#39;E&#39;)
    graph.addEdge(&#39;B&#39;, &#39;F&#39;)
    graph.addEdge(&#39;E&#39;, &#39;I&#39;)

    //4.输出结果
    console.log(graph.toString());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614686639566.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;25图的遍历&#34;&gt;2.5.图的遍历&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;图的遍历思想：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图的遍历思想与树的遍历思想一样，意味着需要将图中&lt;strong&gt;所有的顶点&lt;/strong&gt;都访问一遍，并且不能有&lt;strong&gt;重复的访问&lt;/strong&gt;（上面的toString方法会重复访问）；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;遍历图的两种算法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;广度优先搜索（Breadth - First Search，简称&lt;strong&gt;BFS&lt;/strong&gt;）;&lt;/li&gt;
&lt;li&gt;深度优先搜索（Depth - First Search，简称&lt;strong&gt;DFS&lt;/strong&gt;）;&lt;/li&gt;
&lt;li&gt;两种遍历算法都需要指定&lt;strong&gt;第一个被访问的顶点&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了记录顶点是否被访问过，使用&lt;strong&gt;三种颜色&lt;/strong&gt;来表示它们的状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;白色&lt;/strong&gt;：表示该顶点还没有被访问过；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;灰色&lt;/strong&gt;：表示该顶点被访问过，但其相邻顶点并未完全被访问过；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;黑色&lt;/strong&gt;：表示该顶点被访问过，且其所有相邻顶点都被访问过；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先封装initializeColor方法将图中的所有顶点初始化为白色，代码实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //四.初始化状态颜色
      Graph.prototype.initializeColor = function(){
        let colors = []
        for (let i = 0; i &amp;lt; this.vertexes.length; i++) {
           colors[this.vertexes[i]] = &#39;white&#39;;
        }
        return colors
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;广度优先搜索&lt;/code&gt;&lt;br&gt;
广度优先搜索算法的思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻顶点，就像一次访问图的一层；&lt;/li&gt;
&lt;li&gt;也可以说是&lt;strong&gt;先宽后深&lt;/strong&gt;地遍历图中的各个顶点；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614686757512.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于&lt;strong&gt;队列&lt;/strong&gt;可以简单地实现广度优先搜索算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先创建一个队列Q（尾部进，首部出）；&lt;/li&gt;
&lt;li&gt;调用封装的initializeColor方法将所有顶点初始化为白色；&lt;/li&gt;
&lt;li&gt;指定第一个顶点A，将A标注为灰色（被访问过的节点），并将A放入队列Q中；&lt;/li&gt;
&lt;li&gt;循环遍历队列中的元素，只要队列Q非空，就执行以下操作：&lt;br&gt;
1. 先将灰色的A从Q的首部取出；&lt;br&gt;
2. 取出A后，将A的所有未被访问过（白色）的相邻顶点依次从队列Q的尾部加入队列，并变为灰色。以此保证，灰色的相邻顶点不重复加入队列；&lt;br&gt;
3. A的全部相邻节点加入Q后，A变为黑色，在下一次循环中被移除Q外；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;       //五.实现广度搜索(BFS)
      //传入指定的第一个顶点和处理结果的函数
      Graph.prototype.bfs = function(initV, handler){
        //1.初始化颜色
        let colors = this.initializeColor()

        //2.创建队列
        let que = new Queue()

        //3.将顶点加入到队列中
        que.enqueue(initV)

        //4.循环从队列中取出元素，队列为空才停止
        while(!que.isEmpty()){
          //4.1.从队列首部取出一个顶点
          let v = que.dequeue()

          //4.2.从字典对象edges中获取和该顶点相邻的其他顶点组成的数组
          let vNeighbours = this.edges.get(v)

          //4.3.将v的颜色变为灰色
          colors[v] = &#39;gray&#39;

          //4.4.遍历v所有相邻的顶点vNeighbours,并且加入队列中
          for (let i = 0; i &amp;lt; vNeighbours.length; i++) {
            const a = vNeighbours[i];
            //判断相邻顶点是否被探测过，被探测过则不加入队列中；并且加入队列后变为灰色，表示被探测过
            if (colors[a] == &#39;white&#39;) {
              colors[a] = &#39;gray&#39;
              que.enqueue(a)
            }
          }

          //4.5.处理顶点v
          handler(v)

          //4.6.顶点v所有白色的相邻顶点都加入队列后，将顶点v设置为黑色。此时黑色顶点v位于队列最前面，进入下一次while循环时会被取出
          colors[v] = &#39;black&#39;
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下为指定的第一个顶点为A时的遍历过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如 a 图所示，将在字典edges中取出的与A相邻的且未被访问过的白色顶点B、C、D放入队列que中并变为灰色，随后将A变为黑色并移出队列；&lt;/li&gt;
&lt;li&gt;接着，如图 b 所示，将在字典edges中取出的与B相邻的且未被访问过的白色顶点E、F放入队列que中并变为灰色，随后将B变为黑色并移出队列；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614686915234.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;如 c 图所示，将在字典edges中取出的与C相邻的且未被访问过的白色顶点G（A，D也相邻不过已变为灰色，所以不加入队列）放入队列que中并变为灰色，随后将C变为黑色并移出队列；&lt;/li&gt;
&lt;li&gt;接着，如图 d 所示，将在字典edges中取出的与D相邻的且未被访问过的白色顶点H放入队列que中并变为灰色，随后将D变为黑色并移出队列。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614686933411.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如此循环直到队列中元素为0，即所有顶点都变黑并移出队列后才停止，此时图中顶点已被全部遍历。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   //测试代码
    //1.创建图结构
    let graph = new Graph()

    //2.添加顶点
    let myVertexes = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;]
    for (let i = 0; i &amp;lt; myVertexes.length; i++) {
      graph.addVertex(myVertexes[i])
    }

    //3.添加边
    graph.addEdge(&#39;A&#39;, &#39;B&#39;)
    graph.addEdge(&#39;A&#39;, &#39;C&#39;)
    graph.addEdge(&#39;A&#39;, &#39;D&#39;)
    graph.addEdge(&#39;C&#39;, &#39;D&#39;)
    graph.addEdge(&#39;C&#39;, &#39;G&#39;)
    graph.addEdge(&#39;D&#39;, &#39;G&#39;)
    graph.addEdge(&#39;D&#39;, &#39;H&#39;)
    graph.addEdge(&#39;B&#39;, &#39;E&#39;)
    graph.addEdge(&#39;B&#39;, &#39;F&#39;)
    graph.addEdge(&#39;E&#39;, &#39;I&#39;)
    
    //4.测试bfs遍历方法
    let result = &amp;quot;&amp;quot;
    graph.bfs(graph.vertexes[0], function(v){
      result += v + &amp;quot;-&amp;quot;
    })
    console.log(result);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614686966585.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可见，安装了广度优先搜索的顺序&lt;strong&gt;不重复&lt;/strong&gt;地遍历了&lt;strong&gt;所有&lt;/strong&gt;顶点。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;深度优先搜索&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;深度优先算法的思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;深度优先搜索算法将会从指定的第一个顶点开始遍历图，沿着一条路径遍历直到该路径的最后一个顶点都被访问过为止；&lt;/li&gt;
&lt;li&gt;接着沿原来路径回退并探索下一条路径，即&lt;strong&gt;先深后宽&lt;/strong&gt;地遍历图中的各个顶点；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614687004548.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以使用&lt;strong&gt;栈&lt;/strong&gt;结构来实现深度优先搜索算法；&lt;/li&gt;
&lt;li&gt;深度优先搜索算法的遍历顺序与二叉搜索树中的先序遍历较为相似，同样可以使用&lt;strong&gt;递归&lt;/strong&gt;来实现（递归的本质就是&lt;strong&gt;函数栈&lt;/strong&gt;的调用）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于递归实现深度优先搜索算法：定义dfs方法用于调用递归方法dfsVisit，定义dfsVisit方法用于递归访问图中的各个顶点。&lt;/p&gt;
&lt;p&gt;在dfs方法中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，调用initializeColor方法将所有顶点初始化为白色；&lt;/li&gt;
&lt;li&gt;然后，调用dfsVisit方法遍历图的顶点；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在dfsVisit方法中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，将传入的指定节点v标注为&lt;strong&gt;灰色&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;接着，处理顶点V；&lt;/li&gt;
&lt;li&gt;然后，访问V的相邻顶点；&lt;/li&gt;
&lt;li&gt;最后，将顶点v标注为黑色；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     //六.实现深度搜索(DFS)
      Graph.prototype.dfs = function(initV, handler){
        //1.初始化顶点颜色
        let colors = this.initializeColor()

        //2.从某个顶点开始依次递归访问
        this.dfsVisit(initV, colors, handler)
      }

      //为了方便递归调用，封装访问顶点的函数，传入三个参数分别表示：指定的第一个顶点、颜色、处理函数
      Graph.prototype.dfsVisit = function(v, colors, handler){
        //1.将颜色设置为灰色
        colors[v] = &#39;gray&#39;

        //2.处理v顶点
        handler(v)

        //3.访问V的相邻顶点
        let vNeighbours = this.edges.get(v)
        for (let i = 0; i &amp;lt; vNeighbours.length; i++) {
          let a = vNeighbours[i];
          //判断相邻顶点是否为白色，若为白色，递归调用函数继续访问
          if (colors[a] == &#39;white&#39;) {
            this.dfsVisit(a, colors, handler)
          }
          
        }

        //4.将v设置为黑色
        colors[v] = &#39;black&#39;
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里主要解释一下代码中的第3步操作：访问指定顶点的相邻顶点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以指定顶点A为例，先从储存顶点及其对应相邻顶点的字典对象edges中取出由顶点A的相邻顶点组成的数组：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614687096873.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第一步&lt;/strong&gt;：A顶点变为灰色，随后进入第一个for循环，遍历A白色的相邻顶点：B、C、D；在该for循环的第1次循环中（执行B），B顶点满足：colors == &amp;quot;white&amp;quot;，触发递归，重新调用该方法；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二步&lt;/strong&gt;：B顶点变为灰色，随后进入第二个for循环，遍历B白色的相邻顶点：E、F；在该for循环的第1次循环中（执行E），E顶点满足：colors == &amp;quot;white&amp;quot;，触发递归，重新调用该方法；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三步&lt;/strong&gt;：E顶点变为灰色，随后进入第三个for循环，遍历E白色的相邻顶点：I；在该for循环的第1次循环中（执行I），I顶点满足：colors == &amp;quot;white&amp;quot;，触发递归，重新调用该方法；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第四步&lt;/strong&gt;：I顶点变为灰色，随后进入第四个for循环，由于顶点I的相邻顶点E不满足：colors == &amp;quot;white&amp;quot;，停止递归调用。过程如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614687132186.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第五步&lt;/strong&gt;：递归结束后一路向上返回，首先回到第三个for循环中继续执行其中的第2、3...次循环，每次循环的执行过程与上面的同理，直到递归再次结束后，再返回到第二个for循环中继续执行其中的第2、3...次循环....以此类推直到将图的所有顶点访问完为止。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图为遍历图中各顶点的完整过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;发现&lt;/strong&gt;表示访问了该顶点，状态变为&lt;strong&gt;灰色&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;探索&lt;/strong&gt;表示既访问了该顶点，也访问了该顶点的全部相邻顶点，状态变为&lt;strong&gt;黑色&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;由于在顶点变为灰色后就调用了处理函数handler，所以handler方法的输出顺序为发现顶点的顺序即：A、B、E、I、F、C、D、G、H 。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614687185004.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   //测试代码
    //1.创建图结构
    let graph = new Graph()

    //2.添加顶点
    let myVertexes = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;]
    for (let i = 0; i &amp;lt; myVertexes.length; i++) {
      graph.addVertex(myVertexes[i])
    }

    //3.添加边
    graph.addEdge(&#39;A&#39;, &#39;B&#39;)
    graph.addEdge(&#39;A&#39;, &#39;C&#39;)
    graph.addEdge(&#39;A&#39;, &#39;D&#39;)
    graph.addEdge(&#39;C&#39;, &#39;D&#39;)
    graph.addEdge(&#39;C&#39;, &#39;G&#39;)
    graph.addEdge(&#39;D&#39;, &#39;G&#39;)
    graph.addEdge(&#39;D&#39;, &#39;H&#39;)
    graph.addEdge(&#39;B&#39;, &#39;E&#39;)
    graph.addEdge(&#39;B&#39;, &#39;F&#39;)
    graph.addEdge(&#39;E&#39;, &#39;I&#39;)
    
    //4.测试dfs遍历顶点
    let result = &amp;quot;&amp;quot;
    graph.dfs(graph.vertexes[0], function(v){
      result += v + &amp;quot;-&amp;quot;
    })
    console.log(result);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614687223502.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;26完整实现&#34;&gt;2.6.完整实现&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;    //封装图结构
    function Graph (){
      //属性：顶点(数组)/边(字典)
      this.vertexes = []  //顶点
      this.edges = new Dictionary() //边

      //方法
      //添加方法
      //一.添加顶点
      Graph.prototype.addVertex = function(v){
        this.vertexes.push(v)
        this.edges.set(v, []) //将边添加到字典中，新增的顶点作为键，对应的值为一个存储边的空数组
      }
      //二.添加边
      Graph.prototype.addEdge = function(v1, v2){//传入两个顶点为它们添加边
        this.edges.get(v1).push(v2)//取出字典对象edges中存储边的数组，并添加关联顶点
        this.edges.get(v2).push(v1)//表示的是无向表，故要添加互相指向的两条边
      }

      //三.实现toString方法:转换为邻接表形式
      Graph.prototype.toString = function (){
        //1.定义字符串，保存最终结果
        let resultString = &amp;quot;&amp;quot;

        //2.遍历所有的顶点以及顶点对应的边
        for (let i = 0; i &amp;lt; this.vertexes.length; i++) {//遍历所有顶点
          resultString += this.vertexes[i] + &#39;--&amp;gt;&#39;
          let vEdges = this.edges.get(this.vertexes[i])
          for (let j = 0; j &amp;lt; vEdges.length; j++) {//遍历字典中每个顶点对应的数组
            resultString += vEdges[j] + &#39;  &#39;;
          }
          resultString += &#39;\n&#39;
        }
        return resultString
      }

      //四.初始化状态颜色
      Graph.prototype.initializeColor = function(){
        let colors = []
        for (let i = 0; i &amp;lt; this.vertexes.length; i++) {
           colors[this.vertexes[i]] = &#39;white&#39;;
        }
        return colors
      }

      //五.实现广度搜索(BFS)
      //传入指定的第一个顶点和处理结果的函数
      Graph.prototype.bfs = function(initV, handler){
        //1.初始化颜色
        let colors = this.initializeColor()

        //2.创建队列
        let que = new Queue()

        //3.将顶点加入到队列中
        que.enqueue(initV)

        //4.循环从队列中取出元素
        while(!que.isEmpty()){
          //4.1.从队列中取出一个顶点
          let v = que.dequeue()

          //4.2.获取和顶点相相邻的其他顶点
          let vNeighbours = this.edges.get(v)

          //4.3.将v的颜色变为灰色
          colors[v] = &#39;gray&#39;

          //4.4.遍历v所有相邻的顶点vNeighbours,并且加入队列中
          for (let i = 0; i &amp;lt; vNeighbours.length; i++) {
            const a = vNeighbours[i];
            //判断相邻顶点是否被探测过，被探测过则不加入队列中；并且加入队列后变为灰色，表示被探测过
            if (colors[a] == &#39;white&#39;) {
              colors[a] = &#39;gray&#39;
              que.enqueue(a)
            }
          }

          //4.5.处理顶点v
          handler(v)

          //4.6.顶点v所有白色的相邻顶点都加入队列后，将顶点v设置为黑色。此时黑色顶点v位于队列最前面，进入下一次while循环时会被取出
          colors[v] = &#39;black&#39;
        }
      }

      //六.实现深度搜索(DFS)
      Graph.prototype.dfs = function(initV, handler){
        //1.初始化顶点颜色
        let colors = this.initializeColor()

        //2.从某个顶点开始依次递归访问
        this.dfsVisit(initV, colors, handler)
      }

      //为了方便递归调用，封装访问顶点的函数，传入三个参数分别表示：指定的第一个顶点、颜色、处理函数
      Graph.prototype.dfsVisit = function(v, colors, handler){
        //1.将颜色设置为灰色
        colors[v] = &#39;gray&#39;

        //2.处理v顶点
        handler(v)

        //3.访问v相连的其他顶点
        let vNeighbours = this.edges.get(v)
        for (let i = 0; i &amp;lt; vNeighbours.length; i++) {
          let a = vNeighbours[i];
          //判断相邻顶点是否为白色，若为白色，递归调用函数继续访问
          if (colors[a] == &#39;white&#39;) {
            this.dfsVisit(a, colors, handler)
          }
          
        }

        //4.将v设置为黑色
        colors[v] = &#39;black&#39;
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;27-深度优先和广度优先区别&#34;&gt;2.7 深度优先和广度优先区别&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;bfs＝队列，入队列，出队列；dfs=栈，压栈，出栈&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619575966858.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1x7411L7Q7?from=search&amp;amp;seid=3912456004602554239&#34;&gt;参考资料:JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现图结构</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/javascript-shi-xian-hong-hei-shu/"" data-c="
          &lt;h1 id=&#34;1红黑树的五条规则&#34;&gt;1.红黑树的五条规则&lt;/h1&gt;
&lt;p&gt;红黑树除了符合二叉搜索树的基本规则外，还添加了以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;规则1：节点是红色或黑色的&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规则2：根节点是黑色的；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规则3：每个叶子节点都是黑色的空节点（NIL节点）；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规则4：每个红色节点的两个子节点都是黑色的（从每个叶子到根的所有路径上不可能有两个连续的红色节点）；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规则5：从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点；&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614602841856.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;红黑树的相对平衡&lt;/strong&gt;&lt;br&gt;
前面5条规则的约束确保了以下红黑树的关键特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从&lt;strong&gt;根到叶子节点&lt;/strong&gt;的&lt;strong&gt;最长路径&lt;/strong&gt;，不会超过&lt;strong&gt;最短路径&lt;/strong&gt;的&lt;strong&gt;两倍&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;结果就是这棵树&lt;strong&gt;基本&lt;/strong&gt;是平衡的；&lt;/li&gt;
&lt;li&gt;虽然没有做到绝对的平衡，但是可以保证在最坏的情况下，该树依然是高效的；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么可以做到&lt;strong&gt;最长路径不超过最短路径的两倍&lt;/strong&gt;呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;性质4&lt;/strong&gt;决定了路径上不能有两个相连的红色节点；&lt;/li&gt;
&lt;li&gt;所以，最长路径一定是红色节点和黑色节点交替而成的；&lt;/li&gt;
&lt;li&gt;由于根节点和叶子节点都是黑色的，最短路径可能都是黑色节点，并且最长路径中一定是黑色节点多于红色节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性质5&lt;/strong&gt;决定了所有路径上都有相同数目的黑色节点；&lt;/li&gt;
&lt;li&gt;这就表明了没有路径能多于其他任何路径两倍长。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2红黑树的三种变换&#34;&gt;2.红黑树的三种变换&lt;/h1&gt;
&lt;p&gt;插入一个新节点时，有可能树不再平衡，可以通过三种方式的变换使树保持平衡：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;变色&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;左旋转&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;右旋转&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;21变色&#34;&gt;2.1.变色&lt;/h2&gt;
&lt;p&gt;为了重新符合红黑树的规则，需要把&lt;strong&gt;红色&lt;/strong&gt;节点变为&lt;strong&gt;黑色&lt;/strong&gt;，或者把&lt;strong&gt;黑色&lt;/strong&gt;节点变为&lt;strong&gt;红色&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;插入的&lt;strong&gt;新节点&lt;/strong&gt;通常都是&lt;strong&gt;红色节点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当插入的节点为&lt;strong&gt;红色&lt;/strong&gt;的时候，大多数情况&lt;strong&gt;不违反&lt;/strong&gt;红黑树的任何规则；&lt;/li&gt;
&lt;li&gt;而&lt;strong&gt;插入黑色节点&lt;/strong&gt;，必然会导致一条路径上多了一个&lt;strong&gt;黑色节点&lt;/strong&gt;，这是很难调整的；&lt;/li&gt;
&lt;li&gt;红色节点虽然可能导致&lt;strong&gt;红红相连&lt;/strong&gt;的情况，但是这种情况可以通过&lt;strong&gt;颜色调换&lt;/strong&gt;和&lt;strong&gt;旋转&lt;/strong&gt;来调整；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;22左旋转&#34;&gt;2.2.左旋转&lt;/h2&gt;
&lt;p&gt;以节点X为根&lt;strong&gt;逆时针&lt;/strong&gt;旋转二叉搜索树，使得父节点原来的位置被自己的右子节点替代，左子节点的位置被父节点替代；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604172318.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;详解：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，左旋转之后：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点X取代了节点a原来的位置；&lt;/li&gt;
&lt;li&gt;节点Y取代了节点X原来的位置；&lt;/li&gt;
&lt;li&gt;节点X的&lt;strong&gt;左子树&lt;/strong&gt; a 仍然是节点X的&lt;strong&gt;左子树&lt;/strong&gt;（这里X的左子树只有一个节点，有多个节点时同样适用，以下同理）；&lt;/li&gt;
&lt;li&gt;节点Y的&lt;strong&gt;右子树 &lt;strong&gt;c 仍然是节点Y的&lt;/strong&gt;右子树&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;节点Y的&lt;strong&gt;左子树&lt;/strong&gt; b 向&lt;strong&gt;左平移&lt;/strong&gt;成为了节点X的&lt;strong&gt;右子树&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外，二叉搜索树左旋转之后仍为二叉搜索树：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604239227.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;23右旋转&#34;&gt;2.3.右旋转&lt;/h2&gt;
&lt;p&gt;以节点X为根&lt;strong&gt;顺时针&lt;/strong&gt;旋转二叉搜索树，使得父节点原来的位置被自己的左子节点替代，右子节点的位置被父节点替代；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604262297.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;详解：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，右旋转之后：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点X取代了节点a原来的位置；&lt;/li&gt;
&lt;li&gt;节点Y取代了节点X原来的位置；&lt;/li&gt;
&lt;li&gt;节点X的&lt;strong&gt;右子树&lt;/strong&gt; a 仍然是节点X的&lt;strong&gt;右子树&lt;/strong&gt;（这里X的右子树虽然只有一个节点，但是多个节点时同样适用，以下同理）；&lt;/li&gt;
&lt;li&gt;节点Y的&lt;strong&gt;左子树&lt;/strong&gt; b 仍然是节点Y的&lt;strong&gt;左子树&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;节点Y的&lt;strong&gt;右子树 c 向右平移&lt;/strong&gt;成为了节点X的&lt;strong&gt;左子树&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外，二叉搜索树右旋转之后仍为二叉搜索树：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604315554.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3红黑树的插入操作&#34;&gt;3.红黑树的插入操作&lt;/h1&gt;
&lt;p&gt;首先需要明确，在保证满足红黑树5条规则的情况下，新插入的节点必然是&lt;strong&gt;红色节点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为了方便说明，规定以下四个节点：新插入节点为&lt;strong&gt;N&lt;/strong&gt;（Node），N的父节点为&lt;strong&gt;P&lt;/strong&gt;（Parent），P的兄弟节点为&lt;strong&gt;U&lt;/strong&gt;（Uncle），U的父节点为&lt;strong&gt;G&lt;/strong&gt;（Grandpa），如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604357068.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;31情况1&#34;&gt;3.1.情况1&lt;/h2&gt;
&lt;p&gt;当插入的新节点N位于树的根上时，没有父节点。&lt;/p&gt;
&lt;p&gt;这种情况下，只需要将红色节点变为黑色节点即可满足规则2 。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604378412.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;32情况2&#34;&gt;3.2.情况2&lt;/h2&gt;
&lt;p&gt;新界点N的父节点P为黑色节点，此时不需要任何变化。&lt;/p&gt;
&lt;p&gt;此时既满足规则4也满足规则5。尽管新节点是红色的，但是新节点N有两个黑色节点NIL，所以通向它的路径上黑色节点的个数依然相等，因此满足规则5 。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604403948.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;33情况3&#34;&gt;3.3.情况3&lt;/h2&gt;
&lt;p&gt;节点P为红色，节点U也为红色，此时节点G必为黑色，即&lt;strong&gt;父红叔红祖黑&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在这种情况下需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先将父节点P变为黑色；&lt;/li&gt;
&lt;li&gt;再将叔叔节点U变为黑色；&lt;/li&gt;
&lt;li&gt;最后将祖父节点G变为红色；&lt;/li&gt;
&lt;li&gt;即变为父黑叔黑祖红，如下图所示：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即变为&lt;strong&gt;父黑叔黑祖红&lt;/strong&gt;，如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604452528.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;可能出现的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;N的祖父节点G的父节点也可能是红色，这就违反了规则4，此时可以通过递归调整节点颜色；&lt;/li&gt;
&lt;li&gt;当递归调整到根节点时就需要旋转了，如下图节点A和节点B所示，具体情况后面会介绍；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604474905.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;34情况4&#34;&gt;3.4.情况4&lt;/h2&gt;
&lt;p&gt;节点P是红色节点，节点U是黑色节点，并且节点N为节点P的&lt;strong&gt;左子节点&lt;/strong&gt;，此时节点G一定是黑色节点，即&lt;strong&gt;父红叔黑祖黑&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在这种情况下需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先变色：将父节点P变为黑色，将祖父节点G变为红色；&lt;/li&gt;
&lt;li&gt;后旋转：以祖父节点G为根进行右旋转；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604502174.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;35情况5&#34;&gt;3.5.情况5&lt;/h2&gt;
&lt;p&gt;节点P是红色节点，节点U是黑色节点，并且节点N为节点P的&lt;strong&gt;右子节点&lt;/strong&gt;，此时节点G一定是黑色节点，即&lt;strong&gt;父红叔黑祖黑&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在这种情况下需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先以节点P为根进行左旋转，旋转后如图b所示；&lt;/li&gt;
&lt;li&gt;随后将&lt;strong&gt;红色&lt;/strong&gt;节点&lt;strong&gt;P&lt;/strong&gt;和&lt;strong&gt;黑色&lt;/strong&gt;节点&lt;strong&gt;B&lt;/strong&gt;看成一个整体的&lt;strong&gt;红色&lt;/strong&gt;节点&lt;strong&gt;N1&lt;/strong&gt;，将新插入的&lt;strong&gt;红色&lt;/strong&gt;节点&lt;strong&gt;N&lt;/strong&gt;看成&lt;strong&gt;红色&lt;/strong&gt;节点&lt;strong&gt;P1&lt;/strong&gt; 如图c所示。此时整体就转换为了情况4。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604584661.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接着可以按照情况4进行处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先变色：将N1节点的父节点P1变为黑色，将祖父节点G变为红色；&lt;/li&gt;
&lt;li&gt;后旋转：以祖父节点G为根进行右旋转，旋转后如图 e 所示；&lt;/li&gt;
&lt;li&gt;最后将节点N1和P1变换回来，完成节点N的插入，如图 f 所示；&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604622077.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;36案例&#34;&gt;3.6.案例&lt;/h2&gt;
&lt;p&gt;在二叉树中依次插入节点：10，9，8，7，6，5，4，3，2，1 。&lt;/p&gt;
&lt;p&gt;如果直接采用普通的二叉搜索树，节点全部插入后是这样的：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604643226.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;是一个严重的&lt;strong&gt;不平衡树&lt;/strong&gt;，相当于一个链表，不能体现出二叉搜索树的高效率。而按照红黑树的五条规则插入节点就能最大程度保证搜索二叉树是一棵&lt;strong&gt;平衡树&lt;/strong&gt;。以下为过程详解：&lt;strong&gt;为了方便解释省略了部分红黑树的叶子节点（NIL）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;插入10&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;符合&lt;strong&gt;情况1：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入节点10；&lt;/li&gt;
&lt;li&gt;将节点10的颜色变为黑色；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604704418.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;插入9&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;符合&lt;strong&gt;情况2&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不需要任何变化；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604750380.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;插入8&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;快速判断属于情况3还是情况4的方法：&lt;br&gt;
从新插入的节点N出发，按图示箭头经过的四个节点，若为&lt;strong&gt;红红黑红&lt;/strong&gt;3个红色节点则为情况3，若为&lt;strong&gt;红红黑黑&lt;/strong&gt;两个红色节点则为情况4；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604802506.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;符合&lt;strong&gt;情况4：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点9变成黑，祖父节点10变为红；&lt;/li&gt;
&lt;li&gt;以祖父节点为根进行右旋转；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604830569.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;插入7&lt;/code&gt;&lt;br&gt;
符合&lt;strong&gt;情况3&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点8和叔节点10变为黑，祖父节点9变为红；&lt;/li&gt;
&lt;li&gt;此时会出现问题：不符合规则2，即根节点不为黑，此时可以把以9为根节点的二叉搜索树当作一个整体作为一个新插入的节点N，而此时又符合情况1，只需要把9变回黑色即可。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604863568.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;插入6&lt;/code&gt;&lt;br&gt;
符合&lt;strong&gt;情况4：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点7变为黑，祖父节点8变为红；&lt;/li&gt;
&lt;li&gt;以祖父节点8为根进行右旋转；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604890220.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;插入5&lt;/code&gt;&lt;br&gt;
符合&lt;strong&gt;情况3&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点6和叔节点8变为黑，祖父节点7变为红；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604951192.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;插入4&lt;/code&gt;&lt;br&gt;
符合&lt;strong&gt;情况4&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点5变为黑，祖父节点6变为红；&lt;/li&gt;
&lt;li&gt;以祖父节点6为根进行右旋转；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614604975864.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;插入3&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;第一次变换&lt;/strong&gt;：符合&lt;strong&gt;情况3&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点4和叔节点6变为黑，祖父节点5变为红；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;变换之后发现5和7为相连的两个红色节点，于是把以5为根的整个子树看成一个新插入的节点N1，再进行第二次变换。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614605014069.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二次变换&lt;/strong&gt;：符合&lt;strong&gt;情况4&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点7变为黑，祖父节点9变为红；&lt;/li&gt;
&lt;li&gt;以祖父节点9为根进行右旋转；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614605037802.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后复原N1得到变换后的红黑树：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614605062771.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;插入2&lt;/code&gt;&lt;br&gt;
符合&lt;strong&gt;情况4&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点3变为黑，祖父节点4变为红；&lt;/li&gt;
&lt;li&gt;以祖父节点4为根进行右旋转；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614605088621.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;插入1&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;第一次变换&lt;/strong&gt;：符合&lt;strong&gt;情况3&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点2和叔节点4变为黑，祖父节点3变为红；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;变换之后发现3和5为相连的两个红色节点，于是把以3为根的整个子树看成一个新插入的节点N1，再进行第二次变换。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614605114950.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二次变换&lt;/strong&gt;：符合&lt;strong&gt;情况3&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点5和叔节点9变为黑，祖父节点7变为红；即由图 b -&amp;gt; 图 c 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;变换之后发现根节点7为红色不符合规则2，所以把以7为根节点的红黑树看成一个新插入的节点N2，再进行第三次变换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三次变换&lt;/strong&gt;：符合&lt;strong&gt;情况1&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接将根节点7变为黑色即可。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614605156139.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由此，完成了1~10节点的插入，虽然没有遇到情况5，不过情况5经过左旋转的操作便可转换为情况4，原理一样。如下图所示，将这棵红黑树的叶子节点NIL补全之后，经检验满足红黑树的五条规则，并且基本属于&lt;strong&gt;平衡树&lt;/strong&gt;，效率较高。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614605184855.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;4红黑树的删除操作&#34;&gt;4.红黑树的删除操作&lt;/h1&gt;
&lt;p&gt;红黑树的删除操作结合了复杂的&lt;strong&gt;二叉树的删除操作&lt;/strong&gt;和复杂的&lt;strong&gt;红黑树的插入规则&lt;/strong&gt;，整体来说难度非常大，篇幅较长，这里暂不进行探讨。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av86801505?from=search&amp;amp;seid=4967761411915016256&#34;&gt;参考资料：JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现平衡树（红黑树）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/javascript-shi-xian-shu-jie-gou/"" data-c="
          &lt;h1 id=&#34;1树结构简介&#34;&gt;1.树结构简介&lt;/h1&gt;
&lt;h2 id=&#34;11简单了解树结构&#34;&gt;1.1.简单了解树结构&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;什么是树？&lt;/strong&gt;&lt;br&gt;
真实的树：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614430459970.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;树的特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树一般都有一个&lt;strong&gt;根&lt;/strong&gt;，连接着根的是&lt;strong&gt;树干&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;树干会发生分叉，形成许多&lt;strong&gt;树枝&lt;/strong&gt;，树枝会继续分化成更小的&lt;strong&gt;树枝&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;树枝的最后是&lt;strong&gt;叶子&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现实生活中很多结构都是树的抽象，模拟的树结构相当于旋转180°的树。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614430500028.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;树结构对比于数组/链表/哈希表有哪些优势呢：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数组：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：可以通过&lt;strong&gt;下标值访问&lt;/strong&gt;，效率高；&lt;/li&gt;
&lt;li&gt;缺点：查找数据时需要先对数据进行&lt;strong&gt;排序&lt;/strong&gt;，生成&lt;strong&gt;有序数组&lt;/strong&gt;，才能提高查找效率；并且在插入和删除元素时，需要大量的&lt;strong&gt;位移操作&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;链表：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：数据的插入和删除操作效率都很高；&lt;/li&gt;
&lt;li&gt;缺点：&lt;strong&gt;查找&lt;/strong&gt;效率低，需要从头开始依次查找，直到找到目标数据为止；当需要在链表中间位置插入或删除数据时，插入或删除的效率都不高。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;哈希表：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：哈希表的插入/查询/删除效率都非常高；&lt;/li&gt;
&lt;li&gt;缺点：&lt;strong&gt;空间利用率不高&lt;/strong&gt;，底层使用的数组中很多单元没有被利用；并且哈希表中的元素是&lt;strong&gt;无序&lt;/strong&gt;的，不能按照固定顺序遍历哈希表中的元素；而且不能快速找出哈希表中&lt;strong&gt;最大值或最小值&lt;/strong&gt;这些特殊值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;树结构：&lt;/strong&gt;&lt;br&gt;
优点：树结构综合了上述三种结构的优点，同时也弥补了它们存在的缺点（虽然效率不一定都比它们高），比如树结构中数据都是有序的，查找效率高；空间利用率高；并且可以快速获取最大值和最小值等。&lt;/p&gt;
&lt;p&gt;总的来说：&lt;strong&gt;每种数据结构都有自己特定的应用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;树结构：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;树（Tree）&lt;/strong&gt;:由 n（n ≥ 0）个节点构成的&lt;strong&gt;有限集合&lt;/strong&gt;。当 n = 0 时，称为&lt;strong&gt;空树&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于任一棵非空树（n &amp;gt; 0），它具备以下性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数中有一个称为**根（Root）**的特殊节点，用 **r **表示；&lt;/li&gt;
&lt;li&gt;其余节点可分为 m（m &amp;gt; 0）个互不相交的有限集合 T1，T2，...，Tm，其中每个集合本身又是一棵树，称为原来树的&lt;strong&gt;子树（SubTree）&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;树的常用术语：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614430719871.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;节点的度（Degree）&lt;/strong&gt;：节点的&lt;strong&gt;子树个数&lt;/strong&gt;，比如节点B的度为2；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;树的度&lt;/strong&gt;：树的所有节点中&lt;strong&gt;最大的度数&lt;/strong&gt;，如上图树的度为2；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;叶节点（Leaf）&lt;/strong&gt;：&lt;strong&gt;度为0的节点&lt;/strong&gt;（也称为叶子节点），如上图的H，I等；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;父节点（Parent）&lt;/strong&gt;：度不为0的节点称为父节点，如上图节点B是节点D和E的父节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;子节点（Child）&lt;/strong&gt;：若B是D的父节点，那么D就是B的子节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;兄弟节点（Sibling）&lt;/strong&gt;：具有同一父节点的各节点彼此是兄弟节点，比如上图的B和C，D和E互为兄弟节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路径和路径长度&lt;/strong&gt;：路径指的是一个节点到另一节点的通道，路径所包含边的个数称为路径长度，比如A-&amp;gt;H的路径长度为3；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;节点的层次（Level）&lt;/strong&gt;：规定&lt;strong&gt;根节点在1层&lt;/strong&gt;，其他任一节点的层数是其父节点的&lt;strong&gt;层数加1&lt;/strong&gt;。如B和C节点的层次为2；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;树的深度（Depth）&lt;/strong&gt;：树种所有节点中的&lt;strong&gt;最大层次&lt;/strong&gt;是这棵树的深度，如上图树的深度为4；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12树结构的表示方式&#34;&gt;1.2.树结构的表示方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;最普通的表示方法：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614430807590.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如图，树结构的组成方式类似于链表，都是由一个个节点连接构成。不过，根据每个父节点子节点数量的不同，每一个父节点需要的引用数量也不同。比如节点A需要3个引用，分别指向子节点B，C，D；B节点需要2个引用，分别指向子节点E和F；K节点由于没有子节点，所以不需要引用。&lt;/p&gt;
&lt;p&gt;这种方法缺点在于我们无法确定某一结点的引用数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;儿子-兄弟表示法：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614430840465.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这种表示方法可以完整地记录每个节点的数据，比如：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;//节点A
Node{
  //存储数据
  this.data = data
  //统一只记录左边的子节点
  this.leftChild = B
  //统一只记录右边的第一个兄弟节点
  this.rightSibling = null
}

//节点B
Node{
  this.data = data
  this.leftChild = E
  this.rightSibling = C
}

//节点F
Node{
  this.data = data
  this.leftChild = null
  this.rightSibling = null
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种表示法的优点在于每一个节点中引用的数量都是确定的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;儿子-兄弟表示法旋转&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下为儿子-兄弟表示法组成的树结构：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614430881094.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
将其顺时针旋转45°之后：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614430888569.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这样就成为了一棵&lt;strong&gt;二叉树&lt;/strong&gt;，由此我们可以得出结论：&lt;strong&gt;任何树都可以通过二叉树进行模拟&lt;/strong&gt;。但是这样父节点不是变了吗？其实，父节点的设置只是为了方便指向子节点，在代码实现中谁是父节点并没有关系，只要能正确找到对应节点即可。&lt;/p&gt;
&lt;h1 id=&#34;2二叉树&#34;&gt;2.二叉树&lt;/h1&gt;
&lt;h2 id=&#34;21二叉树简介&#34;&gt;2.1.二叉树简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;二叉树的概念&lt;/strong&gt;：如果树中的每一个节点最多只能由&lt;strong&gt;两个子节点&lt;/strong&gt;，这样的树就称为&lt;strong&gt;二叉树&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;二叉树十分重要，不仅仅是因为简单，更是因为几乎所有的树都可以表示成二叉树形式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二叉树的组成&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二叉树可以为空，也就是没有节点；&lt;/li&gt;
&lt;li&gt;若二叉树不为空，则它由根节点和称为其左子树TL和右子树TR的两个不相交的二叉树组成；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;二叉树的五种形态：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614430959785.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
上图分别表示：空的二叉树、只有一个节点的二叉树、只有左子树TL的二叉树、只有右子树TR的二叉树和有左右两个子树的二叉树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二叉树的特性：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个二叉树的第 i 层的最大节点树为：2(i-1)，i &amp;gt;= 1；&lt;/li&gt;
&lt;li&gt;深度为k的二叉树的最大节点总数为：2k - 1 ，k &amp;gt;= 1；&lt;/li&gt;
&lt;li&gt;对任何非空二叉树，若 n0 表示叶子节点的个数，n2表示度为2的非叶子节点个数，那么两者满足关系：n0 = n2 + 1；如下图所示：H，E，I，J，G为叶子节点，总数为5；A，B，C，F为度为2的非叶子节点，总数为4；满足n0 = n2 + 1的规律。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614430990764.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;22特殊的二叉树&#34;&gt;2.2.特殊的二叉树&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;完美二叉树&lt;/strong&gt;&lt;br&gt;
完美二叉树（Perfect Binary Tree）也成为满二叉树（Full Binary Tree），在二叉树中，除了最下一层的叶子节点外，每层节点都有2个子节点，这就构成了完美二叉树。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431028944.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完全二叉树&lt;/strong&gt;&lt;br&gt;
完全二叉树（Complete Binary Tree）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;除了二叉树最后一层外，其他各层的节点数都达到了最大值；&lt;/li&gt;
&lt;li&gt;并且，最后一层的叶子节点从左向右是连续存在，只缺失右侧若干叶子节点；&lt;/li&gt;
&lt;li&gt;完美二叉树是特殊的完全二叉树；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431051756.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在上图中，由于H缺失了右子节点，所以它不是完全二叉树。&lt;/p&gt;
&lt;h2 id=&#34;23二叉树的数据存储&#34;&gt;2.3.二叉树的数据存储&lt;/h2&gt;
&lt;p&gt;常见的二叉树存储方式为&lt;strong&gt;数组&lt;/strong&gt;和&lt;strong&gt;链表&lt;/strong&gt;：&lt;br&gt;
&lt;strong&gt;使用数组：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完全二叉树：按从上到下，从左到右的方式存储数据。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431087611.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;节点&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;A&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;B&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;C&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;D&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;E&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;F&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;G&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;H&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;序号&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;使用数组存储时，取数据的时候也十分方便：左子节点的序号等于父节点序号 * 2，右子节点的序号等于父节点序号 * 2 + 1 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非完全二叉树：非完全二叉树需要转换成完全二叉树才能按照上面的方案存储，这样会浪费很大的存储空间。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431341849.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431447014.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;使用链表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;二叉树最常见的存储方式为&lt;strong&gt;链表&lt;/strong&gt;：每一个节点封装成一个Node，Node中包含存储的数据、左节点的引用和右节点的引用。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431472922.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3二叉搜索树&#34;&gt;3.二叉搜索树&lt;/h1&gt;
&lt;h2 id=&#34;31认识二叉搜索树&#34;&gt;3.1.认识二叉搜索树&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;二叉搜索树&lt;/strong&gt;（&lt;strong&gt;BST&lt;/strong&gt;，Binary Search Tree），也称为&lt;strong&gt;二叉排序树&lt;/strong&gt;和&lt;strong&gt;二叉查找树&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;二叉搜索树是一棵二叉树，可以为空；&lt;/p&gt;
&lt;p&gt;如果不为空，则满足以下&lt;strong&gt;性质&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;条件1：非空左子树的&lt;strong&gt;所有&lt;/strong&gt;键值&lt;strong&gt;小于&lt;/strong&gt;其根节点的键值。比如三中节点6的所有非空左子树的键值都小于6；&lt;/li&gt;
&lt;li&gt;条件2：非空右子树的&lt;strong&gt;所有&lt;/strong&gt;键值&lt;strong&gt;大于&lt;/strong&gt;其根节点的键值；比如三中节点6的所有非空右子树的键值都大于6；&lt;/li&gt;
&lt;li&gt;条件3：左、右子树本身也都是二叉搜索树；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431547872.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如上图所示，树二和树三符合3个条件属于二叉树，树一不满足条件3所以不是二叉树。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：二叉搜索树的特点主要是&lt;strong&gt;较小的值&lt;/strong&gt;总是保存在&lt;strong&gt;左节点&lt;/strong&gt;上，相对&lt;strong&gt;较大的值&lt;/strong&gt;总是保存在&lt;strong&gt;右节点&lt;/strong&gt;上。这种特点使得二叉搜索树的查询效率非常高，这也就是二叉搜索树中&amp;quot;搜索&amp;quot;的来源。&lt;/p&gt;
&lt;h2 id=&#34;32二叉搜索树应用举例&#34;&gt;3.2.二叉搜索树应用举例&lt;/h2&gt;
&lt;p&gt;下面是一个二叉搜索树：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431584847.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
若想在其中查找数据10，只需要查找4次，查找效率非常高。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第1次：将10与根节点9进行比较，由于10 &amp;gt; 9，所以10下一步与根节点9的右子节点13比较；&lt;/li&gt;
&lt;li&gt;第2次：由于10 &amp;lt; 13，所以10下一步与父节点13的左子节点11比较；&lt;/li&gt;
&lt;li&gt;第3次：由于10 &amp;lt; 11，所以10下一步与父节点11的左子节点10比较；&lt;/li&gt;
&lt;li&gt;第4次：由于10 = 10，最终查找到数据10 。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431605019.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
同样是15个数据，在排序好的数组中查询数据10，需要查询10次：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431617619.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实：如果是排序好的数组，可以通过二分查找：第一次找9，第二次找13，第三次找15...。我们发现如果把每次二分的数据拿出来以树的形式表示的话就是&lt;strong&gt;二叉搜索树&lt;/strong&gt;。这就是数组二分法查找效率之所以高的原因。&lt;/p&gt;
&lt;h1 id=&#34;4二叉搜索树的封装&#34;&gt;4.二叉搜索树的封装&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;二叉树搜索树的基本属性&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;如图所示：二叉搜索树有四个最基本的属性：指向节点的&lt;strong&gt;根&lt;/strong&gt;（root），节点中的&lt;strong&gt;键&lt;/strong&gt;（key）、&lt;strong&gt;左指针&lt;/strong&gt;（right）、&lt;strong&gt;右指针&lt;/strong&gt;（right）。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431790313.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
所以，二叉搜索树中除了定义root属性外，还应定义一个节点内部类，里面包含每个节点中的left、right和key三个属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //封装二叉搜索树
    function BinarySearchTree(){

      //节点内部类
      function Node(key){
        this.key = key
        this.left = null
        this.right = null
      }

      //属性
      this.root = null
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;二叉搜索树的常见操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insert（key）：向树中插入一个新的键；&lt;/li&gt;
&lt;li&gt;search（key）：在树中查找一个键，如果节点存在，则返回true；如果不存在，则返回false；&lt;/li&gt;
&lt;li&gt;inOrderTraverse：通过中序遍历方式遍历所有节点；&lt;/li&gt;
&lt;li&gt;preOrderTraverse：通过先序遍历方式遍历所有节点；&lt;/li&gt;
&lt;li&gt;postOrderTraverse：通过后序遍历方式遍历所有节点；&lt;/li&gt;
&lt;li&gt;min：返回树中最小的值/键；&lt;/li&gt;
&lt;li&gt;max：返回树中最大的值/键；&lt;/li&gt;
&lt;li&gt;remove（key）：从树中移除某个键；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;41插入数据&#34;&gt;4.1.插入数据&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先根据传入的key创建节点对象；&lt;/li&gt;
&lt;li&gt;然后判断根节点是否存在，不存在时通过：this.root = newNode，直接把新节点作为二叉搜索树的根节点。&lt;/li&gt;
&lt;li&gt;若存在根节点则重新定义一个内部方法insertNode（）用于查找插入点。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    //insert方法:对外向用户暴露的方法
      BinarySearchTree.prototype.insert = function(key){
        //1.根据key创建节点
        let newNode = new Node(key)
          
        //2.判断根节点是否存在
        if (this.root == null) {
          this.root = newNode
          //根节点存在时
        }else {
          this.insertNode(this.root, newNode)
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;内部方法insertNode（）的实现思路:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据比较传入的两个节点，一直查找新节点适合插入的位置，直到成功插入新节点为止。&lt;/p&gt;
&lt;p&gt;当newNode.key &amp;lt; node.key向左查找:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：当node无左子节点时，直接插入：&lt;/li&gt;
&lt;li&gt;情况2：当node有左子节点时，递归调用insertNode(),直到遇到无左子节点成功插入newNode后，不再符合该情况，也就不再调用insertNode()，递归停止。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431894630.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当newNode.key &amp;gt;= node.key向右查找，与向左查找类似：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：当node无右子节点时，直接插入：&lt;/li&gt;
&lt;li&gt;情况2：当node有右子节点时，依然递归调用insertNode(),直到遇到传入insertNode方法的node无右子节点成功插入newNode为止：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431913325.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;insertNode()代码实现：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    //内部使用的insertNode方法:用于比较节点从左边插入还是右边插入
      BinarySearchTree.prototype.insertNode = function(node, newNode){
        //当newNode.key &amp;lt; node.key向左查找
/*----------------------分支1:向左查找--------------------------*/      
        if(newNode.key &amp;lt; node.key){
          //情况1：node无左子节点，直接插入
/*----------------------分支1.1--------------------------*/
          if (node.left == null) {
            node.left = newNode
          //情况2：node有左子节点，递归调用insertNode(),直到遇到无左子节点成功插入newNode后，不再符合该情况，也就不再调用insertNode()，递归停止。
/*----------------------分支1.2--------------------------*/
          }else{
            this.insertNode(node.left, newNode)
          }
        //当newNode.key &amp;gt;= node.key向右查找
/*-----------------------分支2:向右查找--------------------------*/        
        }else{
          //情况1：node无右子节点，直接插入
/*-----------------------分支2.1--------------------------*/ 
          if(node.right == null){
            node.right == newNode
          //情况2：node有右子节点，依然递归调用insertNode(),直到遇到无右子节点成功插入newNode为止
/*-----------------------分支2.2--------------------------*/ 
          }else{
            this.insertNode(node.right, newNode)
          }
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
为了更好理解以下列二叉搜索树为例：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614431949845.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
想要上述的二叉搜索树（蓝色）中插入数据10：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先把key = 10 传入insert方法，由于存在根节点 9，所以直接调用insetNode方法，传入的参数：node = 9，newNode = 10；&lt;/li&gt;
&lt;li&gt;由于10 &amp;gt; 9，进入分支2，向右查找适合插入的位置；&lt;/li&gt;
&lt;li&gt;由于根节点 9 的右子节点存在且为 13 ，所以进入分支2.2，递归调用insertNode方法，传入的参数：node = 13，newNode = 10；&lt;/li&gt;
&lt;li&gt;由于 10 &amp;lt; 13 ，进入分支1，向左查找适合插入的位置；&lt;/li&gt;
&lt;li&gt;由于父节点 13 的左子节点存在且为11，所以进入分支1.2，递归调用insertNode方法，传入的参数：node = 11，newNode = 10；&lt;/li&gt;
&lt;li&gt;由于 10 &amp;lt; 11，进入分支1，向左查找适合插入的位置；&lt;/li&gt;
&lt;li&gt;由于父节点 11 的左子节点不存在，所以进入分支1.1，成功插入节点 10 。由于不符合分支1.2的条件所以不会继续调用insertNode方法，递归停止。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试代码
    //1.创建BinarySearchTree
    let bst = new BinarySearchTree()

    //2.插入数据
    bst.insert(11);
    bst.insert(7);
    bst.insert(15);
    bst.insert(5);
    bst.insert(9);
	console.log(bst);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应得到下图所示的二叉搜索树：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432007528.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试结果&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432014572.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;42遍历数据&#34;&gt;4.2.遍历数据&lt;/h2&gt;
&lt;p&gt;这里所说的树的遍历不仅仅针对二叉搜索树，而是适用于所有的二叉树。由于树结构不是线性结构，所以遍历方式有多种选择，常见的三种二叉树遍历方式为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先序遍历；&lt;/li&gt;
&lt;li&gt;中序遍历；&lt;/li&gt;
&lt;li&gt;后序遍历；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有层序遍历，使用较少。&lt;/p&gt;
&lt;h3 id=&#34;421先序遍历&#34;&gt;4.2.1.先序遍历&lt;/h3&gt;
&lt;p&gt;先序遍历的过程为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，遍历根节点；&lt;/li&gt;
&lt;li&gt;然后，遍历其左子树；&lt;/li&gt;
&lt;li&gt;最后，遍历其右子树；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432186175.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如上图所示，二叉树的节点遍历顺序为：A -&amp;gt; B -&amp;gt; D -&amp;gt; H -&amp;gt; I -&amp;gt; E -&amp;gt; C -&amp;gt; F -&amp;gt; G。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	  //先序遍历
      //掺入一个handler函数方便之后对得到的key进行处理
      BinarySearchTree.prototype.preOrderTraversal = function(handler){
        this.preOrderTraversalNode(this.root, handler)
      }

      //封装内部方法，对某个节点进行遍历
      BinarySearchTree.prototype.preOrderTraversalNode = function(node,handler){
        if (node != null) {
          //1.处理经过的节点
          handler(node.key)
/*----------------------递归1----------------------------*/
          //2.遍历左子树中的节点
          this.preOrderTraversalNode(node.left, handler)
/*----------------------递归2----------------------------*/
          //3.遍历右子树中的节点
          this.preOrderTraversalNode(node.right, handler)
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
以遍历以下二叉搜索树为例：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432234410.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先调用preOrderTraversal方法，在方法里再调用preOrderTraversalNode方法用于遍历二叉搜索树。在preOrderTraversalNode方法中，递归1负责遍历左子节点，递归2负责遍历右子节点。先执行递归1，执行过程如下图所示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;记：preOrderTraversalNode() 为 A()&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432256706.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看到一共递归调用了4次方法A，分别传入11、7、5、3，最后遇到null不满足 node != null 条件结束递归1；注意此时只是执行完最开始的递归1，并没有执行递归2，并且递归1执行到null停止后要一层层地往上返回，按顺序将调用的函数压出函数调用栈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于函数调用栈：之前的四次递归共把4个函数压入了函数调用栈，现在递归执行完了一层层地把函数压出栈。&lt;/p&gt;
&lt;p&gt;值得注意的是：每一层函数都只是执行完了递归1，当返回到该层函数时，比如A（3）要继续执行递归2遍历二叉搜索树中的右子节点；&lt;/p&gt;
&lt;p&gt;在执行递归2的过程中会不断调用方法A，并依次执行递归1和递归2，以此类推直到遇到null不满足 node != null 条件为止，才停止递归并一层层返回，如此循环。同理A（5）层、A（7）层、A（11）层都要经历上述循环，直到将二叉搜索树中的节点全部遍历完为止。&lt;/p&gt;
&lt;p&gt;具体过程如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432285791.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试代码
    //1.创建BinarySearchTree
    let bst = new BinarySearchTree()

    //2.插入数据
    bst.insert(11);
    bst.insert(7);
    bst.insert(15);
    bst.insert(5);
    bst.insert(3);
    bst.insert(9);
    bst.insert(8);
    bst.insert(10);
    bst.insert(13);
    bst.insert(12);
    bst.insert(14);
    bst.insert(20);
    bst.insert(18);
    bst.insert(25);
    bst.insert(6);
    
    //3.测试遍历
    let resultString = &amp;quot;&amp;quot;
    //掺入处理节点值的处理函数
    bst.preOrderTraversal(function(key){
      resultString += key + &amp;quot;-&amp;gt;&amp;quot;
    })
    alert(resultString)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应输出这样的顺序：11 -&amp;gt; 7 -&amp;gt; 5 -&amp;gt; 3 -&amp;gt; 6 -&amp;gt; 9 -&amp;gt; 8 -&amp;gt; 10 -&amp;gt; 15 -&amp;gt; 13 -&amp;gt;12 -&amp;gt; 14 -&amp;gt; 20 -&amp;gt; 18 -&amp;gt; 25 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432317782.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;422中序遍历&#34;&gt;4.2.2.中序遍历&lt;/h3&gt;
&lt;p&gt;实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，遍历其左子树；&lt;/li&gt;
&lt;li&gt;然后，遍历根（父）节点；&lt;/li&gt;
&lt;li&gt;最后，遍历其右子树；&lt;br&gt;
&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    //中序遍历
      BinarySearchTree.prototype.midOrderTraversal = function(handler){
        this.midOrderTraversalNode(this.root, handler)
      }

      BinarySearchTree.prototype.midOrderTraversalNode = function(node, handler){
        if (node != null) {
          //1.遍历左子树中的节点
          this.midOrderTraversalNode(node.left, handler)
          
          //2.处理节点
          handler(node.key)

          //3.遍历右子树中的节点
          this.midOrderTraversalNode(node.right, handler)
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
遍历的顺序应如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432386478.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先调用midOrderTraversal方法，在方法里再调用midOrderTraversalNode方法用于遍历二叉搜索树。先使用递归1遍历左子树中的节点；然后，处理父节点；最后，遍历右子树中的节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     //测试代码
    //1.创建BinarySearchTree
    let bst = new BinarySearchTree()

    //2.插入数据
    bst.insert(11);
    bst.insert(7);
    bst.insert(15);
    bst.insert(5);
    bst.insert(3);
    bst.insert(9);
    bst.insert(8);
    bst.insert(10);
    bst.insert(13);
    bst.insert(12);
    bst.insert(14);
    bst.insert(20);
    bst.insert(18);
    bst.insert(25);
    bst.insert(6);	
    
    //3.测试中序遍历
    let resultString2 =&amp;quot;&amp;quot;
    bst.midOrderTraversal(function(key){
      resultString2 += key + &amp;quot;-&amp;gt;&amp;quot;
    })
    alert(resultString2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出节点的顺序应为：3 -&amp;gt; 5 -&amp;gt; 6 -&amp;gt; 7 -&amp;gt; 8 -&amp;gt; 9 -&amp;gt; 10 -&amp;gt; 11 -&amp;gt; 12 -&amp;gt; 13 -&amp;gt; 14 -&amp;gt; 15 -&amp;gt; 18 -&amp;gt; 25-&amp;gt; 20 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432578638.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;423后续遍历&#34;&gt;4.2.3.后续遍历&lt;/h3&gt;
&lt;p&gt;实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，遍历其左子树；&lt;/li&gt;
&lt;li&gt;然后，遍历其右子树；&lt;/li&gt;
&lt;li&gt;最后，遍历根（父）节点；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //后序遍历
      BinarySearchTree.prototype.postOrderTraversal = function(handler){
        this.postOrderTraversalNode(this.root, handler)
      }

      BinarySearchTree.prototype.postOrderTraversalNode = function(node, handler){
        if (node != null) {
          //1.遍历左子树中的节点
          this.postOrderTraversalNode(node.left, handler)
          
          //2.遍历右子树中的节点
          this.postOrderTraversalNode(node.right, handler)

          //3.处理节点
          handler(node.key)
        }
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
遍历的顺序应如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432643528.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先调用postOrderTraversal方法，在方法里再调用postOrderTraversalNode方法用于遍历二叉搜索树。先使用递归1遍历左子树中的节点；然后，遍历右子树中的节点；最后，处理父节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试代码
    //1.创建BinarySearchTree
    let bst = new BinarySearchTree()

    //2.插入数据
    bst.insert(11);
    bst.insert(7);
    bst.insert(15);
    bst.insert(5);
    bst.insert(3);
    bst.insert(9);
    bst.insert(8);
    bst.insert(10);
    bst.insert(13);
    bst.insert(12);
    bst.insert(14);
    bst.insert(20);
    bst.insert(18);
    bst.insert(25);
    bst.insert(6);
    
    //3.测试后序遍历
    let resultString3 =&amp;quot;&amp;quot;
    bst.postOrderTraversal(function(key){
      resultString3 += key + &amp;quot;-&amp;gt;&amp;quot;
    })
    alert(resultString3)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出节点的顺序应为：3 -&amp;gt; 6 -&amp;gt; 5 -&amp;gt; 8 -&amp;gt; 10 -&amp;gt; 9 -&amp;gt; 7 -&amp;gt; 12 -&amp;gt; 14 -&amp;gt; 13 -&amp;gt; 18 -&amp;gt; 25 -&amp;gt; 20 -&amp;gt; 15 -&amp;gt; 11 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432682849.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：以遍历根（父）节点的顺序来区分三种遍历方式。比如：先序遍历先遍历根节点、中序遍历第二遍历根节点、后续遍历最后遍历根节点。&lt;/p&gt;
&lt;h2 id=&#34;43查找数据&#34;&gt;4.3.查找数据&lt;/h2&gt;
&lt;h3 id=&#34;431查找最大值最小值&#34;&gt;4.3.1.查找最大值&amp;amp;最小值&lt;/h3&gt;
&lt;p&gt;在二叉搜索树中查找最值非常简单，最小值在二叉搜索树的最左边，最大值在二叉搜索树的最右边。只需要一直向左/右查找就能得到最值，如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432719664.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //寻找最大值
      BinarySearchTree.prototype.max = function () {
        //1.获取根节点
        let node = this.root
        //2.定义key保存节点值
        let key = null
        //3.依次向右不断查找，直到节点为null
        while (node != null) {
          key = node.key
          node = node.right
        }
        return key
      }

      //寻找最小值
      BinarySearchTree.prototype.min = function(){
         //1.获取根节点
         let node = this.root
        //2.定义key保存节点值
        let key = null
        //3.依次向左不断查找，直到节点为null
        while (node != null) {
          key = node.key
          node = node.left
        }
        return key
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试代码
    //1.创建BinarySearchTree
    let bst = new BinarySearchTree()

    //2.插入数据
    bst.insert(11);
    bst.insert(7);
    bst.insert(15);
    bst.insert(5);
    bst.insert(3);
    bst.insert(9);
    bst.insert(8);
    bst.insert(10);
    bst.insert(13);
    bst.insert(12);
    bst.insert(14);
    bst.insert(20);
    bst.insert(18);
    bst.insert(25);
    bst.insert(6);
    
    //4.测试最值
    console.log(bst.max());
    console.log(bst.min());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432766498.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;432查找特定值&#34;&gt;4.3.2.查找特定值&lt;/h3&gt;
&lt;p&gt;查找二叉搜索树当中的特定值效率也非常高。只需要从根节点开始将需要查找节点的key值与之比较，若&lt;strong&gt;node.key &amp;lt; root&lt;/strong&gt;则向左查找，若&lt;strong&gt;node.key &amp;gt; root&lt;/strong&gt;就向右查找，直到找到或查找到null为止。这里可以使用递归实现，也可以采用循环来实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //查找特定的key
      BinarySearchTree.prototype.search = function(key){
        //1.获取根节点
        let node = this.root

        //2.循环搜索key
        while(node != null){
          if (key &amp;lt; node.key) {
            //小于根(父)节点就往左边找
            node = node.left
            //大于根(父)节点就往右边找
          }else if(key &amp;gt; node.key){
            node = node.right
          }else{
            return true
          }
        } 
        return false
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试代码
    //1.创建BinarySearchTree
    let bst = new BinarySearchTree()

    //2.插入数据
    bst.insert(11);
    bst.insert(7);
    bst.insert(15);
    bst.insert(5);
    bst.insert(3);
    bst.insert(9);
    bst.insert(8);
    bst.insert(10);
    bst.insert(13);
    bst.insert(12);
    bst.insert(14);
    bst.insert(20);
    bst.insert(18);
    bst.insert(25);
    bst.insert(6);
    
    //3.测试搜索方法
    console.log(bst.search(24));//false
    console.log(bst.search(13));//true
    console.log(bst.search(2));//false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432854806.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;44删除数据&#34;&gt;4.4.删除数据&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;第一步&lt;/strong&gt;：先找到需要删除的节点，若没找到，则不需要删除；&lt;/p&gt;
&lt;p&gt;首先定义变量current用于保存需要删除的节点、变量parent用于保存它的父节点、变量isLeftChild保存current是否为parent的左节点，这样方便之后删除节点时改变相关节点的指向。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现代码&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	    //1.1.定义变量
        let current = this.root
        let parent = null
        let isLeftChild = true

        //1.2.开始寻找删除的节点
        while (current.key != key) {
          parent = current
          // 小于则往左查找
          if (key &amp;lt; current.key) {
            isLeftChild = true
            current = current.left
          } else{
            isLeftChild = false
            current = current.rigth
          }
          //找到最后依然没有找到相等的节点
          if (current == null) {
            return false
          }
        }
        //结束while循环后：current.key = key
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第二步&lt;/strong&gt;：删除找到的指定节点，后分3种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除叶子节点；&lt;/li&gt;
&lt;li&gt;删除只有一个子节点的节点；&lt;/li&gt;
&lt;li&gt;删除有两个子节点的节点；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;441情况1没有子节点&#34;&gt;4.4.1.情况1：没有子节点&lt;/h3&gt;
&lt;p&gt;没有子节点时也有两种情况：&lt;/p&gt;
&lt;p&gt;当该叶子节点为根节点时，如下图所示，此时&lt;strong&gt;current == this.root&lt;/strong&gt;，直接通过：&lt;strong&gt;this.root = null&lt;/strong&gt;，删除根节点。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432946911.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当该叶子节点不为根节点时也有两种情况，如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614432958464.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
若current = 8，可以通过：parent.left = null，删除节点8；&lt;/p&gt;
&lt;p&gt;若current = 10，可以通过：parent.right = null，删除节点10；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     //情况1：删除的是叶子节点(没有子节点)
        if (current.left == null &amp;amp;&amp;amp; current.right ==null) {
          if (current == this.root) {
            this.root = null
          }else if(isLeftChild){
            parent.left = null
          }else {
            parent.right =null
          }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;442情况2有一个子节点&#34;&gt;4.4.2.情况2：有一个子节点&lt;/h3&gt;
&lt;p&gt;有六种情况分别是：&lt;/p&gt;
&lt;p&gt;当current存在左子节点时（current.right == null）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：current为根节点（current == this.root），如节点11，此时通过：this.root = current.left，删除根节点11；&lt;/li&gt;
&lt;li&gt;情况2：current为父节点parent的左子节点（isLeftChild == true），如节点5，此时通过：parent.left = current.left，删除节点5；&lt;/li&gt;
&lt;li&gt;情况3：current为父节点parent的右子节点（isLeftChild == false），如节点9，此时通过：parent.right = current.left，删除节点9；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614433008524.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当current存在右子节点时（current.left = null）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况4：current为根节点（current == this.root），如节点11，此时通过：this.root = current.right，删除根节点11。&lt;/li&gt;
&lt;li&gt;情况5：current为父节点parent的左子节点（isLeftChild == true），如节点5，此时通过：parent.left = current.right，删除节点5；&lt;/li&gt;
&lt;li&gt;情况6：current为父节点parent的右子节点（isLeftChild == false），如节点9，此时通过：parent.right = current.right，删除节点9；&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614433035143.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;实现代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        //情况2：删除的节点有一个子节点
        //当current存在左子节点时
        else if(current.right == null){
            if (current == this.root) {
              this.root = current.left
            } else if(isLeftChild) {
                parent.left = current.left
            } else{
                parent.right = current.left
            }
        //当current存在右子节点时
      } else if(current.left == null){
            if (current == this.root) {
              this.root = current.rigth
            } else if(isLeftChild) {
                parent.left = current.right
            } else{
                parent.right = current.right
            } 
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;443情况3有两个子节点&#34;&gt;4.4.3.情况3：有两个子节点&lt;/h3&gt;
&lt;p&gt;这种情况&lt;strong&gt;十分复杂&lt;/strong&gt;，首先依据以下二叉搜索树，讨论这样的问题：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614433090866.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;删除节点9&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在保证删除节点9后原二叉树仍为二叉搜索树的前提下，有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方式1：从节点9的左子树中选择一合适的节点替代节点9，可知节点8符合要求；&lt;/li&gt;
&lt;li&gt;方式2：从节点9的右子树中选择一合适的节点替代节点9，可知节点10符合要求；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614433110249.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;删除节点7&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在保证删除节点7后原二叉树仍为二叉搜索树的前提下，也有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方式1：从节点7的左子树中选择一合适的节点替代节点7，可知节点5符合要求；&lt;/li&gt;
&lt;li&gt;方式2：从节点7的右子树中选择一合适的节点替代节点7，可知节点8符合要求；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614433138554.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;删除节点15&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在保证删除节点15后原树二叉树仍为二叉搜索树的前提下，同样有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方式1：从节点15的左子树中选择一合适的节点替代节点15，可知节点14符合要求；&lt;/li&gt;
&lt;li&gt;方式2：从节点15的右子树中选择一合适的节点替代节点15，可知节点18符合要求；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614433162474.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相信你已经发现其中的规律了！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规律总结&lt;/strong&gt;：如果要删除的节点有两个子节点，甚至子节点还有子节点，这种情况下需要从要删除节点&lt;strong&gt;下面的子节点中找到一个合适的节点&lt;/strong&gt;，来替换当前的节点。&lt;/p&gt;
&lt;p&gt;若用current表示需要删除的节点，则合适的节点指的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;current左子树中比current&lt;strong&gt;小一点点的节点&lt;/strong&gt;，即current&lt;strong&gt;左子树&lt;/strong&gt;中的&lt;strong&gt;最大值&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;current右子树中比current&lt;strong&gt;大一点点的节点&lt;/strong&gt;，即current&lt;strong&gt;右子树&lt;/strong&gt;中的&lt;strong&gt;最小值&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;前驱&amp;amp;后继&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在二叉搜索树中，这两个特殊的节点有特殊的名字：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比current小一点点的节点，称为current节点的&lt;strong&gt;前驱&lt;/strong&gt;。比如下图中的节点5就是节点7的前驱；&lt;/li&gt;
&lt;li&gt;比current大一点点的节点，称为current节点的&lt;strong&gt;后继&lt;/strong&gt;。比如下图中的节点8就是节点7的后继；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614433240999.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查找需要被删除的节点current的后继时，需要在current的&lt;strong&gt;右子树&lt;/strong&gt;中查找&lt;strong&gt;最小值&lt;/strong&gt;，即在current的&lt;strong&gt;右子树&lt;/strong&gt;中一直&lt;strong&gt;向左遍历&lt;/strong&gt;查找；&lt;/li&gt;
&lt;li&gt;查找前驱时，则需要在current的&lt;strong&gt;左子树&lt;/strong&gt;中查找&lt;strong&gt;最大值&lt;/strong&gt;，即在current的&lt;strong&gt;左子树&lt;/strong&gt;中一直&lt;strong&gt;向右遍历&lt;/strong&gt;查找。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面只讨论查找current后继的情况，查找前驱的原理相同，这里暂不讨论。&lt;/p&gt;
&lt;h3 id=&#34;444完整实现&#34;&gt;4.4.4.完整实现&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;    //删除节点
      BinarySearchTree.prototype.remove = function(key){
/*------------------------------1.寻找要删除的节点---------------------------------*/
        //1.1.定义变量current保存删除的节点，parent保存它的父节点。isLeftChild保存current是否为parent的左节点
        let current = this.root
        let parent = null
        let isLeftChild = true

        //1.2.开始寻找删除的节点
        while (current.key != key) {
          parent = current
          // 小于则往左查找
          if (key &amp;lt; current.key) {
            isLeftChild = true
            current = current.left
          } else{
            isLeftChild = false
            current = current.right
          }
          //找到最后依然没有找到相等的节点
          if (current == null) {
            return false
          }
        }
        //结束while循环后：current.key = key

/*------------------------------2.根据对应情况删除节点------------------------------*/
        //情况1：删除的是叶子节点(没有子节点)
        if (current.left == null &amp;amp;&amp;amp; current.right ==null) {
          if (current == this.root) {
            this.root = null
          }else if(isLeftChild){
            parent.left = null
          }else {
            parent.right =null
          }
        }
        //情况2：删除的节点有一个子节点
        //当current存在左子节点时
        else if(current.right == null){
            if (current == this.root) {
              this.root = current.left
            } else if(isLeftChild) {
                parent.left = current.left
            } else{
                parent.right = current.left
            }
        //当current存在右子节点时
      } else if(current.left == null){
            if (current == this.root) {
              this.root = current.right
            } else if(isLeftChild) {
                parent.left = current.right
            } else{
                parent.right = current.right
            } 
      }
        //情况3：删除的节点有两个子节点
        else{
          //1.获取后继节点
          let successor = this.getSuccessor(current)

          //2.判断是否根节点
          if (current == this.root) {
            this.root = successor
          }else if (isLeftChild){
            parent.left = successor
          }else{
            parent.right = successor
          }

          //3.将后继的左子节点改为被删除节点的左子节点
          successor.left = current.left
        }
      }

      //封装查找后继的方法
      BinarySearchTree.prototype.getSuccessor = function(delNode){
        //1.定义变量,保存找到的后继
        let successor = delNode
        let current = delNode.right
        let successorParent = delNode

        //2.循环查找current的右子树节点
        while(current != null){
          successorParent = successor
          successor = current
          current = current.left
        }

        //3.判断寻找到的后继节点是否直接就是删除节点的right节点
        if(successor != delNode.right){
          successorParent.left = successor.right
          successor.right = delNode.right 
        }
        return successor
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试代码
    //1.创建BinarySearchTree
    let bst = new BinarySearchTree()

    //2.插入数据
    bst.insert(11);
    bst.insert(7);
    bst.insert(15);
    bst.insert(5);
    bst.insert(3);
    bst.insert(9);
    bst.insert(8);
    bst.insert(10);
    bst.insert(13);
    bst.insert(12);
    bst.insert(14);
    bst.insert(20);
    bst.insert(18);
    bst.insert(25);
    bst.insert(6);
    bst.insert(19);
    
   //3.测试删除代码
    //删除没有子节点的节点
    bst.remove(3)
    bst.remove(8)
    bst.remove(10)

    //删除有一个子节点的节点
    bst.remove(5)
    bst.remove(19)

    //删除有两个子节点的节点
    bst.remove(9)
    bst.remove(7)
    bst.remove(15)

    //遍历二叉搜索树并输出
    let resultString = &amp;quot;&amp;quot;
    bst.midOrderTraversal(function(key){
      resultString += key + &amp;quot;-&amp;gt;&amp;quot;
    })
    alert(resultString)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614433417414.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可见三种情况的节点都被成功删除了。&lt;/p&gt;
&lt;h2 id=&#34;45二叉搜索树完整封装&#34;&gt;4.5.二叉搜索树完整封装&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;    //封装二叉搜索树
    function BinarySearchTree(){

      //节点内部类
      function Node(key){
        this.key = key
        this.left = null
        this.right = null
      }

      //属性
      this.root = null

      //方法
      //一.插入数据：insert方法:对外向用户暴露的方法
      BinarySearchTree.prototype.insert = function(key){
        //1.根据key创建节点
        let newNode = new Node(key)
          
        //2.判断根节点是否存在
        if (this.root == null) {
          this.root = newNode
          //根节点存在时
        }else {
          this.insertNode(this.root, newNode)
        }
      }

      //内部使用的insertNode方法:用于比较节点从左边插入还是右边插入
      BinarySearchTree.prototype.insertNode = function(node, newNode){
        //当newNode.key &amp;lt; node.key向左查找
        if(newNode.key &amp;lt; node.key){
          //情况1：node无左子节点，直接插入
          if (node.left == null) {
            node.left = newNode
          //情况2：node有左子节点，递归调用insertNode(),直到遇到无左子节点成功插入newNode后，不再符合该情况，也就不再调用insertNode()，递归停止。
          }else{
            this.insertNode(node.left, newNode)
          }
        //当newNode.key &amp;gt;= node.key向右查找
        }else{
          //情况1：node无右子节点，直接插入
          if(node.right == null){
            node.right = newNode
          //情况2：node有右子节点，依然递归调用insertNode(),直到遇到无右子节点成功插入newNode为止
          }else{
            this.insertNode(node.right, newNode)
          }
        }
      }

      //二.树的遍历
      //1.先序遍历
      //掺入一个handler函数对得到的key进行处理
      BinarySearchTree.prototype.preOrderTraversal = function(handler){
        this.preOrderTraversalNode(this.root, handler)
      }

      //封装内部方法，对某个节点进行遍历
      BinarySearchTree.prototype.preOrderTraversalNode = function(node,handler){
        if (node != null) {
          //1.处理经过的节点
          handler(node.key)

          //2.遍历经过节点的左子节点
          this.preOrderTraversalNode(node.left, handler)

          //3.遍历经过节点的右子节点
          this.preOrderTraversalNode(node.right, handler)
        }
      }

      //2.中序遍历
      BinarySearchTree.prototype.midOrderTraversal = function(handler){
        this.midOrderTraversalNode(this.root, handler)
      }

      BinarySearchTree.prototype.midOrderTraversalNode = function(node, handler){
        if (node != null) {
          //1.遍历左子树中的节点
          this.midOrderTraversalNode(node.left, handler)
          
          //2.处理节点
          handler(node.key)

          //3.遍历右子树中的节点
          this.midOrderTraversalNode(node.right, handler)
        }
      }

      //3.后序遍历
      BinarySearchTree.prototype.postOrderTraversal = function(handler){
        this.postOrderTraversalNode(this.root, handler)
      }

      BinarySearchTree.prototype.postOrderTraversalNode = function(node, handler){
        if (node != null) {
          //1.遍历左子树中的节点
          this.postOrderTraversalNode(node.left, handler)
          
          //2.遍历右子树中的节点
          this.postOrderTraversalNode(node.right, handler)

          //3.处理节点
          handler(node.key)
        }
      }

      //三.寻找最值
      //寻找最大值
      BinarySearchTree.prototype.max = function () {
        //1.获取根节点
        let node = this.root
        //2.定义key保存节点值
        let key = null
        //3.依次向右不断查找，直到节点为null
        while (node != null) {
          key = node.key
          node = node.right
        }
        return key
      }

      //寻找最小值
      BinarySearchTree.prototype.min = function(){
         //1.获取根节点
         let node = this.root
        //2.定义key保存节点值
        let key = null
        //3.依次向左不断查找，直到节点为null
        while (node != null) {
          key = node.key
          node = node.left
        }
        return key
      }

      //查找特定的key
      BinarySearchTree.prototype.search = function(key){
        //1.获取根节点
        let node = this.root

        //2.循环搜索key
        while(node != null){
          if (key &amp;lt; node.key) {
            //小于根(父)节点就往左边找
            node = node.left
            //大于根(父)节点就往右边找
          }else if(key &amp;gt; node.key){
            node = node.right
          }else{
            return true
          }
        } 
        return false
      }

      //四.删除节点
      BinarySearchTree.prototype.remove = function(key){
/*------------------------------1.寻找要删除的节点---------------------------------*/
        //1.1.定义变量current保存删除的节点，parent保存它的父节点。isLeftChild保存current是否为parent的左节点
        let current = this.root
        let parent = null
        let isLeftChild = true

        //1.2.开始寻找删除的节点
        while (current.key != key) {
          parent = current
          // 小于则往左查找
          if (key &amp;lt; current.key) {
            isLeftChild = true
            current = current.left
          } else{
            isLeftChild = false
            current = current.right
          }
          //找到最后依然没有找到相等的节点
          if (current == null) {
            return false
          }
        }
        //结束while循环后：current.key = key

/*------------------------------2.根据对应情况删除节点------------------------------*/
        //情况1：删除的是叶子节点(没有子节点)
        if (current.left == null &amp;amp;&amp;amp; current.right ==null) {
          if (current == this.root) {
            this.root = null
          }else if(isLeftChild){
            parent.left = null
          }else {
            parent.right =null
          }
        }
        //情况2：删除的节点有一个子节点
        //当current存在左子节点时
        else if(current.right == null){
            if (current == this.root) {
              this.root = current.left
            } else if(isLeftChild) {
                parent.left = current.left
            } else{
                parent.right = current.left
            }
        //当current存在右子节点时
      } else if(current.left == null){
            if (current == this.root) {
              this.root = current.right
            } else if(isLeftChild) {
                parent.left = current.right
            } else{
                parent.right = current.right
            } 
      }
        //情况3：删除的节点有两个子节点
        else{
          //1.获取后继节点
          let successor = this.getSuccessor(current)

          //2.判断是否根节点
          if (current == this.root) {
            this.root = successor
          }else if (isLeftChild){
            parent.left = successor
          }else{
            parent.right = successor
          }

          //3.将后继的左子节点改为被删除节点的左子节点
          successor.left = current.left
        }
      }

      //封装查找后继的方法
      BinarySearchTree.prototype.getSuccessor = function(delNode){
        //1.定义变量,保存找到的后继
        let successor = delNode
        let current = delNode.right
        let successorParent = delNode

        //2.循环查找current的右子树节点
        while(current != null){
          successorParent = successor
          successor = current
          current = current.left
        }

        //3.判断寻找到的后继节点是否直接就是删除节点的right节点
        if(successor != delNode.right){
          successorParent.left = successor.right
          successor.right = delNode.right 
        }
        return successor
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5平衡树&#34;&gt;5.平衡树&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;二叉搜索树的缺陷：&lt;/strong&gt;&lt;br&gt;
当插入的数据是有序的数据，就会造成二叉搜索树的深度过大。比如原二叉搜索树右 11 7 15 组成，如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614433630544.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当插入一组有序数据：6 5 4 3 2就会变成深度过大的搜索二叉树，会严重影响二叉搜索树的性能。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614433639468.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非平衡树&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比较好的二叉搜索树，它的数据应该是&lt;strong&gt;左右均匀分布&lt;/strong&gt;的；&lt;/li&gt;
&lt;li&gt;但是插入&lt;strong&gt;连续数据&lt;/strong&gt;后，二叉搜索树中的数据分布就变得&lt;strong&gt;不均匀了&lt;/strong&gt;，我们称这种树为&lt;strong&gt;非平衡树&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;对于一棵&lt;strong&gt;平衡二叉树&lt;/strong&gt;来说，插入/查找等操作的效率是&lt;strong&gt;O（logN）&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;而对于一棵&lt;strong&gt;非平衡二叉树&lt;/strong&gt;来说，相当于编写了一个链表，查找效率变成了&lt;strong&gt;O（N）&lt;/strong&gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;树的平衡性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了能以&lt;strong&gt;较快的时间O（logN）&lt;strong&gt;来操作一棵树，我们需要&lt;/strong&gt;保证树总是平衡&lt;/strong&gt;的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;起码大部分是平衡的，此时的时间复杂度也是接近O（logN）的；&lt;/li&gt;
&lt;li&gt;这就要求树中&lt;strong&gt;每个节点左边的子孙节点&lt;/strong&gt;的个数，应该尽可能地等于&lt;strong&gt;右边的子孙节点&lt;/strong&gt;的个数；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;常见的平衡树&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;AVL树&lt;/strong&gt;：是最早的一种平衡树，它通过在每个节点多存储一个额外的数据来保持树的平衡。由于AVL树是平衡树，所以它的时间复杂度也是O（logN）。但是它的整体效率不如红黑树，开发中比较少用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;红黑树&lt;/strong&gt;：同样通过一些&lt;strong&gt;特性&lt;/strong&gt;来保持树的平衡，时间复杂度也是O（logN）。进行插入/删除等操作时，性能优于AVL树，所以平衡树的应用基本都是红黑树。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;6-字典树&#34;&gt;6. 字典树&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;字典树适合查找，后缀树适合存储&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-定义&#34;&gt;1. 定义&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;定义：Trie树，即字典树，又称单词查找树或键树。是一种用于快速检索的多叉树结构。
    Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。
优点：最大限度地减少无谓的字符串比较。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们给定字符串集合为{b abc abd bcd abcd efg hii}，那么这个字符串的字典树为：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619572990429.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;对于一颗字典树来说，应该具有以下性质：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619573241644.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
第二条性质中的到某个结点，就是指到红色结点。&lt;/p&gt;
&lt;h2 id=&#34;2-字典树的构建&#34;&gt;2. 字典树的构建&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619573363448.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
现在给出了，许多的字符串，我们从第一个字符串CAI开始构建。首先构建根节点，其次构建出CAI三个结点&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619573381140.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
现在构建字符串CAO因为CA已经存在，所以遍历到A，发现O结点并不存在，生成O结点。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619573403573.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
以此类推，最后生成的字典树，如上图所示。这个构建过程，每一次都相当于遍历了一个字符串的长度。&lt;br&gt;
假如有n个字符串，那么它的&lt;code&gt;时间复杂度&lt;/code&gt;就是，&lt;code&gt;n乘上字符串的平均长度&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619573434882.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
对于字典树，在空间上的花费为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;空间花费：平均单词长度*结点长度*单词数
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-字典树的查询&#34;&gt;3. 字典树的查询&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619573574154.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先我们根据给出的单词，构建出了相应的字典树。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619573596240.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
现在，我们要对inn这个单词进行查询，当然是从根节点先开始。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619573882704.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
按照结点进行查询，最后可以找到inn这个字符串。那么它的时间复杂度就是这个字符串的长度O(len)。&lt;/p&gt;
&lt;h2 id=&#34;4-字典树的插入&#34;&gt;4. 字典树的插入&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619573911453.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
现在我们要插入新的字符串atm，那应该怎么做呢？&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619573929269.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在走到t结点时，发现没有m结点，所以构造出m结点，并变为红色。&lt;/p&gt;
&lt;h2 id=&#34;5-字典树的删除&#34;&gt;5. 字典树的删除&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619573951867.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
现在我们要删除字典树中的ant字符串，当然是从根节点开始去做一个查询。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619573969658.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
最后找到，结点t并且n结点也并没有其他分支，所以在删除时，会将n-&amp;gt;t全部删除。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619573985600.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
最后结果如图所示，时间复杂度也为O(len)。&lt;/p&gt;
&lt;h2 id=&#34;6-字典树的应用&#34;&gt;6. 字典树的应用&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619574013354.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;7-后缀树&#34;&gt;7. 后缀树&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;定义：后缀树是一棵压缩字典树，其次，后缀树中存储的关键词为所有的后缀。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1-后缀树的构建&#34;&gt;1. 后缀树的构建&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619574786201.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;规则1：遇到叶子节点时只需往叶子所在的边上面的字符串后面插入字符就好了，不用改变树的结构；
规则2：遇到内部节点的时候，先看看插入的字符是否出现在显式节点后紧跟的字符
      集合中,如果插入的字符出现在集合中，那么什么也不要做（是指不用改变构），
      因为已经存在了；如果没有出现，在显式节点后面增加一个叶子，边上标注为这个字符。
规则3：遇到隐式节点时，先看看隐式节点后面的字符是不是当前将要插入的字符，
      如果有则不用管了，没有则需要将当前隐式节点变为显式节点，再增加新叶子。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-后缀树的作用&#34;&gt;2. 后缀树的作用&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1619575214408.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av86801505?from=search&amp;amp;seid=4967761411915016256&#34;&gt;参考资料：JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现树结构</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/javascript-shi-xian-ha-xi-biao/"" data-c="
          &lt;h1 id=&#34;1哈希表简介&#34;&gt;1.哈希表简介&lt;/h1&gt;
&lt;h2 id=&#34;11认识哈希表&#34;&gt;1.1.认识哈希表&lt;/h2&gt;
&lt;p&gt;哈希表通常是基于&lt;strong&gt;数组&lt;/strong&gt;实现的，但是相对于数组，它存在更多优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哈希表可以提供非常快速的&lt;strong&gt;插入-删除-查找操作&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;无论多少数据，插入和删除值都只需要非常短的时间，即O(1)的时间级。实际上，只需要&lt;strong&gt;几个机器指令&lt;/strong&gt;即可完成；&lt;/li&gt;
&lt;li&gt;哈希表的速度比&lt;strong&gt;树还要快&lt;/strong&gt;，基本可以瞬间查找到想要的元素。但是相对于树来说编码要简单得多。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;哈希表同样存在不足之处：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哈希表中的数据是&lt;strong&gt;没有顺序&lt;/strong&gt;的，所以不能以一种固定的方式（比如从小到大 ）来遍历其中的元素。&lt;/li&gt;
&lt;li&gt;通常情况下，哈希表中的key是&lt;strong&gt;不允许重复&lt;/strong&gt;的，不能放置相同的key，用于保存不同的元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;哈希表是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哈希表并不好理解，不像数组、链表和树等可通过图形的形式表示其结构和原理。&lt;/li&gt;
&lt;li&gt;哈希表的结构就是&lt;strong&gt;数组&lt;/strong&gt;，但它神奇之处在于对&lt;strong&gt;下标值的一种变换&lt;/strong&gt;，这种变换我们可以称之为&lt;strong&gt;哈希函数&lt;/strong&gt;，通过哈希函数可以获取&lt;strong&gt;HashCode&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;通过以下案例了解哈希表：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;案例一：公司想要存储1000个人的信息，每一个工号对应一个员工的信息。若使用数组，增删数据时比较麻烦；使用链表，获取数据时比较麻烦。有没有一种数据结构，能把某一员工的姓名转换为它对应的工号，再根据工号查找该员工的完整信息呢？没错此时就可以使用哈希表的哈希函数来实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;案例二：存储联系人和对应的电话号码：当要查找张三（比如）的号码时，若使用数组：由于不知道存储张三数据对象的下标值，所以查找起来十分麻烦，使用链表时也同样麻烦。而使用哈希表就能通过哈希函数把张三这个名称转换为它对应的下标值，再通过下标值查找效率就非常高了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是说：哈希表最后还是基于数据来实现的，只不过哈希表能够通过哈希函数把字符串转化为对应的&lt;strong&gt;下标值&lt;/strong&gt;，建立字符串和下标值的对应关系。&lt;/p&gt;
&lt;h2 id=&#34;12哈希化的方式&#34;&gt;1.2.哈希化的方式&lt;/h2&gt;
&lt;p&gt;为了把字符串转化为对应的下标值，需要有一套编码系统，为了方便理解我们创建这样一套编码系统：比如&lt;strong&gt;a为1，b为2，c为3，以此类推z为26，空格为27（不考虑大写情况）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;有了编码系统后，将字母转化为数字也有很多种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方式一：数字相加。例如&lt;strong&gt;cats转化为数字&lt;/strong&gt;：3+1+20+19=43，那么就把43作为cats单词的下标值储存在数组中；&lt;br&gt;
但是这种方式会存在这样的问题：很多的单词按照该方式转化为数字后都是43，比如was。而在数组中&lt;strong&gt;一个下标值&lt;/strong&gt;只能&lt;strong&gt;储存一个数据&lt;/strong&gt;，所以该方式不合理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方式二：幂的连乘。我们平时使用的&lt;strong&gt;大于10的数字&lt;/strong&gt;，就是用&lt;strong&gt;幂的连乘&lt;/strong&gt;来表示它的唯一性的。比如： 6543=6 * 103 + 5 * 102 + 4 * 10 + 3；这样单词也可以用该种方式来表示：cats = 3 * 273 + 1 * 272 + 20 * 27 + 17 =60337;&lt;br&gt;
虽然该方式可以保证字符的唯一性，但是如果是较长的字符（如aaaaaaaaaa）所表示的数字就非常大，此时要求很大容量的数组，然而其中却有许多下标值指向的是无效的数据（比如不存在zxcvvv这样的单词），造成了数组空间的浪费。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;两种方案总结：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一种方案（让数字相加求和）产生的&lt;strong&gt;数组下标太少；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;第二种方案（与27的幂相乘求和）产生的&lt;strong&gt;数组下标又太多；&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在需要一种&lt;strong&gt;压缩方法&lt;/strong&gt;，把幂的连乘方案系统中得到的&lt;strong&gt;巨大整数范围&lt;/strong&gt;压缩到&lt;strong&gt;可接受的数组范围&lt;/strong&gt;中。可以通过取余操作来实现。虽然取余操作得到的结构也有可能重复，但是可以通过其他方式解决。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;哈希表的一些概念：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;哈希化&lt;/strong&gt;：将&lt;strong&gt;大数字&lt;/strong&gt;转化成&lt;strong&gt;数组范围内下标&lt;/strong&gt;的过程，称之为&lt;strong&gt;哈希化&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;哈希函数&lt;/strong&gt;：我们通常会将&lt;strong&gt;单词&lt;/strong&gt;转化成&lt;strong&gt;大数字&lt;/strong&gt;，把&lt;strong&gt;大数字&lt;/strong&gt;进行&lt;strong&gt;哈希化&lt;/strong&gt;的代码实现放在一个函数中，该函数就称为&lt;strong&gt;哈希函数&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;哈希表&lt;/strong&gt;：对最终数据插入的&lt;strong&gt;数组&lt;/strong&gt;进行整个&lt;strong&gt;结构的封装&lt;/strong&gt;，得到的就是&lt;strong&gt;哈希表&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;仍然需要解决的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哈希化过后的下标依然可能&lt;strong&gt;重复&lt;/strong&gt;，如何解决这个问题呢？这种情况称为&lt;strong&gt;冲突&lt;/strong&gt;，冲突是&lt;strong&gt;不可避免&lt;/strong&gt;的，我们只能&lt;strong&gt;解决冲突&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;13解决冲突的方法&#34;&gt;1.3.解决冲突的方法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;解决冲突常见的两种方案：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方案一：&lt;strong&gt;链地址法（拉链法）&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下图所示，我们将每一个数字都对&lt;strong&gt;10&lt;/strong&gt;进行取余操作，则余数的范围&lt;strong&gt;0~9&lt;/strong&gt;作为数组的下标值。并且，数组每一个下标值对应的位置存储的不再是一个数字了，而是存储由经过取余操作后得到相同余数的数字组成的&lt;strong&gt;数组&lt;/strong&gt;或&lt;strong&gt;链表&lt;/strong&gt;。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614344975950.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这样可以根据下标值获取到整个数组或链表，之后继续在数组或链表中查找就可以了。而且，产生冲突的元素一般不会太多。&lt;br&gt;
&lt;strong&gt;总结&lt;/strong&gt;：链地址法解决冲突的办法是&lt;strong&gt;每个数组单元&lt;/strong&gt;中存储的不再是&lt;strong&gt;单个数据&lt;/strong&gt;，而是一条&lt;strong&gt;链条&lt;/strong&gt;，这条链条常使用的数据结构为&lt;strong&gt;数组&lt;/strong&gt;或&lt;strong&gt;链表&lt;/strong&gt;，两种数据结构查找的效率相当（因为链条的元素一般不会太多）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方案二：&lt;strong&gt;开放地址法&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开放地址法的主要工作方式是&lt;strong&gt;寻找空白的单元格&lt;/strong&gt;来放置&lt;strong&gt;冲突&lt;/strong&gt;的数据项。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614345198909.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
根据探测空白单元格位置方式的不同，可分为三种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线性探测&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;二次探测&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;再哈希法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;14寻找空白单元格的方式&#34;&gt;1.4.寻找空白单元格的方式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;线性探测&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;当插入13时&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;经过哈希化（对10取余）之后得到的下标值index=3，但是该位置已经放置了数据33。而线性探测就是从&lt;strong&gt;index位置+1&lt;/strong&gt;开始向后一个一个来查找&lt;strong&gt;合适的位置&lt;/strong&gt;来放置13，所谓合适的位置指的是&lt;strong&gt;空的位置&lt;/strong&gt;，如上图中index=4的位置就是合适的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;当查询13时：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先13经过哈希化得到index=3，如果index=3的位置存放的数据与需要查询的数据13相同，就直接返回；&lt;/li&gt;
&lt;li&gt;不相同时，则线性查找，从&lt;strong&gt;index+1&lt;/strong&gt;位置开始一个一个位置地查找数据13；&lt;/li&gt;
&lt;li&gt;查询过程中不会遍历整个哈希表，只要查询到&lt;strong&gt;空位置，就停止&lt;/strong&gt;，因为插入13时不会跳过空位置去插入其他位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;当删除13时&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除操作和上述两种情况类似，但需要注意的是，删除一个数据项时，&lt;strong&gt;不能&lt;/strong&gt;将该位置下标的&lt;strong&gt;内容设置为null&lt;/strong&gt;，否则会&lt;strong&gt;影响到之后其他的查询操作&lt;/strong&gt;，因为一遇到为null的位置就会停止查找。&lt;/li&gt;
&lt;li&gt;通常&lt;strong&gt;删除一个位置的数据项&lt;/strong&gt;时，我们可以&lt;strong&gt;将它进行特殊处理&lt;/strong&gt;（比如设置为-1），这样在查找时遇到-1就知道要&lt;strong&gt;继续查找&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;线性探测存在的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性探测存在一个比较严重的问题，就是&lt;strong&gt;聚集&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;如哈希表中还没插入任何元素时，插入23、24、25、26、27，这就意味着下标值为3、4、5、6、7的位置都放置了数据，这种&lt;strong&gt;一连串填充单元&lt;/strong&gt;就称为&lt;strong&gt;聚集&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;聚集会影响哈希表的&lt;strong&gt;性能&lt;/strong&gt;，无论是插入/查询/删除都会影响；&lt;/li&gt;
&lt;li&gt;比如插入13时就会发现，连续的单元3~7都不允许插入数据，并且在插入的过程中需要经历多次这种情况。二次探测法可以解决该问题。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614345460679.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;二次探测&lt;/code&gt;&lt;br&gt;
上文所说的&lt;strong&gt;线性探测存在的问题&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果之前的数据是&lt;strong&gt;连续插入&lt;/strong&gt;的，那么新插入的一个数据可能需要&lt;strong&gt;探测很长的距离&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;二次探测是在线性探测的基础上进行了&lt;strong&gt;优化&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;线性探测&lt;/strong&gt;：我们可以看成是&lt;strong&gt;步长为1&lt;/strong&gt;的探测，比如从下表值x开始，那么线性探测就是按照下标值：x+1、x+2、x+3等依次探测；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;二次探测&lt;/strong&gt;：对步长进行了优化，比如从下标值x开始探测：x+12、x+22、x+33 。这样&lt;strong&gt;一次性探测比较长的距离&lt;/strong&gt;，避免了数据聚集带来的影响。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;二次探测存在的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当插入数据分布性较大的一组数据时，比如：13-163-63-3-213，这种情况会造成&lt;strong&gt;步长不一的一种聚集&lt;/strong&gt;（虽然这种情况出现的概率较线性探测的聚集要小），同样会影响性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;再哈希化&lt;/code&gt;&lt;br&gt;
在开放地址法中寻找空白单元格的最好的解决方式为&lt;strong&gt;再哈希化&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二次探测的步长是固定的：1，4，9，16依次类推；&lt;/li&gt;
&lt;li&gt;现在需要一种方法：产生一种&lt;strong&gt;依赖关键字(数据)的探测序列&lt;/strong&gt;，而不是每个关键字探测步长都一样；&lt;/li&gt;
&lt;li&gt;这样，&lt;strong&gt;不同的关键字&lt;/strong&gt;即使映射到&lt;strong&gt;相同的数组下标&lt;/strong&gt;，也可以使用&lt;strong&gt;不同的探测序列&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;再哈希法的做法为：把关键字用&lt;strong&gt;另一个&lt;/strong&gt;哈希函数，&lt;strong&gt;再做一次哈希化&lt;/strong&gt;，用这次哈希化的&lt;strong&gt;结果作为该关键字的步长&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;第二次哈希化需要满足以下两点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和&lt;strong&gt;第一个哈希函数不同&lt;/strong&gt;，不然哈希化后的结果仍是原来位置；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不能输出为0&lt;/strong&gt;，否则每次探测都是原地踏步的死循环；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;优秀的哈希函数：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;stepSize = constant - （key % constant）&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;其中constant是&lt;strong&gt;质数&lt;/strong&gt;，且小于数组的容量；&lt;/li&gt;
&lt;li&gt;例如：stepSize = 5 - （key % 5），满足需求，并且结果不可能为0；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;哈希化的效率&lt;/strong&gt;&lt;br&gt;
哈希表中执行插入和搜索操作效率是非常高的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果没有&lt;strong&gt;发生冲突&lt;/strong&gt;，那么效率就会更高；&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;发生冲突&lt;/strong&gt;，存取时间就依赖后来的探测长度；&lt;/li&gt;
&lt;li&gt;平均探测长度以及平均存取时间，取决于装填因子，随着&lt;strong&gt;装填因子&lt;/strong&gt;变大，探测长度会越来越长。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;理解概念&lt;strong&gt;装填因子&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;装填因子表示当前哈希表中已经&lt;strong&gt;包含的数据项&lt;/strong&gt;和&lt;strong&gt;整个哈希表长度&lt;/strong&gt;的&lt;strong&gt;比值&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;装填因子 = 总数据项 / 哈希表长度&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开放地址法的装填因子&lt;/strong&gt;最大为1，因为只有空白的单元才能放入元素；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链地址法的装填因子&lt;/strong&gt;可以&lt;strong&gt;大于1&lt;/strong&gt;，因为只要愿意，拉链法可以无限延伸下去；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;15不同探测方式性能的比较&#34;&gt;1.5.不同探测方式性能的比较&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线性探测&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，随着装填因子的增大，平均探测长度呈指数形式增长，性能较差。实际情况中，最好的装填因子取决于存储效率和速度之间的平衡，随着装填因子变小，存储效率下降，而速度上升。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614347865771.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;二次探测和再哈希化的性能&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二次探测和再哈希法性能相当，它们的性能比线性探测略好。由下图可知，随着装填因子的变大，平均探测长度呈指数形式增长，需要探测的次数也呈指数形式增长，性能不高。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614347917941.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;链地址法的性能&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到随着装填因子的增加，平均探测长度呈线性增长，较为平缓。在开发中使用链地址法较多，比如Java中的HashMap中使用的就是&lt;strong&gt;链地址法&lt;/strong&gt;。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614347946852.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;16优秀的哈希函数&#34;&gt;1.6.优秀的哈希函数&lt;/h2&gt;
&lt;p&gt;哈希表的优势在于它的速度，所以哈希函数不能采用消耗性能较高的复杂算法。提高速度的一个方法是在哈希函数中&lt;strong&gt;尽量减少乘法和除法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;性能高的哈希函数应具备以下两个优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;快速的计算&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;均匀的分布&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;快速计算&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;霍纳法则&lt;/strong&gt;：在中国霍纳法则也叫做&lt;strong&gt;秦久韶算法&lt;/strong&gt;，具体算法为：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614352364784.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
求多项式的值时，首先计算最内层括号内一次多项式的值，然后由内向外逐层计算一次多项式的值。这种算法把求n次多项式f(x)的值就转化为求n个一次多项式的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;变换之前：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;乘法次数：n（n+1）/2次；&lt;/li&gt;
&lt;li&gt;加法次数：n次；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;变换之前：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;乘法次数：n次；&lt;/li&gt;
&lt;li&gt;加法次数：n次；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果使用大O表示时间复杂度的话，直接从变换前的&lt;strong&gt;O(N2)&lt;strong&gt;降到了&lt;/strong&gt;O(N)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;均匀分布&lt;/code&gt;&lt;br&gt;
为了保证数据在哈希表中&lt;strong&gt;均匀分布&lt;/strong&gt;，当我们需要&lt;strong&gt;使用常量的地方&lt;/strong&gt;，尽量使用&lt;strong&gt;质数&lt;/strong&gt;；比如：哈希表的长度、N次幂的底数等。&lt;/p&gt;
&lt;p&gt;Java中的HashMap采用的是链地址法，哈希化采用的是公式为：&lt;strong&gt;index = HashCode（key）&amp;amp;（Length-1）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即将数据化为二进制进行&lt;strong&gt;与&lt;/strong&gt;运算，而不是取余运算。这样计算机直接运算二进制数据，效率更高。但是JavaScript在进行叫大数据的&lt;strong&gt;与&lt;/strong&gt;运算时会出现问题，所以以下使用JavaScript实现哈希化时还是采用取余运算。&lt;/p&gt;
&lt;h1 id=&#34;2初步封装哈希表&#34;&gt;2.初步封装哈希表&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;哈希表的常见操作为&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;put（key，value）：插入或修改操作；&lt;/li&gt;
&lt;li&gt;get（key）：获取哈希表中特定位置的元素；&lt;/li&gt;
&lt;li&gt;remove（key）：删除哈希表中特定位置的元素；&lt;/li&gt;
&lt;li&gt;isEmpty（）：如果哈希表中不包含任何元素，返回trun，如果哈希表长度大于0则返回false；&lt;/li&gt;
&lt;li&gt;size（）：返回哈希表包含的元素个数；&lt;/li&gt;
&lt;li&gt;resize（value）：对哈希表进行扩容操作；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;21哈希函数的简单实现&#34;&gt;2.1.哈希函数的简单实现&lt;/h2&gt;
&lt;p&gt;首先使用霍纳法则计算hashCode的值，通过取余操作实现哈希化，此处先简单地指定数组的大小。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //设计哈希函数
    //1.将字符串转成比较大的数字：hashCede
    //2.将大的数字hasCode压缩到数组范围(大小)之内
    function hashFunc(str, size){
      //1.定义hashCode变量
      let hashCode = 0

      //2.霍纳法则，计算hashCode的值
      //cats -&amp;gt; Unicode编码
      for(let i = 0 ;i &amp;lt; str.length; i++){
        // str.charCodeAt(i)//获取某个字符对应的unicode编码
        hashCode = 37 * hashCode + str.charCodeAt(i)
      }

      //3.取余操作
      let index = hashCode % size
      return index
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     //测试哈希函数
    console.log(hashFunc(&#39;123&#39;, 7));
    console.log(hashFunc(&#39;NBA&#39;, 7));
    console.log(hashFunc(&#39;CBA&#39;, 7));
    console.log(hashFunc(&#39;CMF&#39;, 7));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614352556116.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;22创建哈希表&#34;&gt;2.2.创建哈希表&lt;/h2&gt;
&lt;p&gt;封装哈希表的数组结构模型：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614352568255.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先创建哈希表类HashTable，并添加必要的属性和上面实现的哈希函数，再进行其他方法的实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //封装哈希表类
    function HashTable() {
      //属性
      this.storage = []
      this.count = 0//计算已经存储的元素个数
      //装填因子：loadFactor &amp;gt; 0.75时需要扩容；loadFactor &amp;lt; 0.25时需要减少容量
      this.limit = 7//初始长度

      //方法
      //哈希函数
      HashTable.prototype.hashFunc = function(str, size){
      //1.定义hashCode变量
      let hashCode = 0

      //2.霍纳法则，计算hashCode的值
      //cats -&amp;gt; Unicode编码
      for(let i = 0 ;i &amp;lt; str.length; i++){
        // str.charCodeAt(i)//获取某个字符对应的unicode编码
        hashCode = 37 * hashCode + str.charCodeAt(i)
      }

      //3.取余操作
      let index = hashCode % size
      return index
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;23putkeyvalue&#34;&gt;2.3.put(key,value)&lt;/h2&gt;
&lt;p&gt;哈希表的插入和修改操作是同一个函数：因为，当使用者传入一个&amp;lt;key，value&amp;gt;时，如果原来不存在该key，那么就是插入操作，如果原来已经存在该key，那么就是修改操作。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614352604336.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，根据key获取索引值index，目的为将数据插入到storage的对应位置；&lt;/li&gt;
&lt;li&gt;然后，根据索引值取出bucket，如果bucket不存在，先创建bucket，随后放置在该索引值的位置；&lt;/li&gt;
&lt;li&gt;接着，判断新增还是修改原来的值。如果已经有值了，就修改该值；如果没有，就执行后续操作。&lt;/li&gt;
&lt;li&gt;最后，进行新增数据操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //插入&amp;amp;修改操作
    HashTable.prototype.put = function (key, value){
      //1.根据key获取对应的index
      let index = this.hashFunc(key, this.limit)

      //2.根据index取出对应的bucket
      let bucket = this.storage[index]

      //3.判断该bucket是否为null
      if (bucket == null) {
        bucket = []
        this.storage[index] = bucket
      }

      //4.判断是否是修改数据
      for (let i = 0; i &amp;lt; bucket.length; i++) {
        let tuple = bucket[i];
        if (tuple[0] == key) {
          tuple[1] = value
          return//不用返回值
        }
      }

      //5.进行添加操作
      bucket.push([key, value])
      this.count += 1
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   //测试哈希表
    //1.创建哈希表
    let ht = new HashTable()

    //2.插入数据
    ht.put(&#39;class1&#39;,&#39;Tom&#39;)
    ht.put(&#39;class2&#39;,&#39;Mary&#39;)
    ht.put(&#39;class3&#39;,&#39;Gogo&#39;)
    ht.put(&#39;class4&#39;,&#39;Tony&#39;)
    ht.put(&#39;class4&#39;, &#39;Vibi&#39;)
    console.log(ht);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614352672421.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;24getkey&#34;&gt;2.4.get(key)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，根据key通过哈希函数获取它在storage中对应的索引值index；&lt;/li&gt;
&lt;li&gt;然后，根据索引值获取对应的bucket；&lt;/li&gt;
&lt;li&gt;接着，判断获取到的bucket是否为null，如果为null，直接返回null；&lt;/li&gt;
&lt;li&gt;随后，线性遍历bucket中每一个key是否等于传入的key。如果等于，直接返回对应的value；&lt;/li&gt;
&lt;li&gt;最后，遍历完bucket后，仍然没有找到对应的key，直接return null即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    //获取操作
    HashTable.prototype.get = function(key){
      //1.根据key获取对应的index
      let index = this.hashFunc(key, this.limit)

      //2.根据index获取对应的bucket
      let bucket = this.storage[index]

      //3.判断bucket是否等于null
      if (bucket == null) {
        return null
      }

      //4.有bucket，那么就进行线性查找
      for (let i = 0; i &amp;lt; bucket.length; i++) {
        let tuple = bucket[i];
        if (tuple[0] == key) {//tuple[0]存储key，tuple[1]存储value
          return tuple[1]
        }
      }

      //5.依然没有找到，那么返回null
      return null
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //测试哈希表
    //1.创建哈希表
    let ht = new HashTable()
    
	//2.插入数据
    ht.put(&#39;class1&#39;,&#39;Tom&#39;)
    ht.put(&#39;class2&#39;,&#39;Mary&#39;)
    ht.put(&#39;class3&#39;,&#39;Gogo&#39;)
    ht.put(&#39;class4&#39;,&#39;Tony&#39;)
    
    //3.获取数据
    console.log(ht.get(&#39;class3&#39;));
    console.log(ht.get(&#39;class2&#39;));
    console.log(ht.get(&#39;class1&#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614352753473.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;25removekey&#34;&gt;2.5.remove(key)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，根据key通过哈希函数获取它在storage中对应的索引值index；&lt;/li&gt;
&lt;li&gt;然后，根据索引值获取对应的bucket；&lt;/li&gt;
&lt;li&gt;接着，判断获取到的bucket是否为null，如果为null，直接返回null；&lt;/li&gt;
&lt;li&gt;随后，线性查找bucket，寻找对应的数据，并且删除；&lt;/li&gt;
&lt;li&gt;最后，依然没有找到，返回null；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //删除操作
    HashTable.prototype.remove = function(key){
      //1.根据key获取对应的index
      let index = this.hashFunc(key, this.limit)

      //2.根据index获取对应的bucket
      let bucket = this.storage[index]

      //3.判断bucket是否为null
      if (bucket == null) {
        return null
      }

      //4.有bucket,那么就进行线性查找并删除
      for (let i = 0; i &amp;lt; bucket.length; i++) {
        let tuple = bucket[i]
        if (tuple[0] == key) {
          bucket.splice(i,1)
          this.count -= 1 
          return tuple[1]
        }
    }

      //5.依然没有找到，返回null
      return null
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   //测试哈希表
   //1.创建哈希表
   let ht = new HashTable()
   
   //2.插入数据
   ht.put(&#39;class1&#39;,&#39;Tom&#39;)
   ht.put(&#39;class2&#39;,&#39;Mary&#39;)
   ht.put(&#39;class3&#39;,&#39;Gogo&#39;)
   ht.put(&#39;class4&#39;,&#39;Tony&#39;)
   
   //3.删除数据
   console.log( ht.remove(&#39;class2&#39;));
   console.log(ht.get(&#39;class2&#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614352863082.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;26其他方法的实现&#34;&gt;2.6.其他方法的实现&lt;/h2&gt;
&lt;p&gt;其他方法包括：&lt;strong&gt;isEmpty()、size()&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  //判断哈希表是否为null
  HashTable.prototype.isEmpty = function(){
    return this.count == 0
  }

  //获取哈希表中元素的个数
  HashTable.prototype.size = function(){
    return this.count
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  //测试哈希表
  //1.创建哈希表
  let ht = new HashTable()

  //2.插入数据
  ht.put(&#39;class1&#39;,&#39;Tom&#39;)
  ht.put(&#39;class2&#39;,&#39;Mary&#39;)
  ht.put(&#39;class3&#39;,&#39;Gogo&#39;)
  ht.put(&#39;class4&#39;,&#39;Tony&#39;)
  
  //3.测试isEmpty()
  console.log(ht.isEmpty());
  //4.测试isEmpty()
  console.log(ht.size());
  console.log(ht);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614352923431.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3哈希表的扩容&#34;&gt;3.哈希表的扩容&lt;/h1&gt;
&lt;h2 id=&#34;31扩容与压缩&#34;&gt;3.1.扩容与压缩&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;为什么需要扩容？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前面我们在哈希表中使用的是&lt;strong&gt;长度为7的数组&lt;/strong&gt;，由于使用的是&lt;strong&gt;链地址法&lt;/strong&gt;，**装填因子(loadFactor)**可以大于1，所以这个哈希表可以无限制地插入新数据。&lt;/li&gt;
&lt;li&gt;但是，随着&lt;strong&gt;数据量的增多&lt;/strong&gt;，storage中每一个index对应的bucket数组（链表）就会越来越长，这就会造成哈希表&lt;strong&gt;效率的降低&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;什么情况下需要扩容？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常见的情况是&lt;strong&gt;loadFactor &amp;gt; 0.75&lt;/strong&gt;的时候进行扩容；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;如何进行扩容？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单的扩容可以直接扩大&lt;strong&gt;两倍&lt;/strong&gt;（关于质数，之后讨论）；&lt;/li&gt;
&lt;li&gt;扩容之后&lt;strong&gt;所有的&lt;/strong&gt;数据项都要进行&lt;strong&gt;同步修改&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现思路:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，定义一个变量，比如oldStorage指向原来的storage；&lt;/li&gt;
&lt;li&gt;然后，创建一个新的容量更大的数组，让this.storage指向它；&lt;/li&gt;
&lt;li&gt;最后，将oldStorage中的每一个bucket中的每一个数据取出来依次添加到this.storage指向的新数组中；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614353051852.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //哈希表扩容
  HashTable.prototype.resize = function(newLimit){
    //1.保存旧的storage数组内容
    let oldStorage = this.storage

    //2.重置所有的属性
    this.storage = []
    this.count = 0
    this.limit = newLimit

    //3.遍历oldStorage中所有的bucket
    for (let i = 0; i &amp;lt; oldStorage.length; i++) {
      //3.1.取出对应的bucket
      const bucket = oldStorage[i];

      //3.2.判断bucket是否为null
      if (bucket == null) {
        continue
      }      

      //3.3.bucket中有数据，就取出数据重新插入
      for (let j = 0; j &amp;lt; bucket.length; j++) {
        const tuple = bucket[j];
        this.put(tuple[0], tuple[1])//插入数据的key和value
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述定义的哈希表的resize方法，既可以实现哈希表的&lt;strong&gt;扩容&lt;/strong&gt;，也可以实现哈希表容量的&lt;strong&gt;压缩&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;装填因子 = 哈希表中数据 / 哈希表长度，即 loadFactor = count / HashTable.length。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;通常情况下当&lt;strong&gt;装填因子laodFactor &amp;gt; 0.75&lt;/strong&gt;时，对哈希表进行扩容。在哈希表中的添加方法（push方法）中添加如下代码，判断是否需要调用扩容函数进行扩容：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;     //判断是否需要扩容操作
      if(this.count &amp;gt; this.limit * 0.75){
        this.resize(this.limit * 2)
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;当装填因子&lt;strong&gt;laodFactor &amp;lt; 0.25&lt;/strong&gt;时，对哈希表容量进行压缩。在哈希表中的删除方法（remove方法）中添加如下代码，判断是否需要调用扩容函数进行压缩：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    //缩小容量
    if (this.limit &amp;gt; 7 &amp;amp;&amp;amp; this.count &amp;lt; this.limit * 0.25) {
      this.resize(Math.floor(this.limit / 2))
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;32选择质数作为容量&#34;&gt;3.2.选择质数作为容量&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;质数的判断&lt;/strong&gt;&lt;br&gt;
首先我们来复习一下，判断质数的方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意1不是质数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;方法一：针对质数的特点：只能被1和num整除，不能被2 ~ (num-1)整除。遍历2 ~ (num-1) 。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;function isPrime(num){
      if(num &amp;lt;= 1 ){
        return false
      } 
      for(let i = 2; i &amp;lt;= num - 1; i++){
        if(num % i ==0){
          return false
        }
      }
        return true
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方法虽然能实现质数的判断，但是效率不高。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法二：只需要遍历2 ~ num的平方根即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    function isPrime(num){
      if (num &amp;lt;= 1) {
        return false
      }
      //1.获取num的平方根:Math.sqrt(num)
      //2.循环判断
      for(var i = 2; i&amp;lt;= Math.sqrt(num); i++ ){
        if(num % i == 0){
          return false;
        }
      }
        return true;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;实现扩容后的哈希表容量为质数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;br&gt;
2倍扩容之后，通过循环调用isPrime判断得到的容量是否为质数，不是则+1，直到是为止。比如原长度：7，2倍扩容后长度为14，14不是质数，14 + 1 = 15不是质数，15 + 1 = 16不是质数，16 + 1 = 17是质数，停止循环，由此得到质数17。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步：首先需要为HashTable类添加判断质数的isPrime方法和获取质数的getPrime方法：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;  //判断传入的num是否质数
  HashTable.prototype.isPrime = function(num){
      if (num &amp;lt;= 1) {
        return false
      }
      //1.获取num的平方根:Math.sqrt(num)
      //2.循环判断
      for(var i = 2; i&amp;lt;= Math.sqrt(num); i++ ){
        if(num % i == 0){
          return false;
        }
      }
        return true;
    }

    //获取质数的方法
    HashTable.prototype.getPrime = function(num){
       //7*2=14,+1=15,+1=16,+1=17(质数)
      while (!this.isPrime(num)) {
        num++
      }
      return num
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;第二步：修改添加元素的put方法和删除元素的remove方法中关于数组扩容的相关操作：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在put方法中添加如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //判断是否需要扩容操作
      if(this.count &amp;gt; this.limit * 0.75){
        let newSize = this.limit * 2
        let newPrime = this.getPrime(newSize)
        this.resize(newPrime)
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在remove方法中添加如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     //缩小容量
          if (this.limit &amp;gt; 7 &amp;amp;&amp;amp; this.count &amp;lt; this.limit * 0.25) {
            let newSize = Math.floor(this.limit / 2)
            let newPrime = this.getPrime(newSize)
            this.resize(newPrime)
          }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  let ht = new HashTable()

    ht.put(&#39;class1&#39;,&#39;Tom&#39;)
    ht.put(&#39;class2&#39;,&#39;Mary&#39;)
    ht.put(&#39;class3&#39;,&#39;Gogo&#39;)
    ht.put(&#39;class4&#39;,&#39;Tony&#39;)
    ht.put(&#39;class5&#39;,&#39;5&#39;)
    ht.put(&#39;class6&#39;,&#39;6&#39;)
    ht.put(&#39;class7&#39;,&#39;7&#39;)
    ht.put(&#39;class8&#39;,&#39;8&#39;)
    ht.put(&#39;class9&#39;,&#39;9&#39;)
    ht.put(&#39;class10&#39;,&#39;10&#39;)
    console.log(ht.size());//10
    console.log(ht.limit);//17
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1614353404211.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;4哈希表的完整实现&#34;&gt;4.哈希表的完整实现&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;    //封装哈希表类
    function HashTable() {
      //属性
      this.storage = []
      this.count = 0//计算已经存储的元素个数
      //装填因子：loadFactor &amp;gt; 0.75时需要扩容；loadFactor &amp;lt; 0.25时需要减少容量
      this.limit = 7//初始长度

      //方法
      //哈希函数
      HashTable.prototype.hashFunc = function(str, size){
      //1.定义hashCode变量
      let hashCode = 0

      //2.霍纳法则，计算hashCode的值
      //cats -&amp;gt; Unicode编码
      for(let i = 0 ;i &amp;lt; str.length; i++){
        // str.charCodeAt(i)//获取某个字符对应的unicode编码
        hashCode = 37 * hashCode + str.charCodeAt(i)
      }

      //3.取余操作
      let index = hashCode % size
      return index
    }

    //一.插入&amp;amp;修改操作
    HashTable.prototype.put = function (key, value){
      //1.根据key获取对应的index
      let index = this.hashFunc(key, this.limit)

      //2.根据index取出对应的bucket
      let bucket = this.storage[index]

      //3.判断该bucket是否为null
      if (bucket == null) {
        bucket = []
        this.storage[index] = bucket
      }

      //4.判断是否是修改数据
      for (let i = 0; i &amp;lt; bucket.length; i++) {
        let tuple = bucket[i];
        if (tuple[0] == key) {
          tuple[1] = value
          return//不用返回值
        }
      }

      //5.进行添加操作
      bucket.push([key, value])
      this.count += 1

      //6.判断是否需要扩容操作
      if(this.count &amp;gt; this.limit * 0.75){
        let newSize = this.limit * 2
        let newPrime = this.getPrime(newSize)
        this.resize(newPrime)
      }
    }

    //二.获取操作
    HashTable.prototype.get = function(key){
      //1.根据key获取对应的index
      let index = this.hashFunc(key, this.limit)

      //2.根据index获取对应的bucket
      let bucket = this.storage[index]

      //3.判断bucket是否等于null
      if (bucket == null) {
        return null
      }

      //4.有bucket，那么就进行线性查找
      for (let i = 0; i &amp;lt; bucket.length; i++) {
        let tuple = bucket[i];
        if (tuple[0] == key) {//tuple[0]存储key，tuple[1]存储value
          return tuple[1]
        }
      }

      //5.依然没有找到，那么返回null
      return null
    }

    //三.删除操作
    HashTable.prototype.remove = function(key){
      //1.根据key获取对应的index
      let index = this.hashFunc(key, this.limit)

      //2.根据index获取对应的bucket
      let bucket = this.storage[index]

      //3.判断bucket是否为null
      if (bucket == null) {
        return null
      }

      //4.有bucket,那么就进行线性查找并删除
      for (let i = 0; i &amp;lt; bucket.length; i++) {
        let tuple = bucket[i]
        if (tuple[0] == key) {
          bucket.splice(i,1)
          this.count -= 1 
          return tuple[1]

          //6.缩小容量
          if (this.limit &amp;gt; 7 &amp;amp;&amp;amp; this.count &amp;lt; this.limit * 0.25) {
            let newSize = Math.floor(this.limit / 2)
            let newPrime = this.getPrime(newSize)
            this.resize(newPrime)
          }
        }
    }

      //5.依然没有找到，返回null
      return null
    }

  /*------------------其他方法--------------------*/
  //判断哈希表是否为null
  HashTable.prototype.isEmpty = function(){
    return this.count == 0
  }

  //获取哈希表中元素的个数
  HashTable.prototype.size = function(){
    return this.count
  }


  //哈希表扩容
  HashTable.prototype.resize = function(newLimit){
    //1.保存旧的storage数组内容
    let oldStorage = this.storage

    //2.重置所有的属性
    this.storage = []
    this.count = 0
    this.limit = newLimit

    //3.遍历oldStorage中所有的bucket
    for (let i = 0; i &amp;lt; oldStorage.length; i++) {
      //3.1.取出对应的bucket
      const bucket = oldStorage[i];

      //3.2.判断bucket是否为null
      if (bucket == null) {
        continue
      }      

      //3.3.bucket中有数据，就取出数据重新插入
      for (let j = 0; j &amp;lt; bucket.length; j++) {
        const tuple = bucket[j];
        this.put(tuple[0], tuple[1])//插入数据的key和value
      }
    }
  }

  //判断传入的num是否质数
  HashTable.prototype.isPrime = function(num){
      if (num &amp;lt;= 1) {
        return false
      }
      //1.获取num的平方根:Math.sqrt(num)
      //2.循环判断
      for(var i = 2; i&amp;lt;= Math.sqrt(num); i++ ){
        if(num % i == 0){
          return false;
        }
      }
        return true;
    }

    //获取质数的方法
    HashTable.prototype.getPrime = function(num){
       //7*2=14,+1=15,+1=16,+1=17(质数)
      while (!this.isPrime(num)) {
        num++
      }
      return num
    }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1x7411L7Q7?from=search&amp;amp;seid=3912456004602554239&#34;&gt;参考资料:JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现哈希表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/fan-wai-cong-a-li-yun-ban-jia-dao-teng-xun-yun-de-tian-keng-zhi-lu/"" data-c="
          &lt;p&gt;原因：穷，续费超过花呗上限🙁&lt;br&gt;
目的：域名(备案)从阿里云转移到腾讯云&lt;br&gt;
题记：作为一个“敬业”的博主(其实是怕以后忘了)，随手记录并分享出来。&lt;/p&gt;
&lt;h1 id=&#34;一-域名转移&#34;&gt;一、域名转移&lt;/h1&gt;
&lt;h2 id=&#34;11-阿里云索取域名转移密码&#34;&gt;1.1 阿里云索取域名转移密码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.aliyun.com/minisite/goods?userCode=2rbhf9dd&#34;&gt;点我登陆&lt;/a&gt;阿里云控制台，进入域名控制台，在域名基本信息中点击【索取域名转移码】，这时阿里云会向域名管理邮箱发送一封带有转移密码的邮件，名头是“万网域名转出密码通知”。复制邮件中的转移密码。&lt;br&gt;
提示:如果提示“已开启[禁止更新锁],该功能暂不可用”，这是阿里云的安全机制作用了，需要你去手动关闭，在【安全设置】中关闭系统自带的“两把锁”，按照提示操作，提供相应的手机验证码即可。然后就能正常索取密码了。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613741482839.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;12-腾讯云域名转入操作&#34;&gt;1.2 腾讯云域名转入操作&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://cloud.tencent.com/?fromSource=gwzcw.1293314.1293314.1293314&amp;amp;cps_key=5c28f3346f24fe86eb5b34852bad6c77&#34;&gt;点我打开&lt;/a&gt;腾讯云官网，进入控制台中的域名管理，先创建一份【域名信息模板】，按照页面要求填写完毕提交，等待审核完毕。正常审核时间为一个工作日，实际上1小时左右就能完成。&lt;br&gt;
然后在下图的【域名转入】页面中，输入域名和转移码，要求中间有空格，不懂的看系统提示。&lt;br&gt;
绑定域名信息模板后，提交。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613741580974.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;13-等待域名转移和后悔期&#34;&gt;1.3 等待域名转移和后悔期&lt;/h2&gt;
&lt;p&gt;这时候阿里云再次发邮件给你，名头是“阿里云域名转出通知”，里面有转移到期的日期，意思是说如果你想转移域名，就可以忽略这封邮件。等待几天就会自动转移成功了。&lt;br&gt;
提示:在这期间有5~7天的后悔期，就是说转移不是马上就完成了，在这些天中如果你不想转移了，可以点击阿里云域名控制台或者邮件中的【取消】，来停止这场转移，这样域名仍旧留在阿里云了。&lt;/p&gt;
&lt;h2 id=&#34;14-域名转移到腾讯云&#34;&gt;1.4 域名转移到腾讯云&lt;/h2&gt;
&lt;p&gt;超过了到期时间后域名就会自动转移到腾讯云了，域名邮箱也会同时收到转移成功的邮件。这时候域名会借助域名信息模板自动实名，接下来就是网站备案，域名解析，安装环境及部署网站等一系列操作了。&lt;/p&gt;
&lt;h1 id=&#34;二-部署个人博客&#34;&gt;二、部署个人博客&lt;/h1&gt;
&lt;h2 id=&#34;21-所需工具&#34;&gt;2.1 所需工具&lt;/h2&gt;
&lt;p&gt;使用github托管个人博客静态网页，使用gridea作为静态网页生成器(操作简单)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;github账号&lt;a href=&#34;https://github.com/&#34;&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;gridea下载安装&lt;a href=&#34;https://gridea.dev/&#34;&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;22-创建仓库存储静态网页&#34;&gt;2.2 创建仓库存储静态网页&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742044871.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742050262.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;23-生成个人访问令牌&#34;&gt;2.3 生成个人访问令牌&lt;/h2&gt;
&lt;p&gt;依次点击，右上角头像-&amp;gt;Developer settings-&amp;gt;Personal access tokens-&amp;gt;Generate new token&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742116246.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742119740.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;24-在gridea填写域名仓库名称等信息同步&#34;&gt;2.4 在gridea填写域名，仓库名称等信息，同步&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742207612.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742210710.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
刷新一下github仓库网页，会看到多了很多文件&lt;/p&gt;
&lt;h1 id=&#34;三-github绑定自己的域名&#34;&gt;三、github绑定自己的域名&lt;/h1&gt;
&lt;h2 id=&#34;31-在仓库里添加cname文件并在文件中填写绑定的域名&#34;&gt;3.1 在仓库里添加CNAME文件并在文件中填写绑定的域名&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742323733.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
文件里填写的内容：要绑定的域名（不要包含Http://和www）&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742361386.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
进入设置&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742397702.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
找到 Custom domain添加域名后保存即可。&lt;br&gt;
（添加CNAME文件并在文件中填写绑定的域名后应该会自动保存，看看有没有自动保存）&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742412812.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-添加域名解析&#34;&gt;3.2 添加域名解析&lt;/h2&gt;
&lt;p&gt;ping你的http://github.io域名，得到一个IP&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742460079.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
修改你的域名解析记录；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742567477.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加两个记录分别为A和CNAME，A绑定刚才得到的ip地址，CNAME绑定自己的域名&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613742731980.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;33-绑定成功&#34;&gt;3.3 绑定成功&lt;/h2&gt;
&lt;h1 id=&#34;四-本地dns更新&#34;&gt;四、本地DNS更新&lt;/h1&gt;
&lt;p&gt;域名指向新的服务器IP后不能访问的解决办法：&lt;br&gt;
不能访问是因为本地DNS缓存，缓存清除方法：dos命令窗口输入ipconfig/flushdns ，回车即可。&lt;/p&gt;
">【番外】从阿里云搬家到腾讯云的填坑之路</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/javascript-shi-xian-ji-he-yu-zi-dian/"" data-c="
          &lt;h1 id=&#34;1集合结构&#34;&gt;1.集合结构&lt;/h1&gt;
&lt;h2 id=&#34;11简介&#34;&gt;1.1.简介&lt;/h2&gt;
&lt;p&gt;集合比较常见的实现方式是&lt;strong&gt;哈希表&lt;/strong&gt;，这里使用JavaScript的Object类进行封装。&lt;br&gt;
集合通常是由一组&lt;strong&gt;无序的、不能重复&lt;/strong&gt;的元素构成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数学中常指的集合中的元素是可以重复的，但是计算机中集合的元素不能重复。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;集合是特殊的数组：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特殊之处在于里面的元素&lt;strong&gt;没有顺序，也不能重复&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;没有顺序意味着&lt;strong&gt;不能通过下标值进行访问&lt;/strong&gt;，不能重复意味着&lt;strong&gt;相同的对象&lt;/strong&gt;在集合中只会&lt;strong&gt;存在一份&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现集合类：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在ES6中的&lt;strong&gt;Set&lt;/strong&gt;类就是一个集合类，这里我们重新封装一个Set类，了解集合的底层实现。&lt;/li&gt;
&lt;li&gt;JavaScript中的&lt;strong&gt;Object&lt;/strong&gt;类中的&lt;strong&gt;key&lt;/strong&gt;就是一个集合，可以使用它来封装集合类Set。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;集合常见的操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;add（value）：向集合添加一个新的项；&lt;/li&gt;
&lt;li&gt;remove（value）：从集合中移除一个值；&lt;/li&gt;
&lt;li&gt;has（value）：如果值在集合中，返回true，否则返回false；&lt;/li&gt;
&lt;li&gt;clear（）：移除集合中的所有项；&lt;/li&gt;
&lt;li&gt;size（）：返回集合所包含元素的数量，与数组的length属性相似；&lt;/li&gt;
&lt;li&gt;values（）：返回一个包含集合中所有值的数组；&lt;br&gt;
还有其他的方法，用的不多这里不做封装；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12代码实现&#34;&gt;1.2.代码实现&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;     //封装集合类
    function Set() {
      //属性
      this.items = {}

      //方法
      //一.has方法
      Set.prototype.has = value =&amp;gt; {
        return this.items.hasOwnProperty(value)
      }

      //二.add方法
      Set.prototype.add = value =&amp;gt; {
        //判断集合中是否已经包含该元素
        if (this.has(value)) {
          return false
        }
        //将元素添加到集合中
        this.items[value] = value//表示该属性键和值都为value
        return true//表示添加成功
      }

      //三.remove方法
      Set.prototype.remove = (value) =&amp;gt; {
        //1.判断集合中是否包含该元素
        if (!this.has(value)) {
          return false
        }

        //2.将元素从属性中删除
        delete this.items[value]
        return true
      }

      //四.clear方法
      Set.prototype.clear = () =&amp;gt; {
        //原来的对象没有引用指向，会被自动回收
        this.items = {}
      }

      //五.size方法
      Set.prototype.size = () =&amp;gt; {
        return Object.keys(this.items).length
      }

      //获取集合中所有的值
      //六.values方法
      Set.prototype.values = function() {
        return Object.keys(this.items)
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试集合类
    //1.创建Set类对象
    let set = new Set()

    //添加元素
    //2.测试add方法
    console.log(set.add(&#39;a&#39;));									
    console.log(set.add(&#39;a&#39;));										
    console.log(set.add(&#39;b&#39;));									
    console.log(set.add(&#39;c&#39;));										
    console.log(set.add(&#39;d&#39;));										

    //3.测试values方法
    console.log(set.values());									

    //删除元素
    //4.测试remove方法
    console.log(set.remove(&#39;a&#39;));								
    console.log(set.remove(&#39;a&#39;));								
    console.log(set.values());										

    //5.测试has方法
    console.log(set.has(&#39;b&#39;));										

    //6.测试size方法和clear方法
    console.log(set.size());										
    set.clear()
    // 由于clear方法的实现原理为指向另外一个空对象，所以不影响原来的对象
    console.log(set.size());										
    console.log(set.values());				
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613738370515.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;13集合间的操作&#34;&gt;1.3.集合间的操作&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;集合间操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合；&lt;/li&gt;
&lt;li&gt;交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合；&lt;/li&gt;
&lt;li&gt;差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合；&lt;/li&gt;
&lt;li&gt;子集：验证一个给定集合是否是另一个集合的子集；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1613738411477.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;并集的实现：&lt;/strong&gt;&lt;br&gt;
实现思路：创建集合C代表集合A和集合B的并集，先将集合A中的所有元素添加到集合C中，再遍历集合B，如果是集合C所没有的元素就把它添加到集合C中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Set.prototype.union = otherSet =&amp;gt; {
      // this:集合对象A
      // otherSet:集合对象B
      //1.创建一个新的集合
      let unionSet = new Set()

      //2.将A集合中的所有元素添加到新集合中
      let values = this.values()
      // for(let i of values){
      //   unionSet.add(i)
      // }
      for(let i = 0;i &amp;lt; values.length;i++){
        unionSet.add(values[i])
      }

      //3.取出B集合中的元素,判断是否需要加到新集合中
      values = otherSet.values()
      // for(let i of values){
      //   //由于集合的add方法已经对重复的元素进行了判断,所以这里可以直接添加
      //   unionSet.add(i)
      // }
      for(let i = 0;i &amp;lt; values.length;i++){
        unionSet.add(values[i])
      }
      return unionSet
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;交集的实现：&lt;/strong&gt;&lt;br&gt;
实现思路：遍历集合A，当取得的元素也存在于集合B时，就把该元素添加到另一个集合C中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; Set.prototype.intersection = otherSet =&amp;gt; {
      // this:集合A
      // otherSet:集合B
      //1.创建新的集合
      let intersectionSet = new Set()
      
      //2.从A中取出一个元素，判断是否同时存在于集合B中，是则放入新集合中
      let values = this.values()
      for(let i =0 ; i &amp;lt; values.length; i++){
        let item = values[i]
        if (otherSet.has(item)) {
          intersectionSet.add(item)
        }
      }
      return intersectionSet
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;差集的实现：&lt;/strong&gt;&lt;br&gt;
实现思路：遍历集合A，当取得的元素不存在于集合B时，就把该元素添加到另一个集合C中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Set.prototype.diffrence = otherSet =&amp;gt; {
        //this:集合A
        //otherSet:集合B
        //1.创建新的集合
        var diffrenceSet = new Set()

        //2.取出A集合中的每一个元素，判断是否同时存在于B中，不存在则添加到新集合中
        var values = this.values()
        for(var i = 0;i &amp;lt; values.length; i++){
          var item = values[i]
          if (!otherSet.has(item)) {
            diffrenceSet.add(item)
          }
        }
        return diffrenceSet
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;子集的实现：&lt;/strong&gt;&lt;br&gt;
实现思路：遍历集合A，当取得的元素中有一个不存在于集合B时，就说明集合A不是集合B的子集，返回false。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; Set.prototype.subset = otherSet =&amp;gt; {
        //this:集合A
        //otherSet：集合B
        //遍历集合A中的所有元素，如果发现，集合A中的元素，在集合B中不存在，那么放回false，如果遍历完整个集合A没有返回false，就返回true
        let values = this.values()
        for(let i = 0; i &amp;lt; values.length; i++){
          let item = values[i]
          if(!otherSet.has(item)){
            return false
          }
        }
        return true
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2字典结构&#34;&gt;2.字典结构&lt;/h1&gt;
&lt;h2 id=&#34;21简介&#34;&gt;2.1.简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;字典的特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字典存储的是键值对，主要特点是一一对应；&lt;/li&gt;
&lt;li&gt;比如保存一个人的信息：数组形式：[19，‘Tom’，1.65]，可通过下标值取出信息；字典形式：{&amp;quot;age&amp;quot;：19，&amp;quot;name&amp;quot;：&amp;quot;Tom&amp;quot;，&amp;quot;height&amp;quot;：165}，可以通过key取出value。&lt;/li&gt;
&lt;li&gt;此外，在字典中&lt;strong&gt;key&lt;/strong&gt;是&lt;strong&gt;不能重复&lt;/strong&gt;且&lt;strong&gt;无序&lt;/strong&gt;的，而&lt;strong&gt;Value&lt;/strong&gt;可以&lt;strong&gt;重复&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;字典和映射的关系：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有些编程语言中称这种映射关系为字典，如Swift中的Dictonary，Python中的dict；&lt;/li&gt;
&lt;li&gt;有些编程语言中称这种映射关系为Map，比如Java中的HashMap&amp;amp;TreeMap等；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;字典类常见的操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;set(key,value)：向字典中添加新元素。&lt;/li&gt;
&lt;li&gt;remove(key)：通过使用键值来从字典中移除键值对应的数据值。&lt;/li&gt;
&lt;li&gt;has(key)：如果某个键值存在于这个字典中，则返回true，反之则返回false。&lt;/li&gt;
&lt;li&gt;get(key)：通过键值查找特定的数值并返回。&lt;/li&gt;
&lt;li&gt;clear()：将这个字典中的所有元素全部删除。&lt;/li&gt;
&lt;li&gt;size()：返回字典所包含元素的数量。与数组的length属性类似。&lt;/li&gt;
&lt;li&gt;keys()：将字典所包含的所有键名以数组形式返回。&lt;/li&gt;
&lt;li&gt;values()：将字典所包含的所有数值以数组形式返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;22封装字典&#34;&gt;2.2.封装字典&lt;/h2&gt;
&lt;p&gt;字典类可以基于JavaScript中的对象结构来实现，比较简单，这里直接实现字典类中的常用方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//封装字典类
function Dictionary(){
  //字典属性
  this.items = {}

  //字典操作方法
  //一.在字典中添加键值对
  Dictionary.prototype.set = function(key, value){
    this.items[key] = value
  }

  //二.判断字典中是否有某个key
  Dictionary.prototype.has = function(key){
    return this.items.hasOwnProperty(key)
  }

  //三.从字典中移除元素
  Dictionary.prototype.remove = function(key){
    //1.判断字典中是否有这个key
    if(!this.has(key)) return false

    //2.从字典中删除key
    delete this.items[key]
    return true
  }

  //四.根据key获取value
  Dictionary.prototype.get = function(key){
    return this.has(key) ? this.items[key] : undefined
  }

  //五.获取所有keys
  Dictionary.prototype.keys = function(){
    return Object.keys(this.items)
  }

  //六.size方法
  Dictionary.prototype.keys = function(){
    return this.keys().length
  }

  //七.clear方法
  Dictionary.prototype.clear = function(){
    this.items = {}
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1x7411L7Q7?from=search&amp;amp;seid=3912456004602554239&#34;&gt;参考资料:JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现集合与字典</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/javascript-shi-xian-shuang-xiang-lian-biao/"" data-c="
          &lt;h1 id=&#34;1双向链表简介&#34;&gt;1.双向链表简介&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;双向链表&lt;/strong&gt;：既可以&lt;strong&gt;从头遍历到尾&lt;/strong&gt;，又可以&lt;strong&gt;从尾遍历到头&lt;/strong&gt;。也就是说链表连接的过程是&lt;strong&gt;双向&lt;/strong&gt;的，它的实现原理是：一个节点既有&lt;strong&gt;向前连接的引用&lt;/strong&gt;，也有一个&lt;strong&gt;向后连接的引用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;双向链表的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次在插入或删除某个节点时，都需要处理四个引用，而不是两个，实现起来会困难些；&lt;/li&gt;
&lt;li&gt;相对于单向链表，所占内存空间更大一些；&lt;/li&gt;
&lt;li&gt;但是，相对于双向链表的便利性而言，这些缺点微不足道。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;双向链表的结构：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612851991692.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双向链表不仅有&lt;strong&gt;head&lt;/strong&gt;指针指向第一个节点，而且有&lt;strong&gt;tail&lt;/strong&gt;指针指向最后一个节点；&lt;/li&gt;
&lt;li&gt;每一个节点由三部分组成：&lt;strong&gt;item&lt;/strong&gt;储存数据、&lt;strong&gt;prev&lt;/strong&gt;指向前一个节点、&lt;strong&gt;next&lt;/strong&gt;指向后一个节点；&lt;/li&gt;
&lt;li&gt;双向链表的第一个节点的&lt;strong&gt;prev&lt;/strong&gt;指向&lt;strong&gt;null&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;双向链表的最后一个节点的&lt;strong&gt;next&lt;/strong&gt;指向&lt;strong&gt;null&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;双向链表常见的操作（方法）：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;append（element）：向链表尾部添加一个新的项；&lt;/li&gt;
&lt;li&gt;inset（position，element）：向链表的特定位置插入一个新的项；&lt;/li&gt;
&lt;li&gt;get（element）：获取对应位置的元素；&lt;/li&gt;
&lt;li&gt;indexOf（element）：返回元素在链表中的索引，如果链表中没有元素就返回-1；&lt;/li&gt;
&lt;li&gt;update（position，element）：修改某个位置的元素；&lt;/li&gt;
&lt;li&gt;removeAt（position）：从链表的特定位置移除一项；&lt;/li&gt;
&lt;li&gt;isEmpty（）：如果链表中不包含任何元素，返回trun，如果链表长度大于0则返回false；&lt;/li&gt;
&lt;li&gt;size（）：返回链表包含的元素个数，与数组的length属性类似；&lt;/li&gt;
&lt;li&gt;toString（）：由于链表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值；&lt;/li&gt;
&lt;li&gt;forwardString（）：返回正向遍历节点字符串形式；&lt;/li&gt;
&lt;li&gt;backwordString（）：返回反向遍历的节点的字符串形式；&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2封装双向链表类&#34;&gt;2.封装双向链表类&lt;/h1&gt;
&lt;h2 id=&#34;21创建双向链表类&#34;&gt;2.1.创建双向链表类&lt;/h2&gt;
&lt;p&gt;先创建双向链表类DoubleLinklist，并添加基本属性，再实现双向链表的常用方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //封装双向链表类
    function DoubleLinklist(){
      //封装内部类：节点类
      function Node(data){
        this.data = data
        this.prev = null
        this.next = null
      }

      //属性
      this.head = null
      this.tail ==null
      this.length = 0
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;22appendelement&#34;&gt;2.2.append(element)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //append方法
      DoubleLinklist.prototype.append = data =&amp;gt; {
        //1.根据data创建新节点
        let newNode = new Node(data)

        //2.添加节点
        //情况1：添加的是第一个节点
        if (this.length == 0) {
          this.tail = newNode
          this.head = newNode 
        //情况2：添加的不是第一个节点
        }else {
          newNode.prev = this.tail
          this.tail.next = newNode
          this.tail = newNode
        }

        //3.length+1
        this.length += 1
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
添加节点时分为多种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：添加的是第一个节点：只需要让head和tail都指向新节点即可；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852175479.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;情况2：添加的不是第一个节点，如下图所示：只需要改变相关引用的指向即可。&lt;br&gt;
通过：newNode.prev = this.tail：建立指向1；&lt;br&gt;
通过：this.tail.next = newNode：建立指向2；&lt;br&gt;
通过：this.tail = newNode：建立指向3&lt;br&gt;
要注意改变变量指向的顺序，最后修改tail指向，这样未修改前tail始终指向原链表的最后一个节点。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852234410.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852237080.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
   //1.创建双向链表
   let list = new DoubleLinklist()

    //2.测试append方法
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;next方向：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852391457.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;prev方向：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852402201.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;23tostring汇总&#34;&gt;2.3.toString()汇总&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //将链表转变为字符串形式
      //一.toString方法
      DoubleLinklist.prototype.toString = () =&amp;gt; {
        return this.backwardString()
      }

      //二.forwardString方法
      DoubleLinklist.prototype.forwardString = () =&amp;gt; {
        //1.定义变量
        let current =this.tail
        let resultString = &amp;quot;&amp;quot;
        //2.依次向前遍历，获取每一个节点
        while (current) {
          resultString += current.data + &amp;quot;--&amp;quot;
          current = current.prev 
        }
        return resultString
      }

      //三.backwardString方法
      DoubleLinklist.prototype.backwardString = () =&amp;gt; {
        //1.定义变量
        let current = this.head
        let resultString = &amp;quot;&amp;quot;

        //2.依次向后遍历，获取每一个节点
        while (current) {
          resultString += current.data + &amp;quot;--&amp;quot;
          current = current.next
        }
        return resultString
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
三种获取字符串的方法：toString（）、forwardString（）、backwardString（）实现原理相似，仅以backWardString方法为例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义current变量记录当前指向的节点。首先让current指向第一个节点，然后通过 current = current.next 依次向后遍历。在while循环中以(current)作为条件遍历链表，只要current ！= null就一直遍历，由此可获取链表所有节点的数据。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852477706.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建双向链表
    let list = new DoubleLinklist()
    
    //2.测试字符串方法   
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)
    console.log(list.toString());
    console.log(list.forwardString());
    console.log(list.backwardString());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852509395.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;24insertpositionelement&#34;&gt;2.4.insert(position,element)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      //insert方法
      DoubleLinklist.prototype.insert = (position, data) =&amp;gt; {
        //1.越界判断
        if (position &amp;lt; 0 || position &amp;gt; this.length) return false

        //2.根据data创建新的节点
        let newNode = new Node(data)

        //3.插入新节点
        //原链表为空
          //情况1：插入的newNode是第一个节点
        if (this.length == 0) {
          this.head = newNode
          this.tail = newNode
        //原链表不为空
        }else {
          //情况2：position == 0
          if (position == 0) {
            this.head.prev = newNode
            newNode.next = this.head
            this.head = newNode
          //情况3：position == this.length 
          } else if(position == this.length){
            this.tail.next = newNode
            newNode.prev = this.tail
            this.tail = newNode
            //情况4：0 &amp;lt; position &amp;lt; this.length
          }else{
            let current = this.head
            let index = 0
            while(index++ &amp;lt; position){
              current = current.next
            }
            //修改pos位置前后节点变量的指向
            newNode.next = current
            newNode.prev = current.prev
            current.prev.next = newNode
            current.prev = newNode
          }
        }
        //4.length+1
        this.length += 1
        return true//返回true表示插入成功
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
插入节点可分为多种情况：&lt;br&gt;
&lt;strong&gt;当原链表为空时：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：插入的新节点是链表的第一个节点；只需要让head和tail都指向newNode即可。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852572211.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;当原链表不为空时：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;情况2：当position == 0，即在链表的首部添加节点：如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852606766.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先，通过：this.head.prev = newNode，改变指向1；&lt;br&gt;
然后，通过：newNode.next = this.head，改变指向2；&lt;br&gt;
最后，通过：this.head = newNode，改变指向3；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852623273.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;情况3：position == this.length，即在链表的尾部添加节点，如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852636699.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;首先&lt;/strong&gt;，通过：this.tail.next = newNode，改变指向1；（注意这里使用this.tail指向原链表最后一个节点，而不是this.head。因为当length&amp;gt;1时，this.head != this.tail。）&lt;br&gt;
&lt;strong&gt;然后&lt;/strong&gt;，通过：newNode.prev = this.tail，改变指向2；&lt;br&gt;
&lt;strong&gt;最后&lt;/strong&gt;，通过：this.tail = newNode，改变指向3；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852702385.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;情况4：0 &amp;lt; position &amp;lt; this.length，即在链表的中间插入新节点，假设在position = 1的位置插入，如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852718023.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先，需要定义变量current按照之前的思路，通过while循环找到position位置的后一个节点，循环结束后index = position&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852732864.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如下图所示：当position = 1时，current就指向了Node2。这样操作current就等同于间接地操作Node2，还可以通过current.prev间接获取Node1。得到了newNode的前一个节点和后一个节点就可以通过改变它们的prev和next变量的指向来插入newNode了。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852753700.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;通过&lt;/strong&gt;：newNode.next = current，改变指向1；&lt;br&gt;
&lt;strong&gt;通过&lt;/strong&gt;：newNode.prev = current.prev，改变指向2；&lt;br&gt;
&lt;strong&gt;通过&lt;/strong&gt;：current.prev.next = newNode，改变指向3；&lt;br&gt;
&lt;code&gt;注意必须最后才修改current.prev的指向，不然就无法通过current.prev获取需要操作的Node1了。&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;通过&lt;/strong&gt;：current.prev = current，改变指向4；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852934567.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建双向链表
    let list = new DoubleLinklist()

	//2.测试insert方法
    list.insert(0, &#39;插入链表的第一个元素&#39;)
    list.insert(0, &#39;在链表首部插入元素&#39;)
    list.insert(1, &#39;在链表中间插入元素&#39;)
    list.insert(3, &#39;在链表尾部插入元素&#39;)
    console.log(list);
    alert(list)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852974146.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612852977704.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;25getposition&#34;&gt;2.5.get(position)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      //get方法
      DoubleLinklist.prototype.get = position =&amp;gt; {
        //1.越界判断
        if (position &amp;lt; 0 || position &amp;gt;= this.length) {//获取元素时position不能等于length
          return null
        }

        //2.获取元素
        let current = null
        let index = 0
        //this.length / 2 &amp;gt; position:从头开始遍历
        if ((this.length / 2) &amp;gt; position) {
          current = this.head
          while(index++ &amp;lt; position){
          current = current.next
        }
        //this.length / 2 =&amp;lt; position:从尾开始遍历
        }else{
          current = this.tail
          index = this.length - 1
          while(index-- &amp;gt; position){
          current = current.prev
        }
        }
        return current.data
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
定义两个变量current和index，按照之前的思路通过while循环遍历分别获取当前节点和对应的索引值index，直到找到需要获取的position位置后的一个节点，此时index = pos =x，然后return current.data即可。&lt;/p&gt;
&lt;p&gt;如果链表的节点数量很多时，这种查找方式效率不高，改进方法为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一定要通过this.length来获取链表的节点数否则就会报错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;当this.length / 2 &amp;gt; position：从头（head）开始遍历；&lt;/li&gt;
&lt;li&gt;当this.length / 2 &amp;lt; position：从尾（tail）开始遍历；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853079217.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建双向链表
    let list = new DoubleLinklist()
    
  	//2.测试get方法
    list.append(&#39;a&#39;)
    list.append(&#39;b&#39;)
    list.append(&#39;b1&#39;)
    list.append(&#39;b2&#39;)
    list.append(&#39;b3&#39;)
    list.append(&#39;b4&#39;)
    list.append(&#39;b5&#39;)
    list.append(&#39;b6&#39;)
    list.append(&#39;b7&#39;)
    console.log(list.get(0));
    console.log(list.get(7));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853118806.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;26indexofelement&#34;&gt;2.6.indexOf(element)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      //indexOf方法
      DoubleLinklist.prototype.indexOf = data =&amp;gt; {
        //1.定义变量
        let current = this.head
        let index = 0

        //2.遍历链表，查找与data相同的节点
        while(current){
          if (current.data == data) {
            return index
          }
          current = current.next
          index += 1
        }
        return -1
      } 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
以（current）作为条件，通过while循环遍历链表中的所有节点（停止条件为current = null）。在遍历每个节点时将current指向的当前节点的data和传入的data进行比较即可。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853385534.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建双向链表
    let list = new DoubleLinklist()
    
    //2.测试indexOf方法
    list.append(&#39;a&#39;)
    list.append(&#39;b&#39;)
    list.append(&#39;c&#39;)
    console.log(list.indexOf(&#39;a&#39;));
    console.log(list.indexOf(&#39;c&#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853417022.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;28updatepositionelement&#34;&gt;2.8.update(position,element)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;        //update方法
      DoubleLinklist.prototype.update = (position, newData) =&amp;gt; {
        //1.越界判断
        if (position &amp;lt; 0 || position &amp;gt;= this.length) {
          return false
        }

        //2.寻找正确的节点
        let current = this.head
        let index = 0
        //this.length / 2 &amp;gt; position:从头开始遍历
        if (this.length / 2 &amp;gt; position) {
          while(index++ &amp;lt; position){
          current = current.next
        }
        //this.length / 2 =&amp;lt; position:从尾开始遍历
        }else{
          current = this.tail
          index = this.length - 1
          while (index -- &amp;gt; position) {
            current = current.prev
          }
        }

        //3.修改找到节点的data
        current.data = newData
        return true//表示成功修改
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
以（index++ &amp;lt; position）为条件，通过while循环遍历链表中的节点（停止条件为index = position）。循环结束后，current指向需要修改的节点。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853464522.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建双向链表
    let list = new DoubleLinklist()
    
    //2.测试update方法
    list.append(&#39;a&#39;)
    list.append(&#39;b&#39;)
    console.log(list.update(1, &#39;c&#39;));
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853512616.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;29removeatposition&#34;&gt;2.9.removeAt(position)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      //removeAt方法
      DoubleLinklist.prototype.removeAt = position =&amp;gt; {
        //1.越界判断
        if (position &amp;lt; 0 || position &amp;gt;= this.length) {
          return null
        }
        
        //2.删除节点
        //当链表中length == 1
        //情况1：链表只有一个节点
        let current = this.head//定义在最上面方便以下各种情况返回current.data
        if (this.length == 1) {
          this.head = null
          this.tail = null
        //当链表中length &amp;gt; 1
        } else{
          //情况2：删除第一个节点
          if (position == 0) {
            this.head.next.prev = null
            this.head = this.head.next
          //情况3：删除最后一个节点
          }else if(position == this.length - 1){
            current = this.tail//该情况下返回被删除的最后一个节点
            this.tail.prev.next = null
            this.tail = this.tail.prev
          }else{
          //情况4：删除链表中间的节点
            let index = 0
            while(index++ &amp;lt; position){
              current = current.next
            }
            current.next.prev = current.prev
            current.prev.next = current.next
          }
        }

        //3.length -= 1
        this.length -= 1
        return current.data//返回被删除节点的数据
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
删除节点时有多种情况：&lt;br&gt;
&lt;strong&gt;当链表的length = 1时：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：删除链表中的所有节点：只需要让链表的head和tail指向null即可。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853571732.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;当链表的length &amp;gt; 1时：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;情况2：删除链表中的第一个节点：&lt;br&gt;
通过：this.head.next.prev = null，改变指向1；&lt;br&gt;
通过：this.head = this.head.next，改变指向2；&lt;br&gt;
虽然Node1有引用指向其它节点，但是没有引用指向Node1，那么Node1会被自动回收。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853599140.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;情况3：删除链表中的最后一个节点：&lt;br&gt;
通过：this.tail.prev.next = null，修改指向1；&lt;br&gt;
通过：this.tail = this.tail.prev，修改指向2；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853618439.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;情况4：删除链表中间的节点：&lt;br&gt;
通过while循环找到需要删除的节点，比如position = x，那么需要删除的节点就是Node(x+1)，如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853635573.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
通过：current.next.prev = current.prev，修改指向1；&lt;br&gt;
通过：current.prev.next = current.next，修改指向2；&lt;br&gt;
这样就没有引用指向Node(x+1)了（current虽指向Node(x+1)，但current时临时变量，该方法执行完就会被销毁），随后Node(x+1)就会被自动删除。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853650608.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建双向链表
    let list = new DoubleLinklist()	
	
	//2.测试removeAt方法
    list.append(&#39;a&#39;)
    list.append(&#39;b&#39;)
    list.append(&#39;c&#39;)
    console.log(list.removeAt(1));
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853684660.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;210其他方法&#34;&gt;2.10.其他方法&lt;/h2&gt;
&lt;p&gt;其他方法包括：&lt;strong&gt;remove(element)、isEmpty()、size()、getHead()、getTail()&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  //八.remove方法
  DoubleLinklist.prototype.remove = data =&amp;gt; {
    //1.根据data获取下标值
    let index = this.indexOf(data)
    
    //2.根据index删除对应位置的节点
    return this.removeAt(index)
  }

  //九.isEmpty方法
  DoubleLinklist.prototype.isEmpty = () =&amp;gt; {
    return this.length == 0
  }

  //十.size方法
  DoubleLinklist.prototype.size = () =&amp;gt; {
    return this.length
  }

  //十一.getHead方法：获取链表的第一个元素
  DoubleLinklist.prototype.getHead = () =&amp;gt; {
    return this.head.data
  }

  //十二.getTail方法：获取链表的最后一个元素
  DoubleLinklist.prototype.getTail = () =&amp;gt; {
    return this.tail.data
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//测试代码
    //1.创建双向链表
    let list = new DoubleLinklist()	

/*------------其他方法的测试--------------*/
    list.append(&#39;a&#39;)
    list.append(&#39;b&#39;)
    list.append(&#39;c&#39;)
    list.append(&#39;d&#39;)
    //remove方法
    console.log(list.remove(&#39;a&#39;));
    console.log(list);
    //isEmpty方法
    console.log(list.isEmpty());
    //size方法
    console.log(list.size());
    //getHead方法
    console.log(list.getHead());
    //getTead方法
    console.log(list.getTail());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853763963.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;211完整实现&#34;&gt;2.11.完整实现&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//封装双向链表
function DoubleLinklist(){
  //封装内部类：节点类
  function Node(data){
    this.data = data
    this.prev = null
    this.next = null
  }

  //属性
  this.head = null
  this.tail ==null
  this.length = 0

  //常见的操作：方法
  //一.append方法
  DoubleLinklist.prototype.append = data =&amp;gt; {
    //1.根据data创建新节点
    let newNode = new Node(data)

    //2.添加节点
    //情况1：添加的是第一个节点
    if (this.length == 0) {
      this.tail = newNode
      this.head = newNode 
    //情况2：添加的不是第一个节点
    }else {
      newNode.prev = this.tail
      this.tail.next = newNode
      this.tail = newNode
    }

    //3.length+1
    this.length += 1
  }

  //二.将链表转变为字符串形式
  //2.1.toString方法
  DoubleLinklist.prototype.toString = () =&amp;gt; {
    return this.backwardString()
  }

  //2.2.forwardString方法
  DoubleLinklist.prototype.forwardString = () =&amp;gt; {
    //1.定义变量
    let current =this.tail
    let resultString = &amp;quot;&amp;quot;

    //2.依次向前遍历，获取每一个节点
    while (current) {
      resultString += current.data + &amp;quot;--&amp;quot;
      current = current.prev 
    }
    return resultString
  }

  //2.3.backwardString方法
  DoubleLinklist.prototype.backwardString = () =&amp;gt; {
    //1.定义变量
    let current = this.head
    let resultString = &amp;quot;&amp;quot;

    //2.依次向后遍历，获取每一个节点
    while (current) {
      resultString += current.data + &amp;quot;--&amp;quot;
      current = current.next
    }
    return resultString
  }

  //三.insert方法
  DoubleLinklist.prototype.insert = (position, data) =&amp;gt; {
    //1.越界判断
    if (position &amp;lt; 0 || position &amp;gt; this.length) return false

    //2.根据data创建新的节点
    let newNode = new Node(data)

    //3.插入新节点
    //原链表为空
      //情况1：插入的newNode是第一个节点
    if (this.length == 0) {
      this.head = newNode
      this.tail = newNode
    //原链表不为空
    }else {
      //情况2：position == 0
      if (position == 0) {
        this.head.prev = newNode
        newNode.next = this.head
        this.head = newNode
      //情况3：position == this.length 
      } else if(position == this.length){
        this.tail.next = newNode
        newNode.prev = this.tail
        this.tail = newNode
        //情况4：0 &amp;lt; position &amp;lt; this.length
      }else{
        let current = this.head
        let index = 0
        while(index++ &amp;lt; position){
          current = current.next
        }
        //修改pos位置前后节点变量的指向
        newNode.next = current
        newNode.prev = current.prev
        current.prev.next = newNode
        current.prev = newNode
      }
    }
    //4.length+1
    this.length += 1
    return true//返回true表示插入成功
  }

  //四.get方法
  DoubleLinklist.prototype.get = position =&amp;gt; {
    //1.越界判断
    if (position &amp;lt; 0 || position &amp;gt;= this.length) {//获取元素时position不能等于length
      return null
    }

    //2.获取元素
    let current = null
    let index = 0
    //this.length / 2 &amp;gt; position:从头开始遍历
    if ((this.length / 2) &amp;gt; position) {
      current = this.head
      while(index++ &amp;lt; position){
      current = current.next
    }
    //this.length / 2 =&amp;lt; position:从尾开始遍历
    }else{
      current = this.tail
      index = this.length - 1
      while(index-- &amp;gt; position){
      current = current.prev
    }
    }
    return current.data
  }

  //五.indexOf方法
  DoubleLinklist.prototype.indexOf = data =&amp;gt; {
    //1.定义变量
    let current = this.head
    let index = 0

    //2.遍历链表，查找与data相同的节点
    while(current){
      if (current.data == data) {
        return index
      }
      current = current.next
      index += 1
    }
    return -1
  } 

  //六.update方法
  DoubleLinklist.prototype.update = (position, newData) =&amp;gt; {
    //1.越界判断
    if (position &amp;lt; 0 || position &amp;gt;= this.length) {
      return false
    }

    //2.寻找正确的节点
    let current = this.head
    let index = 0
    //this.length / 2 &amp;gt; position:从头开始遍历
    if (this.length / 2 &amp;gt; position) {
      while(index++ &amp;lt; position){
      current = current.next
    }
    //this.length / 2 =&amp;lt; position:从尾开始遍历
    }else{
      current = this.tail
      index = this.length - 1
      while (index -- &amp;gt; position) {
        current = current.prev
      }
    }

    //3.修改找到节点的data
    current.data = newData
    return true//表示成功修改
  }

  //七.removeAt方法
  DoubleLinklist.prototype.removeAt = position =&amp;gt; {
    //1.越界判断
    if (position &amp;lt; 0 || position &amp;gt;= this.length) {
      return null
    }
    
    //2.删除节点
    //当链表中length == 1
    //情况1：链表只有一个节点
    let current = this.head//定义在最上面方便以下各种情况返回current.data
    if (this.length == 1) {
      this.head = null
      this.tail = null
    //当链表中length &amp;gt; 1
    } else{
      //情况2：删除第一个节点
      if (position == 0) {
        this.head.next.prev = null
        this.head = this.head.next
      //情况3：删除最后一个节点
      }else if(position == this.length - 1){
        current = this.tail//该情况下返回被删除的最后一个节点
        this.tail.prev.next = null
        this.tail = this.tail.prev
      }else{
      //情况4：删除链表中间的节点
        let index = 0
        while(index++ &amp;lt; position){
          current = current.next
        }
        current.next.prev = current.prev
        current.prev.next = current.next
      }
    }

    //3.length -= 1
    this.length -= 1
    return current.data//返回被删除节点的数据
  }
  /*--------------------其他方法-------------------*/
  //八.remove方法
  DoubleLinklist.prototype.remove = data =&amp;gt; {
    //1.根据data获取下标值
    let index = this.indexOf(data)
    
    //2.根据index删除对应位置的节点
    return this.removeAt(index)
  }

  //九.isEmpty方法
  DoubleLinklist.prototype.isEmpty = () =&amp;gt; {
    return this.length == 0
  }

  //十.size方法
  DoubleLinklist.prototype.size = () =&amp;gt; {
    return this.length
  }

  //十一.getHead方法：获取链表的第一个元素
  DoubleLinklist.prototype.getHead = () =&amp;gt; {
    return this.head.data
  }

  //十二.getTail方法：获取链表的最后一个元素
  DoubleLinklist.prototype.getTail = () =&amp;gt; {
    return this.tail.data
  }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3链表结构总结&#34;&gt;3.链表结构总结&lt;/h1&gt;
&lt;p&gt;单向链表有head和next两个属性，双向链表有head、tail、next、prev四个属性。处理好它们的指向，相当于将它们正确地连接在一起，这样就组成了一条链，这就是简单链表的实现。&lt;/p&gt;
&lt;p&gt;在实际开发中链表使用得非常多，比如Java中的&lt;strong&gt;LinkList&lt;/strong&gt;就是双向链表。&lt;/p&gt;
&lt;h2 id=&#34;31注意点&#34;&gt;3.1.注意点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在链表中current = current.next 可以从左往右看，看成是current --&amp;gt; current.next，即current指向current的下一个节点。&lt;/li&gt;
&lt;li&gt;删除节点的原理：只要没有引用指向该对象，无论该对象是否有引用指向其他对象，该对象都会被回收（删除）。&lt;/li&gt;
&lt;li&gt;参数中凡是有position的都要进行越界判断。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;32链表的增删改查&#34;&gt;3.2.链表的增删改查&lt;/h2&gt;
&lt;p&gt;以双向链表为例：&lt;strong&gt;链表的增删改查无非就是获取链表中相应的节点改变其中的prev和next两个变量的指向。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况一：只需要&lt;strong&gt;head&lt;/strong&gt;和&lt;strong&gt;tail&lt;/strong&gt;两个变量就可以获取需要操作的变量（这里指的是能够轻松获取，当然你想通过head.next.next...或tail.prev.prev...来获取想要的节点也可以），在这种情况下链表的长度length：&lt;strong&gt;0 &amp;lt;= length &amp;lt;=2&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;情况二：不能靠tail和head来获取到需要操作的变量时，可采用while循环遍历的方式，找到需要操作的节点：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853909360.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在这种情况下，如果我们想要在链表的position = x的位置插入新节点，那么可以通过current获取position的后一个节点Node(x+1)，通过current.prev获取position位置的前一个节点Node(x)；之后修改Node(x+1)和Node(x)中的prev和next两个变量的指向即可在pos=x 的位置插入新节点。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853922088.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;33修改链表引用指向&#34;&gt;3.3.修改链表引用指向&lt;/h2&gt;
&lt;p&gt;应先修改newNode引用的指向，再修改其他引用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：通过head和tail引用就能获取需要操作的节点时，最后更改head或tail变量的指向（因为它们分别指向链表的第一个和最后一个节点，获取其他节点时可能需要用到它们）。&lt;/li&gt;
&lt;li&gt;情况2：使用current获取到需要操作的节点时，最后更改curren.next或current.prev的指向。因为current.next和current.prev表示的是Node(x+2)和Node(x)这两个节点，如下图所示，一旦变更它们的指向就无法获取Node(x)或Node(x+2)了，&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853947258.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;34遍历链表&#34;&gt;3.4.遍历链表&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;积累两种遍历思路&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取指定的position = x 位置的后一个节点和索引值：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853980453.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612853983952.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
循环结束后index = position = x，变量current就指向了Node(x+1)，变量index的值为Node(x+1)的索引值x。&lt;/li&gt;
&lt;li&gt;遍历链表中的所有节点：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612854002125.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612854005730.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当current.next = null时停止循环，此时current指向链表的最后一个节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av86801505?from=search&amp;amp;seid=4967761411915016256&#34;&gt;参考资料：JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现双向链表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/javascript-shi-xian-dan-xiang-lian-biao/"" data-c="
          &lt;h1 id=&#34;1单向链表简介&#34;&gt;1.单向链表简介&lt;/h1&gt;
&lt;p&gt;链表和数组一样，可以用于&lt;strong&gt;存储一系列的元素&lt;/strong&gt;，但是链表和数组的&lt;strong&gt;实现机制完全不同&lt;/strong&gt;。链表的每个元素由一个存储&lt;strong&gt;元素本身的节点&lt;/strong&gt;和一个&lt;strong&gt;指向下一个元素的引用&lt;/strong&gt;（有的语言称为指针或连接）组成。类似于火车头，一节车厢载着乘客（数据），通过节点连接另一节车厢。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612443894132.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612443897959.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612443901003.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;head属性指向链表的第一个节点；&lt;/li&gt;
&lt;li&gt;链表中的最后一个节点指向null；&lt;/li&gt;
&lt;li&gt;当链表中一个节点也没有的时候，head直接指向null；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;链表是链式的存储结构；数组是顺序的存储结构&lt;/code&gt;&lt;br&gt;
&lt;code&gt;链表通过指针来连接元素与元素，数组则是把所有元素按次序依次存储&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数组存在的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组便于查询和修改&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;数组存在的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组的创建通常需要申请一段&lt;strong&gt;连续的内存空间&lt;/strong&gt;（一整块内存），并且大小是固定的。所以当原数组&lt;strong&gt;不能满足容量需求&lt;/strong&gt;时，需要&lt;strong&gt;扩容&lt;/strong&gt;（一般情况下是申请一个更大的数组，比如2倍，然后将原数组中的元素复制过去）。&lt;/li&gt;
&lt;li&gt;在数组的开头或中间位置插入数据的成本很高，需要进行大量元素的位移。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;数组操作时间复杂度：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;查找&lt;br&gt;
即便是排序好的数组，用二分查找，时间复杂度也为O(log2n)。所以正确的表述应该是数组支持随机访问，根据下标随机访问的时间复杂度为O(1)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插入和删除&lt;br&gt;
插入和删除操作对于数组来说比较低效，假设数组的长度为n，现在，如果我们需要将一个数据插入到数组中的第K个位置。为了把第k个位置腾出来，我们需要将第k~n的数据往后挪，那么来分析一下其时间复杂度：&lt;br&gt;
如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果&lt;br&gt;
在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是&lt;br&gt;
O(n)。因为在每个位置插入数据的概率是一样的所以时间复杂度平均为O(n/2)，省略常数1/2，即O(n)。&lt;br&gt;
删除同理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;链表的优势：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链表中的元素在内存中&lt;strong&gt;不必是连续的空间&lt;/strong&gt;，可以充分利用计算机的内存，实现灵活的&lt;strong&gt;内存动态管理&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;链表不必在创建时就&lt;strong&gt;确定大小&lt;/strong&gt;，并且大小可以&lt;strong&gt;无限地延伸&lt;/strong&gt;下去。&lt;/li&gt;
&lt;li&gt;链表在&lt;strong&gt;插入和删除&lt;/strong&gt;数据时，&lt;strong&gt;时间复杂度&lt;/strong&gt;可以达到O(1)，相对数组效率高很多。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;链表的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;寻找某个元素较为困难&lt;/li&gt;
&lt;li&gt;链表访问任何一个位置的元素时，都需要&lt;strong&gt;从头开始访问&lt;/strong&gt;（无法跳过第一个元素访问任何一个元素）。&lt;/li&gt;
&lt;li&gt;无法通过下标值直接访问元素，需要从头开始一个个访问，直到找到对应的元素。&lt;/li&gt;
&lt;li&gt;虽然可以轻松地到达&lt;strong&gt;下一个节点&lt;/strong&gt;，但是回到&lt;strong&gt;前一个节点&lt;/strong&gt;是很难的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;链表中的常见操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;append（element）：向链表尾部添加一个新的项；&lt;/li&gt;
&lt;li&gt;insert（position，element）：向链表的特定位置插入一个新的项；&lt;/li&gt;
&lt;li&gt;get（position）：获取对应位置的元素；&lt;/li&gt;
&lt;li&gt;indexOf（element）：返回元素在链表中的索引。如果链表中没有该元素就返回-1；&lt;/li&gt;
&lt;li&gt;update（position，element）：修改某个位置的元素；&lt;/li&gt;
&lt;li&gt;removeAt（position）：从链表的特定位置移除一项；&lt;/li&gt;
&lt;li&gt;remove（element）：从链表中移除一项；&lt;/li&gt;
&lt;li&gt;isEmpty（）：如果链表中不包含任何元素，返回trun，如果链表长度大于0则返回false；&lt;/li&gt;
&lt;li&gt;size（）：返回链表包含的元素个数，与数组的length属性类似；&lt;/li&gt;
&lt;li&gt;toString（）：由于链表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先需要弄清楚：下文中的position指的是两个节点之间，并且与index的关系如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444098945.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;position的值一般表示position所指位置的下一个节点。当position的值与index的值相等时，比如position = index = 1，那么它们都表示Node2。&lt;/p&gt;
&lt;h1 id=&#34;2封装单向链表类&#34;&gt;2.封装单向链表类&lt;/h1&gt;
&lt;h2 id=&#34;21创建单向链表类&#34;&gt;2.1.创建单向链表类&lt;/h2&gt;
&lt;p&gt;先创建单向链表类Linklist，并添加基本属性，再实现单向链表的常用方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    // 封装单向链表类
    function LinkList(){
      // 封装一个内部类：节点类
      function Node(data){
        this.data = data;
        this.next = null;
      }

      // 属性
      // 属性head指向链表的第一个节点
      this.head = null;
      this.length = 0;
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;22appendelement&#34;&gt;2.2.append(element)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;     // 一.实现append方法
      LinkList.prototype.append = data =&amp;gt; {
        //1.创建新节点
        let newNode = new Node(data)

        //2.添加新节点
        //情况1：只有一个节点时候
        if(this.length == 0){
          this.head = newNode
        //情况2：节点数大于1，在链表的最后添加新节点  
        }else {              
          //让变量current指向第一个节点
          let current = this.head
          //当current.next(下一个节点不为空)不为空时，一直循环，直到current指向最后一个节点
          while (current.next){
            current = current.next
          }
          // 最后节点的next指向新的节点
          current.next = newNode
        }
        //3.添加完新结点之后length+1
        this.length += 1
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先让current指向第一个节点：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444270200.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;通过while循环使current指向最后一个节点，最后通过current.next = newNode，让最后一个节点指向新节点newNode：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444281470.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建LinkList
    let list = new LinkList()
    
    //2.测试append方法
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)
    console.log(list);  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444320368.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;23tostring&#34;&gt;2.3.toString()&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;     // 实现toString方法
      LinkList.prototype.toString = () =&amp;gt; {
        // 1.定义变量
        let current = this.head
        let listString = &amp;quot;&amp;quot;

        // 2.循环获取一个个的节点
        while(current){ 
          listString += current.data + &amp;quot; &amp;quot;
          current = current.next//千万不要忘了拼接完一个节点数据之后，让current指向下一个节点
        }
        return  listString
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建LinkList
    let list = new LinkList()
    
    //2.插入数据
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)
    
    //3.测试toString方法
    console.log(list.toString());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444411617.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;24insertpositionelement&#34;&gt;2.4.insert(position,element)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    // 实现insert方法
      LinkList.prototype.insert = (position, data) =&amp;gt; {
      //理解positon的含义：position=0表示新界点插入后要成为第1个节点，position=2表示新界点插入后要成为第3个节点
        //1.对position进行越界判断:要求传入的position不能是负数且不能超过LinkList的length
        if(position &amp;lt; 0 || position &amp;gt; this.length){
          return false
        }
        //2.根据data创建newNode
        let newNode = new Node(data)

        //3.插入新节点
        //情况1：插入位置position=0
        if(position == 0){
          // 让新节点指向第一个节点
          newNode.next = this.head
          // 让head指向新节点
          this.head = newNode
        //情况2：插入位置position&amp;gt;0(该情况包含position=length)
        } else{
          let index = 0
          let previous = null
          let current = this.head
          //步骤1：通过while循环使变量current指向position位置的后一个节点(注意while循环的写法)
          while(index++ &amp;lt; position){
          //步骤2：在current指向下一个节点之前，让previous指向current当前指向的节点
            previous = current
            current = current.next
          }
          // 步骤3：通过变量current(此时current已经指向position位置的后一个节点)，使newNode指向position位置的后一个节点
          newNode.next = current
          //步骤4：通过变量previous，使position位置的前一个节点指向newNode
          previous.next = newNode
          /*
            启示：
            1.我们无法直接操作链表中的节点，但是可以通过变量指向这些节点，以此间接地操作节点(替身使者)；
            比如current指向节点3，想要节点3指向节点4只需要：current.next = 4即可。
            2.两个节点间是双向的，想要节点2的前一个节点为节点1，可以通过：1.next=2，来实现；
          */
        }
        //4.新节点插入后要length+1
        this.length += 1;

        return true
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
inset方法实现的过程：根据插入节点位置的不同可分为多种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：position = 0：&lt;br&gt;
通过： newNode.next = this.head，建立连接1；&lt;br&gt;
通过： this.head = newNode，建立连接2；（不能先建立连接2，否则this.head不再指向Node1）&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444479910.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;情况2：position &amp;gt; 0：&lt;br&gt;
首先定义两个变量previous和curent分别指向需要插入位置pos = X的前一个节点和后一个节点；&lt;br&gt;
然后，通过：newNode.next = current，改变指向3；&lt;br&gt;
最后，通过：previous.next = newNode，改变指向4；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444504059.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;情况2的特殊情形：position = length：&lt;br&gt;
情况2也包含了pos = length的情况，该情况下current和newNode.next都指向null；建立连接3和连接4的方式与情况2相同。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444521406.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;     //测试代码
    //1.创建LinkList
    let list = new LinkList()
    
    //2.插入数据
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)
    
    //3.测试insert方法
    list.insert(0, &#39;在链表最前面插入节点&#39;);
    list.insert(2, &#39;在链表中第二个节点后插入节点&#39;);
    list.insert(5, &#39;在链表最后插入节点&#39;);
    alert(list);
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444552747.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444561625.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;25getposition&#34;&gt;2.5.get(position)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      //实现get方法
      LinkList.prototype.get = (position) =&amp;gt; {
        //1.越界判断
        // 当position = length时，取到的是null所以0 =&amp;lt; position &amp;lt; length
        if(position &amp;lt; 0 || position &amp;gt;= this.length){
          return null
        }
        //2.获取指定的positon位置的后一个节点的data
        //同样使用一个变量间接操作节点
        let current = this.head
        let index = 0
        while(index++ &amp;lt; position){
          current = current.next
        }
        return current.data
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
get方法的实现过程：以获取position = 2为例，如下图所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先使current指向第一个节点，此时index=0；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444624072.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;通过while循环使current循环指向下一个节点，注意循环终止的条件index++ &amp;lt; position，即当index=position时停止循环，此时循环了1次，current指向第二个节点(Node2)，最后通过current.data返回Node2节点的数据；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444638164.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建LinkList
    let list = new LinkList()
    
    //2.插入数据
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)	

	//3.测试get方法
    console.log(list.get(0));
    console.log(list.get(1));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444676610.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;26indexofelement&#34;&gt;2.6.indexOf(element)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//实现indexOf方法
      LinkList.prototype.indexOf = data =&amp;gt; {
        //1.定义变量
        let current = this.head
        let index = 0

        //2.开始查找:只要current不指向null就一直循环
        while(current){
          if(current.data == data){
            return index
          }
          current = current.next
          index += 1
        } 

        //3.遍历完链表没有找到，返回-1
        return -1
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
indexOf方法的实现过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用变量current记录当前指向的节点，使用变量index记录当前节点的索引值（注意index = node数-1）：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444722712.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建LinkList
    let list = new LinkList()
    
    //2.插入数据
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)	
    
    //3.测试indexOf方法
    console.log(list.indexOf(&#39;aaa&#39;));
    console.log(list.indexOf(&#39;ccc&#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444758126.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;27updatepositionelement&#34;&gt;2.7.update(position,element)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;     //实现update方法
      LinkList.prototype.update = (position, newData) =&amp;gt; {
        //1.越界判断
        //因为被修改的节点不能为null，所以position不能等于length
        if(position &amp;lt; 0 || position &amp;gt;= this.length){
          return false
        }
        //2.查找正确的节点
        let current = this.head
        let index = 0
        while(index++ &amp;lt; position){
          current = current.next
        }
        //3.将position位置的后一个节点的data修改成newData
        current.data = newData
        //返回true表示修改成功
        return true
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建LinkList
    let list = new LinkList()
    
    //2.插入数据
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)	
    
    //3.测试update方法
    list.update(0, &#39;修改第一个节点&#39;)
    list.update(1, &#39;修改第二个节点&#39;)
    console.log(list);
    console.log(list.update(3, &#39;能修改么&#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444815485.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;28removeatposition&#34;&gt;2.8.removeAt(position)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      //实现removeAt方法
      LinkList.prototype.removeAt = position =&amp;gt; {
        //1.越界判断
        if (position &amp;lt; 0 || position &amp;gt;= this.length) {//position不能为length
          return null
        }
        //2.删除元素
        //情况1：position = 0时(删除第一个节点)
        let current = this.head
        if (position ==0 ) {
        //情况2：position &amp;gt; 0时
          this.head = this.head.next
        }else{
          let index = 0
          let previous = null
          while (index++ &amp;lt; position) {
            previous = current
            current = current.next
          }
          //循环结束后，current指向position后一个节点，previous指向current前一个节点
          //再使前一个节点的next指向current的next即可
          previous.next = current.next
        }
        //3，length-1
        this.length -= 1

        //返回被删除节点的data，为此current定义在最上面
        return current.data
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过程详解：&lt;/strong&gt;&lt;br&gt;
removeAt方法的实现过程：删除节点时存在多种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况1：position = 0，即移除第一个节点（Node1）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过：this.head = this.head.next，改变指向1即可；&lt;br&gt;
虽然Node1的next仍指向Node2，但是没有引用指向Node1，则Node1会被垃圾回收器自动回收，所以不用处理Node1指向Node2的引用next。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612444914446.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况2：positon &amp;gt; 0，比如pos = 2即移除第三个节点（Node3）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：position = length时position后一个节点为null不能删除，因此position != length；&lt;br&gt;
首先，定义两个变量previous和curent分别指向需要删除位置pos = x的前一个节点和后一个节点；&lt;br&gt;
然后，通过：previous.next = current.next，改变指向1即可；&lt;br&gt;
随后，没有引用指向Node3，Node3就会被自动回收，至此成功删除Node3 。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612445034409.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    //测试代码
    //1.创建LinkList
    let list = new LinkList()
    
    //2.插入数据
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)
  
  //3.测试removeAt方法
    console.log(list.removeAt(0));
    console.log(list.removeAt(0));
    console.log(list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612445073288.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;29其他方法&#34;&gt;2.9.其他方法&lt;/h2&gt;
&lt;p&gt;其他方法包括：&lt;strong&gt;remove(element)、isEmpty()、size()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/*-------------其他方法的实现--------------*/
      //一.实现remove方法
      LinkList.prototype.remove = (data) =&amp;gt; {
        //1.获取data在列表中的位置
        let position = this.indexOf(data)
        //2.根据位置信息，删除结点
        return this.removeAt(position)
      }

      //二.实现isEmpty方法
      LinkList.prototype.isEmpty = () =&amp;gt; {
        return this.length == 0
      }

      //三.实现size方法
      LinkList.prototype.size = () =&amp;gt; {
        return this.length
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  //测试代码
    //1.创建LinkList
    let list = new LinkList()
    
    //2.插入数据
    list.append(&#39;aaa&#39;)
    list.append(&#39;bbb&#39;)
    list.append(&#39;ccc&#39;)

/*---------------其他方法测试----------------*/
  	//remove方法
  	console.log(list.remove(&#39;aaa&#39;));
  	console.log(list);
  	//isEmpty方法
  	console.log(list.isEmpty());
  	//size方法
  	console.log(list.size());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612445152104.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;210完整实现&#34;&gt;2.10.完整实现&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt; // 封装链表类
    function LinkList(){
      // 封装一个内部类：节点类
      function Node(data){
        this.data = data;
        this.next = null;
      }

      // 属性
      // 属性head指向链表的第一个节点
      this.head = null;
      this.length = 0;

      // 一.实现append方法
      LinkList.prototype.append = data =&amp;gt; {
        //1.创建新节点
        let newNode = new Node(data)

        //2.添加新节点
        //情况1：只有一个节点时候
        if(this.length == 0){
          this.head = newNode
        //情况2：节点数大于1，在链表的最后添加新节点  
        }else {              
          //让变量current指向第一个节点
          let current = this.head
          //当current.next(下一个节点不为空)不为空时，一直循环，直到current指向最后一个节点
          while (current.next){
            current = current.next
          }
          // 最后节点的next指向新的节点
          current.next = newNode
        }
        //3.添加完新结点之后length+1
        this.length += 1
      }

      // 二.实现toString方法
      LinkList.prototype.toString = () =&amp;gt; {
        // 1.定义变量
        let current = this.head
        let listString = &amp;quot;&amp;quot;

        // 2.循环获取一个个的节点
        while(current){ 
          listString += current.data + &amp;quot; &amp;quot;
          current = current.next//千万不要忘了拼接完一个节点数据之后，让current指向下一个节点
        }
        return  listString
      }

      // 三.实现insert方法
      LinkList.prototype.insert = (position, data) =&amp;gt; {
      //理解positon的含义：position=0表示新界点插入后要成为第1个节点，position=2表示新界点插入后要成为第3个节点
        //1.对position进行越界判断:要求传入的position不能是负数且不能超过LinkList的length
        if(position &amp;lt; 0 || position &amp;gt; this.length){
          return false
        }
        //2.根据data创建newNode
        let newNode = new Node(data)

        //3.插入新节点
        //情况1：插入位置position=0
        if(position == 0){
          // 让新节点指向第一个节点
          newNode.next = this.head
          // 让head指向新节点
          this.head = newNode
        //情况2：插入位置position&amp;gt;0(该情况包含position=length)
        } else{
          let index = 0
          let previous = null
          let current = this.head
          //步骤1：通过while循环使变量current指向position位置的后一个节点(注意while循环的写法)
          while(index++ &amp;lt; position){
          //步骤2：在current指向下一个节点之前，让previous指向current当前指向的节点
            previous = current
            current = current.next
          }
          // 步骤3：通过变量current(此时current已经指向position位置的后一个节点)，使newNode指向position位置的后一个节点
          newNode.next = current
          //步骤4：通过变量previous，使position位置的前一个节点指向newNode
          previous.next = newNode
          
		//我们无法直接操作链表中的节点，但是可以通过变量指向这些节点，以此间接地操作节点；
        }
        //4.新节点插入后要length+1
        this.length += 1;

        return true
      }

      //四.实现get方法
      LinkList.prototype.get = (position) =&amp;gt; {
        //1.越界判断
        // 当position = length时，取到的是null所以0 =&amp;lt; position &amp;lt; length
        if(position &amp;lt; 0 || position &amp;gt;= this.length){
          return null
        }
        //2.获取指定的positon位置的后一个节点的data
        //同样使用一个变量间接操作节点
        let current = this.head
        let index = 0
        while(index++ &amp;lt; position){
          current = current.next
        }
        return current.data
      }

      //五.实现indexOf方法
      LinkList.prototype.indexOf = data =&amp;gt; {
        //1.定义变量
        let current = this.head
        let index = 0

        //2.开始查找:只要current不指向null就一直循环
        while(current){
          if(current.data == data){
            return index
          }
          current = current.next
          index += 1
        } 

        //3.遍历完链表没有找到，返回-1
        return -1
      }

      //六.实现update方法
      LinkList.prototype.update = (position, newData) =&amp;gt; {
        //1.越界判断
        //因为被修改的节点不能为null，所以position不能等于length
        if(position &amp;lt; 0 || position &amp;gt;= this.length){
          return false
        }
        //2.查找正确的节点
        let current = this.head
        let index = 0
        while(index++ &amp;lt; position){
          current = current.next
        }
        //3.将position位置的后一个节点的data修改成newData
        current.data = newData
        //返回true表示修改成功
        return true
      }

      //七.实现removeAt方法
      LinkList.prototype.removeAt = position =&amp;gt; {
        //1.越界判断
        if (position &amp;lt; 0 || position &amp;gt;= this.length) {
          return null
        }
        //2.删除元素
        //情况1：position = 0时(删除第一个节点)
        let current = this.head
        if (position ==0 ) {
        //情况2：position &amp;gt; 0时
          this.head = this.head.next
        }else{
          let index = 0
          let previous = null
          while (index++ &amp;lt; position) {
            previous = current
            current = current.next
          }
          //循环结束后，current指向position后一个节点，previous指向current前一个节点
          //再使前一个节点的next指向current的next即可
          previous.next = current.next
        }
        //3，length-1
        this.length -= 1

        //返回被删除节点的data，为此current定义在最上面
        return current.data
      }

/*-------------其他方法的实现--------------*/
      //八.实现remove方法
      LinkList.prototype.remove = (data) =&amp;gt; {
        //1.获取data在列表中的位置
        let position = this.indexOf(data)
        //2.根据位置信息，删除结点
        return this.removeAt(position)
      }

      //九.实现isEmpty方法
      LinkList.prototype.isEmpty = () =&amp;gt; {
        return this.length == 0
      }

      //十.实现size方法
      LinkList.prototype.size = () =&amp;gt; {
        return this.length
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1x7411L7Q7?from=search&amp;amp;seid=3912456004602554239&#34;&gt;参考资料:JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现单向链表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/javascript-shi-xian-dui-lie-jie-gou-queue/"" data-c="
          &lt;h1 id=&#34;1队列简介&#34;&gt;1.队列简介&lt;/h1&gt;
&lt;p&gt;队列是是一种受限的线性表，特点为&lt;strong&gt;先进先出&lt;/strong&gt;（&lt;strong&gt;FIFO&lt;/strong&gt;：first in first out）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;受限之处在于它只允许在表的&lt;strong&gt;前端&lt;/strong&gt;（front）进行删除操作；&lt;/li&gt;
&lt;li&gt;在表的&lt;strong&gt;后端&lt;/strong&gt;（rear）进行插入操作；&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612359092282.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
相当于排队买票，先来的先买票，后来的后买票。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612359106480.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;队列的应用&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打印队列：计算机打印多个文件的时候，需要排队打印；&lt;/li&gt;
&lt;li&gt;线程队列：当开启多线程时，当新开启的线程所需的资源不足时就先放入线程队列，等待CPU处理；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;队列类的实现&lt;/strong&gt;：&lt;br&gt;
队列的实现和栈一样，有两种方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于数组实现；&lt;/li&gt;
&lt;li&gt;基于链表实现；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;队列的常见操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;enqueue（element）：向队列尾部添加一个（或多个）新的项；&lt;/li&gt;
&lt;li&gt;dequeue（）：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素；&lt;/li&gt;
&lt;li&gt;front（）：返回队列中的第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息与Stack类的peek方法非常类似）；&lt;/li&gt;
&lt;li&gt;isEmpty（）：如果队列中不包含任何元素，返回true，否则返回false；&lt;/li&gt;
&lt;li&gt;size（）：返回队列包含的元素个数，与数组的length属性类似；&lt;/li&gt;
&lt;li&gt;toString（）：将队列中的内容，转成字符串形式；&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2封装队列类&#34;&gt;2.封装队列类&lt;/h1&gt;
&lt;h2 id=&#34;21代码实现&#34;&gt;2.1.代码实现&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;    // 基于数组封装队列类
    function Queue() {
    // 属性
      this.items = []
      
    // 方法
    // 1.enqueue():将元素加入到队列中
    Queue.prototype.enqueue = element =&amp;gt; {
      this.items.push(element)
    }

    // 2.dequeue():从队列中删除前端元素
    Queue.prototype.dequeue = () =&amp;gt; {
      return this.items.shift()
    }

    // 3.front():查看前端的元素
    Queue.prototype.front = () =&amp;gt; {
      return this.items[0]
    }

    // 4.isEmpty:查看队列是否为空
    Queue.prototype.isEmpty = () =&amp;gt; {
      return this.items.length == 0;
    }

    // 5.size():查看队列中元素的个数
    Queue.prototype.size = () =&amp;gt; {
      return this.items.length
    }

    // 6.toString():将队列中元素以字符串形式输出
    Queue.prototype.toString = () =&amp;gt; {
      let resultString = &#39;&#39;
        for (let i of this.items){
          resultString += i + &#39; &#39;
        }
        return resultString
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;    // 创建队列
    let queue = new  Queue()

    // 将元素加入到队列中
    queue.enqueue(&#39;a&#39;)
    queue.enqueue(&#39;b&#39;)
    queue.enqueue(&#39;c&#39;)
    queue.enqueue(&#39;d&#39;)
    console.log(queue);												

    // 从队列中删除元素
    queue.dequeue()
    console.log(queue);											
    queue.dequeue()
    console.log(queue);											

    //front
    console.log(queue.front());								 		
    
    // 验证其他方法
    console.log(queue.isEmpty());								 	
    console.log(queue.size());								 	
    console.log(queue.toString());								 	
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612359291030.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;22队列的应用&#34;&gt;2.2.队列的应用&lt;/h2&gt;
&lt;p&gt;使用队列实现小游戏：击鼓传花，传入一组数据和设定的数字num，循环遍历数组内元素，遍历到的元素为指定数字num时将该元素删除，直至数组剩下一个元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;    // 队列应用：面试题：击鼓传花
    let passGame = (nameList, num) =&amp;gt; {
      //1.创建队列结构
      let queue = new Queue()

      //2.将所有人依次加入队列
      // 这是ES6的for循环写法，i相当于nameList[i]
      for(let i of nameList){
        queue.enqueue(i)
      }
      

      // 3.开始数数
     while(queue.size() &amp;gt; 1){//队列中只剩1个人就停止数数
      // 不是num的时候，重新加入队列末尾
      // 是num的时候，将其从队列中删除
      // 3.1.num数字之前的人重新放入队列的末尾(把队列前面删除的加到队列最后)
      for(let i = 0; i&amp;lt; num-1; i++ ){
        queue.enqueue(queue.dequeue())
      }
      // 3.2.num对应这个人，直接从队列中删除
      /*
        思路是这样的，由于队列没有像数组一样的下标值不能直接取到某一元素，所以采用，把num前面的num-1个元素先删除后添加到队列末尾，这样第num个元素就排到了队列的最前面，可以直接使用dequeue方法进行删除
      */
      queue.dequeue()
     }

      //4.获取剩下的那个人
      console.log(queue.size());									
      let endName = queue.front()
      console.log(&#39;最终剩下的人：&#39; + endName);						   	
      
      return nameList.indexOf(endName);
    }

    //5.测试击鼓传花
    let names = [&#39;lily&#39;, &#39;lucy&#39;, &#39;Tom&#39;, &#39;Lilei&#39;, &#39;Tony&#39;]
    console.log(passGame(names, 3));		
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612359343343.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3优先队列&#34;&gt;3.优先队列&lt;/h1&gt;
&lt;p&gt;优先级队列主要考虑的问题为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个元素不再只是一个数据，还包含数据的优先级；&lt;/li&gt;
&lt;li&gt;在添加数据过程中，根据优先级放入到正确位置；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;31优先级队列的实现&#34;&gt;3.1.优先级队列的实现&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;    // 封装优先级队列
    function PriorityQueue() {

      //内部类：在类里面再封装一个类;表示带优先级的数据
      function QueueElement(element, priority) {
        this.element = element;
        this.priority = priority;
      } 

      // 封装属性
      this.items = []

      // 1.实现按照优先级插入方法
      PriorityQueue.prototype.enqueue = (element, priority) =&amp;gt; {
        // 1.1.创建QueueElement对象
        let queueElement = new QueueElement(element, priority)

        // 1.2.判断队列是否为空
        if(this.items.length == 0){
          this.items.push(queueElement)
        }else{
          // 定义一个变量记录是否成功添加了新元素
          let added = false
          for(let i of this.items){
            // 让新插入的元素与原有元素进行优先级比较(priority越小，优先级越大)
            if(queueElement.priority &amp;lt; i.priority){
              this.items.splice(i, 0, queueElement)
              added = true
              // 新元素已经找到插入位置了可以使用break停止循环
              break
            }
          }
          // 新元素没有成功插入，就把它放在队列的最前面
          if(!added){
            this.items.push(queueElement)
          }
        }
      }

      // 2.dequeue():从队列中删除前端元素
      PriorityQueue.prototype.dequeue = () =&amp;gt; {
        return this.items.shift()
      }

      // 3.front():查看前端的元素
      PriorityQueue.prototype.front = () =&amp;gt; {
        return this.items[0]
      }

      // 4.isEmpty():查看队列是否为空
      PriorityQueue.prototype.isEmpty = () =&amp;gt; {
        return this.items.length == 0;
      }

      // 5.size():查看队列中元素的个数
      PriorityQueue.prototype.size = () =&amp;gt; {
        return this.items.length
      }

      // 6.toString():以字符串形式输出队列中的元素
      PriorityQueue.prototype.toString = () =&amp;gt; {
        let resultString = &#39;&#39;
          for (let i of this.items){
            resultString += i.element + &#39;-&#39; + i.priority + &#39; &#39;
          }
          return resultString
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JS&#34;&gt;  // 测试代码
    let pq = new PriorityQueue();
    pq.enqueue(&#39;Tom&#39;,111);
    pq.enqueue(&#39;Hellen&#39;,200);
    pq.enqueue(&#39;Mary&#39;,30);
    pq.enqueue(&#39;Gogo&#39;,27);
    // 打印修改过后的优先队列对象
    console.log(pq);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612359507202.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;32注意点&#34;&gt;3.2.注意点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;关于数组方法splice用法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;splice（1，0，&#39;Tom&#39;）：表示在索引为1的元素前面插入元素’Tom‘（也可以理解为从索引为1的元素开始删除，删除0个元素，再在索引为1的元素前面添加元素&#39;Tom&#39;）；&lt;/li&gt;
&lt;li&gt;splice（1，1，&#39;Tom&#39;）：表示从索引为1的元素开始删除（包括索引为1的元素），共删除1个元素，并添加元素&#39;Tom&#39;。即把索引为1的元素替换为元素&#39;Tom&#39;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;数组的push方法在数组、栈和队列中的形式：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数组&lt;/strong&gt;：在数组[0，1，2]中，pop(3)，结果为[0，1，2，3]；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;栈&lt;/strong&gt;：执行pop(0)，pop(1)，pop(2)，pop(3)，从栈底到栈顶的元素分别为：0，1，2，3；如果看成数组，可写为[0，1，2，3]，但是索引为3的元素3其实是栈顶元素；所以说栈的push方法是向栈顶添加元素（但在数组的视角下为向数组尾部添加元素）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;队列&lt;/strong&gt;：enqueue方法可以由数组的push方法实现，与数组相同，相当于在数组尾部添加元素。&lt;br&gt;
可以这样想：栈结构是头朝下（索引值由下往上增大）的数组结构。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612359579513.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1x7411L7Q7?from=search&amp;amp;seid=3912456004602554239&#34;&gt;参考资料:JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现队列结构（Queue）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/javascript-shu-ju-jie-gou-yu-suan-fa-shi-xian-zhan-jie-gou-stack/"" data-c="
          &lt;h1 id=&#34;1前言&#34;&gt;1.前言&lt;/h1&gt;
&lt;h2 id=&#34;11-什么是数据结构&#34;&gt;1.1 什么是数据结构？&lt;/h2&gt;
&lt;p&gt;数据结构就是在计算机中，存储和组织数据的方式。&lt;br&gt;
例如：图书管理，怎样摆放图书才能既能放很多书，也方便取？&lt;/p&gt;
&lt;p&gt;主要需要考虑两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作一：新书怎么插入？&lt;/li&gt;
&lt;li&gt;操作二：怎么找到某本指定的书？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;常见的数据结构：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组（Aarray）&lt;/li&gt;
&lt;li&gt;栈（Stack）&lt;/li&gt;
&lt;li&gt;链表（Linked List）&lt;/li&gt;
&lt;li&gt;图（Graph）&lt;/li&gt;
&lt;li&gt;散列表（Hash）&lt;/li&gt;
&lt;li&gt;队列（Queue）&lt;/li&gt;
&lt;li&gt;树（Tree）&lt;/li&gt;
&lt;li&gt;堆（Heap）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：数据结构与算法与语言无关，常见的编程语言都有&lt;strong&gt;直接或间接&lt;/strong&gt;的使用上述常见的数据结构。&lt;/p&gt;
&lt;h2 id=&#34;12什么是算法&#34;&gt;1.2.什么是算法？&lt;/h2&gt;
&lt;p&gt;算法（Algorithm）的定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个有限指令集，每条指令的描述不依赖于语言；&lt;/li&gt;
&lt;li&gt;接收一些输入（有些情况下不需要输入）；&lt;/li&gt;
&lt;li&gt;产生输入；&lt;/li&gt;
&lt;li&gt;一定在有限步骤之后终止；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;算法通俗理解：解决问题的办法/步骤逻辑。数据结构的实现，离不开算法。&lt;/p&gt;
&lt;h1 id=&#34;2栈结构stack&#34;&gt;2.栈结构（Stack）&lt;/h1&gt;
&lt;h2 id=&#34;21简介&#34;&gt;2.1简介&lt;/h2&gt;
&lt;p&gt;数组是一个线性结构，并且可以在数组的&lt;strong&gt;任意位置&lt;/strong&gt;插入和删除元素。而&lt;strong&gt;栈和队列&lt;/strong&gt;就是比较常见的&lt;strong&gt;受限的线性结构&lt;/strong&gt;。如下图所示：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612336192859.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
栈的特点为&lt;strong&gt;先进后出，后进先出&lt;/strong&gt;（LIFO：last in first out）。&lt;/p&gt;
&lt;p&gt;程序中的栈结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;函数调用栈&lt;/strong&gt;：A（B（C（D（））））：即A函数中调用B，B调用C，C调用D；在A执行的过程中会将A压入栈，随后B执行时B也被压入栈，函数C和D执行时也会被压入栈。所以当前栈的顺序为：A-&amp;gt;B-&amp;gt;C-&amp;gt;D（栈顶）；函数D执行完之后，会弹出栈被释放，弹出栈的顺序为D-&amp;gt;C-&amp;gt;B-&amp;gt;A;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;递归&lt;/strong&gt;：为什么没有停止条件的递归会造成栈溢出？比如函数A为递归函数，不断地调用自己（因为函数还没有执行完，不会把函数弹出栈），不停地把相同的函数A压入栈，最后造成&lt;strong&gt;栈溢出&lt;/strong&gt;（Stack Overfloat）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.练习：题目：有6个元素6，5，4，3，2，1按顺序进栈，问下列哪一个不是合法的出栈顺序？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A：5	4	3	6	1	2	（√）&lt;/li&gt;
&lt;li&gt;B：4 5 3 2 1 6 （√）&lt;/li&gt;
&lt;li&gt;C：3 4 6 5 2 1 （×）&lt;/li&gt;
&lt;li&gt;D：2 3 4 1 5 6 （√）&lt;br&gt;
题目所说的按顺序进栈指的不是一次性全部进栈，而是有进有出，进栈顺序为6 -&amp;gt; 5 -&amp;gt; 4 -&amp;gt; 3 -&amp;gt; 2 -&amp;gt; 1。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A答案：65进栈，5出栈，4进栈出栈，3进栈出栈，6出栈，21进栈，1出栈，2出栈（整体入栈顺序符合654321）;&lt;/li&gt;
&lt;li&gt;B答案：654进栈，4出栈，5出栈，3进栈出栈，2进栈出栈，1进栈出栈，6出栈（整体的入栈顺序符合654321）;&lt;/li&gt;
&lt;li&gt;C答案：6543进栈，3出栈，4出栈，之后应该5出栈而不是6，所以错误；&lt;/li&gt;
&lt;li&gt;D答案：65432进栈，2出栈，3出栈，4出栈，1进栈出栈，5出栈，6出栈。符合入栈顺序；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;栈常见的操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;push（element）：添加一个新元素到栈顶位置；&lt;/li&gt;
&lt;li&gt;pop（）：移除栈顶的元素，同时返回被移除的元素；&lt;/li&gt;
&lt;li&gt;peek（）：返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）；&lt;/li&gt;
&lt;li&gt;isEmpty（）：如果栈里没有任何元素就返回true，否则返回false；&lt;/li&gt;
&lt;li&gt;size（）：返回栈里的元素个数。这个方法和数组的length属性类似；&lt;/li&gt;
&lt;li&gt;toString（）：将栈结构的内容以字符串的形式返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;22封装栈类&#34;&gt;2.2封装栈类&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    // 封装栈类
    function Stack(){
      // 栈中的属性
      this.items =[]

      // 栈的相关操作
      // 1.push():将元素压入栈
      //方式一(不推荐)：给对象添加方法，其他对象不能复用
      // this.push = () =&amp;gt; {
      // }
      
      //方式二(推荐)：给Stack类添加方法，能够多对象复用
      Stack.prototype.push = function(element) {
      // 利用数组item的push方法实现Stack类的pop方法
        this.items.push(element)
      }

      // 2.pop():从栈中取出元素
      Stack.prototype.pop = () =&amp;gt; {
      // 利用数组item的pop方法实现Stack类的pop方法
        return this.items.pop()
      }

      // 3.peek():查看一下栈顶元素
      Stack.prototype.peek = () =&amp;gt; {
        return this.items[this.items.length - 1]
      }

      // 4.isEmpty():判断栈是否为空
      Stack.prototype.isEmpty = () =&amp;gt; {
      // 两个小时的教训啊不是this.length(不是Stack对象的length，Stack类没有length属性啊)，而是			Stack类中定义的数组items才有length属性呀
        return this.items.length == 0 
      }

      // 5.size():获取栈中元素的个数
      Stack.prototype.size = () =&amp;gt; {
        return this.items.length
      }

      // 6.toString():以字符串形式输出栈内数据
      Stack.prototype.toString = () =&amp;gt; {
        //希望输出的形式：20 10 12 8 7
        let resultString = &#39;&#39;
        for (let i of this.items){
          resultString += i + &#39; &#39;
        }
        return resultString
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    // 栈的使用
    let  s = new Stack()
    s.push(20)
    s.push(10)
    s.push(100)
    s.push(77)
    console.log(s)													//65

    console.log(s.pop());											//68
    console.log(s.pop());											//69
    
    console.log(s.peek());											//71
	console.log(s.isEmpty());										//72
   
    console.log(s.size());											//74
    console.log(s.toString());			
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612336478157.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;栈结构的简单应用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;利用栈结构的特点封装十进至转换为二进至的函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;     //简单应用：
    //封装函数：将十进制转成二进制(十转二的运算最后倒叙取余的特点符合栈&#39;先进后出&#39;)
    let dec2bin = decNumber =&amp;gt; {
      //1.定义一个栈对象，保存余数
      var  stack = new Stack()

      // 2.循环操作
      while(decNumber &amp;gt; 0){
        // 2.1.获取余数并放入栈中
        stack.push(decNumber % 2)
        // 2.2.获取整除后的结果作为下一次运算的数字(floor:向下取整)
        decNumber = Math.floor(decNumber / 2)
      }

      // 3.从栈中取出0和1
      let  binaryString = &#39;&#39;;
      let a = stack.items.length
     while(stack.items.length != 0){
        binaryString += stack.pop();
      }
      return binaryString;
    }
    
    //测试代码
    console.log(dec2bin(10));										
    console.log(dec2bin(100));										
    console.log(dec2bin(1000));				
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612336555837.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV1x7411L7Q7?from=search&amp;amp;seid=3912456004602554239&#34;&gt;参考资料：JavaScript数据结构与算法&lt;/a&gt;&lt;/p&gt;
">JavaScript实现栈结构（Stack）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/ji-suan-ji-wang-luo-bi-ji-part6-ying-yong-ceng-application-layer/"" data-c="
          &lt;h1 id=&#34;1-概述&#34;&gt;1. 概述&lt;/h1&gt;
&lt;p&gt;因为不同的网络应用之间需要有一个确定的通信规则&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273015782.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;11-两种常用的网络应用模型&#34;&gt;1.1 两种常用的网络应用模型&lt;/h2&gt;
&lt;h3 id=&#34;111-客户服务器模型clientserver&#34;&gt;1.1.1 客户/服务器模型（Client/Server）&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273041065.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;112-p2p模型peer-to-peer&#34;&gt;1.1.2 P2P模型（Peer-to-Peer）&lt;/h3&gt;
&lt;p&gt;网络健壮性指的是P2P模型不容易坏掉，即使一个节点坏了也没问题，可以有其他节点代替&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273076632.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;2-域名系统协议dns&#34;&gt;2. 域名系统协议（DNS）&lt;/h1&gt;
&lt;h2 id=&#34;21-概述&#34;&gt;2.1 概述&lt;/h2&gt;
&lt;p&gt;DNS就是将打在地址栏的域名转化为IP地址的东西&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273105853.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;211-域名&#34;&gt;2.1.1 域名&lt;/h3&gt;
&lt;p&gt;域名就是www.xxx.com，当然这是最简单的一种&lt;br&gt;
.com之后还可以有东西，称之为根&lt;br&gt;
域名从左向右，级别逐渐增高&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273137155.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273140326.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;22-域名服务器dns服务器&#34;&gt;2.2 域名服务器（DNS服务器）&lt;/h2&gt;
&lt;p&gt;DNS服务器有很多台，根据层次结构分为三层，根域名服务器，顶级域名服务器，权限域名服务器&lt;br&gt;
本地域名服务器不算层次结构，特点是里主机比较近，当主机和另一台比较近的主机通信时，就不用走哪些更高级的服务器了&lt;br&gt;
根域名服务器并不是一个域名只有一台，而是一个域名对应多台域名服务器，全世界一共有13个这样的域名，分别是a.rootservers.net，b.rootservers.net，c.rootservers.net，~m.rootservers.net&lt;br&gt;
在权限域名服务器中，虽然看似abc.com比y.abc.com少了一位，但是他们的&lt;strong&gt;地位仍是对等的&lt;/strong&gt;，对应的两台权限域名服务器&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273183064.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;23-域名解析过程&#34;&gt;2.3 域名解析过程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273223655.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273226529.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;231-递归查询&#34;&gt;2.3.1 递归查询&lt;/h3&gt;
&lt;p&gt;在上图中&lt;br&gt;
主机先是想本地域名服务器发送请求，如果查不到的话，&lt;br&gt;
&lt;code&gt;本地域名服务器&lt;/code&gt;向根域名服务器发送请求（找别人），如果还是查不到的话，&lt;br&gt;
&lt;code&gt;根域名域名服务器&lt;/code&gt;向顶级域名服务器发送请求（找别人），如果还是查不到的话，&lt;br&gt;
&lt;code&gt;顶级域名服务器&lt;/code&gt;向权限域名服务器发送请求（找别人）&lt;br&gt;
可以看到每一次向下一个查询的服务器都变了，不是主机一个个去问，而是&lt;code&gt;服务器自己一个个问下去&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;232-迭代查询&#34;&gt;2.3.2 迭代查询&lt;/h3&gt;
&lt;p&gt;在上图中&lt;br&gt;
主机先是想本地域名服务器发送请求，如果查不到的话，&lt;br&gt;
本地域名服务器就让&lt;code&gt;主机&lt;/code&gt;去向根域名服务器发送请求（主机去找，本地域名给目标根域名服务器的IP地址），如果还是查不到的话，&lt;br&gt;
根域名域名服务器让&lt;code&gt;主机&lt;/code&gt;去向对应的顶级域名服务器发送请求（主机去找，根域名给目标顶级域名服务器的IP地址），如果还是查不到的话，&lt;br&gt;
顶级域名服务器让&lt;code&gt;主机&lt;/code&gt;去向权限域名服务器发送请求（主机去找，顶级域名给目标权限域名服务器的IP地址）&lt;br&gt;
可以看到这里是&lt;code&gt;主机&lt;/code&gt;一个个挨个问的地址&lt;/p&gt;
&lt;h3 id=&#34;233-高速缓存&#34;&gt;2.3.3 高速缓存&lt;/h3&gt;
&lt;p&gt;为了减少多次查询同一个域名的资源浪费，&lt;code&gt;本地域名服务器&lt;/code&gt;会存储最近使用的ip地址解析，下次再访问同一个域名就不需要这么多查询步骤了。同时这个高速缓存&lt;code&gt;主机本身也有存储&lt;/code&gt;&lt;br&gt;
同时本地域名服务器还可以对顶级域名服务器，权限域名服务器的地址进行缓存，下一次即使是不知道的ip地址，查询也可以更快&lt;br&gt;
高速缓存为了保持正确性，需要定时更新&lt;/p&gt;
&lt;h1 id=&#34;3-文件传输协议ftptftp&#34;&gt;3. 文件传输协议（FTP，TFTP）&lt;/h1&gt;
&lt;h2 id=&#34;31-概述&#34;&gt;3.1 概述&lt;/h2&gt;
&lt;p&gt;TFTP是一个轻量的，比较容易实现的，面对小文件的，UDP的文件传输协议&lt;br&gt;
这里我们重点是FTP协议&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273377105.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-ftp的服务端和客户端&#34;&gt;3.2 FTP的服务端和客户端&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273399779.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;33-ftp的工作原理&#34;&gt;3.3 FTP的工作原理&lt;/h2&gt;
&lt;p&gt;为什么有匿名登陆：对于一些公共服务器来说，增加验证阶段就是增加资源开销，减少验证阶段就可以节省资源来更好地服务&lt;br&gt;
主进程和从属进程的区别：主进程是打开端口，让外部发送的数据可以进来，并且将这些数据逐个分配各从属进程。从属进程则是单独为这些数据服务&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273431637.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273434321.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
先注释一下这里的主进程被忽略掉了，只是没标在上面，不是没有啊&lt;br&gt;
这里客户端和服务器端先建立TCP连接，端口是21，称为控制连接&lt;br&gt;
然后看情况是主动建立连接还是被动建立连接&lt;br&gt;
主动建立连接是指服务器端主动发送请求和客户端进行连接，此时端口号固定是20&lt;br&gt;
被动连接是指客户端发送请求和服务器端建立数据传送连接，此时端口号是不确定，有两者协商得到&lt;br&gt;
数据传输完成之后，数据连接断开，控制连接继续保持，直至两边发送断开请求&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273448354.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;FTP的两种传输模式了解即可&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273464576.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;4-电子邮件&#34;&gt;4. 电子邮件&lt;/h1&gt;
&lt;h2 id=&#34;41-概述&#34;&gt;4.1 概述&lt;/h2&gt;
&lt;h3 id=&#34;411-电子邮件的格式&#34;&gt;4.1.1 电子邮件的格式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273598681.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;412-电子邮件系统的组成结构&#34;&gt;4.1.2 电子邮件系统的组成结构&lt;/h3&gt;
&lt;p&gt;注释：&lt;br&gt;
用户代理的四个功能解释：&lt;br&gt;
撰写就是给用户编辑信件的环境&lt;br&gt;
显示就是可以看到自己写的和自己收的信件内容&lt;br&gt;
处理就是对信件进行操作，包括删除，打印，转发等等&lt;br&gt;
通信就是可以将邮件发送到&lt;strong&gt;邮件服务器当中&lt;/strong&gt;，同时可以从&lt;strong&gt;邮件服务器当中&lt;/strong&gt;读取邮件&lt;/p&gt;
&lt;p&gt;邮件服务器的功能注释&lt;br&gt;
邮件服务器端的发送和接受是指从自己的&lt;strong&gt;用户代理处接收邮件&lt;/strong&gt;，之后&lt;strong&gt;向对面的邮件服务器发送邮件&lt;/strong&gt;&lt;br&gt;
邮件服务器的报告邮件发送结果就是投递是否成功这种情况&lt;br&gt;
邮件服务器既可以作为客户端又可以作为服务器端，使用的是C/S方式&lt;/p&gt;
&lt;p&gt;协议的功能注释&lt;br&gt;
发邮件用的是SMTP&lt;br&gt;
收邮件的是POP3或者IMAP&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273640637.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273652798.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;42-几个邮件协议&#34;&gt;4.2 几个邮件协议&lt;/h2&gt;
&lt;h3 id=&#34;421-简单邮件传送协议smtp&#34;&gt;4.2.1 简单邮件传送协议SMTP&lt;/h3&gt;
&lt;p&gt;注意一下，这里STMP客户和服务器不是固定死的，可以也可以成为服务器，服务器也可以成为用户，由发送方和接收方决定，发送方就是客户，接收方就是服务器&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273682225.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注释&lt;br&gt;
可以看见这里比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;220 service ready
250 OK
421 service not available
550 xxx
354 xxx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;都是应答信息&lt;/p&gt;
&lt;p&gt;这里RCPT能有多条命令的原因是，电子邮件可以有多个收件人，就是群发，所以允许多个RCPT&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;再强调一下，这里服务器和客户端可以互换，视具体情况而定，发送方是客户端，接收方是服务器端&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273748438.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;422-改进smtp缺点的mime协议&#34;&gt;4.2.2 改进SMTP缺点的MIME协议&lt;/h3&gt;
&lt;p&gt;MIME改善SMTP发送数据的缺点，是SMTP的功能性扩展&lt;br&gt;
MIME协议已经逐渐开始应用到浏览器当中，通过对不同文件类型用不同的标识符标识，来让浏览器读取通过MIME的相关文件&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273765867.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;423-邮局协议pop3&#34;&gt;4.2.3 邮局协议POP3&lt;/h3&gt;
&lt;p&gt;这里接收方是客户端，邮件服务器是服务器端&lt;br&gt;
POP3确实很简单，但是有不少缺点，比较难受的就是邮件一旦下载就自动删除了&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273790716.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;424-比较复杂的读取邮件的协议imap协议&#34;&gt;4.2.4 比较复杂的读取邮件的协议——IMAP协议&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273808897.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;43-基于万维网的电子邮件&#34;&gt;4.3 基于万维网的电子邮件&lt;/h2&gt;
&lt;p&gt;与之前的不同的地方就是，基于万维网的电子邮件的&lt;strong&gt;邮件服务器端可以不同&lt;/strong&gt;&lt;br&gt;
同时，发送邮件使用的SMTP/MIME和收邮件时的POP3/IMAP协议都&lt;strong&gt;换成了HTTP协议&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273840716.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;5-万维网和http协议&#34;&gt;5. 万维网和HTTP协议&lt;/h1&gt;
&lt;h2 id=&#34;51-万维网概述&#34;&gt;5.1 万维网概述&lt;/h2&gt;
&lt;p&gt;URL用来标识整个互联网当中的某一个资源（文字，视屏，音频等）的位置&lt;/p&gt;
&lt;p&gt;HTTP用来将这些资源传送给用户&lt;/p&gt;
&lt;p&gt;HTML帮助设计者来设计页面，让不同设计者设计的页面都可以在界面上显示&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273871245.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;52-http协议&#34;&gt;5.2 HTTP协议&lt;/h2&gt;
&lt;h3 id=&#34;521-http协议的过程&#34;&gt;5.2.1 HTTP协议的过程&lt;/h3&gt;
&lt;p&gt;这张图里讲了HTTP的具体过程&lt;/p&gt;
&lt;p&gt;服务器通过TCP 80端口来监听HTTP请求&lt;/p&gt;
&lt;p&gt;注意HTTP可以不一次性下载完页面的所有资源，可以只下载文本部分，其他音频视频等待用户下一步请求之后再传输&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273896774.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;522-http协议的特点&#34;&gt;5.2.2 HTTP协议的特点&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273916610.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;523-http的连接方式持久连接和非持久连接&#34;&gt;5.2.3 HTTP的连接方式——持久连接和非持久连接&lt;/h3&gt;
&lt;p&gt;非持久连接在TCP三次握手的第三次握手时发生，将HTTP请求作为第三次握手的数据部分发给服务器，服务器收到请求之后将HTTP相应报文传输给客户。耗时就是RTT*2+文档传输时间。&lt;br&gt;
缺点就是这样如果再想传输，那么就需要重新建立TCP连接从头开始&lt;/p&gt;
&lt;p&gt;持久连接和非持久连接类似，都是在第三次握手时发生，将HTTP请求作为第三次握手的数据部分发给服务器，服务器收到请求之后将HTTP相应报文传输给客户。但是持久连接再需要请资源的时候就不需要建立新的TCP连接了&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612273937976.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;持久连接的两种方式非流水线和流水线&#34;&gt;持久连接的两种方式——非流水线和流水线&lt;/h2&gt;
&lt;p&gt;非流水线就是发一个，确认一个，才能再发下一个&lt;br&gt;
流水线就是一个个连着发，然后多个确认&lt;br&gt;
和之前说过的停止等待协议，后退N帧协议和选择重传协议很像，忘了的话可以去复习一下&lt;br&gt;
开个传送门&lt;a href=&#34;https://ttarea.com/post/ji-suan-ji-wang-luo-bi-ji-part3-shu-ju-lian-lu-ceng-data-link-layer/&#34;&gt;计算机网络笔记Part3 数据链路层（Data Link Layer）&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;524-http的报文结构&#34;&gt;5.2.4 HTTP的报文结构&lt;/h3&gt;
&lt;p&gt;开始行用于区别请求报文和响应报文。可以明显的看到两者第一行的东西都不一样&lt;/p&gt;
&lt;p&gt;请求报文的方法是指命令，就是对所请求的对象进行什么操作，如获取/删除等等&lt;br&gt;
URL就是之间说的资源标识符&lt;br&gt;
版本是指使用的是什么版本的HTTP协议&lt;/p&gt;
&lt;p&gt;CRLF相当于我们程序里面的；，标识一行的结束。同时，在整个首部行结束时，为了区别首部行和实体主体还会有一行单独的CRLF&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612274029654.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里举了请求报文的例子，和一些常用的状态码&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612274047064.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;6-本章思维导图&#34;&gt;6. 本章思维导图&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612274078846.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;本章常用中英文对照&#34;&gt;本章常用中英文对照&lt;/h1&gt;
&lt;p&gt;Server farm 服务器集群&lt;br&gt;
Infrastructure 基础设施，或基础架构&lt;br&gt;
Self-scalability 自扩展性&lt;br&gt;
Timing 实时性&lt;br&gt;
Connection-oriented service 面向连接的服务&lt;br&gt;
Base HTML file 基本HTML文件&lt;br&gt;
Stateless protocol 无状态协议&lt;br&gt;
RTT (round-trip time ) 往返时间&lt;br&gt;
User agents 用户代理&lt;br&gt;
Mail servers 邮件服务器&lt;br&gt;
Top-level domain (TLD) servers 顶级域名服务器&lt;br&gt;
Authoritative DNS servers P161 权威域名服务器&lt;br&gt;
Iterative queries 迭代查询&lt;br&gt;
Resource records (RRs) 资源记录&lt;br&gt;
Nonpersistent HTTP 非持久HTTP，或非坚持HTTP&lt;br&gt;
Persistent HTTP 持久性HTTP，或坚持的HTTP&lt;br&gt;
Peer-to-Peer (P2P) Network 对等网络&lt;br&gt;
Socket programming 套接字编程&lt;/p&gt;
&lt;p&gt;参考资料&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV19E411D78Q?p=1&#34;&gt;2019 王道考研 计算机网络&lt;/a&gt;&lt;/p&gt;
">计算机网络笔记Part6 应用层（Application Layer）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/ji-suan-ji-wang-luo-bi-ji-part5-chuan-shu-ceng-transport-layer/"" data-c="
          &lt;h1 id=&#34;1-概述&#34;&gt;1. 概述&lt;/h1&gt;
&lt;h2 id=&#34;11-传输层的意义&#34;&gt;1.1 传输层的意义&lt;/h2&gt;
&lt;p&gt;网络层可以把数据从一个主机传送到另一个主机，但是没有和进程建立联系。&lt;br&gt;
传输层就是讲进程和收到的数据联系到一起，使数据能够为应用服务&lt;br&gt;
所以说传输层是主机才有的层次&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612264339876.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;12-传输层的两个协议&#34;&gt;1.2 传输层的两个协议&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612264374947.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;13-传输层的寻址和端口&#34;&gt;1.3 传输层的寻址和端口&lt;/h2&gt;
&lt;p&gt;端口号只用于计算机分辨本地进程，总共有2^16=65536种端口号，端口号有很多种，不能随便使用&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612264395717.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;131-常见的应用程序端口号&#34;&gt;1.3.1 常见的应用程序端口号&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612264419074.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;2-udp协议&#34;&gt;2. UDP协议&lt;/h1&gt;
&lt;h2 id=&#34;21-udp概述&#34;&gt;2.1 UDP概述&lt;/h2&gt;
&lt;p&gt;注释：&lt;br&gt;
因为UDP一次发送一个完整报文不会分片，所以需要应用层传输过来的数据不要太大，否则网络层分片任务就很重，但是也不能太小，不然效率较低&lt;br&gt;
UDP适合一些实时应用，因为实时应用延迟要求高，需要立即响应&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612264447032.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;22-udp首部格式&#34;&gt;2.2 UDP首部格式&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612264472057.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;221-udp的校验位构成&#34;&gt;2.2.1 UDP的校验位构成&lt;/h3&gt;
&lt;p&gt;这里的伪首部只是用来计算检验和的，计算完了就丢弃，可以见下UDP的校验方式&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612264492450.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;222-udp校验方式&#34;&gt;2.2.2 UDP校验方式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;总结一下步骤：&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;在发送端的时候：&lt;/strong&gt;&lt;br&gt;
1.就是将每一行（4字节）拆成两部分，左右平均2字节大小，将这两字节数据写成二进制，那么2字节一共就需要2*8=16位。此时检验和没有计算，默认填充0，同时如果数据字段不整齐，则用0补齐，这样就可以写出几十行二进制数，如图中方所示&lt;br&gt;
2.计算着几十行二进制数按&lt;strong&gt;二进制反码运算求和&lt;/strong&gt;，二进制反码运算可以参考&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/jcchan/p/10400504.html&#34;&gt;二进制反码求和运算&lt;/a&gt;&lt;br&gt;
得到的最后简介再反码，之后将&lt;strong&gt;反码之后&lt;/strong&gt;的放入原来的检验和字段&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在接收端的时候&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;与发送端的时候不同的是，此时检验和字段不是0了&lt;/strong&gt;&lt;br&gt;
按照发送端的步骤再将所有数据写成二进制进行二进制反码运算求和&lt;br&gt;
如果最后得到结果全1就是没问题，否则丢弃&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612264590178.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-tcp协议&#34;&gt;3. TCP协议&lt;/h1&gt;
&lt;h2 id=&#34;31-tcp协议的特点&#34;&gt;3.1 TCP协议的特点&lt;/h2&gt;
&lt;p&gt;TCP必须要建立连接之后才可以进行数据交换，所以TCP是面向连接的&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612271954885.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
TCP传输数据是随机切割数据的&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612271959573.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-tcp报文段的首部&#34;&gt;3.2 TCP报文段的首部&lt;/h2&gt;
&lt;p&gt;注释：&lt;br&gt;
见上图，可以看到TCP是将数据随机分割后加上TCP头传输的，所以序号就是为了标记这些随机分割之后的数据，这里把第一个字节的编号当成序号。&lt;br&gt;
确认号就是收到之后做一下标记，代表这之前的都收到了，希望收到的下一个编号的数据就是确认号打头的那个数据。&lt;br&gt;
偏移量就是为了标记一下距离TCP开始多少字节是数据，这里的单位是4B，这个偏移量就是TCP首部长度。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612271997941.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
窗口就是接收方告诉发送方，还有多少地方（缓存）可以放数据&lt;br&gt;
紧急指针就是告诉TCP从哪里到哪里是紧急数据&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272021989.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;321-tcp的六个控制位&#34;&gt;3.2.1 TCP的六个控制位&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;紧急位URG&lt;/code&gt;&lt;br&gt;
URG的特点就是让数据&lt;strong&gt;插队&lt;/strong&gt;，URG=1的就会在缓存中被提前到第一个传输&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272088545.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272102301.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;确认位ACK&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272129028.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;推送位PSH&lt;/code&gt;&lt;br&gt;
就是接收端的URG，将PSH=1的数据尽快接收&lt;br&gt;
注意一下，如果没有PSH，一般都是接收方缓存满了之后再将数据发送到主机&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272160110.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;复位RST&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272172344.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;同步位SYN&lt;/code&gt;&lt;br&gt;
A和B主机要建立连接，就A先发一个报文，其中SYN=1&lt;br&gt;
B收到之后也回复一个SYN=1的报文，代表接受连接&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272207838.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;终止位FIN&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272235086.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️&lt;/p&gt;
&lt;h2 id=&#34;33-tcp连接管理&#34;&gt;3.3 TCP连接管理&lt;/h2&gt;
&lt;h2 id=&#34;331-tcp三次握手建立连接&#34;&gt;3.3.1 TCP三次握手（建立连接）&lt;/h2&gt;
&lt;p&gt;注释：&lt;br&gt;
第一段的意思是&lt;br&gt;
SYN=1：(A)要建立连接了！&lt;br&gt;
seq=x（随机）：因为还没有数据，所以写什么都无所谓&lt;/p&gt;
&lt;p&gt;第二段的意思是&lt;br&gt;
SYN=1：我(B)同意你(A)建立连接！&lt;br&gt;
ACK=1：连接建立了，之后的ACK必须都置为1&lt;br&gt;
seq=y（随机）：因为还没有数据，所以写什么都无所谓&lt;br&gt;
ack=x+1：之前发送方(A)说发送的是第x位数据（虽然发送方是瞎说的），所以我(B)要的是x+1位数据&lt;/p&gt;
&lt;p&gt;第三段的意思是&lt;br&gt;
SYN=0：SYN只有在建立连接时才为1，其他时候均设为0&lt;br&gt;
ACK=1：连接建立了，之后的ACK必须都置为1&lt;br&gt;
seq=x+1：我(A)发送的报文段的第一个字节就是x+1&lt;br&gt;
ack=y+1：之前接收方(B)说发送的是第y位数据（虽然接收方是瞎说的），所以我(A)要的是y+1位数据&lt;/p&gt;
&lt;p&gt;注意一下，TCP是双向的，所以不存在绝对不变的发送方接收方，这里的两台主机都同时是发送方和接收方&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272302854.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TCP三次握手特定导致的SYN洪泛攻击&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272318640.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️❗️&lt;/p&gt;
&lt;h3 id=&#34;332-tcp四次挥手连接释放&#34;&gt;3.3.2 TCP四次挥手（连接释放）&lt;/h3&gt;
&lt;p&gt;注释：&lt;br&gt;
第一段的意思是&lt;br&gt;
FIN=1：(A)要释放连接了！&lt;br&gt;
seq=u：发了好多数据，这里只是用u指代一下，这里u是有确定值的&lt;/p&gt;
&lt;p&gt;第二段的意思是&lt;br&gt;
ACK=1：连接建立了，之后的ACK必须都置为1&lt;br&gt;
seq=v：发了好多数据，这里只是用v指代一下，这里v是有确定值的&lt;br&gt;
ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（尽管此时A已经决定释放连接了）&lt;/p&gt;
&lt;p&gt;第三段的意思是&lt;br&gt;
FIN=1：(B)要释放连接了！&lt;br&gt;
ACK=1：连接建立了，之后的ACK必须都置为1&lt;br&gt;
seq=w：发了好多数据，这里只是用w指代一下，这里w是有确定值的&lt;br&gt;
ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（因为A直接不发数据了，所以第二段第三段的ack都是u+1）&lt;/p&gt;
&lt;p&gt;第四段的意思是&lt;br&gt;
ACK=1：连接建立了，之后的ACK必须都置为1&lt;br&gt;
seq=u+1：之前发的数据时第u位数据，B也要第u+1位数据，所以我发第u+1位数据&lt;br&gt;
ack=w+1：之前发送方(B)说发送的是第w位数据，所以我(A)要的是w+1位数据&lt;/p&gt;
&lt;p&gt;为什么需要等待计时2MSL？&lt;br&gt;
因为这样可以保证B可以收到A的终止报文段进而进入关闭状态&lt;br&gt;
比如说如果A的第四段报文丢失，那么等待一个MSL之后B就会重传第三段报文，花费小于1MSL之后A就会再收到第三段报文，之后就可以再次向B发送第四段报文提示B关闭连接&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272433783.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;34-tcp可靠传输&#34;&gt;3.4 TCP可靠传输&lt;/h2&gt;
&lt;p&gt;TCP是提供可靠传输，UDP这种本身还是不可靠传输的就再靠应用层解决了&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272456274.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;341-序号&#34;&gt;3.4.1 序号&lt;/h3&gt;
&lt;p&gt;就是TCP根据下方数据链路层的MTU（最大传输单元）来随即将数据切割成好几端并且进行编号&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272493105.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;342-确认&#34;&gt;3.4.2 确认&lt;/h3&gt;
&lt;p&gt;发送方每一次发送数据之后都需要接收方进行确认。&lt;br&gt;
TCP使用的是累计确认机制，就是从第一个丢失的字节开始请求丢失的报文段。如图中456丢失，78到达，但仍然请求发送的数据序号是4&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272519527.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;343-重传&#34;&gt;3.4.3 重传&lt;/h3&gt;
&lt;p&gt;为什么要使用自适应算法？网络环境太复杂，路径又长又短，RTT设置短了照顾不了距离远的，RTT设置长了又导致网络利用率降低，所以使用RTTs&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272538461.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;35-tcp流量控制&#34;&gt;3.5 TCP流量控制&lt;/h2&gt;
&lt;p&gt;简单来说就是接收方可以动态的发送信息告诉发送方发送窗口的大小。&lt;br&gt;
接收方接受不过来了就让发送方发送窗口小点，这样发送方发送的速率就慢下来了，接收方就有时间处理它的数据了&lt;br&gt;
接受方处理完了也可以发送请求让发送方发送窗口大点，这样发送方发送的速率就快起来了，接收方就可以处理更多数据而不是空闲等着收数据了&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272568911.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;351-计时器&#34;&gt;3.5.1 计时器&lt;/h3&gt;
&lt;p&gt;在本例子中，使用的累计确认机制（一次回复收到ack=201）和三次流量控制机制。&lt;br&gt;
但是有一个情况就是，如果最后B不允许A再发送数据了，B在处理完数据之后想要恢复窗口大小时发送的有rwnd大小的数据报丢了怎么办？此时A有B的指令在前，发送窗口为0无法发送数据，B也在等待A回复，造成了类似死锁的现象&lt;br&gt;
解决方法：使用计时器&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272591905.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;36-tcp拥塞控制&#34;&gt;3.6 TCP拥塞控制&lt;/h2&gt;
&lt;p&gt;流量控制是对单独一个来说的，拥塞控制是一群&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272745809.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;361-拥塞控制四种算法&#34;&gt;3.6.1 拥塞控制四种算法&lt;/h3&gt;
&lt;p&gt;这里虽然是四种算法，但是通常是两两结合进行使用&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272768432.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;362-慢开始和拥塞避免&#34;&gt;3.6.2 慢开始和拥塞避免&lt;/h3&gt;
&lt;p&gt;这里开始时以&lt;strong&gt;指数形式增长&lt;/strong&gt;，ssthresh的意思是慢开始门限，代表从这个地方注入的报文段就比较多了，需要开始慢速增加了。&lt;br&gt;
之后一段都是&lt;strong&gt;线性增长&lt;/strong&gt;，每次增加1，直至达到网络拥塞状态&lt;br&gt;
瞬间将cwnd设置为1，同时调整原来的ssthresh的值到之前达到网络拥塞状态的1/2,（这里是24降到12）&lt;br&gt;
重复以上步骤，但是注意此时ssthresh变了之后线性增长的转折点也变了&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272809278.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;363-快重传和快恢复&#34;&gt;3.6.3 快重传和快恢复&lt;/h3&gt;
&lt;p&gt;这里和上面的慢开始和拥塞避免的一开始步骤差不多，都是先指数增长再转变为线性增长。&lt;br&gt;
不同的点是快重传和快恢复算法是在收到连续的ack确认之后执行，这里的ack就是冗余ack，冗余ack的特点是如果多次对某一段请求的数据没有被收到，达到一定数目之后就会立即执行重传。但是此时只是降到现在cwnd的一半，再重新线性增长。而不是像慢开始和拥塞避免的从头开始&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272834927.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;4-本章思维导图&#34;&gt;4. 本章思维导图&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612272877495.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;本文常用名词中英文对照&#34;&gt;本文常用名词中英文对照&lt;/h1&gt;
&lt;p&gt;Multiplexing and demultiplexing 复用与分用&lt;br&gt;
Positive acknowledgments 肯定确认&lt;br&gt;
Negative acknowledgments 否定确认&lt;br&gt;
Countdown timer （倒数）计时器&lt;br&gt;
Cumulative acknowledgment 累积确认&lt;br&gt;
Receive buffer 接收缓冲区，或接收缓存&lt;br&gt;
Resource-management cells 资源管理单元&lt;br&gt;
Source (port number) 源端口号&lt;br&gt;
Destination (port number) 目的端口号&lt;br&gt;
Checksum 校验和&lt;br&gt;
Pipelined protocols 流水线（型）协议&lt;br&gt;
Go-back-N 回退N&lt;br&gt;
Selective Repeat 选择重传&lt;br&gt;
Timeout （定时器）超时&lt;br&gt;
Fast Retransmit 快速重传&lt;br&gt;
Flow Control 流量控制&lt;br&gt;
Three way handshake 三次握手&lt;br&gt;
sequence number 序列号（简写为seq）&lt;br&gt;
acknowledgement number 确认号（简写为ack；注意与大小的ACK不同）&lt;br&gt;
Congestion Control 拥塞控制&lt;br&gt;
additive increase, multiplicative decrease 加性增乘性减&lt;br&gt;
Slow Start 慢启动&lt;br&gt;
congestion-avoidance 拥塞避免&lt;br&gt;
fast recovery 快速恢复&lt;br&gt;
duplicate (ACK) 冗余（ACK）&lt;br&gt;
Random Early Detection 随机早期检测&lt;/p&gt;
&lt;p&gt;参考资料&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV19E411D78Q?p=1&#34;&gt;2019 王道考研 计算机网络&lt;/a&gt;&lt;/p&gt;
">计算机网络笔记Part5 传输层（Transport Layer）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/22/"" data-c="
          &lt;h1 id=&#34;1tcp报文格式&#34;&gt;1.TCP报文格式&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1611559421318.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;1、端口号&lt;/strong&gt;：用来标识同一台计算机的不同的应用进程。&lt;br&gt;
&lt;strong&gt;1）源端口&lt;/strong&gt;：源端口和IP地址的作用是标识报文的返回地址。&lt;br&gt;
&lt;strong&gt;2）目的端口&lt;/strong&gt;：端口指明接收方计算机上的应用程序接口。&lt;br&gt;
&lt;code&gt;TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、序号和确认号&lt;/strong&gt;：是TCP可靠传输的关键部分。&lt;strong&gt;序号&lt;/strong&gt;是本报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节一个序号。e.g.一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性。&lt;strong&gt;确认号&lt;/strong&gt;，即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、数据偏移／首部长度&lt;/strong&gt;：4bits。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32/8 = 60，&lt;code&gt;故报头最大长度为60字节&lt;/code&gt;。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、保留&lt;/strong&gt;：为将来定义新的用途保留，现在一般置0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、控制位&lt;/strong&gt;：URG  ACK  PSH  RST  SYN  FIN，共6个，每一个标志位表示一个控制功能。&lt;br&gt;
&lt;strong&gt;1）URG&lt;/strong&gt;：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。&lt;br&gt;
&lt;strong&gt;2）ACK&lt;/strong&gt;：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。&lt;br&gt;
&lt;strong&gt;3）PSH&lt;/strong&gt;：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。&lt;br&gt;
&lt;strong&gt;4）RST&lt;/strong&gt;：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。&lt;br&gt;
&lt;strong&gt;5）SYN&lt;/strong&gt;：同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。&lt;br&gt;
&lt;strong&gt;6）FIN&lt;/strong&gt;：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、窗口&lt;/strong&gt;：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、校验和&lt;/strong&gt;：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8、紧急指针&lt;/strong&gt;：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9、选项和填充&lt;/strong&gt;：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10、数据部分&lt;/strong&gt;： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。&lt;/p&gt;
&lt;h1 id=&#34;2三次握手&#34;&gt;2.三次握手&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612076354558.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
TCP/IP 协议是传输层的一个面向连接的安全可靠的一个传输协议，三次握手的机制是为了保证能建立一个安全可靠的连接，那么第一次握手是由客户端发起，客户端会向服务端发送一个报文，在报文里面：SYN标志位置为1，表示发起新的连接。当服务端收到这个报文之后就知道客户端要和我建立一个新的连接，于是服务端就向客户端发送一个确认消息包，在这个消息包里面：ack标志位置为1，表示确认客户端发起的第一次连接请求。以上两次握手之后，对于客户端而言：已经明确了我既能给服务端成功发消息，也能成功收到服务端的响应。但是对于服务端而言：两次握手是不够的，因为到目前为止，服务端只知道一件事，客户端发给我的消息我能收到，但是我响应给客户端的消息，客户端能不能收到我是不知道的。所以，还需要进行第三次握手，第三次握手就是当客户端收到服务端发送的确认响应报文之后，还要继续去给服务端进行回应，也是一个ack标志位置1的确认消息。通过以上三次连接，不管是客户端还是服务端，都知道我既能给对方发送消息，也能收到对方的响应。那么，这个连接就被安全的建了。&lt;/p&gt;
&lt;h1 id=&#34;3-为什么两次握手不行&#34;&gt;3. 为什么两次握手不行？&lt;/h1&gt;
&lt;p&gt;谢希仁版《计算机网络》中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”&lt;/p&gt;
&lt;p&gt;这个例子很清晰的阐释了“三次握手”对于建立可靠连接的意义。&lt;/p&gt;
&lt;p&gt;在Google Groups的TopLanguage中看到一帖讨论TCP“三次握手”觉得很有意思。贴主提出“TCP建立连接为什么是三次握手？”的问题，在众多回复中，有一条回复写道：“&lt;code&gt;这个问题的本质是, 信道不可靠,&lt;/code&gt; 但是通信双发需要就某个问题达成一致. 而要解决这个问题,  无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足&amp;quot;&lt;code&gt;在不可靠信道上可靠地传输信息&lt;/code&gt;&amp;quot;这一需求所导致的. 请注意这里的本质需求,信道不可靠, 数据传输要可靠. 三次达到了, 那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了. 因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到, 或者你不关心是否要保证对方收到你的消息, 那就能像UDP那样直接发送消息就可以了.”。这可视为对“三次握手”目的的另一种解答思路。&lt;/p&gt;
&lt;p&gt;后面一段话意思就是如果想确定双通道通畅，必须使用三个包的发送接收，也就是三次握手&lt;/p&gt;
&lt;h1 id=&#34;4四次挥手&#34;&gt;4.四次挥手&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612076620053.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
四次握手机制也是由客户端去发起，客户端会发送一个报文，在报文里面FIN位标志位置一，当服务端收到这个报文之后，我就知道了客户端想要和我断开连接，但是此时服务端不一定能做好准备，因为当客户端发起断开连接的这个消息的时候，对于服务端而言，他和还有可能有未发送完的消息，他还要继续发送，所以呢，此时对于服务端而言，我只能进行一个消息确认，就是我先告诉服务端，我知道你要给我断开连接了，但是我这里边还可能没有做好准备，你需要等我一下，等会儿我会告诉你，于是呢，发完这个消息确认包之后，可能稍过片刻它就会继续发送一个断开连接的一个报文啊，也是一个FIN位置1的报文也是由服务端发给客户端的啊，这个报文表示服务端已经做好了断开连接的准备，那么当这个报文发给客户端的时候，客户端同样要给服务端继续发送一个消息确认的报文一共有四次，那么，通过这四次的相互沟通和连接，我就知道了，不管是服务端还是客户端都已经做好了断开连接的准备，于是连接就可以被断开啊，这是我对三次握手和四次挥手的一个理解。&lt;/p&gt;
">TCP报文——三次握手&四次挥手</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/ji-suan-ji-wang-luo-bi-ji-part4-wang-luo-ceng-network-layer/"" data-c="
          &lt;h1 id=&#34;1-概述&#34;&gt;1. 概述&lt;/h1&gt;
&lt;p&gt;注释：&lt;br&gt;
数据报和分组的关系：分组是一段比较长的数据，将它进行切割成一段段之后就得到数据报&lt;br&gt;
功能一就是让数据在路由器之间走最佳的路径&lt;br&gt;
功能二就是让不同的设备（手机，电脑，平板等）都能正常连接&lt;br&gt;
功能三见图中解释&lt;br&gt;
开环控制就是在拥塞之前就提前设计解决&lt;br&gt;
闭环控制就是在拥塞时自动调整解决问题&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612095965455.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;OSI参考模型&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;各层次的传输单元&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;应用层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;报文&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;传输层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;报文段&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;网络层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IP数据报，分组（如果IP数据报太大就切割成分组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据链路层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;帧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;物理层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;比特流&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;2-数据交换方式&#34;&gt;2. 数据交换方式&lt;/h1&gt;
&lt;p&gt;为什么要进行数据交换？因为每个节点之间都拉网线太麻烦了也不实际，所以通过大量交换设备互联进行数据交换&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096463674.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;21-电路交换&#34;&gt;2.1 电路交换&lt;/h2&gt;
&lt;p&gt;常见的例子：打电话&lt;br&gt;
注释：&lt;br&gt;
链路支持多路复用（可参考数据链路层的TDM等）&lt;br&gt;
特点是独占资源，因为两者建立了连接&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096503276.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;22-报文交换&#34;&gt;2.2 报文交换&lt;/h2&gt;
&lt;p&gt;注释：报文发送的过程&lt;br&gt;
1.源先根据报文加上ip地址，物理地址等，通过物理层发送&lt;br&gt;
2.交换机收到报文之后，先进行存储，等待链路空闲之后进行转发，但是转发的路径不是固定的，是比较随机的&lt;br&gt;
3.最后通过许多交换机最终到达目的地&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096535503.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;23-分组交换&#34;&gt;2.3 分组交换&lt;/h2&gt;
&lt;p&gt;分组交换和报文交换基本相同，就是将报文切割之后再进行发送&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096614492.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;24-分组交换和报文交换的具体计算对比&#34;&gt;2.4 分组交换和报文交换的具体计算对比&lt;/h2&gt;
&lt;p&gt;注释：是怎么计算的？&lt;br&gt;
报文交换：一共三段，每段都需要10000bit/1000bps=10s，三段就是3x10=30s&lt;br&gt;
分组交换：可以分为两段，一个是第一个数据开始发到最后一个数据从源发出，一段是最后一个数据到达目的地。第一段总时间是10000bit/1000bps=10s，第二段总时间是（10/1000）*2=0.02s，所以总时间是10.02s。&lt;br&gt;
理解一下，这里就是报文交换的时候，由于报文没有分割，所以即使先到的数据也不能先发走，只能等到最后一段报文全部到了之后才能一起走，相对于分组交换明显拖慢了前面数据的速度，所以导致报文交换明显慢于分组交换。&lt;br&gt;
可以看到分组交换明显快于报文交换，所以我们通常使用分组交换&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096647245.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;241-分组传输的两种传输方式-数据报与虚电路&#34;&gt;2.4.1 分组传输的两种传输方式-数据报与虚电路&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;综述&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096711651.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096715380.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据报&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096731409.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虚电路&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096762230.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-路由算法和路由协议概述&#34;&gt;3. 路由算法和路由协议概述&lt;/h1&gt;
&lt;p&gt;路由算法就是让路由知道收到报文之后下一步怎么走&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096787286.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
AS就是多个路由器之间构成的单独的小圈子，圈子内使用自己的协议，圈子和圈子之间用的是BGP协议&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096806087.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;31-rip协议和距离向量算法&#34;&gt;3.1 RIP协议和距离向量算法&lt;/h2&gt;
&lt;h3 id=&#34;311-rip协议概述&#34;&gt;3.1.1 RIP协议概述&lt;/h3&gt;
&lt;p&gt;通过交换信息构建路由表&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096856709.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;312-如何建立路由表&#34;&gt;3.1.2 如何建立路由表&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096869111.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;313-rip协议报文格式&#34;&gt;3.1.3 RIP协议报文格式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096886347.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;314-rip协议特点&#34;&gt;3.1.4 RIP协议特点&lt;/h3&gt;
&lt;p&gt;就是来回更新路由表，错误信息被覆盖，导致直至达到距离上限强制错误时才可以得知出错&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096940327.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096944098.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096947518.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612096950613.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;315-距离向量算法&#34;&gt;3.1.5 距离向量算法&lt;/h3&gt;
&lt;p&gt;注释：&lt;br&gt;
为什么改地址？因为图中是从x得到的信息&lt;br&gt;
为什么距离固定+1？因为路由器只从相邻路由器之间获取RIP报文，举例只会是1&lt;br&gt;
为什么下一跳是x就要替换？因为网络环境不断变化，可能这次某个节点挂掉，所以保持最新的&lt;br&gt;
为什么下一跳不是x时有更新和不处理两种手段？因为这样可以提高效率，比原来快就换，比原来慢就保留原来的，也可以理解&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097004430.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097008383.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097012997.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-ospf协议和链路状态算法&#34;&gt;3.2 OSPF协议和链路状态算法&lt;/h2&gt;
&lt;h3 id=&#34;321-ospf协议概述&#34;&gt;3.2.1 OSPF协议概述&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097042017.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;322-ospf的其他特点&#34;&gt;3.2.2 OSPF的其他特点&lt;/h3&gt;
&lt;p&gt;为什么OSPF收敛速度快？因为它只是刷新一下链路状态，得知其是否连通，不需要和RIP一样进行对照，而是直接通过Dijilstra算法来自己算出路径&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097062831.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;323-链路状态路由算法&#34;&gt;3.2.3 链路状态路由算法&lt;/h3&gt;
&lt;p&gt;了解即可&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097087324.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;324-ospf区域&#34;&gt;3.2.4 OSPF区域&lt;/h3&gt;
&lt;p&gt;了解即可&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097205918.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;325-ospf分组&#34;&gt;3.2.5 OSPF分组&lt;/h3&gt;
&lt;p&gt;了解即可&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097230145.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;33-bgp协议&#34;&gt;3.3 BGP协议&lt;/h2&gt;
&lt;h3 id=&#34;331-bgp协议简介&#34;&gt;3.3.1 BGP协议简介&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097260741.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;332-bgp协议交换信息的过程&#34;&gt;3.3.2 BGP协议交换信息的过程&lt;/h3&gt;
&lt;p&gt;了解即可，只需要知道BGP交换协议里面交换的是一组路径向量&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097302736.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097305652.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097309001.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;333-bgp协议报文格式&#34;&gt;3.3.3 BGP协议报文格式&lt;/h3&gt;
&lt;p&gt;BGP是应用层协议&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097339499.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;334-bgp协议特点&#34;&gt;3.3.4 BGP协议特点&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097372931.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;335-bgp的四种报文&#34;&gt;3.3.5 BGP的四种报文&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097376737.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;34-三种路由协议的比较&#34;&gt;3.4 三种路由协议的比较&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097403721.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612097407772.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;4-ip数据报&#34;&gt;4. IP数据报&lt;/h1&gt;
&lt;h2 id=&#34;41-ip数据报格式&#34;&gt;4.1 IP数据报格式&lt;/h2&gt;
&lt;p&gt;注释：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;注释&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;大小&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;版本 Version&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ipv4或者ipv6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;首部长度 IHL&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;此处数值再乘以4才是真正大小，同时因为IP数据报固定长度为20字节，所以此处最小值为5，即二进制的0101&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;区分服务 DSCP + ECN&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;希望获得哪种服务，用的比较少&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;总长度 Total Length&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;首部+数据的长度，最大为2^16-1=65535&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;标识 Identification&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用来表示是哪一个数据报的分片，不同的分片标识各不相同&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;标志 Flags&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用来表示是否分片和分片是否结束&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3位，但实际有用的只有后两位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;片偏移 Fragment Offset&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用来标记分片之后，该分片在原来的数据报的位置，以8字节为单位&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;13位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;生存时间 Time To Live&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;即TTL，没经过一个路由器TTL-1,0时自动放弃，根据系统不同默认的TTL不同&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;协议 Protocol&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用来标记协议名的字段值，如TCP,UDP,ICMP等等&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;首部检验和 Header Checksum&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;检验首部的字段是否出错，出错就丢弃此数据报&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;源地址 Source IP Address&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;发送方ip地址&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;目的地址 Destination IP Address&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;接收方ip地址&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可选字段 Options&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用来排错等安全检测&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;未知，可在0-40位之间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;填充&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;将数据报对齐成4字节的整数倍，数值全部为0&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;未知，根据可选字段来定&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098474398.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098477627.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
计算偏移量时记住是以0开始的就行，以每一篇最开始的除以8得到的数值就是偏移量&lt;br&gt;
MF和DF的定义见上图&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098493784.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;5-ip&#34;&gt;5. IP&lt;/h1&gt;
&lt;h2 id=&#34;51-ipv4地址&#34;&gt;5.1 ipv4地址&lt;/h2&gt;
&lt;p&gt;全球唯一的表示某一个主机或者路由器接口的编码&lt;/p&gt;
&lt;h3 id=&#34;511-ip地址分类&#34;&gt;5.1.1 ip地址分类&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098535241.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;512-特殊ip地址&#34;&gt;5.1.2 特殊ip地址&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098614057.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;513-私有ip地址&#34;&gt;5.1.3 私有ip地址&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098637063.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;解释一下&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;为什么A类最大是126.xxx.xxx.xxx？&lt;/code&gt;&lt;br&gt;
因为网络号最开始第一位是0，一共八位，所以二进制表示位0xxxxxxx，最大就是2^7-1=127，但是因为127.xxx.xxx.xxx是特殊ip地址，所以将其去掉&lt;br&gt;
&lt;code&gt;为什么B类最大是191.255.xxx.xxx？&lt;/code&gt;&lt;br&gt;
因为网络号最开始第一位是10，一共八位，所以二进制表示位10xxxxxx，最大就是10111111=191，最小就是10000000=128，无特殊ip地址&lt;br&gt;
&lt;code&gt;为什么C类最大是223.255.xxx.xxx？&lt;/code&gt;&lt;br&gt;
因为网络号最开始第一位是110，一共八位，所以二进制表示位110xxxxx，最大就是11011111=223，最小就是10000000=192，无特殊ip地址&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098684254.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;52-网络地址转换nat&#34;&gt;5.2 网络地址转换NAT&lt;/h2&gt;
&lt;p&gt;注释：连接内网和外网，就是找个代理的用它的ip地址与外面收发数据&lt;br&gt;
NAT需要构建NAT转换表，既要存广域网（WAN，外网）也要存局域网（LAN，内网）的ip地址和端口号&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098723762.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;53-子网划分和子网掩码&#34;&gt;5.3 子网划分和子网掩码&lt;/h2&gt;
&lt;h3 id=&#34;531-为什么需要子网划分&#34;&gt;5.3.1 为什么需要子网划分&lt;/h3&gt;
&lt;p&gt;总结一下，就是ip不够用，所以需要额外整个子网扩展ip&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098876586.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注释：&lt;br&gt;
为什么子网好能全0或者全1：因为CIDR编址（可见下一段）&lt;br&gt;
为什么主机号不能全0或者全1：因为全0代表本网络，全1代表广播分组&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098885794.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;532-子网掩码&#34;&gt;5.3.2 子网掩码&lt;/h3&gt;
&lt;p&gt;子网掩码就是用来和ip地址一起计算子网的地址的&lt;br&gt;
方法就是讲子网掩码逐位写成二进制然后而原来ip地址进行与运算，就可以得到子网ip地址&lt;br&gt;
因为255是11111111，所以如果写着255的话，ip地址和子网ip地址对应的地方的数值就相同&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098919450.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这道题可以看出来，即使子网掩码不同，相同ip地址对应的子网ip地址也可能相同&lt;br&gt;
但是子网掩码不同，划分的&lt;strong&gt;子网数目不同&lt;/strong&gt;&lt;br&gt;
为什么划分的子网数目不同？或者说怎么算划分的子网位数目？&lt;br&gt;
以255.255.192.0为例，255是11111111即八个1,192是11000000即2个1，一共是82+2=18个1，一共有32位地址，所以剩余有32-18=14位&lt;br&gt;
以255.255.224.0为例，255是11111111即八个1,224是11100000即3个1，一共是82+3=19个1，一共有32位地址，所以剩余有32-19=13位&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098940092.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这道题先将255.255.252.0计算出一共有8+8+6=22位网络号位&lt;br&gt;
所以就有32-22=10位主机号位&lt;br&gt;
将180.80.77.55解析，可以知道在77部分某部分开始会用来表示主机号位&lt;br&gt;
77的二进制是0100 1101，因为一共有22位网络号位，所以010011 （此处分开） 01，从这个01开始是主机号位。&lt;br&gt;
所以用来表示子网ip地址的应该是180.80.76（010011 00）.xxx PS注意76括号内后两位二进制00&lt;br&gt;
但是本体是发布广播地址，所以主机号全部都要是1&lt;br&gt;
所以应该是180.80.79（010011 11）.255（11111111）注意79括号内后两位二进制11&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098960245.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注释：&lt;br&gt;
1.这里特定主机路由就是指找特定的处理这里这个ip地址的路由&lt;br&gt;
2.默认路由会将这个数据报发给另一个路由，直至找到对应的路由，或者TTL耗尽被丢弃&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098976631.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;54-无分类编制cidr&#34;&gt;5.4 无分类编制CIDR&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612098994138.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
使用CIDR可以聚合网络&lt;br&gt;
如图，通过缩短前缀，R1和R2就可以合并在206.1.0.0/16的子网下&lt;br&gt;
但是这样转发表之中就会有多个匹配结果，所以我们使用&lt;strong&gt;最长前缀匹配&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099099244.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
最长前缀匹配就是在计算后符合同一子网的时候，选前缀越长的&lt;br&gt;
这道题选B&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099115616.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
因为本网络是192.168.5.0/24，就是192.168.5.（0000 0000）/24，将248写成二进制是11111 000，有五个1，所以前五位都可以作为子网的编号，剩下的三位就是用来分配子网内剩余的地址了，因为不能全0或者全1，所以还要减2&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099128555.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;55-arp协议&#34;&gt;5.5 ARP协议&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099442070.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099446128.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;56-dhcp协议&#34;&gt;5.6 DHCP协议&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099461816.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;57-icmp协议&#34;&gt;5.7 ICMP协议&lt;/h2&gt;
&lt;h3 id=&#34;571-icmp协议概述&#34;&gt;5.7.1 ICMP协议概述&lt;/h3&gt;
&lt;p&gt;ICMP，IGMP处于网络层和传输层之间，就是为了更好地转发ip数据报和提高交互成功的几率&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099557198.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;572-icmp差错报告报文&#34;&gt;5.7.2 ICMP差错报告报文&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ICMP差错报告报文如何与IP数据报结合&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099586573.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五种ICMP差错报文&lt;/strong&gt;&lt;br&gt;
其中源点抑制已废弃不用&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099758130.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四种不发送ICMP差错报文的情况&lt;/strong&gt;&lt;br&gt;
注释：组播是指由一点到多点，但不是无脑发到所有点，无脑发到所有点的是广播，组播有筛选条件&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099792458.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;573-icmp询问报文&#34;&gt;5.7.3 ICMP询问报文&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;四种ICMP询问报文&lt;/strong&gt;&lt;br&gt;
后两种是掩码地址请求和回答报文，路由器询问和通告报文，这两个已经废弃不再使用&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099832338.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;574-icmp的应用&#34;&gt;5.7.4 ICMP的应用&lt;/h3&gt;
&lt;p&gt;1.ping命令：测试两个主机之间连通性，使用了ICMP回送请求和回答报文&lt;br&gt;
2.traceroute命令：跟踪一个分组从原点到终点的路径，使用了ICMP时间超过差错报告报文&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/llq_200/article/details/81034345&#34;&gt;traceroute命令讲解&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;6-ipv6&#34;&gt;6. IPV6&lt;/h1&gt;
&lt;h2 id=&#34;61-为什么会有ipv6&#34;&gt;6.1 为什么会有IPV6&lt;/h2&gt;
&lt;p&gt;就是IPV4地址用完了，从根本上增加ip地址数目，之前讲的NAT和CIDR也只是在IPV4的基础上扩展了IPV4地址数目，治标不治本&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099968178.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;62-ipv6地址表示形式&#34;&gt;6.2 IPV6地址表示形式&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612099983088.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;63-ipv6数据报格式&#34;&gt;6.3 IPV6数据报格式&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;作用&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;位数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;版本 Version&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;知名协议版本，此处因为是ipv6所以总是6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;优先级 Traffic Class&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;又来区分数据报的类型和优先级&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;流标签 Flow Label&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;和ipv4标识某个数据报分片不同，这是对于一整个数据报流的标记&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;19位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有效载荷长度 Payload Length&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;指的是扩展首部+数据部分的大小，和ipv4的总长度和首部长度都不同，ipv6的首部长度是固定的40字节&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;下一个首部 Next Header&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;基本首部的下一个首部指的是有效载荷里标记的的扩展首部，有效载荷里的扩展首部再指向有效载荷里标记的的扩展首部，直至最后指向数据&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;跳数限制 Hop Limit&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;基本相当于ipv4当中的TTL，每到一个路由器-1.减到0时丢弃&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;源地址 Source Address&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;发送方ipv6地址&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;128位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;目标地址 Destination Address&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;接收方ipv6地址&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;128位&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100298399.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;64-ipv4和ipv6的区别&#34;&gt;6.4 IPV4和IPV6的区别&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100321103.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;65-ipv6基本地址类型&#34;&gt;6.5 IPV6基本地址类型&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;作用&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;要求&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一对一通信&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可做源地址，目的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;多播&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一对多通信，以前的广播地址当做覆盖所有主机的多播&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可做目的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;任播&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一对多当中的一个通信，看似一对多，实则一对一&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可做目的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;66-ipv4和ipv6之间的过渡&#34;&gt;6.6 IPV4和IPV6之间的过渡&lt;/h2&gt;
&lt;p&gt;如果是ipv6的数据报到了ipv4，就用ipv4重新封装，把ipv6数据报前面加上ipv4伪装成ipv4数据报继续传输，直至到了ipv6路由再解开ipv4伪装&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100421431.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;7-ip组播多播&#34;&gt;7. IP组播（多播）&lt;/h1&gt;
&lt;h2 id=&#34;71-什么是组播&#34;&gt;7.1 什么是组播&lt;/h2&gt;
&lt;p&gt;单播只能一对一，广播必须一对全部，组播就可以是一对全部中的一部分&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100449986.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
辅助理解：单播所占资源多&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100580765.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
组播明显减轻了压力&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100600765.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;72-ip组播地址&#34;&gt;7.2 IP组播地址&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100630663.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;73-硬件组播&#34;&gt;7.3 硬件组播&lt;/h2&gt;
&lt;p&gt;就像全F的mac地址代表广播一样，00-10-5E打头的MAC地址就代表组播&lt;br&gt;
7为什么最大是00-10-5E-7F-FF-FF？因为只有最后23位决定&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100653018.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;74-igmp协议与组播路由选择协议&#34;&gt;7.4 IGMP协议与组播路由选择协议&lt;/h2&gt;
&lt;h3 id=&#34;741-igmp协议&#34;&gt;7.4.1 IGMP协议&lt;/h3&gt;
&lt;p&gt;注释：IGMP只能知道有没有组播组成员，对有几个组播组成员，成员在哪个地方都不知道&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100779176.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100792527.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;742-组播路由选择协议&#34;&gt;7.4.2 组播路由选择协议&lt;/h3&gt;
&lt;p&gt;有了这个，成员可以自行找到转发组，自行决定参加哪个组播（就像电视机选台一样）&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100819411.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100823553.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;8-移动ip&#34;&gt;8. 移动IP&lt;/h1&gt;
&lt;p&gt;移动IP&lt;strong&gt;不等于&lt;/strong&gt;动态IP（DHCP获得的）&lt;br&gt;
移动IP的可以让用户因为地理原因等等，即使不在内网也可以访问内网的东西&lt;/p&gt;
&lt;h2 id=&#34;81-移动ip的相关术语&#34;&gt;8.1 移动IP的相关术语&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100855884.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;82-移动ip通信过程&#34;&gt;8.2 移动IP通信过程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100886983.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100892321.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;9-网络层设备&#34;&gt;9. 网络层设备&lt;/h1&gt;
&lt;h2 id=&#34;91-路由器&#34;&gt;9.1 路由器&lt;/h2&gt;
&lt;h3 id=&#34;911-路由器的构造&#34;&gt;9.1.1 路由器的构造&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100922364.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;912-路由器的输入输出端口构造&#34;&gt;9.1.2 路由器的输入输出端口构造&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100934897.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100957008.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;913-集线器网桥路由表几层设备比较&#34;&gt;9.1.3 集线器，网桥，路由表几层设备比较&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612100985820.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;914-路由器的路由表和转发表&#34;&gt;9.1.4 路由器的路由表和转发表&lt;/h3&gt;
&lt;p&gt;这里实际上就是对前面知识的复习了&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612101019453.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;10-本章思维导图&#34;&gt;10. 本章思维导图&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1612101037645.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;本章常用名词中英文对照&#34;&gt;本章常用名词中英文对照&lt;/h1&gt;
&lt;p&gt;Forwarding table 转发表&lt;br&gt;
Virtual-circuit networks 虚电路网络&lt;br&gt;
Datagram networks 数据报网络&lt;br&gt;
Signaling message 信令报文&lt;br&gt;
Active queue management 主动队列管理&lt;br&gt;
Head-of-the-line 队头&lt;br&gt;
Classless interdomain routing (CIDR) 无类域间路由&lt;br&gt;
Plug-and-play 即插即用&lt;br&gt;
Anycast 任播&lt;br&gt;
Interior gateway protocols 内部网关协议&lt;br&gt;
Routing information Protocol 路由信息协议（RIP）&lt;br&gt;
Open shortest Path First OSPF 开放最短路径优先&lt;br&gt;
Area border routers 区域边界路由器&lt;br&gt;
Circuit Switching 电路转换&lt;br&gt;
Packet Switching 分组交换&lt;/p&gt;
&lt;p&gt;参考资料&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV19E411D78Q?p=1&#34;&gt;2019 王道考研 计算机网络&lt;/a&gt;&lt;/p&gt;
">计算机网络笔记Part4 网络层（Network Layer）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/ji-suan-ji-wang-luo-bi-ji-part3-shu-ju-lian-lu-ceng-data-link-layer/"" data-c="
          &lt;h1 id=&#34;1-基本概念&#34;&gt;1. 基本概念&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609390124988.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;2-封装成帧与透明传输&#34;&gt;2. 封装成帧与透明传输&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;封装成帧&lt;/strong&gt;就是加将数据加头加尾，相当于将数据打包&lt;br&gt;
&lt;strong&gt;透明传输&lt;/strong&gt;就是为了防止&lt;strong&gt;特殊的数据无法正常传输&lt;/strong&gt;的情况的发生，比如说在封装成帧的过程中出现数据中的某些标记符与开始/结束标记符恰巧重复等等情况&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609390179336.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609390192674.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;21-透明传输的应用&#34;&gt;2.1 透明传输的应用&lt;/h2&gt;
&lt;h3 id=&#34;211-字符计数法&#34;&gt;2.1.1 字符计数法&lt;/h3&gt;
&lt;p&gt;就是在帧的首部做&lt;strong&gt;计数&lt;/strong&gt;，看看数据是否错误&lt;br&gt;
缺点：如果在某一个帧内，标记位后面的某个字节的数据丢失，那么会影响后面的帧&lt;br&gt;
比如3 1 1 和 4 2 2 2，如果前面的帧丢失变成 3 1，那么后面的4就会被补到前面变成 3 1 4导致错误&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568481663.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;212-字符填充法&#34;&gt;2.1.2 字符填充法&lt;/h3&gt;
&lt;p&gt;就是加头加尾分别标记开始结束，和零比特填充法（见下）对比，&lt;strong&gt;开始和结束的对应的字符不一样&lt;/strong&gt;&lt;br&gt;
但有可能出现数据内某段比特流数据正好&lt;strong&gt;与标记字段重复&lt;/strong&gt;，从而导致误判断的情况&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568577190.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;解决方法：添加转义字符&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568606048.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;213-零比特填充法&#34;&gt;2.1.3 零比特填充法&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568630555.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;214-违规编码法&#34;&gt;2.1.4 违规编码法&lt;/h3&gt;
&lt;p&gt;因为曼彻斯特编码不使用高-高，低-低来表示，所以如果使用高-高，低-低来表示帧起始和终止就&lt;strong&gt;不会与数据冲突&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568672962.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-差错控制&#34;&gt;3. 差错控制&lt;/h1&gt;
&lt;h2 id=&#34;31-差错是什么从哪来的&#34;&gt;3.1 差错是什么，从哪来的&lt;/h2&gt;
&lt;p&gt;数据链路层的差错检测的是&lt;strong&gt;比特&lt;/strong&gt;的错误&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568711580.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-为什么要在数据链路层进行差错控制&#34;&gt;3.2 为什么要在数据链路层进行差错控制？&lt;/h2&gt;
&lt;p&gt;因为错误可以尽早发现，不会让一个错误的数据包发送了很长时间到达最终目的地之后才被发现，从而导致网络资源的浪费&lt;/p&gt;
&lt;h2 id=&#34;33-检错编码奇偶校验码循环冗余码crc&#34;&gt;3.3 检错编码（奇偶校验码，循环冗余码CRC）&lt;/h2&gt;
&lt;h3 id=&#34;331-奇偶校验码&#34;&gt;3.3.1 奇偶校验码&lt;/h3&gt;
&lt;p&gt;缺点：只能检测出1，3，5，7…等等奇位数错误，检测成功率位50%&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568769474.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;332-循环冗余码crc&#34;&gt;3.3.2 循环冗余码CRC&lt;/h3&gt;
&lt;p&gt;就是用传输数据除以生成多项式得到冗余码&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568796342.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
实际例子&lt;br&gt;
注释：&lt;br&gt;
1.阶数就是最高位是哪位，然后位数-1，如10011就是5-1=4,1011就是4-1=3&lt;br&gt;
2.异或运算就是相同得0，不同得1，比如100和101做异或，结果就是001&lt;br&gt;
3.出书和最后的余数添加到要发送的数据后面，称为&lt;strong&gt;帧检验序列FCS&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568834916.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
接收方收到数据后进行检测&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568859283.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
需要注意的地方&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568878943.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;34-纠错编码海明码&#34;&gt;3.4 纠错编码（海明码）&lt;/h2&gt;
&lt;p&gt;分为四步&lt;/p&gt;
&lt;h2 id=&#34;第一步-确认校验码位数r&#34;&gt;第一步 确认校验码位数r&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568956027.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;第二步-确定校验码和数据的位置&#34;&gt;第二步 确定校验码和数据的位置&lt;/h2&gt;
&lt;p&gt;注释：&lt;br&gt;
1.为什么是10为数据位？因为4位校验码+6位信息位=10位&lt;br&gt;
2.校验码放到2的几次方的位置，其他的地方按顺序放已知的信息位&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609568978597.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;第三步-求出校验码的值&#34;&gt;第三步 求出校验码的值&lt;/h2&gt;
&lt;p&gt;注释&lt;br&gt;
1.先是通过二进制位确定有几位。本题中因为最大位10的二进制是1010，所以是4为，将其标注&lt;br&gt;
2.然后从p1开始看，看p1的二进制位的数值和所有信息位的对应位置的数值是否相同，然后找出来这些位&lt;br&gt;
这里有点难理解，这里以p1为例辅助理解，这里找出来的就是P1,D1,D2,D4,D5&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569004823.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
然后计算异或值，比如说这里D1=1,D2=0,D4=1,D5=0,就是p1要同时和0,1，0,1进行异或之后得到0，为了标识我加粗原始计算数据&lt;br&gt;
举例：0和1异或得1,1和0异或得1,1和1异或得0，那么p1和0异或得0，p1就是0了&lt;br&gt;
3.其他同理，按顺序计算出P2,P3,P4,然后填入表格&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569018649.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;第四步-检测并纠错&#34;&gt;第四步 检测并纠错&lt;/h2&gt;
&lt;p&gt;就是和上面一样，将所有校验位进行运算，得出的结果的值就是错误的位&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569067668.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;4-数据链路层的流量控制和可靠传输&#34;&gt;4. 数据链路层的流量控制和可靠传输&lt;/h1&gt;
&lt;h2 id=&#34;41-流量控制与可靠传输&#34;&gt;4.1 流量控制与可靠传输&lt;/h2&gt;
&lt;p&gt;流量控制是为了让传输过程中的发送速度和接受速度匹配，减少传输出错与资源浪费&lt;br&gt;
可靠传输是发送端发送什么，接收端就要受到什么&lt;/p&gt;
&lt;h3 id=&#34;411-停止等待协议stop-and-wait&#34;&gt;4.1.1 停止等待协议（Stop-and-Wait）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569129958.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
停止等待协议的&lt;strong&gt;无差错&lt;/strong&gt;情况&lt;br&gt;
注释：因为一次就一个，所以用0和1标记ack就行&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569160486.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
停止等待协议的&lt;strong&gt;有差错&lt;/strong&gt;情况&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569192898.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569221465.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569225134.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
停止等待协议的特点&lt;br&gt;
1.简单&lt;br&gt;
2.信道利用率低。大部分时间数据都在路上，发送方很长时间闲置，资源浪费&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569585809.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569581900.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;412-后退n帧协议gbn&#34;&gt;4.1.2 后退N帧协议（GBN）&lt;/h3&gt;
&lt;p&gt;因为停止等待协议太浪费时间了，所以尝试采用GBN，发送连续多个数据帧，以增大信道利用率&lt;br&gt;
注释：&lt;br&gt;
累计确认：就是收到一个确认帧，那么&lt;strong&gt;它和它之前的所有帧&lt;/strong&gt;都默认已收到，反之，如果某个确认帧没收到，那么&lt;strong&gt;它和它之后的所有帧&lt;/strong&gt;都默认丢失（即使收到了也丢掉），进行重传&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569637867.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
下图是一个实例&lt;br&gt;
注释：此图发送2帧时丢失，所以接收方几首收到后面的帧也是直接丢弃并且发送最晚收到的有效帧1的ACK，直至2帧的超时重传机制被触发进行重传并得到ACK之后，接收方才会接受2帧以及后面的帧&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569648684.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发送窗口不能无限大，与使用的编号的比特数有关&lt;br&gt;
很简单，就是1比特编号0和1,同理2比特编号0-3，如果用1比特编号，却要4个窗口长度，那么窗口内数据编号都编不过来，直接乱套了&lt;br&gt;
GBN的优缺点也显而易见，优点是提高了信道利用率，缺点是因为重传机制的原因导致已经收到数据却需要强行丢弃而造成浪费&lt;/p&gt;
&lt;h3 id=&#34;413-选择重传协议sr&#34;&gt;4.1.3 选择重传协议（SR）&lt;/h3&gt;
&lt;p&gt;为了解决GBN的缺点，我们打算尝试只重传错误的帧，这样的话就不用浪费资源吧已经收到的帧再重传一次了。&lt;br&gt;
和GBN相比，两者都有窗口了，和GBN的区别其实就是做了一个数据缓存，已经收到的帧不用扔了，等待之前因意外丢失的帧收到的时候确认即可，但是只能缓存窗口尺寸内的包含的帧（PS，缓存咋可能无限大）&lt;br&gt;
&lt;code&gt;SR运行过程&lt;/code&gt;&lt;br&gt;
注释：2帧丢失之后仍然在发送，但是2帧丢失之后只是缓存，并没有移动窗口，直至最后2帧收到后一次性确认2-5帧&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569746034.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
同样的，因为编号的问题，发送窗口不能无限大&lt;br&gt;
发送窗口最后和接受窗口&lt;strong&gt;大小相同&lt;/strong&gt;，这样利用率比较高&lt;/p&gt;
&lt;h1 id=&#34;5-介质访问控制技术&#34;&gt;5. 介质访问控制技术&lt;/h1&gt;
&lt;p&gt;就是让节点之间的通信不会进行相互干扰&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569788475.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;51-信道划分介质访问控制&#34;&gt;5.1 信道划分介质访问控制&lt;/h2&gt;
&lt;p&gt;虽然使用一条共享信道，但是通过多路复用技术组合进行传输，提高了信道的利用率&lt;/p&gt;
&lt;h3 id=&#34;511-频分多路复用fdm&#34;&gt;5.1.1 频分多路复用FDM&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569822950.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;512-时分多路复用tdm&#34;&gt;5.1.2 时分多路复用TDM&lt;/h3&gt;
&lt;p&gt;TDM的缺点就是利用率低，所以又衍生出了STDM&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569854305.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;513-统计时分复用stdm&#34;&gt;5.1.3 统计时分复用STDM&lt;/h3&gt;
&lt;p&gt;STDM的原则是先到先走，满了就发，相对于TDM提高了利用率&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569881696.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;514-码分多路复用cdm&#34;&gt;5.1.4 码分多路复用CDM&lt;/h3&gt;
&lt;p&gt;CDM只是做一下记录，暂时还用不到，有需要请自行查找资料&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569908502.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;52-随机访问介质访问控制&#34;&gt;5.2 随机访问介质访问控制&lt;/h2&gt;
&lt;p&gt;所有用户都可以随机发送信息，发送时可以占用全部带宽，理论上个人使用时比静态分配信道的速度更快&lt;/p&gt;
&lt;h3 id=&#34;521-aloha协议&#34;&gt;5.2.1 ALOHA协议&lt;/h3&gt;
&lt;p&gt;纯ALOHA协议缺点：太随性，导致效率低&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569957093.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
时隙ALOHA协议&lt;br&gt;
相对于纯ALOHA协议就是固定了发送的时间（只能在一个时间片的开始），提高了效率&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609569986799.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;522-csma协议&#34;&gt;5.2.2 CSMA协议&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609570006807.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;优点&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;缺点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1-坚持CSMA&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;发送信息时监听信道，一空闲下来就立即传输，信道忙也一直监听，如果发送时冲突就等待随机时长之后再监听&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;立即发送，利用率高&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;如果多台设备同时监听，那么会发生冲突&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;非坚持CSMA&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;发送信息时监听信道，如果空闲就立即传输，信道忙就随机等待一段时间后再监听&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;冲突发生的几率减少&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;因为需要等待，所以利用率不高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;p-坚持CSMA&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;发送信息时监听信道，空闲时以概率p进行传输，概率1-p不传输。信道忙就随机等待一段时间后再监听&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;冲突减少的同时效率也比较高&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;即使发生冲突也要坚持发送数据，资源被浪费&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;523-csmacd协议&#34;&gt;5.2.3 CSMA/CD协议&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;br&gt;
就是因为链路实际有长短，发送数据需要时间，这个时间内可能就被其他节点当成空闲状态导致发生碰撞&lt;br&gt;
知道自己发生碰撞的最长时间是2τ（两倍的&lt;strong&gt;传播时延&lt;/strong&gt;），就是一去一回&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609570559893.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
图示传播时延对载波监听的影响&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609570573007.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609570597526.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609570601177.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
由此我们可以想到最小帧长的问题，因为如果帧太短，帧都发送完了才检测到碰撞导致停止，导致无法停止碰撞&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609570623056.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;524-csmaca协议&#34;&gt;5.2.4 CSMA/CA协议&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609570763204.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609570766975.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;525-csmacd-与-csmaca的区别&#34;&gt;5.2.5 CSMA/CD 与 CSMA/CA的区别&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609570843437.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;53-轮询访问介质访问控制&#34;&gt;5.3 轮询访问介质访问控制&lt;/h2&gt;
&lt;p&gt;主要包括两大类，一个是&lt;strong&gt;轮询协议&lt;/strong&gt;，另一个是&lt;strong&gt;令牌传递协议&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;531-轮询协议&#34;&gt;5.3.1 轮询协议&lt;/h3&gt;
&lt;p&gt;就是选出一个代表，让他控制所有的传输&lt;br&gt;
注释：&lt;br&gt;
轮询开销在随着服务的节点越多，需要用于查询是否发送数据发送的数据帧也就越多，会造成一定开销&lt;br&gt;
等待延迟就是因为这是轮流“邀请”，所以难免某个节点需要发送数据，但是主节点还在较远的需要里有需求的节点那边，导致需求得不到立即响应&lt;br&gt;
单点故障很好理解，就是代表挂了&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609570905055.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;532-令牌传递协议&#34;&gt;5.3.2 令牌传递协议&lt;/h3&gt;
&lt;p&gt;注释：在节点之间没有收发数据的需求时，令牌在节点之间循环。&lt;br&gt;
发送数据的流程&lt;br&gt;
》当一个节点需要时就可以获得这个令牌。然后修改这个令牌的状态（空闲-&amp;gt;占用）&lt;br&gt;
》再将令牌与数据帧结合，让其在节点构成的环之间流动&lt;br&gt;
》不是目的地的节点收到令牌也不接受，直接略过，目标节点收到信息并复制一份到本地（传输完成），因为是个闭环，所以发送节点最后得到令牌&lt;br&gt;
》最后，发送令牌的节点对令牌的内容进行检查，如果发现数据出错还要重新发一遍&lt;br&gt;
问题基本和轮询协议相同&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609570949965.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;6局域网&#34;&gt;6.局域网&lt;/h1&gt;
&lt;h2 id=&#34;61-局域网的概念&#34;&gt;6.1 局域网的概念&lt;/h2&gt;
&lt;p&gt;概括：范围大小，速度快，延迟低，节点平等&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609570990208.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;611-局域网的网络拓扑结构&#34;&gt;6.1.1 局域网的网络拓扑结构&lt;/h3&gt;
&lt;p&gt;常用的是&lt;strong&gt;总线型拓扑&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571010148.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;612-局域网的传播介质&#34;&gt;6.1.2 局域网的传播介质&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;局域网&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;常用介质&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有线局域网&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;双绞线，同轴电缆，光纤&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无线局域网&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;电磁波&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;613-局域网介质访问方法&#34;&gt;6.1.3 局域网介质访问方法&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571141124.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;62-局域网的分类&#34;&gt;6.2 局域网的分类&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571180089.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;63-ieee802标准&#34;&gt;6.3 IEEE802标准&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571191251.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;631-ieee802描述的局域网参考模型&#34;&gt;6.3.1 IEEE802描述的局域网参考模型&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571213929.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;64以太网&#34;&gt;6.4以太网&lt;/h2&gt;
&lt;h3 id=&#34;641-以太网概念&#34;&gt;6.4.1 以太网概念&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571245741.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571249735.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;642-以太网的发展&#34;&gt;6.4.2 以太网的发展&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571279431.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;643-适配器和mac地址&#34;&gt;6.4.3 适配器和MAC地址&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571294253.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;644-以太网mac帧&#34;&gt;6.4.4 以太网MAC帧&lt;/h3&gt;
&lt;p&gt;注释：&lt;br&gt;
1.这里的mac层指的是数据链路层&lt;br&gt;
2.之前说过数据链路层将上一层ip数据包加头加尾&lt;br&gt;
头就是目标地址（6字节），源地址（6字节），类型（2字节）&lt;br&gt;
尾就是FCS（帧检验序列），（4字节）&lt;br&gt;
3.前导码&lt;strong&gt;不是MAC帧的一部分&lt;/strong&gt;，目的是使时钟同步&lt;br&gt;
4.为什么数据长度时46~1500？&lt;br&gt;
因为有最小传输字节64字节，mac占用6+6+2+4=18，所以数据最小为64-18=46，1500则是规定的默认最大字节，没有理由&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571340452.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;645-10base-t以太网&#34;&gt;6.4.5 10BASE-T以太网&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571372027.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;646-高速以太网&#34;&gt;6.4.6 高速以太网&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571385266.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;65-无线局域网&#34;&gt;6.5 无线局域网&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571418731.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571423009.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;651-两种无线局域网&#34;&gt;6.5.1 两种无线局域网&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571452731.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609571457676.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;7广域网&#34;&gt;7.广域网&lt;/h1&gt;
&lt;h2 id=&#34;71-广域网的概述&#34;&gt;7.1 广域网的概述&lt;/h2&gt;
&lt;p&gt;概括一下，一个字大&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572131515.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;72-ppp协议point-to-point-protocol&#34;&gt;7.2 PPP协议（Point-to-Point Protocol）&lt;/h2&gt;
&lt;p&gt;PPP协议是目前&lt;strong&gt;使用最广泛&lt;/strong&gt;的数据链路层协议，拨号基本都是PPP协议&lt;br&gt;
PPP协议&lt;strong&gt;仅支持全双工&lt;/strong&gt;链路&lt;/p&gt;
&lt;h3 id=&#34;721-ppp协议需要满足的要求&#34;&gt;7.2.1 PPP协议需要满足的要求&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572186032.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;722-ppp协议不需要满足的要求&#34;&gt;7.2.2 PPP协议不需要满足的要求&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572227622.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;723-ppp协议组成成分以及功能&#34;&gt;7.2.3 PPP协议组成成分以及功能&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572247195.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;724-ppp协议的帧格式&#34;&gt;7.2.4 PPP协议的帧格式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572272595.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;73-hdlc协议high-level-data-link-control&#34;&gt;7.3 HDLC协议（High-Level Data Link Control）&lt;/h2&gt;
&lt;h3 id=&#34;731-hdlc协议概述&#34;&gt;7.3.1 HDLC协议概述&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572303168.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;732-hdlc的三种站&#34;&gt;7.3.2 HDLC的三种站&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572325373.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;733-hdlc的帧格式&#34;&gt;7.3.3 HDLC的帧格式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572351245.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;74-ppp协议和hdlc协议对比&#34;&gt;7.4 PPP协议和HDLC协议对比&lt;/h2&gt;
&lt;p&gt;为什么HDLC协议更可靠，但是我们使用PPP协议？&lt;br&gt;
因为现在网络要求高，数据链路层本来就是不可靠的尽力传输，差错控制这些复杂的交给了TCP等&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572379651.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;8-链路层设备&#34;&gt;8. 链路层设备&lt;/h1&gt;
&lt;h2 id=&#34;81-集线器hub&#34;&gt;8.1 集线器（Hub）&lt;/h2&gt;
&lt;p&gt;可以扩展以太网，但是集线器会无脑将一个设备的所有消息转发到集线器所连的所有设备，故会将所连接的&lt;strong&gt;所有设备&lt;/strong&gt;变成一个大的冲突域，同时只能有两台设备进行通信，且设备越多，冲突越多。由此诞生了网桥&lt;/p&gt;
&lt;h2 id=&#34;82-网桥bridge&#34;&gt;8.2 网桥（Bridge）&lt;/h2&gt;
&lt;p&gt;使用网桥时，由于网桥会根据mac地址进行过滤，所以&lt;strong&gt;不会形成冲突域&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572446383.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;821-两种网桥&#34;&gt;8.2.1 两种网桥&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;透明网桥&lt;/strong&gt;&lt;br&gt;
通过自学习来构建转发表。每一个通过网桥的数据包都会被记录下网桥收到数据时&lt;strong&gt;数据对应的地址&lt;/strong&gt;和&lt;strong&gt;网桥自己的接口&lt;/strong&gt;，通过许许多多的数据包的构造的缓存，网桥就可以知道哪个数据包在哪个接口，以后如果要穿数据包就知道要往哪个接口发送数据包了&lt;br&gt;
&lt;strong&gt;原路由网桥&lt;/strong&gt;&lt;br&gt;
在发送时，直接将最佳路径放到帧首部。那么网桥如何获得最佳路径？通过广播方式想目标地址发送广播，此时可能会经过不同路由产生不同的路径，目标地址收到后再将每一条路径都发一个响应帧给网桥，网桥经过对比就知道哪个接口最快了&lt;/p&gt;
&lt;h2 id=&#34;83-交换机&#34;&gt;8.3 交换机&lt;/h2&gt;
&lt;p&gt;网桥接口越来越多，网桥就变成了交换机&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572535311.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;84-冲突域和广播域&#34;&gt;8.4 冲突域和广播域&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572566320.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;9-本章总结思维导图&#34;&gt;9. 本章总结思维导图&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609572590789.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;本章常用中英文对照&#34;&gt;本章常用中英文对照&lt;/h1&gt;
&lt;p&gt;End system 端系统&lt;br&gt;
Modem 调制解调器（俗称：猫）&lt;br&gt;
Base station 基站&lt;br&gt;
Communication link 通信链路&lt;br&gt;
Physical media 物理介质&lt;br&gt;
Coaxial cable 同轴电缆&lt;br&gt;
Fiber optics 光纤&lt;br&gt;
Radio spectrum 射频频谱&lt;br&gt;
Transmission rate 传输速率&lt;br&gt;
Packets （数据）包，或分组&lt;br&gt;
Routers 路由器&lt;br&gt;
Path 路径&lt;br&gt;
ISP (Internet Service Provider) 网络服务提供商&lt;br&gt;
FDM (frequency-division multiplexing) 频分多路复用&lt;br&gt;
TDM (time-division multiplexing) 时分多路复用&lt;br&gt;
Statistical Multiplexing 统计复用&lt;br&gt;
Store-and-forward 存储转发&lt;br&gt;
Queuing delays 排队延迟&lt;br&gt;
Transmission delay 传输延迟，或发送延迟&lt;br&gt;
Propagation delay 传播延迟&lt;br&gt;
Throughput 吞吐量&lt;br&gt;
Internet backbone 骨干网&lt;br&gt;
Delay 延迟，或时延&lt;br&gt;
Loss 丢包&lt;br&gt;
Message 消息，或报文&lt;br&gt;
Segment （报文）段&lt;br&gt;
Datagram 数据报&lt;br&gt;
Frames 帧&lt;/p&gt;
&lt;p&gt;参考资料&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV19E411D78Q&#34;&gt;2019 王道考研 计算机网络&lt;/a&gt;&lt;/p&gt;
">计算机网络笔记Part3 数据链路层（Data Link Layer）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/ji-suan-ji-wang-luo-bi-ji-part2-wu-li-ceng-physical-layer/"" data-c="
          &lt;h1 id=&#34;1-基本概念&#34;&gt;1. 基本概念&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609332989754.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;2-数据通信基本知识&#34;&gt;2. 数据通信基本知识&lt;/h1&gt;
&lt;h2 id=&#34;21-一个数据通信例子&#34;&gt;2.1 一个数据通信例子&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609333260138.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;22-相关术语&#34;&gt;2.2 相关术语&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609333847379.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;23-三种通讯方式&#34;&gt;2.3 三种通讯方式&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;英文&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;定义&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;需要信道条数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;单工通信&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Simplex&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只能一个发一个收&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一条&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;半双工通信&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;half-duplex&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;都可以发或者收，但是同一时间只能进行一个&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;两条&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;全双工通信&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;duplex&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;都可以同时收发数据&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;两条&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;24-两种数据传输方式&#34;&gt;2.4 两种数据传输方式&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;传输方式&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;特点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;串行传输&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;速度慢，省钱，适合远距离&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;并行传输&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;速度快，耗钱，适合近距离&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379006539.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;25-码元symbol&#34;&gt;2.5 码元（Symbol）&lt;/h2&gt;
&lt;p&gt;定义：码元是指用一个固定时长的信号波形（数字脉冲），代表离散数值的基本波形。当有多个离散状态时，成为M进制码元。一个码元可以携带多个比特的信息&lt;br&gt;
个人理解：码元就是在网线上传输的一个个信号段。码元的不同进制就是用来表示不同的数值的&lt;/p&gt;
&lt;h2 id=&#34;26-波特baud&#34;&gt;2.6 波特（Baud）&lt;/h2&gt;
&lt;p&gt;用来指一秒可以传输多少个码元&lt;/p&gt;
&lt;h2 id=&#34;27-速率&#34;&gt;2.7 速率&lt;/h2&gt;
&lt;p&gt;分为&lt;strong&gt;码元传输速率&lt;/strong&gt;和&lt;strong&gt;信息传输速率&lt;/strong&gt;&lt;br&gt;
信息传输速率就是b/s，就是我们平常说的&lt;strong&gt;网速&lt;/strong&gt;&lt;br&gt;
码元可以理解为几个比特的&lt;strong&gt;集合&lt;/strong&gt;，所以信息传输速率（网速）=码元传输速率x码元所带信息量（多少比特）&lt;br&gt;
码元所带信息量（比特数）=log2（码元进制数）&lt;/p&gt;
&lt;h2 id=&#34;28-带宽band-width&#34;&gt;2.8 带宽（Band Width）&lt;/h2&gt;
&lt;p&gt;用来表示最高数据速率&lt;/p&gt;
&lt;h2 id=&#34;29-奈式准则nyquist&#34;&gt;2.9 奈式准则（Nyquist）&lt;/h2&gt;
&lt;p&gt;是在&lt;strong&gt;理想状态下&lt;/strong&gt;得出的结论&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379171027.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;210-香农公式shannon&#34;&gt;2.10 香农公式（Shannon）&lt;/h2&gt;
&lt;p&gt;是在&lt;strong&gt;有噪声的信道中&lt;/strong&gt;得出的结论&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379224887.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379228696.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;211-基带信号和宽带带通信号base-bandpass-band&#34;&gt;2.11 基带信号和宽带/带通信号（Base band，pass band）&lt;/h2&gt;
&lt;p&gt;计算机网络中用的基带信号是&lt;strong&gt;数字信号&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379264723.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;212-编码&#34;&gt;2.12 编码&lt;/h2&gt;
&lt;p&gt;将数据转化为&lt;strong&gt;数字信号&lt;/strong&gt;&lt;br&gt;
数字数据(digtal data)通过 数字发送器(digit emitter) 转化为 数字信号(digtal signal)&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379325314.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
模拟数据(analog data)通过 PCM编码器(PCM coder) 转化为 数字信号 (digtal signal)&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379338474.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;单极性不归零编码：只使用一个电压值，高电平表示1，低电平表示0。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;双极性不归零编码：用幅值相等的正负电平表示二进制数1和0。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;单极性归零编码：发送码1时高电平在整个码元期间只持续一段时间，其余时间返回零电平。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;双极性归零编码：正负零三个电平，信号本身携带同步信息。
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379405647.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;曼彻斯特编码：&lt;/code&gt;单极性编码的缺点是没有办法区分此时是没有信号，还是有信号，但是信号是0.&lt;br&gt;
这种编码方式是bit中间有信号，低-高跳转表示0，高-低跳转表示1，一个时钟周期只可以表示一个bit，并且必须通过两次采样才能得到一个bit。它能携带时钟信号，而且能区分此时是没有信号还是信号为0.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;差分曼彻斯特编码：&lt;/code&gt;抗干扰能力比曼彻斯特编码更强。bit与bit之间有信号跳变，表示下一个bit为0，bit与bit之间没有信号跳变，表示下一个bit为1。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379572032.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;213-调制数据转化为模拟信号了解&#34;&gt;2.13 调制：数据转化为模拟信号（了解）&lt;/h2&gt;
&lt;p&gt;常用的调制方法：调频(AM)，调频(FM)，调相(PM)&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379690610.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
模拟数据(analog data)通过 调制器(modulaotr) 转化为 模拟信号 (analog signal)&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379708749.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
数字数据(digtal data)通过 调制器(modulaotr) 转化为 模拟信号 (analog signal)&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379737643.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-物理层传输介质&#34;&gt;3. 物理层传输介质&lt;/h1&gt;
&lt;p&gt;传输介质分为&lt;strong&gt;导向性&lt;/strong&gt;传输介质和&lt;strong&gt;非导向性&lt;/strong&gt;传输介质&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;导向性传输介质&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;电磁波沿着固体媒介（铜线or光纤）被导向传播&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;非导向性传输介质&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;自由空间，如空气，水等等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;31-常见的导向性传输介质&#34;&gt;3.1 常见的导向性传输介质&lt;/h2&gt;
&lt;h3 id=&#34;311-双绞线&#34;&gt;3.1.1 双绞线&lt;/h3&gt;
&lt;p&gt;根据有无屏蔽层分为&lt;strong&gt;屏蔽双绞线（STP）和无屏蔽双绞线（UTP）&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379878165.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;312-同轴电缆coaxial-cable&#34;&gt;3.1.2 同轴电缆（Coaxial Cable）&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379892737.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;313-光纤optical-fiber&#34;&gt;3.1.3 光纤（Optical fiber）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379932961.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
根据&lt;strong&gt;入射角&lt;/strong&gt;不同，又分为单模光纤和多模光纤&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379946815.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-常见的非导向性传输介质&#34;&gt;3.2 常见的非导向性传输介质&lt;/h2&gt;
&lt;p&gt;包括&lt;strong&gt;无线电波&lt;/strong&gt;，&lt;strong&gt;微波&lt;/strong&gt;，&lt;strong&gt;红外线&lt;/strong&gt;和&lt;strong&gt;激光&lt;/strong&gt;等&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609379994768.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;4-物理层设备&#34;&gt;4. 物理层设备&lt;/h1&gt;
&lt;h2 id=&#34;41-中继器rp-repeater&#34;&gt;4.1 中继器（RP repeater）&lt;/h2&gt;
&lt;p&gt;注释：5-4-3规则是为了限制中继器使用次数的，理由可见图&lt;br&gt;
5是指不能超过5个网段&lt;br&gt;
4是指在这些网段中的物理层网络设备（中继器，集线器）最多不超过4个&lt;br&gt;
3是指这些网段中最多只有三个网段挂有计算机&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609380050132.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;42-集线器hub&#34;&gt;4.2 集线器（Hub）&lt;/h2&gt;
&lt;p&gt;集线器是个大的冲突域，同时&lt;strong&gt;只能有两个设备进行通讯&lt;/strong&gt;，只会传输信号，没有智能。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609380082969.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;5-本章思维导图&#34;&gt;5. 本章思维导图&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609380107652.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;br&gt;
&lt;br&gt;&lt;br&gt;
参考资料&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV19E411D78Q&#34;&gt;2019 王道考研 计算机网络&lt;/a&gt;&lt;/p&gt;
">计算机网络笔记Part2 物理层（Physical Layer）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/ji-suan-ji-wang-luo-bi-ji-part11/"" data-c="
          &lt;h1 id=&#34;1-速率相关性能指标&#34;&gt;1. 速率相关性能指标&lt;/h1&gt;
&lt;h2 id=&#34;11-速率&#34;&gt;1.1 速率&lt;/h2&gt;
&lt;p&gt;定义：连接在计算机网络上的主机在数字信道上传送数据位数的速率&lt;br&gt;
单位:b/s,Kb/s,Mb/s,Tb/s，&lt;br&gt;
如果用字节表示，则是B/s,KB/s,MB/s,TB/s&lt;br&gt;
1Byte=8Bit&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609227285065.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;12-带宽&#34;&gt;1.2 带宽&lt;/h2&gt;
&lt;p&gt;在计算机网络中，指的是网络设备所支持的最高速度，单位同速率，是&lt;strong&gt;理想条件下最高速率&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;13-吞吐量&#34;&gt;1.3 吞吐量&lt;/h2&gt;
&lt;p&gt;指的是单位时间内通过某个网络的数据&lt;strong&gt;总&lt;/strong&gt;量&lt;/p&gt;
&lt;h3 id=&#34;个人理解&#34;&gt;个人理解&lt;/h3&gt;
&lt;p&gt;速率就是实际网速，带宽是理论网速（长城宽带警告），吞吐量是一个或多个设备的综合速率，比如说1000m宽带的路由器连着三部手机，每部手机都是10mb/s看片，那么速率就是10mb/s，带宽是宽带的1000m，路由器吞吐量是30mb/s，即三者之和&lt;/p&gt;
&lt;h1 id=&#34;2时延相关指标&#34;&gt;2.时延相关指标&lt;/h1&gt;
&lt;h2 id=&#34;21-时延&#34;&gt;2.1 时延&lt;/h2&gt;
&lt;p&gt;时延包括四大类&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;计算公式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;发送时延&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据从主机到信道上所用的时间&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据从主机到信道上所用的时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;传播时延&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据在信道上传播所花费的时间&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;信道长度/电磁波在信道上传播的速率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;排队时延&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据在路由器前等待前面数据处理的时间&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无计算方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;处理时延&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据在路由器中处理需求的时间&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无计算方式&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;使用高速链路(提高网速)，只能减小发送时延，无法减少其他三个时延&lt;/p&gt;
&lt;h2 id=&#34;22-时延带宽积&#34;&gt;2.2 时延带宽积&lt;/h2&gt;
&lt;p&gt;公式：时延带宽积=传播时延x带宽&lt;br&gt;
意思是链路上有多少比特的数据&lt;/p&gt;
&lt;h2 id=&#34;23往返时延rtt&#34;&gt;2.3往返时延RTT&lt;/h2&gt;
&lt;p&gt;从发送方发送数据开始，到接收方确认收到为止所花费的时间&lt;br&gt;
RTT=传播时延x2+处理时间(有时可能直接忽略)&lt;/p&gt;
&lt;h2 id=&#34;24-利用率&#34;&gt;2.4 利用率&lt;/h2&gt;
&lt;h3 id=&#34;241-信道利用率&#34;&gt;2.4.1 信道利用率&lt;/h3&gt;
&lt;p&gt;信道利用率=有数据通过&lt;strong&gt;时间&lt;/strong&gt;/有+无数据通过&lt;strong&gt;时间&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;242-网络利用率&#34;&gt;2.4.2 网络利用率&lt;/h3&gt;
&lt;p&gt;网络利用率=所有信道利用率加权求平均值&lt;/p&gt;
&lt;h3 id=&#34;243-时延和利用率的关系图&#34;&gt;2.4.3 时延和利用率的关系图&lt;/h3&gt;
&lt;p&gt;利用率越高，延迟越大&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609228615004.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-分层结构&#34;&gt;3. 分层结构&lt;/h1&gt;
&lt;h2 id=&#34;31-为什么要分层分层要做什么&#34;&gt;3.1 为什么要分层，分层要做什么&lt;/h2&gt;
&lt;p&gt;（1）发起通信的计算机必须将数据通信的通路进行激活。&lt;br&gt;
（2）要告诉网络如何识别目的主机。&lt;br&gt;
（3）发起通信的计算机要查明目的主机是否开机，并且与网络连接正常。&lt;br&gt;
（4）发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作。&lt;br&gt;
（5）确保差错和意外可以解决。&lt;/p&gt;
&lt;h2 id=&#34;32-正式认识分层结构&#34;&gt;3.2 正式认识分层结构&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609229035668.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;4-参考模型&#34;&gt;4. 参考模型&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;英文&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;应用层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Application Layer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;直接为用户的应用进程（例如电子邮件、文件传输和终端仿真）提供服务。如HTTP、SMTP、FTP、DNS等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;表示层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Presentation Layer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;把数据转换为能与接收者的系统格式兼容并适合传输的格式，即让两个系统可以交换信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;会话层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Session Layer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;传输层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Transport Layer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;负责端到端通讯，可靠传输，不可靠传输 ，流量控制，复用分用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网络层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Network Layer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;负责选择路由最佳路径，规划IP地址(ipv4和ipv6变化只会影响网络层)，拥塞控制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据链路层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Data Link Layer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;帧的开始和结束，还有透明传输，差错校验(纠错由传输层解决)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;物理层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Physical Layer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;定义网络设备接口标准，电气标准(电压)，如何在物理链路上传输的更快&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;41-osi流程简介&#34;&gt;4.1 OSI流程简介&lt;/h2&gt;
&lt;p&gt;网络层及以上，每一层都要对上一层发送的数据进行处理（加个头部）&lt;br&gt;
数据链路层不仅需要加头部，还需要加尾部&lt;br&gt;
物理层什么都不加，只管发送数据（比特流）&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609229644091.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;42-tcpip参考模型&#34;&gt;4.2 TCP/IP参考模型&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609229668243.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;43-五层参考模型及其传输过程简介&#34;&gt;4.3 五层参考模型及其传输过程简介&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609229701190.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609229703634.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;参考资料&lt;br&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV19E411D78Q&#34;&gt;2019 王道考研 计算机网络&lt;/a&gt;&lt;/p&gt;
">计算机网络笔记Part1 概述</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/ji-suan-ji-wang-luo-bi-ji-part0/"" data-c="
          &lt;h1 id=&#34;计算机网络的概念&#34;&gt;计算机网络的概念&lt;/h1&gt;
&lt;p&gt;计算机网络是&lt;code&gt;互连&lt;/code&gt;的、&lt;code&gt;自治&lt;/code&gt;的计算机集合。(互连：互联互通，自治：无助从关系)&lt;/p&gt;
&lt;h1 id=&#34;计算机网络的功能&#34;&gt;计算机网络的功能&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609226192060.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;计算机网络的组成&#34;&gt;计算机网络的组成&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609226327918.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;计算机网络的分类&#34;&gt;计算机网络的分类&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609226484564.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;总结一&#34;&gt;总结一&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609226548838.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;标准化工作&#34;&gt;标准化工作&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609226653873.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;标准化工作流程&#34;&gt;标准化工作流程&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609226712307.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;标准化相关组织&#34;&gt;标准化相关组织&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609226782253.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;总结二&#34;&gt;总结二&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1609226812168.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">计算机网络笔记Part0</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/vueandmock-mo-ni-shu-ju/"" data-c="
          &lt;h1 id=&#34;mock在vue里怎么用&#34;&gt;mock在vue里怎么用？&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/nuysoft/Mock/wiki/Getting-Started&#34;&gt;https://github.com/nuysoft/Mock/wiki/Getting-Started&lt;/a&gt;&lt;br&gt;
以上是官方文档，不知道mock是什么的自行查看&lt;/p&gt;
&lt;h1 id=&#34;一-下载nodejs-的npm-自行下载&#34;&gt;一、下载node.js 的npm 自行下载&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;+ npm install -g cnpm --registry=https://registry.npm.taobao.org
     //npm的镜像
	+ npm install -g @vue/cli    //安装全局脚手架  
	    自己新建一个文件夹，并在文件夹中打开  powershell 
	+ vue create mypro(文件名可随意换)   //创建并下载一个文件夹
	+ npm install vue-router --save //启路由的插件
		--save 代表局部
	+ cd mypro
	+ npm run serve //运行 
	+ 用local 地址打开
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;11-创建项目&#34;&gt;1.1 创建项目&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;vue create mock-demo 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608807847530.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;12-安装依赖-不懂请看上面&#34;&gt;1.2 安装依赖 （不懂请看上面）&lt;/h2&gt;
&lt;p&gt;vue环境搭建好后，开始安装 mock依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     //使用axios发送  ajax
	  	cnpm install axios --save
	//使用mockjs产生随机数据
	  	cnpm install mockjs --save-dev
	//使用json5解决json文件,无法添加注释问题
	  	cnpm install json5 --save-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;二-学习mockjs&#34;&gt;二、学习MOCKJS&lt;/h1&gt;
&lt;p&gt;新建mock文件夹,新建testMockjs.js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const Mock = require(&#39;mockjs&#39;);//mockjs 导入依赖模块
var id = Mock.mock(&#39;@id&#39;)//得到随机的id,字符串
console.log(Mock.mock(&#39;@id&#39;), typeof id)

var obj = Mock.mock({
    id: &amp;quot;@id()&amp;quot;,//得到随机的id,对象
    username: &amp;quot;@cname()&amp;quot;,//随机生成中文名字
    date: &amp;quot;@date()&amp;quot;,//随机生成日期
    avatar: &amp;quot;@image(&#39;200x200&#39;,&#39;red&#39;,&#39;#fff&#39;,&#39;avatar&#39;)&amp;quot;,//生成图片,参数:size, background, foreground, text
    description: &amp;quot;@paragraph()&amp;quot;,//描述
    ip: &amp;quot;@ip()&amp;quot;,//IP地址
    email: &amp;quot;@email()&amp;quot;//email
})
console.log(obj)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;三-学习json5&#34;&gt;三、学习JSON5&lt;/h1&gt;
&lt;p&gt;json文件,中如果说存在注释文件和编辑器都会报错,我们采用json5格式来让json格式可以存在注释&lt;/p&gt;
&lt;h2 id=&#34;31编辑器安装json5扩展&#34;&gt;3.1编辑器安装JSON5扩展&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608807967957.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;32引入json5库来解析json5格式&#34;&gt;3.2引入JSON5库来解析JSON5格式&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);
const JSON5 = require(&#39;json5&#39;);
//读取json文件
function getJsonFile(filePath) {
    //读取指定json文件
    var json = fs.readFileSync(path.resolve(__dirname,filePath), &#39;utf-8&#39;);
    //解析并返回
    return JSON5.parse(json);
}
var json = getJsonFile(&#39;./userInfo.json5&#39;);
console.log(&#39;json&#39;, json) 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;四-mock和vue-cli结合&#34;&gt;四、MOCK和VUE-CLI结合&lt;/h1&gt;
&lt;h2 id=&#34;41新建indexjs&#34;&gt;4.1新建INDEX.JS&lt;/h2&gt;
&lt;p&gt;在mock文件夹下,新建index.js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);
const Mock = require(&#39;mockjs&#39;);//mockjs 导入依赖模块
const JSON5 = require(&#39;json5&#39;);
//读取json文件
function getJsonFile(filePath) {
    //读取指定json文件
    var json = fs.readFileSync(path.resolve(__dirname,filePath), &#39;utf-8&#39;);
    //解析并返回
    return JSON5.parse(json);
}

//返回一个函数
module.exports = function(app){
    //监听http请求
    app.get(&#39;/user/userinfo&#39;, function (rep, res) {
        //每次响应请求时读取mock data的json文件
        //getJsonFile方法定义了如何读取json文件并解析成数据对象
        var json = getJsonFile(&#39;./userInfo.json5&#39;);
        //将json传入 Mock.mock 方法中，生成的数据返回给浏览器
        res.json(Mock.mock(json));
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;42-新建vueconfigjs&#34;&gt;4.2 新建VUE.CONFIG.JS&lt;/h2&gt;
&lt;p&gt;在项目根目录下,新建vue.config.js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module.exports = {
    devServer: {
        before: require(&#39;./mock/index.js&#39;)//引入mock/index.js
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;43-发送ajax请求&#34;&gt;4.3 发送AJAX请求&lt;/h2&gt;
&lt;p&gt;在src\components\HelloWorld.vue中发送ajax请求&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import axios from &#39;axios&#39;
	export default {
	  name: &#39;HelloWorld&#39;,
	  props: {
	    msg: String
	  },
	  mounted() {
	    axios.get(&#39;/user/userinfo&#39;)
	    .then(res =&amp;gt; {
	      console.log(res)
	    })
	    .catch(err =&amp;gt; {
	      console.error(err); 
	    })
	  }
	} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;五-移除mock-连接实际api&#34;&gt;五、移除MOCK （连接实际api）&lt;/h1&gt;
&lt;p&gt;在项目根路径新建.env.development&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MOCK=true 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完善mock\index.js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module.exports = function(app){
    if(process.env.MOCK == &#39;true&#39;){
        //监听http请求
        app.get(&#39;/user/userinfo&#39;, function (rep, res) {
            //每次响应请求时读取mock data的json文件
            //getJsonFile方法定义了如何读取json文件并解析成数据对象
            var json = getJsonFile(&#39;./userInfo.json5&#39;);
            //将json传入 Mock.mock 方法中，生成的数据返回给浏览器
            res.json(Mock.mock(json));
        });
    }
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;六-总结mock-json5-devserver-axios职责&#34;&gt;六、总结,MOCK-JSON5-DEVSERVER-AXIOS职责&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608808179446.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;七-mockjs-中常用的函数&#34;&gt;七、mockjs 中常用的函数&lt;/h1&gt;
&lt;p&gt;&#39;Boolean&#39;: &#39;@boolean&#39;, // 随机生成布尔类型&lt;br&gt;
&#39;Natural&#39;: &#39;@natural(1, 100)&#39;, // 随机生成1到100之间自然数&lt;br&gt;
&#39;Integer&#39;: &#39;@integer(1, 100)&#39;, // 生成1到100之间的整数&lt;br&gt;
&#39;Float&#39;: &#39;@float(0, 100, 0, 5)&#39;, // 生成0到100之间的浮点数,小数点后尾数为0到5位&lt;br&gt;
&#39;Character&#39;: &#39;@character(&amp;quot;aeiou&amp;quot;)&#39;, // 在aeiou中，生成随机字符，不传参表示生成随机字符&lt;br&gt;
&#39;String&#39;: &#39;@string( 2, 10)&#39;, // 生成2到10个字符之间的字符串&lt;br&gt;
&#39;Range&#39;: &#39;@range(0, 10, 2)&#39;, // 生成一个数组，数组元素从0开始到10结束，间隔为2&lt;br&gt;
&#39;Date&#39;: &#39;@date(&amp;quot;yyyy yy y MM M dd d&amp;quot;)&#39;, // 生成一个随机日期,可加参数定义日期格式，默认yyyy-mm-dd&lt;br&gt;
&#39;Color1&#39;: &#39;@color&#39;, // 生成一个颜色16进制随机值&lt;br&gt;
&#39;Color2&#39;: &#39;@rgb&#39;, //生成一个颜色rgb随机值&lt;br&gt;
&#39;Paragraph&#39;:&#39;@paragraph(2, 5)&#39;, //生成2至5个句子的文本&lt;br&gt;
&#39;Sentence&#39;:&#39;@sentence(3, 5)&#39;, //生成3至5个单词组成的一个句子&lt;br&gt;
&#39;World&#39;:&#39;@word(3, 5)&#39;, //生成3-5个字母组成的单词&lt;br&gt;
&#39;title&#39;:&#39;@title(3,5)&#39;, //生成3-5个单词组成的标题&lt;br&gt;
&#39;cParagraph&#39;:&#39;@cparagraph(2, 5)&#39;, //生成2至5个句子的中文文本&lt;br&gt;
&#39;cSentence&#39;:&#39;@csentence(3, 5)&#39;, //生成3至5个词语组成的一个中文句子&lt;br&gt;
&#39;cWorld&#39;:&#39;@cword(3, 5)&#39;, //生成3-5个字组成的中文词语&lt;br&gt;
&#39;ctitle&#39;:&#39;@ctitle(3,5)&#39;, //生成3-5个词语组成的中文标题&lt;br&gt;
&#39;Name&#39;: &#39;@name&#39;, // 生成姓名&lt;br&gt;
&#39;cName&#39;: &#39;@cname&#39;, // 生成中文姓名&lt;br&gt;
&#39;Url&#39;: &#39;@url&#39;, // 生成url地址&lt;br&gt;
&#39;Email&#39;:&#39;@email&#39;,//生成邮箱&lt;br&gt;
&#39;Address&#39;: &#39;@county(true)&#39;， // 生成省 市 县组成的地址&lt;br&gt;
&#39;Guid&#39;:&#39;@guid()&#39;, //生成Guid值&lt;/p&gt;
">Vue&mock模拟数据</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/vueandmarkdown-bian-ji-qi-mavoneditor/"" data-c="
          &lt;h1 id=&#34;一-介绍&#34;&gt;一、介绍&lt;/h1&gt;
&lt;p&gt;Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。mavonEditor是国人开源的一款比较好用的markdown编辑器，GitHub地址：&lt;a href=&#34;https://github.com/hinesboy/mavonEditor&#34;&gt;https://github.com/hinesboy/mavonEditor&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;二-安装&#34;&gt;二、安装&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;npm install mavon-editor --save
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;三-使用&#34;&gt;三、使用&lt;/h1&gt;
&lt;h2 id=&#34;方法一&#34;&gt;方法一：&lt;/h2&gt;
&lt;p&gt;main.js:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; // 全局注册
    // import with ES6
    import Vue from &#39;vue&#39;
    import mavonEditor from &#39;mavon-editor&#39;
    import &#39;mavon-editor/dist/css/index.css&#39;
    // use
    Vue.use(mavonEditor)
    new Vue({
        &#39;el&#39;: &#39;#main&#39;,
        data() {
            return { value: &#39;&#39; }
        }
    })
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;index.html&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;main&amp;quot;&amp;gt;
    &amp;lt;mavon-editor v-model=&amp;quot;value&amp;quot;/&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;方法二&#34;&gt;方法二：&lt;/h2&gt;
&lt;p&gt;editor.vue:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;template&amp;gt;
        &amp;lt;div id=&amp;quot;editor&amp;quot;&amp;gt;
            &amp;lt;mavon-editor style=&amp;quot;height: 100%&amp;quot;&amp;gt;&amp;lt;/mavon-editor&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/template&amp;gt;
    &amp;lt;script&amp;gt;
    // Local Registration
    import { mavonEditor } from &#39;mavon-editor&#39;
    import &#39;mavon-editor/dist/css/index.css&#39;
    export default {
        name: &#39;editor&#39;,
        components: {
            mavonEditor
            // or &#39;mavon-editor&#39;: mavonEditor
        }
    }
    &amp;lt;/script&amp;gt;
    &amp;lt;style&amp;gt;
    #editor {
        margin: auto;
        width: 80%;
        height: 580px;
    }
    &amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;index.js:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 下同
    import Vue from &#39;vue&#39;;
    var editor = require(&#39;./editor.vue&#39;);
    new Vue({
        el: &#39;#main&#39;,
        render: h =&amp;gt; h(editor)
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;index.html:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 下同
&amp;lt;div id=&amp;quot;main&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;四-图片上传&#34;&gt;四、图片上传&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
    &amp;lt;mavon-editor ref=md @imgAdd=&amp;quot;$imgAdd&amp;quot; @imgDel=&amp;quot;$imgDel&amp;quot;&amp;gt;&amp;lt;/mavon-editor&amp;gt;
&amp;lt;/template&amp;gt;
exports default {
    methods: {
        // 绑定@imgAdd event
        $imgAdd(pos, $file){
            // 第一步.将图片上传到服务器.
           var formdata = new FormData();
           formdata.append(&#39;image&#39;, $file);
           axios({
               url: &#39;server url&#39;,
               method: &#39;post&#39;,
               data: formdata,
               headers: { &#39;Content-Type&#39;: &#39;multipart/form-data&#39; },
           }).then((url) =&amp;gt; {
               // 第二步.将返回的url替换到文本原位置![...](0) -&amp;gt; ![...](url)
               /**
               * $vm 指为mavonEditor实例，可以通过如下两种方式获取
               * 1. 通过引入对象获取: `import {mavonEditor} from ...` 等方式引入后，`$vm`为`mavonEditor`
               * 2. 通过$refs获取: html声明ref : `&amp;lt;mavon-editor ref=md &amp;gt;&amp;lt;/mavon-editor&amp;gt;，`$vm`为 `this.$refs.md`
               */
               $vm.$img2Url(pos, url);
           })
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注:&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;默认大小样式为 min-height: 300px , min-width: 300px 可自行覆盖&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;基础z-index: 1500&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;仅用作展示可以设置props: toolbarsFlag: false , subfield: false, defaultOpen: &amp;quot;preview&amp;quot;&lt;/strong&gt;&lt;/p&gt;
">Vue&markdown编辑器--mavonEditor</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/nodejs-cong-ling-dan-pai-9/"" data-c="
          &lt;h1 id=&#34;一-在-nodejs-中使用-mongodb&#34;&gt;一、在 Nodejs 中使用 Mongodb&lt;/h1&gt;
&lt;p&gt;在前面的课程我们给大家讲了如何使用命令操作 Mongodb，这一讲开始我们给大家讲解一 下如何使用 Nodejs 来操作 Mongodb 数据库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Nodejs 操作 mongodb 数据库官方文档：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://mongodb.github.io/node-mongodb-native/&#34;&gt;http://mongodb.github.io/node-mongodb-native/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install mongodb --save 
或者
cnpm install mongodb --save 
或者
yarn add mongodb
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;二-nodejs-连接-mongodb-数据库&#34;&gt;二、Nodejs 连接 MongoDb 数据库&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const MongoClient = require(&#39;mongodb&#39;).MongoClient;
const url = &#39;mongodb://localhost:27017&#39;; 
// const url = &#39;mongodb://admin:123456@localhost:27017/&#39;; 有密码连接方式 
const dbName = &#39;itying&#39;; 
const client = new MongoClient(url,{ useUnifiedTopology: true }); client.connect(function(err) { 
    if(err){
        console.log(err); 
        return;
     }
     console.log(&amp;quot;连接成功&amp;quot;); 
     //获取 db 对象 
     const db = client.db(dbName); 
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span style=&#34;color:red&#34;&gt;注意：如果数据库开启了权限验证的话需要使用下面方式连接数据库&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const url = &#39;mongodb://admin:123456@localhost:27017/&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span style=&#34;color:red&#34;&gt;其中：&lt;/span&gt;admin 表示用户名，123456 表示密码&lt;/p&gt;
&lt;h1 id=&#34;三-nodejs-查找-mongodb-数据库的数据&#34;&gt;三、Nodejs 查找 MongoDb 数据库的数据&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const MongoClient = require(&#39;mongodb&#39;).MongoClient; 
const url = &#39;mongodb://localhost:27017&#39;; 
const dbName = &#39;itying&#39;; 
const client = new MongoClient(url,{ useUnifiedTopology: true }); client.connect(function(err) { 
    if(err){
        console.log(err); 
        return; 
    }
    const db = client.db(dbName); //获取 db 对象 
    db.collection(&amp;quot;user&amp;quot;).find({}).toArray(function(err,data){ //查找 
        if(err){
            console.log(err); 
            return; 
        }
        console.log(data); 
        client.close(); 
        })
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;四-nodejs-给-mongodb-增加数据&#34;&gt;四、Nodejs 给 MongoDb 增加数据&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const MongoClient = require(&#39;mongodb&#39;).MongoClient; 
const url = &#39;mongodb://localhost:27017&#39;; 
const dbName = &#39;itying&#39;; 
const client = new MongoClient(url,{ useUnifiedTopology: true }); client.connect(function(err) { 
    if(err){
        console.log(err); 
        return; 
    }
    //获取 db 对象 
    const db = client.db(dbName); 
    //新增数据 
    db.collection(&amp;quot;user&amp;quot;).insertOne({&amp;quot;username&amp;quot;:&amp;quot;nodejs&amp;quot;,&amp;quot;age&amp;quot;:10},(err,result)=&amp;gt;{ 
        if(err){
            console.log(err); 
            return; 
        }
        console.log(result); 
        client.close(); 
     }) 
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;五-nodejs-修改-mongodb-数据&#34;&gt;五、Nodejs 修改 MongoDb 数据&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const MongoClient = require(&#39;mongodb&#39;).MongoClient; 
const url = &#39;mongodb://localhost:27017&#39;; 
// const url = &#39;mongodb://admin:123456@localhost:27017/&#39;; 有密码连接方式 
const dbName = &#39;itying&#39;; 
const client = new MongoClient(url,{ useUnifiedTopology: true }); client.connect(function(err) {
     if(err){
         console.log(err); 
         return; 
    }
    const db = client.db(dbName); 
    //获取 db 对象 
    db.collection(&amp;quot;user&amp;quot;).updateOne({&amp;quot;name&amp;quot;:&amp;quot;zhangsan&amp;quot;},{$set:{&amp;quot;age&amp;quot;:50}},(err,result)=&amp;gt;{ 
        if(err){
         console.log(err); 
         return; 
        }
        console.log(result); 
        client.close(); 
    })
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;六-nodejs-删除-mongodb-数据&#34;&gt;六、Nodejs 删除 MongoDb 数据&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const {MongoClient,ObjectID} = require(&#39;mongodb&#39;); 
const url = &#39;mongodb://localhost:27017&#39;; 
const dbName = &#39;itying&#39;; 
const client = new MongoClient(url,{ useUnifiedTopology: true }); client.connect(function(err) { 
    if(err){
        console.log(err); 
        return; 
        }
        //获取 db 对象 
        const db = client.db(dbName); 
        //删除数据 
        db.collection(&amp;quot;user&amp;quot;).deleteOne({ &amp;quot;username&amp;quot; : &amp;quot;nodejs&amp;quot; }, function(err, result) { 
            if(err){ 
                console.log(err); 
                return; 
            }
            console.log(result); 
            client.close(); 
        }); 
});
&lt;/code&gt;&lt;/pre&gt;
">NodeJs从零单排(9)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/nodejs-cong-ling-dan-pai-8/"" data-c="
          &lt;h1 id=&#34;1-模块化的方式封装&#34;&gt;1、模块化的方式封装&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;var app={ 
    static:function (req, res, staticPath) { 
        //处理静态资源 
    },
    login:function(req,res){ 
        console.log(&#39;login&#39;); 
        res.end(&#39;login&#39;); 
    },
    dologin:function(req,res){ 
        res.end(&#39;doLogin&#39;); 
    }, 
    register:function(req,res){ 
        res.end(&#39;register&#39;); 
    },error:function(req,res){ 
        res.end(&#39;error&#39;); 
    } 
}
module.exports=app;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;http.createServer(function (req, res) { 
    //创建静态 web 服务 
    routes.static(req,res,&#39;static&#39;); 
    //路由 
    let pathname=url.parse(req.url).pathname.replace(&#39;/&#39;,&#39;&#39;); 
    try { 
        routes[pathname](req, res); 
    } catch (err) { 
        routes[&#39;error&#39;](req, res); 
        }
}).listen(3000);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2-封装仿照-express-的路由&#34;&gt;2、封装仿照 express 的路由&lt;/h1&gt;
&lt;p&gt;Express 官网：&lt;a href=&#34;https://www.expressjs.com.cn/&#34;&gt;https://www.expressjs.com.cn/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var express = require(&#39;express&#39;) 
var app = express() 
app.get(&amp;quot;/&amp;quot;, function (req, res) { 
    res.send(&#39;hello world&#39;) 
})
app.get(&amp;quot;/login&amp;quot;, function (req, res) {
    res.send(&#39;hello world&#39;) 
})
app.post(&amp;quot;/doLogin&amp;quot;, function (req, res) { 
    res.send(&#39;POST request to the homepage&#39;) 
})
&lt;/code&gt;&lt;/pre&gt;
">NodeJs从零单排(8)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/nodejs-cong-ling-dan-pai-7/"" data-c="
          &lt;h1 id=&#34;1-nodejs-封装静态-web-服务&#34;&gt;1、 Nodejs 封装静态 web 服务&lt;/h1&gt;
&lt;p&gt;上一讲的静态 web 服务器封装&lt;/p&gt;
&lt;h1 id=&#34;2-路由&#34;&gt;2、 路由&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;官方解释：&lt;/strong&gt;&lt;br&gt;
路由（Routing）是由一个 URI（或者叫路径）和一个特定的 HTTP 方法（GET、POST 等）组成的，涉及到应用如何响应客户端对某个网站节点的访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通俗的说：&lt;/strong&gt;&lt;br&gt;
路由指的就是针对不同请求的 URL，处理不同的业务逻辑。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608781577104.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-初识-ejs-模块引擎&#34;&gt;3、 初识 EJS 模块引擎&lt;/h1&gt;
&lt;p&gt;我们学的 EJS 是后台模板，可以把我们数据库和文件读取的数据显示到 Html 页面上面。它是一个第三方模块，需要通过 npm 安装&lt;br&gt;
&lt;a href=&#34;https://www.npmjs.com/package/ejs&#34;&gt;https://www.npmjs.com/package/ejs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install ejs –save / cnpm install ejs --save
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nodejs 中使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ejs.renderFile(filename, data, options, function(err, str){ 
    // str =&amp;gt;  Rendered HTML string 
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;EJS 常用标签&lt;br&gt;
 &amp;lt;% %&amp;gt;流程控制标签&lt;br&gt;
 &amp;lt;%= %&amp;gt;输出标签（原文输出 HTML 标签）&lt;br&gt;
 &amp;lt;%- %&amp;gt;输出标签（HTML 会被浏览器解析）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;&amp;lt;%= url %&amp;gt;&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;&amp;lt;%= imageURL %&amp;gt;&amp;quot; alt=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt; 
    &amp;lt;% for(var i = 0 ; i &amp;lt; news.length ; i++){ %&amp;gt; 
         &amp;lt;li&amp;gt;&amp;lt;%= news[i] %&amp;gt;&amp;lt;/li&amp;gt; 
    &amp;lt;% } %&amp;gt; 
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;4-get-post&#34;&gt;4、 Get、Post&lt;/h1&gt;
&lt;p&gt;超文本传输协议（HTTP）的设计目的是保证客户端机器与服务器之间的通信。&lt;br&gt;
在客户端和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。&lt;/p&gt;
&lt;p&gt;GET - 从指定的资源请求数据。（一般用于获取数据）&lt;br&gt;
POST - 向指定的资源提交要被处理的数据。（一般用于提交数据）&lt;/p&gt;
&lt;p&gt;获取 GET 传值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var urlinfo=url.parse(req.url,true); 
urlinfo.query;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取 POST 传值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var postData = &#39;&#39;; 
// 数据块接收中 
req.on(&#39;data&#39;, function (postDataChunk) { 
    postData += postDataChunk; 
}); 
// 数据接收完毕，执行回调函数 
req.on(&#39;end&#39;, function () { 
    try {postData = JSON.parse(postData); 
    } catch (e) { } 
    req.query = postData; 
    console.log(querystring.parse(postData)); 
});
&lt;/code&gt;&lt;/pre&gt;
">NodeJs从零单排(7)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/nodejs-cong-ling-dan-pai-6/"" data-c="
          &lt;h1 id=&#34;1-nodejs-创建的第一个应用&#34;&gt;1、Node.js 创建的第一个应用&lt;/h1&gt;
&lt;p&gt;1、引入 http 模块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var http = require(&amp;quot;http&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、创建服务器&lt;br&gt;
接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 3000 端口。 函数通过 request, response 参数来接收和响应数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const http =require(&#39;http&#39;); 
http.createServer((req,res)=&amp;gt;{ 
    //状态码是 200，文件类型是 html，字符集是 utf-8 
    res.writeHead(200,{&amp;quot;Content-type&amp;quot;:&amp;quot;text/html;charset=&#39;utf-8&#39;&amp;quot;}); 
    res.write(&amp;quot;&amp;lt;head&amp;gt; &amp;lt;meta charset=&#39;UTF-8&#39;&amp;gt;&amp;lt;/head&amp;gt;&amp;quot;); 
    res.write(&#39;你好 nodejs&#39;); 
    res.write(&#39;&amp;lt;h2&amp;gt;你好 nodejs&amp;lt;/h2&amp;gt;&#39;); 
    res.end(); //结束响应
}).listen(3000);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2-web-服务器介绍&#34;&gt;2、WEB 服务器介绍&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Web 服务器一般指网站服务器&lt;/strong&gt;，是指驻留于因特网上某种类型计算机的程序，可以向 浏览器等 Web 客户端提供文档，也可以放置网站文件让全世界浏览，还可以放置数据文件， 让全世界下载。目前最主流的 Web 服务器有 Apache 、Nginx 、IIS 等。&lt;/p&gt;
&lt;h1 id=&#34;3-nodejs-创建一个-web-服务器&#34;&gt;3、Nodejs 创建一个 WEB 服务器。&lt;/h1&gt;
&lt;p&gt;1、可以让我们访问 web 服务器上面的网站&lt;br&gt;
2、可以让我们下载 web 服务器上面的文件&lt;/p&gt;
">NodeJs从零单排(6)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/nodejs-cong-ling-dan-pai-5/"" data-c="
          &lt;h1 id=&#34;一-es6-常见语法的使用&#34;&gt;一、 Es6 常见语法的使用&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;let const&lt;/li&gt;
&lt;li&gt;箭头函数&lt;/li&gt;
&lt;li&gt;对象、属性的简写&lt;/li&gt;
&lt;li&gt;模板字符串&lt;/li&gt;
&lt;li&gt;Promise&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;二-async-await-和-promise-的使用&#34;&gt;二、 Async、Await 和 Promise 的使用&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;async&lt;/strong&gt; 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个异步的 function ，而 await 用于等待一个异步方法执行完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单理解：&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;async&lt;/strong&gt; 是让方法变成异步。&lt;br&gt;
&lt;strong&gt;await&lt;/strong&gt; 是等待异步方法执行完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;详细说明：&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;async 是让方法变成异步&lt;/strong&gt;，在终端里用 node 执行这段代码，你会发现输出了 Promise {‘Hello async’ }，这时候会发现它返回的是 Promise。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;async function testAsync(){ 
    return &#39;Hello async&#39;; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;const result = testAsync(); 
console.log(result);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;PS E:\code\BXShop&amp;gt; node async.js 
Promise { &#39;Hello async&#39; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;await 在等待 async 方法执行完毕&lt;/strong&gt;，其实 await 等待的只是一个表达式，这个表达式在官方 文档里说的是 Promise 对象，但是它也可以接受普通值。 &lt;span style=&#34;color:red&#34;&gt;注意：&lt;/span&gt;await 必须在 async 方法中 才可以使用因为 await 访问本身就会造成程序停止堵塞，所以必须在异步方法中才可以使用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function getData(){ 
    return &#39;zhangsan&#39;; 
}
async function testAsync(){ 
    return &#39;Hello async&#39;; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;async function test(){ 
    const v1=await getData(); 
    const v2=await testAsync(); 
    console.log(v1,v2);
}
test();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;async/await 同时使用&lt;/strong&gt;&lt;br&gt;
async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function findData() { 
    return new Promise(resolve =&amp;gt; { 
        setTimeout(() =&amp;gt; resolve(&amp;quot;long_time_value&amp;quot;), 1000); 
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;async function test() { 
    const v = await findData(); 
    console.log(v);
}
test();
&lt;/code&gt;&lt;/pre&gt;
">NodeJs从零单排(5)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/nodejs-cong-ling-dan-pai-4/"" data-c="
          &lt;h1 id=&#34;1-fsstat-检测是文件还是目录&#34;&gt;1. fs.stat 检测是文件还是目录&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;) 
fs.stat(&#39;hello.js&#39;, (error, stats) =&amp;gt;{ 
    if(error){
         console.log(error) 
         } else {
        console.log(stats) 
        console.log(`文件：${stats.isFile()}`) 
        console.log(`目录：${stats.isDirectory()}`) 
        } 
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2-fsmkdir-创建目录&#34;&gt;2. fs.mkdir 创建目录&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;)
fs.mkdir(&#39;logs&#39;, (error) =&amp;gt; { 
    if(error){ 
       console.log(error) 
   } else { 
    console.log(&#39;成功创建目录：logs&#39;) 
     } 
 })
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3-fswritefile-创建写入文件&#34;&gt;3. fs.writeFile 创建写入文件&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;fs.writeFile(&#39;logs/hello.log&#39;, &#39;您好 ~ \n&#39;, (error) =&amp;gt; { 
    if(error) { 
        console.log(error) 
   } else { 
        console.log(&#39;成功写入文件&#39;) 
    } 
 })
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;4-fsappendfile-追加文件&#34;&gt;4. fs.appendFile 追加文件&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;) 
fs.appendFile(&#39;logs/hello.log&#39;, &#39;hello ~ \n&#39;, (error) =&amp;gt; { 
    if(error) { 
    console.log(error) 
    } else { 
        console.log(&#39;成功写入文件&#39;) 
    } 
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5fsreadfile-读取文件&#34;&gt;5.fs.readFile 读取文件&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;) 
fs.readFile(&#39;logs/hello.log&#39;, &#39;utf8&#39;, (error, data) =&amp;gt;{ 
    if (error) { 
     console.log(error) 
} else { 
    console.log(data) 
    } 
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;6fsreaddir-读取目录&#34;&gt;6.fs.readdir 读取目录&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;) 
fs.readdir(&#39;logs&#39;, (error, files) =&amp;gt; { 
   if (error) { 
     console.log(error) 
  } else { 
    console.log(files) 
    }
 })
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;7fsrename-重命名&#34;&gt;7.fs.rename 重命名&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;) 
fs.rename(&#39;js/hello.log&#39;, &#39;js/greeting.log&#39;, (error) =&amp;gt;{ 
 if (error) { 
     console.log(error) 
  } else { 
console.log(&#39;重命名成功&#39;) 
    }
 })
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;8-fsrmdir-删除目录&#34;&gt;8. fs.rmdir 删除目录&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;) 
fs.rmdir(&#39;logs&#39;, (error) =&amp;gt;{ 
 if (error) { 
    console.log(error) 
    } else { 
    console.log(&#39;成功的删除了目录：logs&#39;) 
     } 
 })
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;9-fsunlink-删除文件&#34;&gt;9. fs.unlink 删除文件&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;) 
fs.unlink(`logs/${file}`, (error) =&amp;gt; { 
  if (error) { 
    console.log(error) 
    } else { 
    console.log(`成功的删除了文件: ${file}`) 
    } 
 })
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;10-fscreatereadstream-从文件流中读取数据&#34;&gt;10. fs.createReadStream 从文件流中读取数据&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;) 
var fileReadStream = fs.createReadStream(&#39;data.json&#39;) 
let count=0; 
var str=&#39;&#39;; 
fileReadStream.on(&#39;data&#39;, (chunk) =&amp;gt; { 
    console.log(`${ ++count } 接收到：${chunk.length}`);
     str+=chunk
     })
fileReadStream.on(&#39;end&#39;, () =&amp;gt; { 
    console.log(&#39;--- 结束 ---&#39;); 
    console.log(count); 
    console.log(str); 
})
fileReadStream.on(&#39;error&#39;, (error) =&amp;gt; { 
    console.log(error)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;11-fscreatewritestream-写入文件&#34;&gt;11. fs.createWriteStream 写入文件&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;var fs = require(&amp;quot;fs&amp;quot;); 
var data = &#39;我是从数据库获取的数据，我要保存起来&#39;; 
// 创建一个可以写入的流，写入到文件 output.txt 中
var writerStream = fs.createWriteStream(&#39;output.txt&#39;); 
// 使用 utf8 编码写入数据 
writerStream.write(data,&#39;UTF8&#39;); 
// 标记文件末尾 
writerStream.end();
// 处理流事件 --&amp;gt; finish 事件
writerStream.on(&#39;finish&#39;, function() { 
    /*finish - 所有数据已被写入到底层系统时触发。*/
console.log(&amp;quot;写入完成。&amp;quot;); 
}); 
writerStream.on(&#39;error&#39;, function(err){ 
    console.log(err.stack); 
}); 
console.log(&amp;quot;程序执行完毕&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;12-管道流&#34;&gt;12. 管道流&lt;/h1&gt;
&lt;p&gt;管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传 递到另外一个流中。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608779085554.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如上面的图片所示，我们把文件比作装水的桶，而水就是文件里的内容，我们用一根管子(pipe)连接两个桶使得水从一个桶流入另一个桶，这样就慢慢的实现了大文件的复制过程。 以下实例我们通过读取一个文件内容并将内容写入到另外一个文件中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var fs = require(&amp;quot;fs&amp;quot;); 
// 创建一个可读流 
var readerStream = fs.createReadStream(&#39;input.txt&#39;); 
// 创建一个可写流 
var writerStream = fs.createWriteStream(&#39;output.txt&#39;); 
// 管道读写操作 
// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中 
readerStream.pipe(writerStream);
console.log(&amp;quot;程序执行完毕&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
">NodeJs从零单排(4)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/nodejs-cong-ling-dan-pai-3/"" data-c="
          &lt;h1 id=&#34;一-包与-npm&#34;&gt;一、包与 NPM&lt;/h1&gt;
&lt;h3 id=&#34;1-包&#34;&gt;1. 包&lt;/h3&gt;
&lt;p&gt;Nodejs 中除了它自己提供的&lt;span style=&#34;color:red&#34;&gt;核心模块&lt;/span&gt;外，我们可以&lt;span style=&#34;color:red&#34;&gt;自定义模块&lt;/span&gt;，也可以使用&lt;span style=&#34;color:red&#34;&gt;第三方的模块&lt;/span&gt;。Nodejs 中第三方模块由包组成，可以通过包来对一组具有相互依赖关系的模块进行统一管理。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608777425715.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;完全符合CommonJs规范的&lt;span style=&#34;color:red&#34;&gt;包目录&lt;/span&gt;一般包含如下这些文件。&lt;br&gt;
• package.json :包描述文件。&lt;br&gt;
• bin :用于存放可执行二进制文件的目录。&lt;br&gt;
• lib :用于存放 JavaScript 代码的目录。&lt;br&gt;
• doc :用于存放文档的目录。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;在 NodeJs 中通过 NPM 命令来下载第三方的模块（包）。&lt;/code&gt;&lt;br&gt;
&lt;a href=&#34;https://www.npmjs.com/package/silly-datetime&#34;&gt;https://www.npmjs.com/package/silly-datetime&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm i silly-datetime –save 
var sd = require(&#39;silly-datetime&#39;); 
sd.format(new Date(), &#39;YYYY-MM-DD HH:mm&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id=&#34;2-npm-介绍&#34;&gt;2. NPM 介绍&lt;/h3&gt;
&lt;p&gt;npm 是&lt;code&gt;世界上最大的开放源代码&lt;/code&gt;的生态系统。我们可以通过 npm 下载各种各样的包， 这些源代码（包）我们可以在&lt;a href=&#34;https://www.npmjs.com&#34;&gt;https://www.npmjs.com&lt;/a&gt;找到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;npm 是随同 NodeJS 一起安装的包管理工具，能解决 NodeJS 代码部署上的很多问题， 常见的使用场景有以下几种：&lt;/strong&gt;&lt;br&gt;
 允许用户从 NPM 服务器下载别人编写的第三方包到本地使用。(silly-datetime)&lt;br&gt;
 允许用户从 NPM 服务器下载并安装别人编写的命令行程序(工具)到本地使用。 （supervisor）&lt;br&gt;
 允许用户将自己编写的包或命令行程序上传到 NPM 服务器供别人使用。&lt;/p&gt;
&lt;h1 id=&#34;二-npm-命令详解&#34;&gt;二、NPM 命令详解。&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;npm -v 查看 npm 版本&lt;/li&gt;
&lt;li&gt;使用 npm 命令安装模块&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;npm install Module Name 
如安装 jq 模块：
npm install jquery
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;npm uninstall moudleName &lt;strong&gt;卸载模块&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;npm uninstall ModuleName
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;npm list 查看当前目录下已安装的 node 包&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;npm list
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;npm info jquery 查看 jquery 的版本&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;npm info 模块 //查看模块的版本
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;code&gt;指定版本安装 npm install jquery@1.8.0&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;三-packagejson&#34;&gt;三、package.json&lt;/h1&gt;
&lt;p&gt;package.json定义了这个项目所需要的各种模块,以及项目的配置信息(比如名称、版本、 许可证等元数据)&lt;br&gt;
1、&lt;code&gt;创建 package.json&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm init 或者 npm init –yes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、&lt;code&gt;package.json 文件&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
     &amp;quot;name&amp;quot;: &amp;quot;test&amp;quot;, 
     &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;, 
     &amp;quot;description&amp;quot;: &amp;quot;test&amp;quot;, 
     &amp;quot;main&amp;quot;: &amp;quot;main.js&amp;quot;, 
     &amp;quot;keywords&amp;quot;: [ &amp;quot;test&amp;quot; ],
     &amp;quot;author&amp;quot;: &amp;quot;wade&amp;quot;,
     &amp;quot;license&amp;quot;: &amp;quot;MIT&amp;quot;, 
     &amp;quot;dependencies&amp;quot;: { 
        &amp;quot;express&amp;quot;: &amp;quot;^4.10.1&amp;quot;
        },
        &amp;quot;devDependencies&amp;quot;: {
        &amp;quot;jslint&amp;quot;: &amp;quot;^0.6.5&amp;quot; 
     }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、安装模块并把模块写入 package.json(依赖)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install babel-cli --save-dev 
npm install 模块 --save 
npm install 模块 --save-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、&lt;code&gt;dependencies 与 devDependencies 之间的区别?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用 npm install node_module –save 自动更新 dependencies 字段值;&lt;br&gt;
使用 npm install node_module –save-dev 自动更新 devDependencies 字段值;&lt;/p&gt;
&lt;p&gt;dependencie 配置当前程序所依赖的其他包。&lt;br&gt;
devDependencie 配置当前程序所依赖的其他包，比如一些工具之类的配置在这里&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;dependencies&amp;quot;: { 
    &amp;quot;ejs&amp;quot;: &amp;quot;^2.3.4&amp;quot;, 
    &amp;quot;express&amp;quot;: &amp;quot;^4.13.3&amp;quot;,
     &amp;quot;formidable&amp;quot;: &amp;quot;^1.0.17&amp;quot;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;div style=&#34;color:red&#34;&gt;
^表示第一位版本号不变，后面两位取最新的&lt;br&gt;
~表示前两位不变，最后一个取最新&lt;br&gt;
*表示全部取最新
&lt;/div&gt;
&lt;h1 id=&#34;四-安装淘宝镜像&#34;&gt;四、安装淘宝镜像&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;http://www.npmjs.org&#34;&gt;http://www.npmjs.org&lt;/a&gt;  npm 包官网&lt;br&gt;
&lt;a href=&#34;https://npm.taobao.org/&#34;&gt;https://npm.taobao.org/&lt;/a&gt; 淘宝 npm 镜像官网&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;淘宝 NPM 镜像&lt;/strong&gt;是一个完整 &lt;strong&gt;npmjs.org&lt;/strong&gt; 镜像，你可以用此代替官方版本(只读)，同步频 率目前为 10 分钟 一次以保证尽量与官方服务同步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们可以使用我们定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g cnpm --registry=https://registry.npm.taobao.org
&lt;/code&gt;&lt;/pre&gt;
">NodeJs从零单排(3)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/nodejs-cong-ling-dan-pai-2/"" data-c="
          &lt;h1 id=&#34;一-什么是-commonjs&#34;&gt;一、什么是 CommonJs？&lt;/h1&gt;
&lt;p&gt;JavaScript 是一个强大面向对象语言，它有很多快速高效的解释器。然而， JavaScript 标准定义的 API 是为了构建基于浏览器的应用程序。并没有制定一个用于更广泛的应用程序 的标准库。&lt;code&gt;CommonJS 规范的提出,主要是为了弥补当前 JavaScript 没有标准库的缺陷。它的 终极目标就是：提供一个类似 Python，Ruby 和 Java 语言的标准库&lt;/code&gt;，而不只是让 JavaScript 停 留在小脚本程序的阶段。用 CommonJS API 编写出的应用，不仅可以利用 JavaScript 开发客户端应用，&lt;strong&gt;而且还可以编写以下应用。&lt;/strong&gt;&lt;br&gt;
     •服务器端 JavaScript 应用程序。（nodejs）&lt;br&gt;
     •命令行工具。&lt;br&gt;
     •桌面图形界面应用程序。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CommonJS 就是模块化的标准，nodejs 就是 CommonJS（模块化）的实现。&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;二-nodejs-中的模块化&#34;&gt;二、Nodejs 中的模块化&lt;/h1&gt;
&lt;p&gt;Node 应用由模块组成，采用 CommonJS 模块规范。&lt;/p&gt;
&lt;h2 id=&#34;21-在-node-中模块分为两类&#34;&gt;2.1 在 Node 中，模块分为两类:&lt;/h2&gt;
&lt;p&gt;一类是 Node 提供的模块,称为&lt;strong&gt;核心模块&lt;/strong&gt;；另一类是用户编写的模块，称为&lt;strong&gt;文件模块&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;    • 核心模块部分在 Node 源代码的编译过程中，编译进了二进制执行文件。在 Node 进 程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和 编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。 &lt;strong&gt;如：HTTP 模块 、URL 模块、Fs 模块都是 nodejs 内置的核心模块，可以直接引入使用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    • 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程、 速度相比核心模块稍微慢一些，但是用的非常多。&lt;strong&gt;这些模块需要我们自己定义。接下来我 们看一下 nodejs 中的自定义模块。&lt;/strong&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&#34;22-commonjsnodejs中自定义模块的规定&#34;&gt;2.2 CommonJS（Nodejs）中自定义模块的规定：&lt;/h2&gt;
&lt;p&gt;1.我们可以把公共的功能&lt;strong&gt;抽离成为一个单独的 js 文件作为&lt;/strong&gt;一个模块，默认情况下面这 个模块里面的方法或者属性，外面是没法访问的。如果要让外部可以访问模块里面的方法或 者属性，就必须在模块里面通过 exports 或者 module.exports 暴露属性或者方法。&lt;/p&gt;
&lt;p&gt;2.在需要使用这些模块的文件中，通过 require 的方式引入这个模块。这个时候就可 以使用模块里面暴露的属性和方法。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608774648876.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;23-定义使用模块&#34;&gt;2.3 定义使用模块：&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 定义一个 tools.js 的模块 
//模块定义
var tools = {
     sayHello: function() {
        return &#39;hello NodeJS&#39;;
        },
        add: function(x, y) {
            return x + y; 
            } 
 };// 模块接口的暴露 
// module.exports = tools; 
    exports.sayHello = tools.sayHello; 
    exports.add = tools.add;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var http = require(&#39;http&#39;); 
// 引入自定义的 tools.js 模块
var tools= require(&#39;./tools&#39;); 
tools.sayHello(); //使用模块
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;三-npm-init-生成-packagejson&#34;&gt;三、npm init 生成 package.json&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;npm init --yes
&lt;/code&gt;&lt;/pre&gt;
">NodeJs从零单排(2)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/nodejs-cong-ling-dan-pai/"" data-c="
          &lt;h1 id=&#34;一-nodejs-环境搭建&#34;&gt;一、NodeJs 环境搭建&lt;/h1&gt;
&lt;p&gt;官网：&lt;a href=&#34;https://nodejs.org/en/&#34;&gt;https://nodejs.org/en/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&#34;https://nodejs.org/en/download/&#34;&gt;https://nodejs.org/en/download/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载稳定版本、双击下一步下一步安装。&lt;/p&gt;
&lt;p&gt;安装完成重新打开 CMD。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608729555271.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;二-nodejs-创建第一个应用&#34;&gt;二、Node.js 创建第一个应用&lt;/h1&gt;
&lt;p&gt;1、引入 http 模块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var http = require(&amp;quot;http&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、创建服务器&lt;br&gt;
接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var http = require(&#39;http&#39;);
 http.createServer(function (request, response) {
    // 发送 HTTP 头部
    // HTTP 状态值: 200 : OK
    //设置 HTTP 头部，状态码是 200，文件类型是 html，字符集是 utf8 
    response.writeHead(200,{&amp;quot;Content-Type&amp;quot;:&amp;quot;text/html;charset=UTF-8&amp;quot;}); 
    // 发送响应数据 &amp;quot;Hello World&amp;quot; 
    res.end(&amp;quot;哈哈哈哈，我买了一个 iPhone&amp;quot; + (1+2+3) + &amp;quot;s&amp;quot;); 
    }).listen(8888); 
    // 终端打印如下信息 
    console.log(&#39;Server running at http://127.0.0.1:8888/&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.运行程序&lt;br&gt;
用命令行切换到程序对应目录。通过 node 命令运行程序。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608771582393.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
浏览器运行&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608771633470.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
你会发现，我们本地写一个 js，打死都不能直接拖入浏览器运行，但是有了 node，我们任何一个 js 文件，都可以通过 node 来运行。&lt;span style=&#34;color:red&#34;&gt;也就是说，node 就是一个 js 的执行环境。&lt;/span&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&#34;三-nodejs-创建第一个应用&#34;&gt;三、Node.js 创建第一个应用&lt;/h1&gt;
&lt;p&gt;Node.js 中，将很多的功能，划分为了一个个 module（模块）。 Node.js 中的很多功能都 是通过模块实现。&lt;/p&gt;
&lt;h2 id=&#34;31-http-模块的使用&#34;&gt;3.1、HTTP 模块的使用&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;//引用模块 
var http = require(&amp;quot;http&amp;quot;); 

//创建一个服务器，回调函数表示接收到请求之后做的事情 
var server = http.createServer(function(req,res){ 
    //req 参数表示请求，res 表示响应 
    console.log(&amp;quot;服务器接收到了请求&amp;quot; + req.url); 
    res.end(); // End 方法使 Web 服务器停止处理脚本并返回当前结果
 }); 
 //监听端口
server.listen(3000,&amp;quot;127.0.0.1&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置一个响应头：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;res.writeHead(200,{&amp;quot;Content-Type&amp;quot;:&amp;quot;text/html;charset=UTF8&amp;quot;});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608772545739.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
我们现在来看一下 req 里面能够使用的东西。&lt;br&gt;
&lt;code&gt;最关键的就是 req.url 属性&lt;/code&gt;，表示用户的请求 URL 地址。所有的路由设计，都是通过 req.url 来实现的。&lt;br&gt;
我们比较关心的不是拿到 URL，而是识别这个 URL。&lt;br&gt;
&lt;span style=&#34;color:green&#34;&gt;识别 URL，用到了下面的&lt;code&gt;url 模块&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-url-模块的使用&#34;&gt;3.2、URL 模块的使用&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;url.parse() 解析 URL
url.format(urlObject) //是上面 url.parse() 操作的逆向操作 
url.resolve(from, to) 添加或者替换地址
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1、url.parse()&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608772888877.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608772910458.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608772947330.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608772951314.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;2、url.format()&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608772985827.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;3、url.resolve()&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608773020569.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&#34;四-nodejs-自启动工具-supervisor&#34;&gt;四、Nodejs 自启动工具 supervisor&lt;/h1&gt;
&lt;p&gt;supervisor 会不停的 watch 你应用下面的所有文件，发现有文件被修改，就重新载入程序文件这样就实现了部署，修 改了程序文件后马上就能看到变更后的结果。麻麻再也不用担心我的重启 nodejs 了！&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先安装 supervisor&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g supervisor
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 supervisor 代替 node 命令启动应用&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1608773581099.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
">NodeJs从零单排(1)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/ecmascript-6-11/"" data-c="
          &lt;h1 id=&#34;第-1-章-ecmasript-相关介绍&#34;&gt;第 1 章 ECMASript 相关介绍&lt;/h1&gt;
&lt;h2 id=&#34;11什么是-ecma&#34;&gt;1.1.什么是 ECMA&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1607764166027.png&#34; alt=&#34;ECMA&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;ECMA（European Computer Manufacturers Association）中文名称为欧洲计算机制造商协会，这个组织的目标是评估、开发和认可电信和计算机标准。1994 年后该组织改名为 Ecma 国际。&lt;/p&gt;
&lt;h2 id=&#34;12什么是-ecmascript&#34;&gt;1.2.什么是 ECMAScript&lt;/h2&gt;
&lt;p&gt;ECMAScript 是由 Ecma 国际通过 ECMA-262 标准化的脚本程序设计语言。&lt;/p&gt;
&lt;h2 id=&#34;13什么是-ecma-262&#34;&gt;1.3.什么是 ECMA-262&lt;/h2&gt;
&lt;p&gt;Ecma 国际制定了许多标准，而 ECMA-262 只是其中的一个，所有标准列表查看&lt;br&gt;
&lt;a href=&#34;http://www.ecma-international.org/publications/standards/Standard.htm&#34;&gt;http://www.ecma-international.org/publications/standards/Standard.htm&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;14ecma-262-历史&#34;&gt;1.4.ECMA-262 历史&lt;/h2&gt;
&lt;p&gt;ECMA-262（ECMAScript）历史版本查看网址&lt;br&gt;
&lt;a href=&#34;http://www.ecma-international.org/publications/standards/Ecma-262-arch.htm&#34;&gt;http://www.ecma-international.org/publications/standards/Ecma-262-arch.htm&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1607764588998.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;div style=&#34;color:red&#34;&gt; 注：从 ES6 开始，每年发布一个版本，版本号比年份最后一位大 1&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;15谁在维护-ecma-262&#34;&gt;1.5.谁在维护 ECMA-262&lt;/h2&gt;
&lt;p&gt;TC39（Technical Committee 39）是推进 ECMAScript 发展的委员会。其会员都是公司（其中主要是浏览器厂商，有苹果、谷歌、微软、因特尔等）。TC39 定期召开会议，会议由会员公司的代表与特邀专家出席。&lt;/p&gt;
&lt;h2 id=&#34;16为什么要学习-es6&#34;&gt;1.6.为什么要学习 ES6&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ES6 的版本变动内容最多，具有里程碑意义&lt;/li&gt;
&lt;li&gt;ES6 加入许多新的语法特性，编程实现更简单、高效&lt;/li&gt;
&lt;li&gt;ES6 是前端发展趋势，就业必备技能&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;17es6-兼容性&#34;&gt;1.7.ES6 兼容性&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://kangax.github.io/compat-table/es6/&#34;&gt;可查看兼容性&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;第-2-章-ecmasript-6-新特性&#34;&gt;第 2 章 ECMASript 6 新特性&lt;/h1&gt;
&lt;h2 id=&#34;21let-关键字&#34;&gt;2.1.let 关键字&lt;/h2&gt;
&lt;p&gt;let 关键字用来声明变量，使用 let 声明的变量有几个特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不允许重复声明&lt;/li&gt;
&lt;li&gt;块儿级作用域&lt;/li&gt;
&lt;li&gt;不存在变量提升&lt;/li&gt;
&lt;li&gt;不影响作用域链&lt;/li&gt;
&lt;/ol&gt;
&lt;div style=&#34;color:red&#34;&gt; 应用场景：以后声明变量使用 let 就对了&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;22-const-关键字&#34;&gt;2.2. const 关键字&lt;/h2&gt;
&lt;p&gt;const 关键字用来声明常量，const 声明有以下特点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;声明必须赋初始值&lt;/li&gt;
&lt;li&gt;标识符一般为大写&lt;/li&gt;
&lt;li&gt;不允许重复声明&lt;/li&gt;
&lt;li&gt;值不允许修改&lt;/li&gt;
&lt;li&gt;块儿级作用域&lt;/li&gt;
&lt;/ol&gt;
&lt;div style=&#34;color:red&#34;&gt; 注意: 对象属性修改和数组元素变化不会出发 const 错误&lt;/div&gt;
&lt;div style=&#34;color:red&#34;&gt; 应用场景：声明对象类型使用 const，非对象类型声明选择 let&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;23变量的解构赋值&#34;&gt;2.3.变量的解构赋值&lt;/h2&gt;
&lt;p&gt;ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//数组的解构赋值
const arr = [&#39;张学友&#39;, &#39;刘德华&#39;, &#39;黎明&#39;, &#39;郭富城&#39;];
let [zhang, liu, li, guo] = arr;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;//对象的解构赋值
const lin = {
 name: &#39;林志颖&#39;,
 tags: [&#39;车手&#39;, &#39;歌手&#39;, &#39;小旋风&#39;, &#39;演员&#39;]
};
let {name, tags} = lin;
//复杂解构
let wangfei = {
 name: &#39;王菲&#39;,
 age: 18,
 songs: [&#39;红豆&#39;, &#39;流年&#39;, &#39;暧昧&#39;, &#39;传奇&#39;],
 history: [
 {name: &#39;窦唯&#39;},
 {name: &#39;李亚鹏&#39;},
 {name: &#39;谢霆锋&#39;}
 ]
};
let {songs: [one, two, three], history: [first, second, third]} = 
wangfei;
&lt;/code&gt;&lt;/pre&gt;
&lt;div style=&#34;color:red&#34;&gt;注意：频繁使用对象方法、数组元素，就可以使用解构赋值形式&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;24模板字符串&#34;&gt;2.4.模板字符串&lt;/h2&gt;
&lt;p&gt;模板字符串（template string）是增强版的字符串，用反引号（`）标识，特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;字符串中可以出现换行符&lt;/li&gt;
&lt;li&gt;可以使用 ${xxx} 形式输出变量&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;// 定义字符串
let str = `&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;沈腾&amp;lt;/li&amp;gt;
 &amp;lt;li&amp;gt;玛丽&amp;lt;/li&amp;gt;
 &amp;lt;li&amp;gt;魏翔&amp;lt;/li&amp;gt;
 &amp;lt;li&amp;gt;艾伦&amp;lt;/li&amp;gt;
 &amp;lt;/ul&amp;gt;`;
// 变量拼接
let star = &#39;王宁&#39;;
let result = `${star}在前几年离开了开心麻花`;
&lt;/code&gt;&lt;/pre&gt;
&lt;div style=&#34;color:red&#34;&gt;注意：当遇到字符串与变量拼接的情况使用模板字符串&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;25简化对象写法&#34;&gt;2.5.简化对象写法&lt;/h2&gt;
&lt;p&gt;ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let name = &#39;尚硅谷&#39;;
let slogon = &#39;永远追求行业更高标准&#39;;
let improve = function () {
 console.log(&#39;可以提高你的技能&#39;);
}
//属性和方法简写
let atguigu = {
 name,
 slogon,
 improve,
 change() {
 console.log(&#39;可以改变你&#39;)
 }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;div style=&#34;color:red&#34;&gt;注意：对象简写形式简化了代码，所以以后用简写就对了&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;26箭头函数&#34;&gt;2.6.箭头函数&lt;/h2&gt;
&lt;p&gt;ES6 允许使用「箭头」（=&amp;gt;）定义函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
* 1. 通用写法
*/
let fn = (arg1, arg2, arg3) =&amp;gt; {
 return arg1 + arg2 + arg3;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;箭头函数的注意点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果形参只有一个，则小括号可以省略&lt;/li&gt;
&lt;li&gt;函数体如果只有一条语句，则花括号可以省略，函数的返回值为该条语句的&lt;br&gt;
执行结果&lt;/li&gt;
&lt;li&gt;箭头函数 this 指向声明时所在作用域下 this 的值&lt;/li&gt;
&lt;li&gt;箭头函数不能作为构造函数实例化&lt;/li&gt;
&lt;li&gt;不能使用 arguments&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;/**
* 2. 省略小括号的情况
*/
let fn2 = num =&amp;gt; {
 return num * 10;
};
/**
* 3. 省略花括号的情况
*/
let fn3 = score =&amp;gt; score * 20;
/**
* 4. this 指向声明时所在作用域中 this 的值
*/
let fn4 = () =&amp;gt; {
 console.log(this);
}
let school = {
 name: &#39;尚硅谷&#39;,
 getName(){
 let fn5 = () =&amp;gt; {
 console.log(this);
 }
 fn5();
 }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;div style=&#34;color:red&#34;&gt;注意：箭头函数不会更改 this 指向，用来指定回调函数会非常合适&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;27-rest-参数&#34;&gt;2.7. rest 参数&lt;/h2&gt;
&lt;p&gt;ES6 引入 rest 参数，用于获取函数的实参，用来代替 arguments&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
* 作用与 arguments 类似
*/
function add(...args){
 console.log(args);
}
add(1,2,3,4,5);
/**
* rest 参数必须是最后一个形参
*/
function minus(a,b,...args){
 console.log(a,b,args);
}
minus(100,1,2,3,4,5,19);
&lt;/code&gt;&lt;/pre&gt;
&lt;div style=&#34;color:red&#34;&gt;注意：rest 参数非常适合不定个数参数函数的场景&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;28-spread-扩展运算符&#34;&gt;2.8. spread 扩展运算符&lt;/h2&gt;
&lt;p&gt;扩展运算符（spread）也是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列，对数组进行解包。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
* 展开数组
*/ 
let tfboys = [&#39;德玛西亚之力&#39;,&#39;德玛西亚之翼&#39;,&#39;德玛西亚皇子&#39;];
function fn(){
 console.log(arguments);
}
fn(...tfboys)
/**
* 展开对象
*/
let skillOne = {
 q: &#39;致命打击&#39;,
};
let skillTwo = {
 w: &#39;勇气&#39;
};
let skillThree = {
 e: &#39;审判&#39;
};
let skillFour = {
 r: &#39;德玛西亚正义&#39;
};
let gailun = {...skillOne, ...skillTwo,...skillThree,...skillFour};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;29symbol&#34;&gt;2.9.Symbol&lt;/h2&gt;
&lt;h3 id=&#34;291symbol-基本使用&#34;&gt;2.9.1.Symbol 基本使用&lt;/h3&gt;
&lt;p&gt;ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是JavaScript 语言的第七种数据类型，是一种类似于字符串的数据类型。&lt;/p&gt;
&lt;p&gt;Symbol 特点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Symbol 的值是唯一的，用来解决命名冲突的问题&lt;/li&gt;
&lt;li&gt;Symbol 值不能与其他数据进行运算&lt;/li&gt;
&lt;li&gt;Symbol 定义 的 对象属 性 不能 使 用 for…in 循 环遍 历 ，但 是可 以 使 用&lt;br&gt;
Reflect.ownKeys 来获取对象的所有键名&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;//创建 Symbol
let s1 = Symbol();
console.log(s1, typeof s1);
//添加标识的 Symbol
let s2 = Symbol(&#39;尚硅谷&#39;);
let s2_2 = Symbol(&#39;尚硅谷&#39;);
console.log(s2 === s2_2);
//使用 Symbol for 定义
let s3 = Symbol.for(&#39;尚硅谷&#39;);
let s3_2 = Symbol.for(&#39;尚硅谷&#39;);
console.log(s3 === s3_2);
&lt;/code&gt;&lt;/pre&gt;
&lt;div style=&#34;color:red&#34;&gt;注: 遇到唯一性的场景时要想到 Symbol&lt;/div&gt;
&lt;br&gt;
&lt;h3 id=&#34;292symbol-内置值&#34;&gt;2.9.2.Symbol 内置值&lt;/h3&gt;
&lt;p&gt;除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。可以称这些方法为魔术方法，因为它们会在特定的场景下自动执行。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1607828563219.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;210-迭代器&#34;&gt;2.10. 迭代器&lt;/h2&gt;
&lt;p&gt;遍历器（Iterator）就是一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ES6 创造了一种新的遍历命令 for...of 循环，Iterator 接口主要供 for...of 消费&lt;/li&gt;
&lt;li&gt;原生具备 iterator 接口的数据(可用 for of 遍历)&lt;br&gt;
a) Array&lt;br&gt;
b) Arguments&lt;br&gt;
c) Set&lt;br&gt;
d) Map&lt;br&gt;
e) String&lt;br&gt;
f) TypedArray&lt;br&gt;
g) NodeList&lt;/li&gt;
&lt;li&gt;工作原理&lt;br&gt;
a) 创建一个指针对象，指向当前数据结构的起始位置&lt;br&gt;
b) 第一次调用对象的 next 方法，指针自动指向数据结构的第一个成员&lt;br&gt;
c) 接下来不断调用 next 方法，指针一直往后移动，直到指向最后一个成员&lt;br&gt;
d) 每调用 next 方法返回一个包含 value 和 done 属性的对象&lt;/li&gt;
&lt;/ol&gt;
&lt;div style=&#34;color:red&#34;&gt;注: 需要自定义遍历数据的时候，要想到迭代器。&lt;/div&gt;
&lt;br&gt;
&lt;h2 id=&#34;211-生成器&#34;&gt;2.11. 生成器&lt;/h2&gt;
&lt;p&gt;生成器函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function * gen(){
 yield &#39;一只没有耳朵&#39;;
 yield &#39;一只没有尾巴&#39;;
 return &#39;真奇怪&#39;; }
let iterator = gen();
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;* 的位置没有限制&lt;/li&gt;
&lt;li&gt;生成器函数返回的结果是迭代器对象，调用迭代器对象的 next 方法可以得到yield 语句后的值&lt;/li&gt;
&lt;li&gt;yield 相当于函数的暂停标记，也可以认为是函数的分隔符，每调用一次 next方法，执行一段代码&lt;/li&gt;
&lt;li&gt;next 方法可以传递实参，作为 yield 语句的返回值&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;212-promise&#34;&gt;2.12. Promise&lt;/h2&gt;
&lt;p&gt;Promise 是 ES6 引入的异步编程的新解决方案。语法上 Promise 是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Promise 构造函数: Promise (excutor) {}&lt;/li&gt;
&lt;li&gt;Promise.prototype.then 方法&lt;/li&gt;
&lt;li&gt;Promise.prototype.catch 方法&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;213-set&#34;&gt;2.13. Set&lt;/h2&gt;
&lt;p&gt;ES6 提供了新的数据结构 Set（集合）。它类似于数组，但成员的值都是唯一的，集合实现了 iterator 接口，所以可以使用『扩展运算符』和『for…of…』进行遍历，集合的属性和方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;size 返回集合的元素个数&lt;/li&gt;
&lt;li&gt;add 增加一个新元素，返回当前集合&lt;/li&gt;
&lt;li&gt;delete 删除元素，返回 boolean 值&lt;/li&gt;
&lt;li&gt;has 检测集合中是否包含某个元素，返回 boolean 值&lt;/li&gt;
&lt;li&gt;clear 清空集合，返回 undefined&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;//创建一个空集合
let s = new Set();
//创建一个非空集合
let s1 = new Set([1,2,3,1,2,3]);
//集合属性与方法
//返回集合的元素个数
console.log(s1.size);
//添加新元素
console.log(s1.add(4));
//删除元素
console.log(s1.delete(1));
//检测是否存在某个值
console.log(s1.has(2));
//清空集合
console.log(s1.clear());
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;214-map&#34;&gt;2.14. Map&lt;/h2&gt;
&lt;p&gt;ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合。但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map 也实现了iterator 接口，所以可以使用『扩展运算符』和『for…of…』进行遍历。Map 的属性和方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;size 返回 Map 的元素个数&lt;/li&gt;
&lt;li&gt;set 增加一个新元素，返回当前 Map&lt;/li&gt;
&lt;li&gt;get 返回键名对象的键值&lt;/li&gt;
&lt;li&gt;has 检测 Map 中是否包含某个元素，返回 boolean 值&lt;/li&gt;
&lt;li&gt;clear 清空集合，返回 undefined&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;//创建一个空 map
let m = new Map();
//创建一个非空 map
let m2 = new Map([
 [&#39;name&#39;,&#39;尚硅谷&#39;],
 [&#39;slogon&#39;,&#39;不断提高行业标准&#39;]
]);
//属性和方法
//获取映射元素的个数
console.log(m2.size);
//添加映射值
console.log(m2.set(&#39;age&#39;, 6));
//获取映射值
console.log(m2.get(&#39;age&#39;));
//检测是否有该映射
console.log(m2.has(&#39;age&#39;));
//清除
console.log(m2.clear());
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;215-class-类&#34;&gt;2.15. class 类&lt;/h2&gt;
&lt;p&gt;ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过 class 关键字，可以定义类。基本上，ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。&lt;br&gt;
知识点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;class 声明类&lt;/li&gt;
&lt;li&gt;constructor 定义构造函数初始化&lt;/li&gt;
&lt;li&gt;extends 继承父类&lt;/li&gt;
&lt;li&gt;super 调用父级构造方法&lt;/li&gt;
&lt;li&gt;static 定义静态方法和属性&lt;/li&gt;
&lt;li&gt;父类方法可以重写&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;//父类
class Phone {
 //构造方法
 constructor(brand, color, price) {
 this.brand = brand;
 this.color = color;
 this.price = price;
 }
 //对象方法
 call() {
     console.log(&#39;我可以打电话!!!&#39;)
 } }
//子类
class SmartPhone extends Phone {
 constructor(brand, color, price, screen, pixel) {
 super(brand, color, price);
 this.screen = screen;
 this.pixel = pixel;
 }
 //子类方法
 photo(){
 console.log(&#39;我可以拍照!!&#39;);
 }
 playGame(){
 console.log(&#39;我可以玩游戏!!&#39;);
 }
 //方法重写
 call(){
 console.log(&#39;我可以进行视频通话!!&#39;);
 }
 //静态方法
 static run(){
 console.log(&#39;我可以运行程序&#39;)
 }
 static connect(){
 console.log(&#39;我可以建立连接&#39;)
 } }
 //实例化对象
const Nokia = new Phone(&#39;诺基亚&#39;, &#39;灰色&#39;, 230);
const iPhone6s = new SmartPhone(&#39;苹果&#39;, &#39;白色&#39;, 6088, 
&#39;4.7inch&#39;,&#39;500w&#39;);
//调用子类方法
iPhone6s.playGame();
//调用重写方法
iPhone6s.call();
//调用静态方法
SmartPhone.run();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;216-数值扩展&#34;&gt;2.16. 数值扩展&lt;/h2&gt;
&lt;h3 id=&#34;2161-二进制和八进制&#34;&gt;2.16.1. 二进制和八进制&lt;/h3&gt;
&lt;p&gt;ES6 提供了二进制和八进制数值的新的写法，分别用前缀 0b 和 0o 表示。&lt;/p&gt;
&lt;h3 id=&#34;2162-numberisfinite-与-numberisnan&#34;&gt;2.16.2. Number.isFinite() 与 Number.isNaN()&lt;/h3&gt;
&lt;p&gt;Number.isFinite() 用来检查一个数值是否为有限的&lt;br&gt;
Number.isNaN() 用来检查一个值是否为 NaN&lt;/p&gt;
&lt;h3 id=&#34;2163-numberparseint-与-numberparsefloat&#34;&gt;2.16.3. Number.parseInt() 与 Number.parseFloat()&lt;/h3&gt;
&lt;p&gt;ES6 将全局方法 parseInt 和 parseFloat，移植到 Number 对象上面，使用不变。&lt;/p&gt;
&lt;h3 id=&#34;2164-mathtrunc&#34;&gt;2.16.4. Math.trunc&lt;/h3&gt;
&lt;p&gt;用于去除一个数的小数部分，返回整数部分。&lt;/p&gt;
&lt;h3 id=&#34;2165-numberisinteger&#34;&gt;2.16.5. Number.isInteger&lt;/h3&gt;
&lt;p&gt;Number.isInteger() 用来判断一个数值是否为整数&lt;/p&gt;
&lt;h2 id=&#34;217-对象扩展&#34;&gt;2.17. 对象扩展&lt;/h2&gt;
&lt;p&gt;ES6 新增了一些 Object 对象的方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Object.is 比较两个值是否严格相等，与『===』行为基本一致（+0 与 NaN）&lt;/li&gt;
&lt;li&gt;Object.assign 对象的合并，将源对象的所有可枚举属性，复制到目标对象&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;proto&lt;/strong&gt;、setPrototypeOf、 setPrototypeOf 可以直接设置对象的原型&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;218-模块化&#34;&gt;2.18. 模块化&lt;/h2&gt;
&lt;p&gt;模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来。&lt;/p&gt;
&lt;h3 id=&#34;2181-模块化的好处&#34;&gt;2.18.1. 模块化的好处&lt;/h3&gt;
&lt;p&gt;模块化的优势有以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;防止命名冲突&lt;/li&gt;
&lt;li&gt;代码复用&lt;/li&gt;
&lt;li&gt;高维护性&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2182-模块化规范产品&#34;&gt;2.18.2. 模块化规范产品&lt;/h3&gt;
&lt;p&gt;ES6 之前的模块化规范有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CommonJS =&amp;gt; NodeJS、Browserify&lt;/li&gt;
&lt;li&gt;AMD =&amp;gt; requireJS&lt;/li&gt;
&lt;li&gt;CMD =&amp;gt; seaJS&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2183-es6-模块化语法&#34;&gt;2.18.3. ES6 模块化语法&lt;/h3&gt;
&lt;p&gt;模块功能主要由两个命令构成：export 和 import。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;export 命令用于规定模块的对外接口&lt;/li&gt;
&lt;li&gt;import 命令用于输入其他模块提供的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;第-3-章-ecmasript-7-新特性&#34;&gt;第 3 章 ECMASript 7 新特性&lt;/h1&gt;
&lt;h2 id=&#34;31arrayprototypeincludes&#34;&gt;3.1.Array.prototype.includes&lt;/h2&gt;
&lt;p&gt;Includes 方法用来检测数组中是否包含某个元素，返回布尔类型值&lt;/p&gt;
&lt;h2 id=&#34;32指数操作符&#34;&gt;3.2.指数操作符&lt;/h2&gt;
&lt;p&gt;在 ES7 中引入指数运算符「**」，用来实现幂运算，功能与 Math.pow 结果相同&lt;/p&gt;
&lt;h1 id=&#34;第-4-章-ecmasript-8-新特性&#34;&gt;第 4 章 ECMASript 8 新特性&lt;/h1&gt;
&lt;h2 id=&#34;41async-和-await&#34;&gt;4.1.async 和 await&lt;/h2&gt;
&lt;p&gt;async 和 await 两种语法结合可以让异步代码像同步代码一样&lt;/p&gt;
&lt;h3 id=&#34;411async-函数&#34;&gt;4.1.1.async 函数&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;async 函数的返回值为 promise 对象，&lt;/li&gt;
&lt;li&gt;promise 对象的结果由 async 函数执行的返回值决定&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;412await-表达式&#34;&gt;4.1.2.await 表达式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;await 必须写在 async 函数中&lt;/li&gt;
&lt;li&gt;await 右侧的表达式一般为 promise 对象&lt;/li&gt;
&lt;li&gt;await 返回的是 promise 成功的值&lt;/li&gt;
&lt;li&gt;await 的 promise 失败了, 就会抛出异常, 需要通过 try...catch 捕获处理&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;42objectvalues-和-objectentries&#34;&gt;4.2.Object.values 和 Object.entries&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Object.values()方法返回一个给定对象的所有可枚举属性值的数组&lt;/li&gt;
&lt;li&gt;Object.entries()方法返回一个给定对象自身可遍历属性 [key,value] 的数组&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;43objectgetownpropertydescriptors&#34;&gt;4.3.Object.getOwnPropertyDescriptors&lt;/h2&gt;
&lt;p&gt;该方法返回指定对象所有自身属性的描述对象&lt;/p&gt;
&lt;h1 id=&#34;第-5-章-ecmasript-9-新特性&#34;&gt;第 5 章 ECMASript 9 新特性&lt;/h1&gt;
&lt;h2 id=&#34;51restspread-属性&#34;&gt;5.1.Rest/Spread 属性&lt;/h2&gt;
&lt;p&gt;Rest 参数与 spread 扩展运算符在 ES6 中已经引入，不过 ES6 中只针对于数组，在 ES9 中为对象提供了像数组一样的 rest 参数和扩展运算符。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function connect({host, port, ...user}) {
 console.log(host);
 console.log(port);
 console.log(user);
}
connect({
 host: &#39;127.0.0.1&#39;,
 port: 3306,
 username: &#39;root&#39;,
 password: &#39;root&#39;,
 type: &#39;master&#39;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;52正则表达式命名捕获组&#34;&gt;5.2.正则表达式命名捕获组&lt;/h2&gt;
&lt;p&gt;ES9 允许命名捕获组使用符号『?&lt;name&gt;』,这样获取捕获结果可读性更强&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let str = &#39;&amp;lt;a href=&amp;quot;http://www.atguigu.com&amp;quot;&amp;gt;尚硅谷&amp;lt;/a&amp;gt;&#39;;
const reg = /&amp;lt;a href=&amp;quot;(?&amp;lt;url&amp;gt;.*)&amp;quot;&amp;gt;(?&amp;lt;text&amp;gt;.*)&amp;lt;\/a&amp;gt;/;
const result = reg.exec(str);
console.log(result.groups.url);
console.log(result.groups.text);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;53正则表达式反向断言&#34;&gt;5.3.正则表达式反向断言&lt;/h2&gt;
&lt;p&gt;ES9 支持反向断言，通过对匹配结果前面的内容进行判断，对匹配进行筛选。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//声明字符串
let str = &#39;JS5211314 你知道么 555 啦啦啦&#39;;
//正向断言
const reg = /\d+(?=啦)/;
const result = reg.exec(str);
//反向断言
const reg = /(?&amp;lt;=么)\d+/;
const result = reg.exec(str);
console.log(result);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;54正则表达式-dotall-模式&#34;&gt;5.4.正则表达式 dotAll 模式&lt;/h2&gt;
&lt;p&gt;正则表达式中点.匹配除回车外的任何单字符，标记『s』改变这种行为，允许行终止符出现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let str = `
&amp;lt;ul&amp;gt;
 &amp;lt;li&amp;gt;
 &amp;lt;a&amp;gt;肖生克的救赎&amp;lt;/a&amp;gt;
 &amp;lt;p&amp;gt;上映日期: 1994-09-10&amp;lt;/p&amp;gt;
 &amp;lt;/li&amp;gt;
 &amp;lt;li&amp;gt;
 &amp;lt;a&amp;gt;阿甘正传&amp;lt;/a&amp;gt;
 &amp;lt;p&amp;gt;上映日期: 1994-07-06&amp;lt;/p&amp;gt;
 &amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;`;
//声明正则
const reg = /&amp;lt;li&amp;gt;.*?&amp;lt;a&amp;gt;(.*?)&amp;lt;\/a&amp;gt;.*?&amp;lt;p&amp;gt;(.*?)&amp;lt;\/p&amp;gt;/gs;
//执行匹配
const result = reg.exec(str);
let result;
let data = [];
while(result = reg.exec(str)){
 data.push({title: result[1], time: result[2]});
}
//输出结果
console.log(data);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第-6-章-ecmasript-10-新特性&#34;&gt;第 6 章 ECMASript 10 新特性&lt;/h1&gt;
&lt;h2 id=&#34;61objectfromentries&#34;&gt;6.1.Object.fromEntries&lt;/h2&gt;
&lt;h2 id=&#34;62trimstart-和-trimend&#34;&gt;6.2.trimStart 和 trimEnd&lt;/h2&gt;
&lt;h2 id=&#34;63arrayprototypeflat-与-flatmap&#34;&gt;6.3.Array.prototype.flat 与 flatMap&lt;/h2&gt;
&lt;h2 id=&#34;64symbolprototypedescription&#34;&gt;6.4.Symbol.prototype.description&lt;/h2&gt;
&lt;h1 id=&#34;第-7-章-ecmasript-11-新特性&#34;&gt;第 7 章 ECMASript 11 新特性&lt;/h1&gt;
&lt;h2 id=&#34;71stringprototypematchall&#34;&gt;7.1.String.prototype.matchAll&lt;/h2&gt;
&lt;h2 id=&#34;72类的私有属性&#34;&gt;7.2.类的私有属性&lt;/h2&gt;
&lt;h2 id=&#34;73promiseallsettled&#34;&gt;7.3.Promise.allSettled&lt;/h2&gt;
&lt;h2 id=&#34;74可选链操作符&#34;&gt;7.4.可选链操作符&lt;/h2&gt;
&lt;h2 id=&#34;75动态-import-导入&#34;&gt;7.5.动态 import 导入&lt;/h2&gt;
&lt;h2 id=&#34;76globalthis-对象&#34;&gt;7.6.globalThis 对象&lt;/h2&gt;
&lt;p&gt;鸣谢：源自&lt;a href=&#34;https://www.bilibili.com/video/BV1uK411H7on&#34;&gt;视频教程-尚硅谷&lt;/a&gt;&lt;/p&gt;
">ECMAScript 6-11</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/ce-shi/"" data-c="
          &lt;h2 id=&#34;1element-ui-引言&#34;&gt;1.Element UI 引言&lt;/h2&gt;
&lt;p&gt;官网: &lt;a href=&#34;https://element.eleme.cn/#/zh-CN&#34;&gt;Element，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;11-官方定义&#34;&gt;1.1 官方定义&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;网站快速成型工具&lt;/code&gt; 和 &lt;code&gt;桌面端组件库&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;12-定义&#34;&gt;1.2 定义&lt;/h3&gt;
&lt;p&gt;element ui 就是基于vue的一个ui框架,该框架基于vue开发了很多相关组件,方便我们快速开发页面。&lt;/p&gt;
&lt;h3 id=&#34;13-由来&#34;&gt;1.3 由来&lt;/h3&gt;
&lt;p&gt;饿了么前端团队 基于vue进行开发并且进行了开源  element ui 中提供全部都是封装好组件。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2安装element-ui&#34;&gt;2.安装Element UI&lt;/h2&gt;
&lt;h3 id=&#34;21通过vue脚手架创建项目&#34;&gt;2.1通过vue脚手架创建项目&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;vue init webpack element(项目名)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;22在vue脚手架项目中安装elementui&#34;&gt;2.2在vue脚手架项目中安装elementui&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# 1.下载elementui的依赖
	npm i element-ui -S

# 2.指定当前项目中使用elementui
	import ElementUI from &#39;element-ui&#39;;
	import &#39;element-ui/lib/theme-chalk/index.css&#39;;

  //在vue脚手架中使用elementui
	Vue.use(ElementUI);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;3按钮组件示例&#34;&gt;3.按钮组件(示例)&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606975701437.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;31-默认样式按钮&#34;&gt;3.1 默认样式按钮&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-row&amp;gt;
  &amp;lt;el-button&amp;gt;默认按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;primary&amp;quot;&amp;gt;主要按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;success&amp;quot;&amp;gt;成功按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;info&amp;quot;&amp;gt;信息按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;warning&amp;quot;&amp;gt;警告按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;danger&amp;quot;&amp;gt;危险按钮&amp;lt;/el-button&amp;gt;
&amp;lt;/el-row&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;32-简洁按钮&#34;&gt;3.2 简洁按钮&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-row&amp;gt;
  &amp;lt;el-button plain&amp;gt;朴素按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;primary&amp;quot; plain&amp;gt;主要按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;success&amp;quot; plain&amp;gt;成功按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;info&amp;quot; plain&amp;gt;信息按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;warning&amp;quot; plain&amp;gt;警告按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;danger&amp;quot; plain&amp;gt;危险按钮&amp;lt;/el-button&amp;gt;
&amp;lt;/el-row&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;33-圆角按钮&#34;&gt;3.3 圆角按钮&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-row&amp;gt;
  &amp;lt;el-button round&amp;gt;圆角按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;primary&amp;quot; round&amp;gt;主要按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;success&amp;quot; round&amp;gt;成功按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;info&amp;quot; round&amp;gt;信息按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;warning&amp;quot; round&amp;gt;警告按钮&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;danger&amp;quot; round&amp;gt;危险按钮&amp;lt;/el-button&amp;gt;
&amp;lt;/el-row&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;34-图标按钮&#34;&gt;3.4 图标按钮&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-row&amp;gt;
  &amp;lt;el-button icon=&amp;quot;el-icon-search&amp;quot; circle&amp;gt;&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;primary&amp;quot; icon=&amp;quot;el-icon-edit&amp;quot; circle&amp;gt;&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;success&amp;quot; icon=&amp;quot;el-icon-check&amp;quot; circle&amp;gt;&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;info&amp;quot; icon=&amp;quot;el-icon-message&amp;quot; circle&amp;gt;&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;warning&amp;quot; icon=&amp;quot;el-icon-star-off&amp;quot; circle&amp;gt;&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;danger&amp;quot; icon=&amp;quot;el-icon-delete&amp;quot; circle&amp;gt;&amp;lt;/el-button&amp;gt;
&amp;lt;/el-row&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;4按钮组件的详细使用&#34;&gt;4.按钮组件的详细使用&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;总结:日后使用element ui的相关组件时需要注意的是 所有组件都是el-组件名称开头&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;41创建按钮&#34;&gt;4.1创建按钮&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-button&amp;gt;默认按钮&amp;lt;/el-button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;42-按钮属性使用&#34;&gt;4.2 按钮属性使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-button type=&amp;quot;primary&amp;quot; 属性名=属性值&amp;gt;默认按钮&amp;lt;/el-button&amp;gt;
&amp;lt;el-button type=&amp;quot;success&amp;quot; size=&amp;quot;medium&amp;quot; plain=true round circle icon=&amp;quot;el-icon-loading&amp;quot;&amp;gt;&amp;lt;/el-button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;总结:在elementui中所有组件的属性全部写在组件标签上&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;43-按钮组使用&#34;&gt;4.3 按钮组使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-button-group&amp;gt;
  &amp;lt;el-button type=&amp;quot;primary&amp;quot; icon=&amp;quot;el-icon-back&amp;quot;&amp;gt;上一页&amp;lt;/el-button&amp;gt;
  &amp;lt;el-button type=&amp;quot;primary&amp;quot; icon=&amp;quot;el-icon-right&amp;quot;&amp;gt;下一页&amp;lt;/el-button&amp;gt;
&amp;lt;/el-button-group&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在element ui中所有组件都是 &lt;code&gt;el-组件名称&lt;/code&gt; 方式进行命名&lt;/li&gt;
&lt;li&gt;在element ui中组件的属性使用&lt;code&gt;都是直接将属性名=属性值方式写在对应的组件标签上&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;5link-文字链接组件&#34;&gt;5.Link 文字链接组件&lt;/h2&gt;
&lt;h3 id=&#34;51-文字链接组件的创建&#34;&gt;5.1 文字链接组件的创建&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-link&amp;gt;默认链接&amp;lt;/el-link&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;52-文字链接组件的属性的使用&#34;&gt;5.2 文字链接组件的属性的使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-link  target=&amp;quot;_blank&amp;quot; href=&amp;quot;http://www.baidu.com&amp;quot; &amp;gt;默认链接&amp;lt;/el-link&amp;gt;
&amp;lt;el-link type=&amp;quot;primary&amp;quot;:underline=&amp;quot;false&amp;quot;&amp;gt;默认链接&amp;lt;/el-link&amp;gt;
&amp;lt;el-link type=&amp;quot;success&amp;quot; disabled&amp;gt;默认链接&amp;lt;/el-link&amp;gt;
&amp;lt;el-link type=&amp;quot;info&amp;quot; icon=&amp;quot;el-icon-platform-eleme&amp;quot;&amp;gt;默认链接&amp;lt;/el-link&amp;gt;
&amp;lt;el-link type=&amp;quot;warning&amp;quot;&amp;gt;默认链接&amp;lt;/el-link&amp;gt;
&amp;lt;el-link type=&amp;quot;danger&amp;quot;&amp;gt;默认链接&amp;lt;/el-link&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;6layout-栅格布局组件的使用&#34;&gt;6.Layout (栅格)布局组件的使用&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;通过基础的 24 分栏，迅速简便地创建布局&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;在element ui中布局组件将页面划分为多个行row,每行最多分为24栏(列)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;61-使用layout组件&#34;&gt;6.1 使用Layout组件&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-row&amp;gt;
	&amp;lt;el-col :span=&amp;quot;8&amp;quot;&amp;gt;占用8份&amp;lt;/el-col&amp;gt;
  &amp;lt;el-col :span=&amp;quot;8&amp;quot;&amp;gt;占用8份&amp;lt;/el-col&amp;gt;
  &amp;lt;el-col :span=&amp;quot;8&amp;quot;&amp;gt;占用8份&amp;lt;/el-col&amp;gt;
&amp;lt;/el-row&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在一个布局组件中 是由 &lt;code&gt;row&lt;/code&gt; 和 &lt;code&gt;col&lt;/code&gt; 组合而成&lt;/li&gt;
&lt;li&gt;在使用时要区分 &lt;code&gt;row属性&lt;/code&gt; 和 &lt;code&gt;col属性&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;62-属性的使用&#34;&gt;6.2 属性的使用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;行属性使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-row :gutter=&amp;quot;50&amp;quot; tag=&amp;quot;span&amp;quot;&amp;gt;
  &amp;lt;el-col :span=&amp;quot;4&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;border: 1px red solid;&amp;quot;&amp;gt;占用4份&amp;lt;/div&amp;gt;&amp;lt;/el-col&amp;gt;
  &amp;lt;el-col :span=&amp;quot;8&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;border: 1px red solid;&amp;quot;&amp;gt;占用8份&amp;lt;/div&amp;gt;&amp;lt;/el-col&amp;gt;
  &amp;lt;el-col :span=&amp;quot;3&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;border: 1px red solid;&amp;quot;&amp;gt;占用3份&amp;lt;/div&amp;gt;&amp;lt;/el-col&amp;gt;
  &amp;lt;el-col :span=&amp;quot;9&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;border: 1px red solid;&amp;quot;&amp;gt;占用9份&amp;lt;/div&amp;gt;&amp;lt;/el-col&amp;gt;
&amp;lt;/el-row&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列属性的使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-row&amp;gt;
  &amp;lt;el-col :span=&amp;quot;12&amp;quot; :offset=&amp;quot;9&amp;quot; :psuh=&amp;quot;3&amp;quot; xs&amp;gt;&amp;lt;div style=&amp;quot;border: 1px blue solid;&amp;quot;&amp;gt;我是占用12分&amp;lt;/div&amp;gt;&amp;lt;/el-col&amp;gt;
  &amp;lt;el-col :span=&amp;quot;6&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;border: 1px blue solid;&amp;quot;&amp;gt;我是占用6分&amp;lt;/div&amp;gt;&amp;lt;/el-col&amp;gt;
&amp;lt;/el-row&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;7container-布局容器组件&#34;&gt;7.Container 布局容器组件&lt;/h2&gt;
&lt;h3 id=&#34;71-创建布局容器&#34;&gt;7.1 创建布局容器&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-container&amp;gt;
	
&amp;lt;/el-container&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;72-容器中包含的子元素&#34;&gt;7.2 容器中包含的子元素&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-header&amp;gt;：顶栏容器。
&amp;lt;el-aside&amp;gt;：侧边栏容器。
&amp;lt;el-main&amp;gt;：主要区域容器。
&amp;lt;el-footer&amp;gt;：底栏容器。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;73-容器的嵌套使用&#34;&gt;7.3 容器的嵌套使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!--创建容器--&amp;gt;
&amp;lt;el-container&amp;gt;
  &amp;lt;!--header--&amp;gt;
  &amp;lt;el-header&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是标题&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-header&amp;gt;
  &amp;lt;!--容器嵌套使用--&amp;gt;
  &amp;lt;el-container&amp;gt;
    &amp;lt;!--aside--&amp;gt;
    &amp;lt;el-aside&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是菜单&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-aside&amp;gt;
    &amp;lt;!--main--&amp;gt;
    &amp;lt;el-main&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是中心内容&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-main&amp;gt;
  &amp;lt;/el-container&amp;gt;
  &amp;lt;el-footer&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是页脚&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-footer&amp;gt;
&amp;lt;/el-container&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;74-水平容器&#34;&gt;7.4 水平容器&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-container direction=&amp;quot;horizontal&amp;quot;&amp;gt;
  &amp;lt;!--header--&amp;gt;
  &amp;lt;el-header&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是标题&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-header&amp;gt;
  &amp;lt;el-container&amp;gt;
    &amp;lt;!--aside--&amp;gt;
    &amp;lt;el-aside&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是菜单&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-aside&amp;gt;
    &amp;lt;!--main--&amp;gt;
    &amp;lt;el-main&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是中心内容&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-main&amp;gt;
  &amp;lt;/el-container&amp;gt;
  &amp;lt;el-footer&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是页脚&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-footer&amp;gt;
&amp;lt;/el-container&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意:当子元素中没有有 el-header 或 el-footer 时容器排列为水平&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;75-垂直容器&#34;&gt;7.5 垂直容器&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-container direction=&amp;quot;vertical&amp;quot;&amp;gt;
  &amp;lt;!--header--&amp;gt;
  &amp;lt;el-header&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是标题&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-header&amp;gt;
  &amp;lt;el-container&amp;gt;
    &amp;lt;!--aside--&amp;gt;
    &amp;lt;el-aside&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是菜单&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-aside&amp;gt;
    &amp;lt;!--main--&amp;gt;
    &amp;lt;el-main&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是中心内容&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-main&amp;gt;
  &amp;lt;/el-container&amp;gt;
  &amp;lt;!--footer--&amp;gt;
  &amp;lt;el-footer&amp;gt;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;我是页脚&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/el-footer&amp;gt;
&amp;lt;/el-container&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;8form相关组件&#34;&gt;8.Form相关组件&lt;/h2&gt;
&lt;h3 id=&#34;81-radio单选按钮&#34;&gt;8.1 Radio单选按钮&lt;/h3&gt;
&lt;h4 id=&#34;1创建radio按钮&#34;&gt;1.创建Radio按钮&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!--组件创建--&amp;gt;
&amp;lt;el-radio v-model=&amp;quot;label&amp;quot; label=&amp;quot;男&amp;quot;&amp;gt;男&amp;lt;/el-radio&amp;gt;
&amp;lt;el-radio v-model=&amp;quot;label&amp;quot; label=&amp;quot;女&amp;quot;&amp;gt;女&amp;lt;/el-radio&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Radio&amp;quot;,
        data(){
            return{
                label:&#39;男&#39;
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意:在使用radio单选按钮是至少加入v-model和label两个属性&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;2radio按钮属性的使用&#34;&gt;2.Radio按钮属性的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-radio v-model=&amp;quot;label&amp;quot; name=&amp;quot;sex&amp;quot; disabled label=&amp;quot;男&amp;quot;&amp;gt;男&amp;lt;/el-radio&amp;gt;
&amp;lt;el-radio v-model=&amp;quot;label&amp;quot; name=&amp;quot;sex&amp;quot; border size=&amp;quot;small&amp;quot; label=&amp;quot;女&amp;quot;&amp;gt;女&amp;lt;/el-radio&amp;gt;
&amp;lt;el-radio v-model=&amp;quot;label&amp;quot; border size=&amp;quot;mini&amp;quot; label=&amp;quot;女&amp;quot;&amp;gt;女&amp;lt;/el-radio&amp;gt;
&amp;lt;el-radio v-model=&amp;quot;label&amp;quot; border size=&amp;quot;medium&amp;quot; label=&amp;quot;女&amp;quot;&amp;gt;女&amp;lt;/el-radio&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;总结:属性使用还是直接卸载对应的组件标签上以 属性名=属性值 方式使用&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;3radio事件的使用&#34;&gt;3.Radio事件的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-radio v-model=&amp;quot;label&amp;quot; @change=&amp;quot;aa&amp;quot; name=&amp;quot;sex&amp;quot; label=&amp;quot;男&amp;quot;&amp;gt;男&amp;lt;/el-radio&amp;gt;
&amp;lt;el-radio v-model=&amp;quot;label&amp;quot; @change=&amp;quot;aa&amp;quot; name=&amp;quot;sex&amp;quot; border size=&amp;quot;small&amp;quot; label=&amp;quot;女&amp;quot;&amp;gt;女&amp;lt;/el-radio&amp;gt;



&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Radio&amp;quot;,
        data(){
            return{
                label:&#39;男&#39;
            }
        },
        methods:{
            aa(){ //定义的事件处理函数
                console.log(this.label);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;总结:&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;​	事件的使用也是和属性使用是一致都是直接写在对应的组件标签上&lt;/li&gt;
&lt;li&gt;事件在使用时必须使用Vue中绑定时间方式进行使用如 @事件名=事件处理函数(绑在在vue组件中对应函数)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;4radio按钮组&#34;&gt;4.radio按钮组&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-radio-group v-model=&amp;quot;radio&amp;quot;&amp;gt;
  &amp;lt;el-radio :label=&amp;quot;3&amp;quot;&amp;gt;备选项3&amp;lt;/el-radio&amp;gt;
  &amp;lt;el-radio :label=&amp;quot;6&amp;quot;&amp;gt;备选项6&amp;lt;/el-radio&amp;gt;
  &amp;lt;el-radio :label=&amp;quot;9&amp;quot;&amp;gt;备选项9&amp;lt;/el-radio&amp;gt;
&amp;lt;/el-radio-group&amp;gt;
&amp;lt;script&amp;gt;
  export default {
    name: &amp;quot;Radio&amp;quot;,
    data() {
      return {
        radio: 6
      }
    }
  }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;82-checkbox组件&#34;&gt;8.2 checkbox组件&lt;/h3&gt;
&lt;h4 id=&#34;1创建checkbox组件&#34;&gt;1.创建checkbox组件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-checkbox v-model=&amp;quot;checked&amp;quot;&amp;gt;北京&amp;lt;/el-checkbox&amp;gt;
&amp;lt;el-checkbox v-model=&amp;quot;checked&amp;quot;&amp;gt;上海&amp;lt;/el-checkbox&amp;gt;
&amp;lt;el-checkbox v-model=&amp;quot;checked&amp;quot;&amp;gt;天津&amp;lt;/el-checkbox&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2属性使用&#34;&gt;2.属性使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-checkbox v-model=&amp;quot;checked&amp;quot;  disabled true-label=&amp;quot;北京&amp;quot;&amp;gt;北京&amp;lt;/el-checkbox&amp;gt;
&amp;lt;el-checkbox checked border true-label=&amp;quot;上海&amp;quot;&amp;gt;上海&amp;lt;/el-checkbox&amp;gt;
&amp;lt;el-checkbox v-model=&amp;quot;checked&amp;quot; true-label=&amp;quot;天津&amp;quot;&amp;gt;天津&amp;lt;/el-checkbox&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3事件使用&#34;&gt;3.事件使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-checkbox @change=&amp;quot;aa&amp;quot;v-model=&amp;quot;checked&amp;quot;  true-label=&amp;quot;上海&amp;quot;&amp;gt;上海&amp;lt;/el-checkbox&amp;gt;
&amp;lt;el-checkbox v-model=&amp;quot;checked&amp;quot; @change=&amp;quot;aa&amp;quot; true-label=&amp;quot;天津&amp;quot;&amp;gt;天津&amp;lt;/el-checkbox&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Checkbox&amp;quot;,
        data(){
            return{
                checked:true
            }
        },
        methods:{
            aa(){
                console.log(this.checked);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4复选框组的使用&#34;&gt;4.复选框组的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-checkbox-group @change=&amp;quot;bb&amp;quot; :min=&amp;quot;1&amp;quot; v-model=&amp;quot;checkList&amp;quot;&amp;gt;
  &amp;lt;el-checkbox label=&amp;quot;复选框 A&amp;quot;&amp;gt;&amp;lt;/el-checkbox&amp;gt;
  &amp;lt;el-checkbox label=&amp;quot;复选框 B&amp;quot;&amp;gt;&amp;lt;/el-checkbox&amp;gt;
  &amp;lt;el-checkbox label=&amp;quot;复选框 C&amp;quot;&amp;gt;&amp;lt;/el-checkbox&amp;gt;
  &amp;lt;el-checkbox label=&amp;quot;禁用&amp;quot; disabled&amp;gt;&amp;lt;/el-checkbox&amp;gt;
  &amp;lt;el-checkbox label=&amp;quot;选中且禁用&amp;quot; disabled&amp;gt;&amp;lt;/el-checkbox&amp;gt;
&amp;lt;/el-checkbox-group&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Checkbox&amp;quot;,
        data(){
            return{
                checked:true,
                checkList:[],
            }
        },
        methods:{
            aa(){
                console.log(this.checked);
            },
            bb(){
                console.log(this.checkList);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;83-input-输入框组件&#34;&gt;8.3 Input 输入框组件&lt;/h3&gt;
&lt;h4 id=&#34;1创建input组件&#34;&gt;1.创建Input组件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-input v-model=&amp;quot;name&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Input&amp;quot;,
        data(){
            return {
                name:&#39;xiaochen&#39;
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2常用属性&#34;&gt;2.常用属性&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-input v-model=&amp;quot;name&amp;quot; disabled type=&amp;quot;textarea&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
&amp;lt;el-input v-model=&amp;quot;price&amp;quot; :maxlength=&amp;quot;10&amp;quot; show-word-limit :minlength=&amp;quot;5&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
&amp;lt;el-input prefix-icon=&amp;quot;el-icon-user-solid&amp;quot; placeholder=&amp;quot;请输入用户名&amp;quot; clearable v-model=&amp;quot;username&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
&amp;lt;el-input suffix-icon=&amp;quot;el-icon-star-off&amp;quot; placeholder=&amp;quot;请输入密码&amp;quot; show-password type=&amp;quot;password&amp;quot; clearable v-model=&amp;quot;password&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Input&amp;quot;,
        data() {
            return {
                restaurants: [],
                state1: &#39;&#39;,
                state2: &#39;&#39;,
                name:&#39;xiaochen&#39;,
                price:0.0,
                username:&amp;quot;&amp;quot;,
                password:&amp;quot;&amp;quot;,
            };
        },
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3事件使用-2&#34;&gt;3.事件使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-input v-model=&amp;quot;username&amp;quot; @blur=&amp;quot;aaa&amp;quot; @focus=&amp;quot;bbb&amp;quot; @clear=&amp;quot;clears&amp;quot; clearable @input=&amp;quot;ccc&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Input&amp;quot;,
        data() {
            return {
                restaurants: [],
                state1: &#39;&#39;,
                state2: &#39;&#39;,
                name:&#39;xiaochen&#39;,
                price:0.0,
                username:&amp;quot;&amp;quot;,
                password:&amp;quot;&amp;quot;,
            };
        },
        methods:{
            aaa(){
                console.log(&#39;失去焦点&#39;);
                ;
            },
            bbb(){
                console.log(&amp;quot;获取焦点&amp;quot;);
            },
            ccc(value){
                console.log(&amp;quot;改变:&amp;quot;+value);
            },
            clears(){
                console.log(&amp;quot;清楚&amp;quot;);
            }


        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4方法的使用&#34;&gt;4.方法的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;h1&amp;gt;方法的使用&amp;lt;/h1&amp;gt;
&amp;lt;el-input v-model=&amp;quot;username&amp;quot; ref=&amp;quot;inputs&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;

&amp;lt;el-button @click=&amp;quot;focusInputs&amp;quot;&amp;gt;focus方法&amp;lt;/el-button&amp;gt;
&amp;lt;el-button @click=&amp;quot;blurInputs&amp;quot;&amp;gt;blur方法&amp;lt;/el-button&amp;gt;

&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Input&amp;quot;,
        data() {
            return{}
        },
        methods:{
            //调用focus方法
            focusInputs(){
                this.$refs.inputs.focus();
            },
           //调用失去焦点方法
            blurInputs(){
                this.$refs.inputs.blur();
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;总结&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;​	在使用组件的方法时需要在对应的组件中加入 &lt;code&gt;ref=&amp;quot;组件别名&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在调用方法时直接使用 &lt;code&gt;this.$refs.组件别名.方法名()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;注意:在elementui中所有组件 都存在 属性 事件 和方法&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;属性:&lt;/code&gt;直接写在对应的组件标签上 使用方式:&lt;code&gt;属性名=属性值&lt;/code&gt;方式&lt;/p&gt;
&lt;p&gt;&lt;code&gt;事件&lt;/code&gt;: 直接使用vue绑定事件方式写在对应的组件标签上 使用方式:&lt;code&gt;@事件名=vue中事件处理函数&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;方法&lt;/code&gt;: 1.在对应组件标签上使用&lt;code&gt;ref=组件别名&lt;/code&gt; 2.&lt;code&gt;通过使用this.$refs.组件别名.方法名()&lt;/code&gt;进行调用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;84-select选择器组件的使用&#34;&gt;8.4 Select选择器组件的使用&lt;/h3&gt;
&lt;h4 id=&#34;1组件创建&#34;&gt;1.组件创建&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# 1.数据写死在页面上
&amp;lt;el-select v-model=&amp;quot;cityName&amp;quot;&amp;gt;
  &amp;lt;el-option value=&amp;quot;北京&amp;quot;&amp;gt;北京&amp;lt;/el-option&amp;gt;
  &amp;lt;el-option value=&amp;quot;天津&amp;quot;&amp;gt;天津&amp;lt;/el-option&amp;gt;
&amp;lt;/el-select&amp;gt;
	注意:1.要求下拉列表中必须存在option的value属性值 2.要求select中必须使用v-model进行数据绑定

# 2.如何动态获取数据
 &amp;lt;el-select&amp;gt;
 		&amp;lt;el-option v-for=&amp;quot;option in options&amp;quot; :label=&amp;quot;option.name&amp;quot; :value=&amp;quot;option.id&amp;quot; :key=&amp;quot;option.id&amp;quot;&amp;gt;
 		&amp;lt;/el-option&amp;gt;
 &amp;lt;/el-select&amp;gt;

  &amp;lt;script&amp;gt;
      export default {
          name: &amp;quot;Select&amp;quot;,
          data(){
              return{
                  options:[
                      {id:&#39;1&#39;,name:&amp;quot;研发部&amp;quot;},
                      {id:&#39;2&#39;,name:&amp;quot;小卖部&amp;quot;},
                      {id:&#39;3&#39;,name:&amp;quot;小米部&amp;quot;},
                  ]
              }
          },
      }
  &amp;lt;/script&amp;gt;
  
# 3.获取下拉列表选中数据
 &amp;lt;el-select v-model=&amp;quot;cityId&amp;quot; multiple clearable&amp;gt;
        &amp;lt;el-option v-for=&amp;quot;option in options&amp;quot; :label=&amp;quot;option.name&amp;quot; :value=&amp;quot;option.id&amp;quot; :key=&amp;quot;option.id&amp;quot;&amp;gt;&amp;lt;/el-option&amp;gt;
&amp;lt;/el-select&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Select&amp;quot;,
        data(){
            return{
                options:[
                    {id:&#39;1&#39;,name:&amp;quot;研发部&amp;quot;},
                    {id:&#39;2&#39;,name:&amp;quot;小卖部&amp;quot;},
                    {id:&#39;3&#39;,name:&amp;quot;小米部&amp;quot;},
                ],
                cityId:&#39;&#39;
            }
        },
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2属性使用-2&#34;&gt;2.属性使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-select v-model=&amp;quot;cityId&amp;quot; multiple clearable&amp;gt;
  ......
&amp;lt;/el-select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3事件的使用&#34;&gt;3.事件的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-select v-model=&amp;quot;cityId&amp;quot; @change=&amp;quot;aaa&amp;quot; multiple clearable&amp;gt;
  &amp;lt;el-option v-for=&amp;quot;option in options&amp;quot; :label=&amp;quot;option.name&amp;quot; :value=&amp;quot;option.id&amp;quot; :key=&amp;quot;option.id&amp;quot;&amp;gt;
  &amp;lt;/el-option&amp;gt;
&amp;lt;/el-select&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Select&amp;quot;,
        data(){
            return{
                options:[
                    {id:&#39;1&#39;,name:&amp;quot;研发部&amp;quot;},
                    {id:&#39;2&#39;,name:&amp;quot;小卖部&amp;quot;},
                    {id:&#39;3&#39;,name:&amp;quot;小米部&amp;quot;},
                ],
                cityId:&#39;&#39;,
                cityName:&#39;&#39;
            }
        },
        methods:{
            aaa(value){
                console.log(value);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4方法的使用-2&#34;&gt;4.方法的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;1.给组件通过ref起别名并绑定到vue实例中
 &amp;lt;el-select ref=&amp;quot;selects&amp;quot; v-model=&amp;quot;cityId&amp;quot; @change=&amp;quot;aaa&amp;quot; multiple clearable&amp;gt;
       ....
 &amp;lt;/el-select&amp;gt;
2.调用方法
 this.$refs.selects.focus();//方法调用
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;85-switch-开关组件&#34;&gt;8.5 Switch 开关组件&lt;/h3&gt;
&lt;h4 id=&#34;1switch组件的创建&#34;&gt;1.Switch组件的创建&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-switch v-model=&amp;quot;value&amp;quot;&amp;gt;&amp;lt;/el-switch&amp;gt;
&amp;lt;script&amp;gt;
  export default {
    name: &amp;quot;Switchs&amp;quot;,
    data(){
      return{
        value:true
      }
    }
  }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2属性使用-3&#34;&gt;2.属性使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-switch v-model=&amp;quot;value&amp;quot; active-text=&amp;quot;打开&amp;quot; active-color=&amp;quot;#13ce66&amp;quot; inactive-color=&amp;quot;#ff4949&amp;quot; :active-
           value=&amp;quot;true&amp;quot; :inactive-value=&amp;quot;false&amp;quot; inactive-text=&amp;quot;关闭&amp;quot; :width=&amp;quot;200&amp;quot;&amp;gt;
&amp;lt;/el-switch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3事件使用-3&#34;&gt;3.事件使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-switch v-model=&amp;quot;value&amp;quot; @change=&amp;quot;aaa&amp;quot;&amp;gt;&amp;lt;/el-switch&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Switchs&amp;quot;,
        data(){
            return{
                value:true
            }
        },
        methods:{
            aaa(value){
                console.log(value);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4方法使用&#34;&gt;4.方法使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-switch ref=&amp;quot;sw&amp;quot; v-model=&amp;quot;value&amp;quot; @change=&amp;quot;aaa&amp;quot; active-text=&amp;quot;打开&amp;quot; active-color=&amp;quot;#13ce66&amp;quot; inactive-color=&amp;quot;#ff4949&amp;quot; :active-value=&amp;quot;true&amp;quot; :inactive-value=&amp;quot;false&amp;quot; inactive-text=&amp;quot;关闭&amp;quot; :width=&amp;quot;200&amp;quot;&amp;gt;&amp;lt;/el-switch&amp;gt;
&amp;lt;el-button @click=&amp;quot;bbb&amp;quot;&amp;gt;调用方法&amp;lt;/el-button&amp;gt;

&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Switchs&amp;quot;,
        data(){
            return{
                value:true
            }
        }
        ,
        methods:{
            aaa(value){
                console.log(value);
            },
            bbb(){
                alert();
                this.$refs.sw.focus();//方法调用
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;86-datepicker组件&#34;&gt;8.6 DatePicker组件&lt;/h3&gt;
&lt;h4 id=&#34;1创建&#34;&gt;1.创建&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-date-picker v-model=&amp;quot;createDate&amp;quot; &amp;gt;&amp;lt;/el-date-picker&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2属性的使用&#34;&gt;2.属性的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-date-picker
        v-model=&amp;quot;createDate&amp;quot;
        :editable=&amp;quot;false&amp;quot;
        :clearable=&amp;quot;false&amp;quot;
        placeholder=&amp;quot;请输入创建时间&amp;quot;
        type=&amp;quot;daterange&amp;quot;
        start-placeholder=&amp;quot;生产时间&amp;quot;
        end-placeholder=&amp;quot;过期时间&amp;quot;
        format=&amp;quot;yyyy/MM/dd&amp;quot;
      &amp;gt;
&amp;lt;/el-date-picker&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3picker-options-和-shortcuts使用&#34;&gt;3.Picker Options 和 Shortcuts使用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Shortcuts:&lt;/strong&gt; 用来增加日期组件的快捷面板&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Picker Options:&lt;/strong&gt; 用来对日期控件做自定义配置&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;31-shortcuts使用&#34;&gt;3.1 Shortcuts使用&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;/el-date-picker&amp;gt;
&amp;lt;h1&amp;gt;日期配置&amp;lt;/h1&amp;gt;
&amp;lt;el-date-picker
                v-model=&amp;quot;createDate&amp;quot;
                type=&amp;quot;date&amp;quot;
                placeholder=&amp;quot;请输入时间&amp;quot;
                :picker-options=&amp;quot;pickerOptions&amp;quot;
                &amp;gt;
&amp;lt;/el-date-picker&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;DatePrickers&amp;quot;,
        data(){
            return{
                createDate:&amp;quot;&amp;quot;,
                pickerOptions: {
                    disabledDate(time) {
                        return time.getTime() &amp;gt; Date.now();
                    },
                    shortcuts: [{  //定义的shortucts
                        text: &#39;今天&#39;,
                        onClick(picker) {
                            picker.$emit(&#39;pick&#39;, new Date());
                        }
                    }, {
                        text: &#39;昨天&#39;,
                        onClick(picker) {
                            const date = new Date();
                            date.setTime(date.getTime() - 3600 * 1000 * 24);
                            picker.$emit(&#39;pick&#39;, date);
                        }
                    }, {
                        text: &#39;一周前&#39;,
                        onClick(picker) {
                            const date = new Date();
                            date.setTime(date.getTime() - 3600 * 1000 * 24 * 7);
                            picker.$emit(&#39;pick&#39;, date);
                        }
                    }]
                },
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606975735552.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;32-picker-options&#34;&gt;3.2 Picker Options&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-date-picker
                v-model=&amp;quot;createDate&amp;quot;
                type=&amp;quot;date&amp;quot;
                placeholder=&amp;quot;请输入时间&amp;quot;
                :picker-options=&amp;quot;pickerOptions&amp;quot;
                &amp;gt;
&amp;lt;/el-date-picker&amp;gt;

&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;DatePrickers&amp;quot;,
        data(){
            return{
                createDate:&amp;quot;&amp;quot;,
                pickerOptions: {
                    disabledDate(time) { //用来对日期进行的控制
                        return time.getTime() &amp;lt; Date.now();
                    }
                },
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606975746134.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;4事件使用&#34;&gt;4.事件使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-date-picker
                .....
                :picker-options=&amp;quot;pickerOptions&amp;quot;
                @change=&amp;quot;aaa&amp;quot;
                &amp;gt;
&amp;lt;/el-date-picker&amp;gt;

&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;DatePrickers&amp;quot;,
        data(){
            return{
                createDate:&amp;quot;&amp;quot;,
            }
        },
        methods:{
            aaa(value){  //发生change事件的函数
                console.log(value);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;87-upload组件&#34;&gt;8.7 Upload组件&lt;/h3&gt;
&lt;h4 id=&#34;1组件创建-2&#34;&gt;1.组件创建&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-upload action=&amp;quot;https://jsonplaceholder.typicode.com/posts/&amp;quot; :file-list=&amp;quot;fileList&amp;quot;&amp;gt;
  &amp;lt;el-button size=&amp;quot;small&amp;quot; type=&amp;quot;primary&amp;quot;&amp;gt;点击上传&amp;lt;/el-button&amp;gt;
  &amp;lt;div slot=&amp;quot;tip&amp;quot; class=&amp;quot;el-upload__tip&amp;quot;&amp;gt;只能上传jpg/png文件，且不超过500kb&amp;lt;/div&amp;gt;
&amp;lt;/el-upload&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意:在使用upload组件时必须设置action属性 action属性为必要参数不能省略&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;2属性和事件的使用&#34;&gt;2.属性和事件的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-upload :limit=&amp;quot;3&amp;quot; :on-exceed=&amp;quot;exceed&amp;quot; :multiple=&amp;quot;false&amp;quot; :before-remove=&amp;quot;beforeRemove&amp;quot; :on-remove=&amp;quot;remove&amp;quot; :on-preview=&amp;quot;show&amp;quot; :drag=&amp;quot;true&amp;quot; accept=&amp;quot;.txt,.png&amp;quot; :show-file-list=&amp;quot;true&amp;quot; name=&amp;quot;aaa&amp;quot; :data=&amp;quot;info&amp;quot; action=&amp;quot;https://jsonplaceholder.typicode.com/posts/&amp;quot;
               :file-list=&amp;quot;fileList&amp;quot;&amp;gt;
  &amp;lt;i class=&amp;quot;el-icon-upload&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;
  &amp;lt;div class=&amp;quot;el-upload__text&amp;quot;&amp;gt;将文件拖到此处，或&amp;lt;em&amp;gt;点击上传&amp;lt;/em&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;el-upload__tip&amp;quot; slot=&amp;quot;tip&amp;quot;&amp;gt;只能上传jpg/png文件，且不超过500kb&amp;lt;/div&amp;gt;
&amp;lt;/el-upload&amp;gt;

&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Uploads&amp;quot;,
        data() {
            return {
                fileList: [{
                    name: &#39;food.jpeg&#39;,
                    url: &#39;https://fuss10.elemecdn.com/3/63/4e7f3a15429bfda99bce42a18cdd1jpeg.jpeg?imageMogr2/thumbnail/360x360/format/webp/quality/100&#39;
                }, {
                    name: &#39;food2.jpeg&#39;,
                    url: &#39;https://fuss10.elemecdn.com/3/63/4e7f3a15429bfda99bce42a18cdd1jpeg.jpeg?imageMogr2/thumbnail/360x360/format/webp/quality/100&#39;
                }],
                info: {id:&amp;quot;21&amp;quot;}
            }
        },
        methods:{
            show(file){
                console.log(file);
            },
            remove(file,fileList){
                console.log(file);
                console.log(fileList);
                //alert(fileList.length)
            },
            beforeRemove(file,fileList){
                if(fileList.length&amp;lt;3){
                    alert(&amp;quot;上传文件不能少于3个&amp;quot;)
                    return false;
                }
            },
            exceed(file,fileList){
                alert(&amp;quot;文件超出上传的个数限制&amp;quot;)
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;注意:在使用upload组件时没有event事件,所有事件都是属性事件&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3方法的使用&#34;&gt;3.方法的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-upload ref=&amp;quot;uploads&amp;quot; ....&amp;gt;........&amp;lt;/el-upload&amp;gt;

方法调用:
	this.$refs.uploads.clearFiles();
	this.$refs.uploads.abort();
	this.$refs.uploads.submit();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;88-form组件&#34;&gt;8.8 Form组件&lt;/h3&gt;
&lt;h4 id=&#34;1组件的创建&#34;&gt;1.组件的创建&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-form ref=&amp;quot;form&amp;quot; :model=&amp;quot;form&amp;quot; label-width=&amp;quot;80px&amp;quot;&amp;gt;
  &amp;lt;el-form-item label=&amp;quot;活动名称&amp;quot;&amp;gt;
    &amp;lt;el-input v-model=&amp;quot;form.name&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
  &amp;lt;/el-form-item&amp;gt;
  ......
  &amp;lt;el-form-item&amp;gt;
    &amp;lt;el-button type=&amp;quot;primary&amp;quot; @click=&amp;quot;onSubmit&amp;quot;&amp;gt;立即创建&amp;lt;/el-button&amp;gt;
    &amp;lt;el-button&amp;gt;取消&amp;lt;/el-button&amp;gt;
  &amp;lt;/el-form-item&amp;gt;
&amp;lt;/el-form&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Form&amp;quot;,
        data() {
            return {
                form: {
                    name: &#39;&#39;,
                    region: &#39;&#39;,
                    date1: &#39;&#39;,
                    date2: &#39;&#39;,
                    delivery: false,
                    type: [],
                    resource: &#39;&#39;,
                    desc: &#39;&#39;
                }
            }
        },
        methods: {
            onSubmit() {
                console.log(&#39;submit!&#39;);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2内联表单&#34;&gt;2.内联表单&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-form :inline=&amp;quot;true&amp;quot; :model=&amp;quot;formInline&amp;quot; class=&amp;quot;demo-form-inline&amp;quot;&amp;gt;
		.......
&amp;lt;/el-form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;通过设置 inline=true方式将表单作为内联表单处理&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;3表单验证&#34;&gt;3.表单验证&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用说明:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Form 组件提供了表单验证的功能，只需要通过 &lt;code&gt;rules&lt;/code&gt; 属性传入约定的验证规则，并将 Form-Item 的 &lt;code&gt;prop&lt;/code&gt; 属性设置为需校验的字段名即可。校验规则参见 &lt;a href=&#34;https://github.com/yiminghe/async-validator&#34;&gt;async-validator&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;31-失去焦点自动验证&#34;&gt;3.1 失去焦点自动验证&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-form :rules=&amp;quot;rules&amp;quot; ...&amp;gt;
  &amp;lt;el-form-item label=&amp;quot;活动名称&amp;quot; prop=&amp;quot;name&amp;quot;&amp;gt;
      &amp;lt;el-input v-model=&amp;quot;form.name&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
  &amp;lt;/el-form-item&amp;gt;
  ....
&amp;lt;/el-form&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Form&amp;quot;,
        data() {
            return {
                form: {
                    name: &#39;&#39;,
                    region: &#39;&#39;,
                    date1: &#39;&#39;,
                    date2: &#39;&#39;,
                    delivery: false,
                    type: [],
                    resource: &#39;&#39;,
                    desc: &#39;&#39;
                },
                rules: {
                    name: [
                        {required: true, message: &#39;请输入活动名称&#39;, trigger: &#39;blur&#39;},
                        {min: 3, max: 5, message: &#39;长度在 3 到 5 个字符&#39;, trigger: &#39;blur&#39;}
                    ],
                }
            }
        },
        methods: {
            onSubmit() {
                console.log(&#39;submit!&#39;);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;32-表单提交调用表单组件的验证方法验证&#34;&gt;3.2 表单提交调用表单组件的验证方法验证&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-form :rules=&amp;quot;rules&amp;quot;.... ref=&amp;quot;form&amp;quot; &amp;gt;
    &amp;lt;el-form-item label=&amp;quot;活动名称&amp;quot; prop=&amp;quot;name&amp;quot;&amp;gt;
      &amp;lt;el-input v-model=&amp;quot;form.name&amp;quot;&amp;gt;&amp;lt;/el-input&amp;gt;
  	&amp;lt;/el-form-item&amp;gt;
  	&amp;lt;el-form-item&amp;gt;
      &amp;lt;el-button type=&amp;quot;primary&amp;quot; @click=&amp;quot;onSubmit(&#39;form&#39;)&amp;quot;&amp;gt;立即创建&amp;lt;/el-button&amp;gt;
      &amp;lt;el-button&amp;gt;取消&amp;lt;/el-button&amp;gt;
  	&amp;lt;/el-form-item&amp;gt;
&amp;lt;/el-form&amp;gt;
...
methods: {
            onSubmit(formName) {
                this.$refs[formName].validate((valid) =&amp;gt; {
                    if (valid) {
                        alert(&#39;submit!&#39;);
                        //发送异步请求 到 springboot项目
                    } else {
                        console.log(&#39;error submit!!&#39;);
                        return false;
                    }
                });
            }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4自定义表单的验证规则&#34;&gt;4.自定义表单的验证规则&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-form :model=&amp;quot;ruleForm&amp;quot; :rules=&amp;quot;rules&amp;quot; ref=&amp;quot;ruleForm&amp;quot; label-width=&amp;quot;100px&amp;quot;&amp;gt;
  &amp;lt;el-form-item label=&amp;quot;手机号&amp;quot; prop=&amp;quot;phone&amp;quot;&amp;gt;
    &amp;lt;el-input type=&amp;quot;password&amp;quot; v-model=&amp;quot;ruleForm.phone&amp;quot; &amp;gt;&amp;lt;/el-input&amp;gt;
  &amp;lt;/el-form-item&amp;gt;
  &amp;lt;el-form-item&amp;gt;
    &amp;lt;el-button type=&amp;quot;primary&amp;quot; @click=&amp;quot;submitForm(&#39;ruleForm&#39;)&amp;quot;&amp;gt;提交&amp;lt;/el-button&amp;gt;
    &amp;lt;el-button @click=&amp;quot;resetForm(&#39;ruleForm&#39;)&amp;quot;&amp;gt;重置&amp;lt;/el-button&amp;gt;
  &amp;lt;/el-form-item&amp;gt;
&amp;lt;/el-form&amp;gt;

&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Form&amp;quot;,
        data() {
            let validatePhone = (rule,value,callback)=&amp;gt;{ //定义自定义的验证规则
                console.log(rule);
                console.log(value);
                console.log(callback);
                if(!value){
                    callback(new Error(&amp;quot;手机号不能为空!&amp;quot;));
                }
                if(!/^1[3456789]\d{9}$/.test(value)){
                    callback(new Error(&amp;quot;手机号码不正确!!&amp;quot;))
                }
            }
            return {
                form: {
                    name: &#39;&#39;,
                    region: &#39;&#39;,
                    date1: &#39;&#39;,
                    date2: &#39;&#39;,
                    delivery: false,
                    type: [],
                    resource: &#39;&#39;,
                    desc: &#39;&#39;
                },
                rules: { //验证规则
                    name: [ //使用默认规则
                        {required: true, message: &#39;请输入活动名称&#39;, trigger: &#39;blur&#39;},
                        {min: 3, max: 5, message: &#39;长度在 3 到 5 个字符&#39;, trigger: &#39;blur&#39;}
                    ],
                    phone:[  //使用自定义规则
                        {validator:validatePhone,trigger: &#39;blur&#39;}
                    ]
                },
                ruleForm:{
                    phone:&#39;&#39;,
                },
            }
        },
        methods: {
           
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;9消息提示&#34;&gt;9.消息提示&lt;/h2&gt;
&lt;h3 id=&#34;91警告提示&#34;&gt;9.1警告提示&lt;/h3&gt;
&lt;h4 id=&#34;11-创建警告提示&#34;&gt;1.1 创建警告提示&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-alert title=&amp;quot;成功信息提示&amp;quot; :closable=&amp;quot;false&amp;quot; type=&amp;quot;success&amp;quot;&amp;gt;
  &amp;lt;div slot&amp;gt;我是辅助信息&amp;lt;/div&amp;gt;
&amp;lt;/el-alert&amp;gt;
&amp;lt;el-alert title=&amp;quot;成功信息提示&amp;quot; type=&amp;quot;info&amp;quot;&amp;gt;&amp;lt;/el-alert&amp;gt;
&amp;lt;el-alert title=&amp;quot;成功信息提示&amp;quot; type=&amp;quot;warning&amp;quot;&amp;gt;&amp;lt;/el-alert&amp;gt;
&amp;lt;el-alert title=&amp;quot;成功信息提示&amp;quot; type=&amp;quot;error&amp;quot;&amp;gt;&amp;lt;/el-alert&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;12属性的使用&#34;&gt;1.2属性的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-alert title=&amp;quot;成功信息提示&amp;quot; effect=&amp;quot;dark&amp;quot; :show-icon=&amp;quot;true&amp;quot; center :closable=&amp;quot;false&amp;quot; type=&amp;quot;success&amp;quot;&amp;gt;
  &amp;lt;div slot&amp;gt;我是辅助信息&amp;lt;/div&amp;gt;
&amp;lt;/el-alert&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;92-message消息提示&#34;&gt;9.2 Message消息提示&lt;/h3&gt;
&lt;h4 id=&#34;21-创建组件&#34;&gt;2.1 创建组件&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;注意:这个组件的创建无须在页面中书写任何标签,他是一个js插件,在需要展示消息提示的位置直接调用提供的js插件方法即可&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;# 1.创建最简单的消息
	this.$message(&#39;这是一个消息提示!!&#39;)

# 2.自定义消息内容
	this.$message({
    message: h(&#39;p&#39;, null, [
      h(&#39;span&#39;, null, &#39;订单创建成功,您的订单编号为: &#39;),
      h(&#39;i&#39;, { style: &#39;color: teal&#39; }, &#39;87&#39;)
    ])
  });

# 3.不同主题的消息提示
	 this.$message({
     message:&#39;这是信息提示&#39;,
     type:&amp;quot;success&amp;quot;,
   })
		//主题样式:  success  info  warning  error

# 4.属性使用
	this.$message({
    message:&#39;这是信息提示&#39;,
    type:&amp;quot;success&amp;quot;,
    showClose:true,
    center:true,
    iconClass:&#39;el-icon-user-solid&#39;,
    duration:0
  })
# 5.方法的使用
	this.$message.closeAll();

&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;10table表格组件&#34;&gt;10.table表格组件&lt;/h2&gt;
&lt;h3 id=&#34;1组件的创建-2&#34;&gt;1.组件的创建&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-table :data=&amp;quot;tableData&amp;quot;&amp;gt;
  &amp;lt;el-table-column prop=&amp;quot;id&amp;quot; label=&amp;quot;编号&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
  &amp;lt;el-table-column prop=&amp;quot;name&amp;quot; label=&amp;quot;姓名&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
  &amp;lt;el-table-column prop=&amp;quot;age&amp;quot; label=&amp;quot;年龄&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
  &amp;lt;el-table-column prop=&amp;quot;email&amp;quot; label=&amp;quot;邮箱&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
&amp;lt;/el-table&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Tables&amp;quot;,
        data(){
            return {
                tableData:[
                    {id:21,name:&amp;quot;小陈&amp;quot;,age:23,email:&amp;quot;60037647@qq.com&amp;quot;},
                    {id:22,name:&amp;quot;小张&amp;quot;,age:25,email:&amp;quot;60038647@qq.com&amp;quot;},
                ]
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2表格中列属性&#34;&gt;2.表格中列属性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;el-table-column属性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-table-column prop=&amp;quot;id&amp;quot; :resizable=&amp;quot;false&amp;quot; header-align=&amp;quot;left&amp;quot; align=&amp;quot;center&amp;quot; fixed=&amp;quot;left&amp;quot; width=&amp;quot;200px;&amp;quot; label=&amp;quot;编号&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
&amp;lt;el-table-column prop=&amp;quot;name&amp;quot; label=&amp;quot;姓名&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
&amp;lt;el-table-column prop=&amp;quot;age&amp;quot; :sort-method=&amp;quot;sorts&amp;quot; sortable label=&amp;quot;年龄&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
&amp;lt;el-table-column prop=&amp;quot;email&amp;quot; label=&amp;quot;邮箱&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
&amp;lt;el-table-column prop=&amp;quot;dept.name&amp;quot; :formatter=&amp;quot;showDept&amp;quot; label=&amp;quot;部门&amp;quot;&amp;gt;&amp;lt;/el-table-column&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Tables&amp;quot;,
        data() {
            return {
                tableData: [
                    {
                        id: 21, name: &amp;quot;小陈&amp;quot;, age: 23, email: &amp;quot;60037647@qq.com&amp;quot;,
                        dept: {id: 1, name: &amp;quot;研发部&amp;quot;}
                    },
                    {
                        id: 22, name: &amp;quot;小张&amp;quot;, age: 25, email: &amp;quot;60038647@qq.com&amp;quot;,
                        dept: {id: 1, name: &amp;quot;小卖部&amp;quot;}
                    },
                    {
                        id: 23, name: &amp;quot;小李&amp;quot;, age: 25, email: &amp;quot;60038657@qq.com&amp;quot;,
                        dept:{}
                    },
                ]
            }
        },
        methods: {
            sorts(a, b) {
                return a.age - b.age;
            },
            showDept(row, column, cellValue, index){
                console.log(row);
                console.log(column);
                console.log(cellValue);
                console.log(index);
                if(cellValue){
                    return cellValue
                }
                return &amp;quot;暂无部门&amp;quot;;
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3表格属性&#34;&gt;3.表格属性&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-table :data=&amp;quot;tableData&amp;quot; empty-text=&amp;quot;暂无数据&amp;quot; :row-class-name=&amp;quot;showCss&amp;quot; highlight-current-row :show-header=&amp;quot;true&amp;quot; :fit=&amp;quot;true&amp;quot;
              size=&amp;quot;mini&amp;quot; :height=&amp;quot;600&amp;quot; border&amp;gt;

&amp;lt;/el-table&amp;gt;
&amp;lt;script&amp;gt;
  .....
	methods: {
            showCss({row, rowIndex}) {
                if (rowIndex % 2 == 0) {
                    return &amp;quot;warning-row&amp;quot;;
                }
                return &amp;quot;success-row&amp;quot;;
            }
        }
 &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4组件事件使用&#34;&gt;4.组件事件使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-table @事件名=&amp;quot;事件处理函数名&amp;quot;&amp;gt;&amp;lt;el-table&amp;gt;

&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Tables&amp;quot;,
        data() {
            //....
        },
        methods: {
            //...事件处理函数
            selectRow(selection, row){
                console.log(selection);
                console.log(row);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5组件方法的使用&#34;&gt;5.组件方法的使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-table  ref=&amp;quot;mytable&amp;quot;&amp;gt;........&amp;lt;/el-table&amp;gt;
//调用方法
	this.$refs.mytable.方法名  
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6表格中定义操作列&#34;&gt;6.表格中定义操作列&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;el-table&amp;gt;
  ....
	 &amp;lt;el-table-column label=&amp;quot;操作&amp;quot;&amp;gt;
      &amp;lt;template slot-scope=&amp;quot;scope&amp;quot;&amp;gt;
        &amp;lt;el-button
          size=&amp;quot;mini&amp;quot;
          @click=&amp;quot;handleEdit(scope.$index, scope.row)&amp;quot;&amp;gt;编辑&amp;lt;/el-button&amp;gt;
        &amp;lt;el-button
          size=&amp;quot;mini&amp;quot;
          type=&amp;quot;danger&amp;quot;
          @click=&amp;quot;handleDelete(scope.$index, scope.row)&amp;quot;&amp;gt;删除&amp;lt;/el-button&amp;gt;
      &amp;lt;/template&amp;gt;
    &amp;lt;/el-table-column&amp;gt;
&amp;lt;/el-table&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Tables&amp;quot;,
        data() {
            .....
        },
        methods: {
						//用来处理编辑和删除的事件函数
            handleEdit(index,row){
                console.log(index);
                console.log(row);
            },
            handleDelete(index,row){
                console.log(index);
                console.log(row);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606975770913.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/h2&gt;
&lt;h3 id=&#34;7自定义表头&#34;&gt;7.自定义表头&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt; &amp;lt;el-table :data=&amp;quot;tableData.filter(data =&amp;gt; !search || data.name.toLowerCase().includes(search.toLowerCase()))&amp;quot; &amp;gt;
   .....
   &amp;lt;!--展示搜索和操作--&amp;gt;
   &amp;lt;el-table-column&amp;gt;
        &amp;lt;template slot=&amp;quot;header&amp;quot; slot-scope=&amp;quot;scope&amp;quot;&amp;gt;
          &amp;lt;el-input
            v-model=&amp;quot;search&amp;quot;
            size=&amp;quot;mini&amp;quot;
            placeholder=&amp;quot;输入关键字搜索&amp;quot;/&amp;gt;
        &amp;lt;/template&amp;gt;
        &amp;lt;template slot-scope=&amp;quot;scope&amp;quot;&amp;gt;
          &amp;lt;el-button
            size=&amp;quot;mini&amp;quot;
            @click=&amp;quot;handleEdit(scope.$index, scope.row)&amp;quot;&amp;gt;编辑&amp;lt;/el-button&amp;gt;
          &amp;lt;el-button
            size=&amp;quot;mini&amp;quot;
            type=&amp;quot;danger&amp;quot;
            @click=&amp;quot;handleDelete(scope.$index, scope.row)&amp;quot;&amp;gt;删除&amp;lt;/el-button&amp;gt;
        &amp;lt;/template&amp;gt;
      &amp;lt;/el-table-column&amp;gt;
&amp;lt;/el-table&amp;gt;
&amp;lt;script&amp;gt;
    export default {
        name: &amp;quot;Tables&amp;quot;,
        data() {
            return {
                tableData: [
                    {
                        id: 21, name: &amp;quot;小陈&amp;quot;, age: 23, email: &amp;quot;60037647@qq.com&amp;quot;,
                        dept: {id: 1, name: &amp;quot;研发部&amp;quot;}
                    },
                    {
                        id: 22, name: &amp;quot;小张&amp;quot;, age: 25, email: &amp;quot;60038647@qq.com&amp;quot;,
                        dept: {id: 1, name: &amp;quot;小卖部&amp;quot;}
                    },
                    {
                        id: 23, name: &amp;quot;小李&amp;quot;, age: 25, email: &amp;quot;60038657@qq.com&amp;quot;,
                        dept: {}
                    },
                    {
                        id: 24, name: &amp;quot;小四&amp;quot;, age: 25, email: &amp;quot;60038657@qq.com&amp;quot;,
                        dept: {}
                    },
                ],
                search: &#39;&#39;
            }
        },
        methods: {
            sorts(a, b) {
                return a.age - b.age;
            },
            showDept(row, column, cellValue, index) {
                if (cellValue) {
                    return cellValue
                }
                return &amp;quot;暂无部门&amp;quot;;
            },
            showCss({row, rowIndex}) {
                if (rowIndex % 2 == 0) {
                    return &amp;quot;warning-row&amp;quot;;
                }
                return &amp;quot;success-row&amp;quot;;
            },
            selectRow(selection, row){
                console.log(selection);
                console.log(row);
            },
            clearSelect(){
                this.$refs.mytable.clearSelection();
            },
            handleEdit(index,row){
                console.log(index);
                console.log(row);
            },
            handleDelete(index,row){
                console.log(index);
                console.log(row);
            }
        }
    }
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606975779180.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;鸣谢：源自&lt;a href=&#34;https://www.bilibili.com/video/BV1NK4y187XH&#34;&gt;视频教程-陈老师&lt;/a&gt;&lt;/p&gt;
">Element UI 实战教程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/can-ting-lian-xi-css-xuan-ze-qi/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://github.com/Tyloo-code/Restaurant&#34;&gt;点此下载&lt;/a&gt;&lt;br&gt;
第一关&lt;br&gt;
plate&lt;br&gt;
plate元素&lt;/p&gt;
&lt;p&gt;第二关&lt;br&gt;
bento&lt;br&gt;
bento元素&lt;/p&gt;
&lt;p&gt;第三关&lt;br&gt;
#fancy&lt;br&gt;
id为fancy的元素&lt;/p&gt;
&lt;p&gt;第四关&lt;br&gt;
plate apple&lt;br&gt;
plate祖先元素下的apple后代元素&lt;/p&gt;
&lt;p&gt;第五关&lt;br&gt;
#fancy pickle&lt;br&gt;
id为#fancy的祖先元素下的pickle后代元素&lt;/p&gt;
&lt;p&gt;第六关&lt;br&gt;
.small&lt;br&gt;
组为small的元素&lt;/p&gt;
&lt;p&gt;第七关&lt;br&gt;
orange.small&lt;br&gt;
组为small的orange元素&lt;/p&gt;
&lt;p&gt;第八关&lt;br&gt;
bento&amp;gt;orange.small&lt;br&gt;
bento父元素下的组为small的orange子元素&lt;/p&gt;
&lt;p&gt;第九关&lt;br&gt;
plate,bento,div&lt;br&gt;
plate,bento兄弟元素在div元素中&lt;/p&gt;
&lt;p&gt;第十关&lt;br&gt;
*&lt;br&gt;
*代表所有元素&lt;/p&gt;
&lt;p&gt;第十一关&lt;br&gt;
plate&amp;gt;*&lt;br&gt;
plate父元素的所有子元素&lt;/p&gt;
&lt;p&gt;第十二关&lt;br&gt;
plate + apple&lt;br&gt;
兄弟元素选择器，plate元素的后一个元素&lt;/p&gt;
&lt;p&gt;第十三关&lt;br&gt;
bento~pickle&lt;br&gt;
兄弟元素选择器,bento元素后的多个pickle元素&lt;/p&gt;
&lt;p&gt;第十四关&lt;br&gt;
plate&amp;gt;apple&lt;br&gt;
plate父元素下的apple子元素&lt;/p&gt;
&lt;p&gt;第十五关&lt;br&gt;
plate orange:first-child&lt;br&gt;
子元素选择器，plate元素下的第一个orange元素&lt;/p&gt;
&lt;p&gt;第十六关&lt;br&gt;
plate :only-child&lt;br&gt;
所有plate元素下的元素&lt;/p&gt;
&lt;p&gt;第十七关&lt;br&gt;
.small:last-child&lt;br&gt;
id为fancy的元素的最后一个和pickle元素的最后一个&lt;/p&gt;
&lt;p&gt;第十八关&lt;br&gt;
plate:nth-child(3)&lt;br&gt;
div元素中的第三个plate元素&lt;/p&gt;
&lt;p&gt;第十九关&lt;br&gt;
bento:nth-of-type(1)&lt;br&gt;
第N个最后一个孩子选择器&lt;/p&gt;
&lt;p&gt;第二十关&lt;br&gt;
apple:first-of-type&lt;br&gt;
第一个apple元素&lt;/p&gt;
&lt;p&gt;第二十一关&lt;br&gt;
plate:nth-of-type(even)&lt;br&gt;
所有偶数个的plate元素&lt;/p&gt;
&lt;p&gt;第二十二关&lt;br&gt;
plate:nth-of-type(2n+3)&lt;br&gt;
同类型的，每2个选择一个plate，从第3 个开始，包括第3个&lt;/p&gt;
&lt;p&gt;第二十三关&lt;br&gt;
plate apple.small:only-of-type&lt;br&gt;
plate元素下满足apple.small元素的唯一一个元素&lt;/p&gt;
&lt;p&gt;第二十四关&lt;br&gt;
orange.small:last-of-type,apple.small:last-of-type&lt;br&gt;
是orange.samll和apple.small元素的最后一个元素&lt;/p&gt;
&lt;p&gt;第二十五关&lt;br&gt;
bento:empty&lt;br&gt;
bento元素里没有包括额外元素&lt;/p&gt;
&lt;p&gt;第二十六关&lt;br&gt;
apple:not(.small)&lt;br&gt;
apple里没有组是.small的元素&lt;/p&gt;
">餐厅练习-Css选择器</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/vue-cong-ru-men-dao-wei-wan-dai-xu/"" data-c="
          &lt;h1 id=&#34;vue-day-01&#34;&gt;Vue Day 01&lt;/h1&gt;
&lt;h3 id=&#34;一-邂逅vuejs&#34;&gt;一. 邂逅Vuejs&lt;/h3&gt;
&lt;h4 id=&#34;11-认识vuejs&#34;&gt;1.1. 认识Vuejs&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;为什么学习Vuejs&lt;/li&gt;
&lt;li&gt;Vue的读音&lt;/li&gt;
&lt;li&gt;Vue的渐进式&lt;/li&gt;
&lt;li&gt;Vue的特点&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;12-安装vue&#34;&gt;1.2. 安装Vue&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;CDN引入&lt;/li&gt;
&lt;li&gt;下载引入&lt;/li&gt;
&lt;li&gt;npm安装&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;13-vue的初体验&#34;&gt;1.3. Vue的初体验&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Hello Vuejs
&lt;ul&gt;
&lt;li&gt;mustache -&amp;gt; 体验vue响应式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Vue列表展示
&lt;ul&gt;
&lt;li&gt;v-for&lt;/li&gt;
&lt;li&gt;后面给数组追加元素的时候, 新的元素也可以在界面中渲染出来&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Vue计数器小案例
&lt;ul&gt;
&lt;li&gt;事件监听: click -&amp;gt; methods&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;14-vue中的mvvm&#34;&gt;1.4. Vue中的MVVM&lt;/h4&gt;
&lt;h4 id=&#34;15-创建vue时-options可以放那些东西&#34;&gt;1.5. 创建Vue时, options可以放那些东西&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;el:&lt;/li&gt;
&lt;li&gt;data:&lt;/li&gt;
&lt;li&gt;methods:&lt;/li&gt;
&lt;li&gt;生命周期函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二插值语法&#34;&gt;二.插值语法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;mustache语法&lt;/li&gt;
&lt;li&gt;v-once&lt;/li&gt;
&lt;li&gt;v-html&lt;/li&gt;
&lt;li&gt;v-text&lt;/li&gt;
&lt;li&gt;v-pre: {{}}&lt;/li&gt;
&lt;li&gt;v-cloak: 斗篷&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三-v-bind&#34;&gt;三. v-bind&lt;/h3&gt;
&lt;h4 id=&#34;31-v-bind绑定基本属性&#34;&gt;3.1. v-bind绑定基本属性&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;v-bind:sr&lt;/li&gt;
&lt;li&gt;:href&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;32-v-bind动态绑定class&#34;&gt;3.2. v-bind动态绑定class&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;对象语法: 作业 :class=&#39;{类名: boolean}&#39;&lt;/li&gt;
&lt;li&gt;数组语法:&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;33-v-bind动态绑定style&#34;&gt;3.3. v-bind动态绑定style&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;对象语法:&lt;/li&gt;
&lt;li&gt;数组语法:&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;四-计算属性&#34;&gt;四. 计算属性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;案例一: firstName+lastName&lt;/li&gt;
&lt;li&gt;案例二: books -&amp;gt; price&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;vue-day-02&#34;&gt;Vue Day 02&lt;/h1&gt;
&lt;h3 id=&#34;一-计算属性&#34;&gt;一. 计算属性&lt;/h3&gt;
&lt;h4 id=&#34;11-计算属性的本质&#34;&gt;1.1. 计算属性的本质&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;fullname: {set(), get()}&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;12-计算属性和methods对比&#34;&gt;1.2. 计算属性和methods对比&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;计算属性在多次使用时, 只会调用一次.&lt;/li&gt;
&lt;li&gt;它是由缓存的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二-事件监听&#34;&gt;二. 事件监听&lt;/h3&gt;
&lt;h4 id=&#34;21-事件监听基本使用&#34;&gt;2.1. 事件监听基本使用&lt;/h4&gt;
&lt;h4 id=&#34;22-参数问题&#34;&gt;2.2. 参数问题&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;btnClick&lt;/li&gt;
&lt;li&gt;btnClick(event)&lt;/li&gt;
&lt;li&gt;btnClick(abc, event) -&amp;gt; $event&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;23-修饰符&#34;&gt;2.3. 修饰符&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;stop&lt;/li&gt;
&lt;li&gt;prevent&lt;/li&gt;
&lt;li&gt;.enter&lt;/li&gt;
&lt;li&gt;.once&lt;/li&gt;
&lt;li&gt;.native&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三-条件判断&#34;&gt;三. 条件判断&lt;/h3&gt;
&lt;h4 id=&#34;31-v-ifv-else-ifv-else&#34;&gt;3.1. v-if/v-else-if/v-else&lt;/h4&gt;
&lt;h4 id=&#34;32-登录小案例&#34;&gt;3.2. 登录小案例&lt;/h4&gt;
&lt;h4 id=&#34;33-v-show&#34;&gt;3.3. v-show&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;v-show和v-if区别&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;四-循环遍历&#34;&gt;四. 循环遍历&lt;/h3&gt;
&lt;h4 id=&#34;41-遍历数组&#34;&gt;4.1. 遍历数组&lt;/h4&gt;
&lt;h4 id=&#34;42-遍历对象&#34;&gt;4.2. 遍历对象&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;value&lt;/li&gt;
&lt;li&gt;value, key&lt;/li&gt;
&lt;li&gt;value, key, index&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;43-数组哪些方法是响应式的&#34;&gt;4.3. 数组哪些方法是响应式的&lt;/h4&gt;
&lt;h4 id=&#34;44-作业完成&#34;&gt;4.4. 作业完成&lt;/h4&gt;
&lt;h3 id=&#34;五-书籍案例&#34;&gt;五. 书籍案例&lt;/h3&gt;
&lt;h3 id=&#34;六-v-model的使用&#34;&gt;六. v-model的使用&lt;/h3&gt;
&lt;h4 id=&#34;61-v-model的基本使用&#34;&gt;6.1. v-model的基本使用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;v-model =&amp;gt; v-bind:value v-on:input&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;62-v-model和radiocheckboxselect&#34;&gt;6.2. v-model和radio/checkbox/select&lt;/h4&gt;
&lt;h4 id=&#34;63-修饰符&#34;&gt;6.3. 修饰符&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;lazy&lt;/li&gt;
&lt;li&gt;number&lt;/li&gt;
&lt;li&gt;trim&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;七-组件化开发&#34;&gt;七. 组件化开发&lt;/h3&gt;
&lt;h4 id=&#34;71-认识组件化&#34;&gt;7.1. 认识组件化&lt;/h4&gt;
&lt;h4 id=&#34;72-组件的基本使用&#34;&gt;7.2. 组件的基本使用&lt;/h4&gt;
&lt;h4 id=&#34;73-全局组件和局部组件&#34;&gt;7.3. 全局组件和局部组件&lt;/h4&gt;
&lt;h4 id=&#34;74-父组件和子组件&#34;&gt;7.4. 父组件和子组件&lt;/h4&gt;
&lt;h4 id=&#34;75-注册的语法糖&#34;&gt;7.5. 注册的语法糖&lt;/h4&gt;
&lt;h4 id=&#34;76-模板的分类写法&#34;&gt;7.6. 模板的分类写法&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;script&lt;/li&gt;
&lt;li&gt;template&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;77-数据的存放&#34;&gt;7.7. 数据的存放&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;子组件不能直接访问父组件&lt;/li&gt;
&lt;li&gt;子组件中有自己的data, 而且必须是一个函数.&lt;/li&gt;
&lt;li&gt;为什么必须是一个函数.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;78-父子组件的通信&#34;&gt;7.8. 父子组件的通信&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;父传子: props&lt;/li&gt;
&lt;li&gt;子传父: $emit&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;79-项目&#34;&gt;7.9. 项目&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;npm install&lt;/li&gt;
&lt;li&gt;npm run serve&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;vue-day-03&#34;&gt;Vue Day 03&lt;/h1&gt;
&lt;h3 id=&#34;一-组件化开发&#34;&gt;一. 组件化开发&lt;/h3&gt;
&lt;h4 id=&#34;11-父子组件的访问&#34;&gt;1.1. 父子组件的访问&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;children/refs&lt;/li&gt;
&lt;li&gt;parent/root&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;12-slot的使用&#34;&gt;1.2. slot的使用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;基本使用&lt;/li&gt;
&lt;li&gt;具名插槽&lt;/li&gt;
&lt;li&gt;编译的作用域&lt;/li&gt;
&lt;li&gt;作用域插槽&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二-前端模块化&#34;&gt;二. 前端模块化&lt;/h3&gt;
&lt;h4 id=&#34;21-为什么要使用模块化&#34;&gt;2.1. 为什么要使用模块化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;简单写js代码带来的问题&lt;/li&gt;
&lt;li&gt;闭包引起代码不可复用.&lt;/li&gt;
&lt;li&gt;自己实现了简单的模块化&lt;/li&gt;
&lt;li&gt;AMD/CMD/CommonJS&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;22-es6中模块化的使用&#34;&gt;2.2. ES6中模块化的使用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;export&lt;/li&gt;
&lt;li&gt;import&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三-webpack&#34;&gt;三. webpack&lt;/h3&gt;
&lt;h4 id=&#34;31-什么是webpack&#34;&gt;3.1. 什么是webpack&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;webpack和gulp对比&lt;/li&gt;
&lt;li&gt;webpack依赖环境&lt;/li&gt;
&lt;li&gt;安装webpack&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;32-webpack的起步&#34;&gt;3.2. webpack的起步&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;webpack命令&lt;/li&gt;
&lt;li&gt;webpack配置: webpack.config.js/package.json(scripts)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;33-webpack的loader&#34;&gt;3.3. webpack的loader&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;css-loader/style-loader&lt;/li&gt;
&lt;li&gt;less-loader/less&lt;/li&gt;
&lt;li&gt;url-loader/file-loader&lt;/li&gt;
&lt;li&gt;babel-loader&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;34-webpack中配置vue&#34;&gt;3.4. webpack中配置Vue&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;vue-loader&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;35-webpack的plugin&#34;&gt;3.5. webpack的plugin&lt;/h4&gt;
&lt;h4 id=&#34;36-搭建本地服务器&#34;&gt;3.6. 搭建本地服务器&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;webpack-dev-server&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;37-配置文件的分离&#34;&gt;3.7. 配置文件的分离&lt;/h4&gt;
&lt;h3 id=&#34;四-vue-cli&#34;&gt;四. Vue CLI&lt;/h3&gt;
&lt;h4 id=&#34;41-什么是cli&#34;&gt;4.1. 什么是CLI&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;脚手架是什么东西.&lt;/li&gt;
&lt;li&gt;CLI依赖webpack,node,npm&lt;/li&gt;
&lt;li&gt;安装CLI3 -&amp;gt; 拉去CLI2模块&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;42-cli2初始化项目的过程&#34;&gt;4.2. CLI2初始化项目的过程&lt;/h4&gt;
&lt;h4 id=&#34;43-cli2生产的目录结构的解析&#34;&gt;4.3. CLI2生产的目录结构的解析&lt;/h4&gt;
&lt;p&gt;export(导出)/import(导入)&lt;/p&gt;
&lt;p&gt;.vue&lt;/p&gt;
&lt;p&gt;dist -&amp;gt; distribution(发布)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;webpack ./src/main.js ./dist/bundle.js&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;开发时依赖&lt;/p&gt;
&lt;p&gt;运行时依赖&lt;/p&gt;
&lt;h1 id=&#34;vue-day-04&#34;&gt;Vue Day 04&lt;/h1&gt;
&lt;h3 id=&#34;一-vue-cli&#34;&gt;一. Vue CLI&lt;/h3&gt;
&lt;h4 id=&#34;11-runtime-compiler和runtime-only的区别&#34;&gt;1.1. runtime-compiler和runtime-only的区别&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ESLint到底是什么?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;template -&amp;gt; ast -&amp;gt; render -&amp;gt; vdom -&amp;gt; 真实DOM&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;render: (h) =&amp;gt; h, -&amp;gt; createElement&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;12-vue-cli3&#34;&gt;1.2. Vue CLI3&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;如何通过CLI3创建项目&lt;/li&gt;
&lt;li&gt;CLI3的目录结构&lt;/li&gt;
&lt;li&gt;配置文件: 1.Vue UI 2.隐藏的配置文件 3.自定义vue.config.js&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二-vue-router&#34;&gt;二. Vue-Router&lt;/h3&gt;
&lt;h4 id=&#34;21-什么是前端路由&#34;&gt;2.1. 什么是前端路由&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;后端渲染\后端路由&lt;/li&gt;
&lt;li&gt;前后端分离&lt;/li&gt;
&lt;li&gt;SPA\前端路由&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;22-路由的基本配置&#34;&gt;2.2. 路由的基本配置&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;安装vue-router&lt;/li&gt;
&lt;li&gt;Vue.use -&amp;gt; 创建VueRouter对象 -&amp;gt; 挂在到Vue实例上&lt;/li&gt;
&lt;li&gt;配置映射关系: 1.创建组件 2.配置映射关系 3.使用router-link/router-view&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;23-细节处理&#34;&gt;2.3. 细节处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;默认路由: redirect&lt;/li&gt;
&lt;li&gt;mode: history&lt;/li&gt;
&lt;li&gt;router-link -&amp;gt; tag/replace/active-class&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;24-动态路由&#34;&gt;2.4. 动态路由&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;/user/:id&lt;/li&gt;
&lt;li&gt;this.$route.params.id&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;25-参数的传递&#34;&gt;2.5. 参数的传递&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;params&lt;/li&gt;
&lt;li&gt;query -&amp;gt; URL&lt;/li&gt;
&lt;li&gt;URL:
&lt;ul&gt;
&lt;li&gt;协议://主机:端口/路径?查询&lt;/li&gt;
&lt;li&gt;scheme://host:port/path?query#fragment&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;26-路由嵌套&#34;&gt;2.6. 路由嵌套&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;children: []&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;27-导航守卫&#34;&gt;2.7. 导航守卫&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;全局导航守卫&lt;/li&gt;
&lt;li&gt;路由独享守卫&lt;/li&gt;
&lt;li&gt;组件类守卫&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;28-keep-alive&#34;&gt;2.8. Keep-alive&lt;/h4&gt;
&lt;h4 id=&#34;29-tabbar的封装过程&#34;&gt;2.9. TabBar的封装过程&lt;/h4&gt;
&lt;p&gt;C:\Users\Administrator\AppData\Roaming&lt;/p&gt;
&lt;p&gt;vue init webpack project&lt;/p&gt;
&lt;p&gt;runtime+compiler和runtime-only&lt;/p&gt;
&lt;p&gt;template -&amp;gt; ast -&amp;gt; render -&amp;gt; virtual dom -&amp;gt; 真实DOM&lt;/p&gt;
&lt;p&gt;vue2.5.21 -&amp;gt; vue2.x -&amp;gt; flow-type(facebook)&lt;/p&gt;
&lt;p&gt;Vue3.x -&amp;gt; TypeScript(micro(微小)soft(软件))&lt;/p&gt;
&lt;p&gt;future: 将来/未来&lt;/p&gt;
&lt;p&gt;fut: 特性&lt;/p&gt;
&lt;p&gt;rc -&amp;gt; run command&lt;/p&gt;
&lt;p&gt;vcs -&amp;gt; version control system(版本控制git/svn)&lt;/p&gt;
&lt;p&gt;什么是前端渲染, 什么是后端渲染?&lt;/p&gt;
&lt;p&gt;什么是前后端分离?&lt;/p&gt;
&lt;p&gt;什么是前端路由, 什么是后端路由?&lt;/p&gt;
&lt;p&gt;href -&amp;gt; hyper reference&lt;/p&gt;
&lt;h1 id=&#34;vue-day-05&#34;&gt;Vue Day 05&lt;/h1&gt;
&lt;h3 id=&#34;一-promise&#34;&gt;一. Promise&lt;/h3&gt;
&lt;h4 id=&#34;11-promise的基本使用&#34;&gt;1.1. Promise的基本使用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;如何将异步操作放入到promise中&lt;/li&gt;
&lt;li&gt;(resolve, reject) =&amp;gt; then/catch&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;12-promise的链式调用&#34;&gt;1.2. Promise的链式调用&lt;/h4&gt;
&lt;h4 id=&#34;13-promise的all方法&#34;&gt;1.3. Promise的all方法&lt;/h4&gt;
&lt;h3 id=&#34;二-vuex&#34;&gt;二. Vuex&lt;/h3&gt;
&lt;h4 id=&#34;21-什么是状态管理&#34;&gt;2.1. 什么是状态管理&lt;/h4&gt;
&lt;h4 id=&#34;22-vuex的基本使用&#34;&gt;2.2. Vuex的基本使用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;state -&amp;gt; 直接修改state(错误)&lt;/li&gt;
&lt;li&gt;mutations -&amp;gt; devtools&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;23-核心概念&#34;&gt;2.3. 核心概念&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;state -&amp;gt; 单一状态树&lt;/li&gt;
&lt;li&gt;getters -&amp;gt;&lt;/li&gt;
&lt;li&gt;mutations -&amp;gt;&lt;/li&gt;
&lt;li&gt;actions -&amp;gt; 异步操作(Promise)&lt;/li&gt;
&lt;li&gt;modules&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;24-目录组织方式&#34;&gt;2.4. 目录组织方式&lt;/h4&gt;
&lt;h3 id=&#34;三-网络请求封装&#34;&gt;三. 网络请求封装&lt;/h3&gt;
&lt;h4 id=&#34;31-网络请求方式的选择&#34;&gt;3.1. 网络请求方式的选择&lt;/h4&gt;
&lt;h4 id=&#34;32-axios的基本使用&#34;&gt;3.2. axios的基本使用&lt;/h4&gt;
&lt;h4 id=&#34;33-axios的相关配置&#34;&gt;3.3. axios的相关配置&lt;/h4&gt;
&lt;h4 id=&#34;34-axios的创建实例&#34;&gt;3.4. axios的创建实例&lt;/h4&gt;
&lt;h4 id=&#34;35-axios的封装&#34;&gt;3.5. axios的封装&lt;/h4&gt;
&lt;h4 id=&#34;36-axios的拦截器&#34;&gt;3.6. axios的拦截器&lt;/h4&gt;
&lt;h3 id=&#34;四-项目开发&#34;&gt;四. 项目开发&lt;/h3&gt;
&lt;h4 id=&#34;41-划分目录结构&#34;&gt;4.1. 划分目录结构&lt;/h4&gt;
&lt;h4 id=&#34;42-引用了两个css文件&#34;&gt;4.2. 引用了两个css文件&lt;/h4&gt;
&lt;h4 id=&#34;43-vueconfigjs和editorconfig&#34;&gt;4.3. vue.config.js和.editorconfig&lt;/h4&gt;
&lt;h4 id=&#34;44-项目的模块划分-tabbar-路由映射关系&#34;&gt;4.4. 项目的模块划分: tabbar -&amp;gt; 路由映射关系&lt;/h4&gt;
&lt;h4 id=&#34;45-首页开发&#34;&gt;4.5. 首页开发&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;navbar 的封装&lt;/li&gt;
&lt;li&gt;网络数据的请求&lt;/li&gt;
&lt;li&gt;轮播图&lt;/li&gt;
&lt;li&gt;推荐信息&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;git remote add origin https://github.com/coderwhy/testmall.git
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sync -&amp;gt; 同步&lt;/p&gt;
&lt;p&gt;async -&amp;gt; 异步&lt;/p&gt;
&lt;p&gt;aysnc operation: 操作&lt;/p&gt;
&lt;p&gt;xcode/iphonex/xml&lt;/p&gt;
&lt;p&gt;token -&amp;gt;&lt;/p&gt;
&lt;p&gt;linus -&amp;gt; linux/git&lt;/p&gt;
&lt;h1 id=&#34;vue-day-06&#34;&gt;Vue Day 06&lt;/h1&gt;
&lt;p&gt;goods: (流行/新款/精选)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;goods: {
  &#39;pop&#39;: {page: 5, list: [150]},
  &#39;news&#39;: {page: 2, list: [60]},
  &#39;sell&#39;: {page: 1, list: [30]}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref如果是绑定在组件中的, 那么通过&lt;strong&gt;this.$refs.refname&lt;/strong&gt;获取到的是一个组件对象.&lt;/p&gt;
&lt;p&gt;ref如果是绑定在普通的元素中, 那么通过&lt;strong&gt;this.$refs.refname&lt;/strong&gt;获取到的是一个元素对象.&lt;/p&gt;
&lt;p&gt;44 + 49 = 93&lt;/p&gt;
&lt;p&gt;vh -&amp;gt; viewport height&lt;/p&gt;
&lt;p&gt;568(100%) - 98 = 470&lt;/p&gt;
&lt;p&gt;修饰.native修饰什么时候使用?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在我们需要监听一个组件的原生事件时, 必须给对应的事件加上.native修饰符, 才能进行监听.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计算机中没有黑魔法.&lt;/p&gt;
&lt;h1 id=&#34;vue-day-07&#34;&gt;Vue Day 07&lt;/h1&gt;
&lt;h3 id=&#34;一-featureview&#34;&gt;一. FeatureView&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;独立组件封装FeatureView
&lt;ul&gt;
&lt;li&gt;div&amp;gt;a&amp;gt;img&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二-tabcontrol&#34;&gt;二. TabControl&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;独立组件的封装
&lt;ul&gt;
&lt;li&gt;props -&amp;gt; titles&lt;/li&gt;
&lt;li&gt;div&amp;gt;根据titles v-for遍历 div -&amp;gt; span{{title}}&lt;/li&gt;
&lt;li&gt;css相关&lt;/li&gt;
&lt;li&gt;选中哪一个tab, 哪一个tab的文字颜色变色, 下面border-bottom
&lt;ul&gt;
&lt;li&gt;currentIndex&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三-首页商品数据的请求&#34;&gt;三. 首页商品数据的请求&lt;/h3&gt;
&lt;h4 id=&#34;31-设计数据结构-用于保存数据&#34;&gt;3.1. 设计数据结构, 用于保存数据&lt;/h4&gt;
&lt;p&gt;goods: {&lt;/p&gt;
&lt;p&gt;pop: page/list&lt;/p&gt;
&lt;p&gt;new: page/list&lt;/p&gt;
&lt;p&gt;sell: page/list&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h4 id=&#34;32-发送数据请求&#34;&gt;3.2. 发送数据请求&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在home.js中封装getHomeGoods(type, page)&lt;/li&gt;
&lt;li&gt;在Home.vue中, 又在methods中getHomeGoods(type)&lt;/li&gt;
&lt;li&gt;调用getHomeGoods(&#39;pop&#39;)/getHomeGoods(&#39;new&#39;)/getHomeGoods(&#39;sell&#39;)
&lt;ul&gt;
&lt;li&gt;page: 动态的获取对应的page&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;获取到数据: res
&lt;ul&gt;
&lt;li&gt;this.goods[type].list.push(...res.data.list)&lt;/li&gt;
&lt;li&gt;this.goods[type].page += 1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;goods: {&lt;/p&gt;
&lt;p&gt;pop: page1:/list[30]&lt;/p&gt;
&lt;p&gt;new: page1/list[30]&lt;/p&gt;
&lt;p&gt;sell: page1/list[30]&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h3 id=&#34;四-对商品数据进行展示&#34;&gt;四. 对商品数据进行展示&lt;/h3&gt;
&lt;h4 id=&#34;41-封装goodslistvue组件&#34;&gt;4.1. 封装GoodsList.vue组件&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;props: goods -&amp;gt; list[30]&lt;/li&gt;
&lt;li&gt;v-for goods -&amp;gt; GoodsListItem[30]&lt;/li&gt;
&lt;li&gt;GoodListItem(组件) -&amp;gt; GoodsItem(数据)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;42-封装goodslistitemvue组件&#34;&gt;4.2. 封装GoodsListItem.vue组件&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;props: goodsItem&lt;/li&gt;
&lt;li&gt;goodsItem 取出数据, 并且使用正确的div/span/img基本标签进行展示&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;五-对滚动进行重构-better-scroll&#34;&gt;五. 对滚动进行重构: Better-Scroll&lt;/h3&gt;
&lt;h4 id=&#34;51-在indexhtml中使用better-scroll&#34;&gt;5.1. 在index.html中使用Better-Scroll&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;const bscroll = new BScroll(el, {   })&lt;/li&gt;
&lt;li&gt;注意: wrapper -&amp;gt; content -&amp;gt; 很多内容&lt;/li&gt;
&lt;li&gt;1.监听滚动
&lt;ul&gt;
&lt;li&gt;probeType: 0/1/2(手指滚动)/3(只要是滚动)&lt;/li&gt;
&lt;li&gt;bscroll .on(&#39;scroll&#39;, (position) =&amp;gt; {})&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2.上拉加载
&lt;ul&gt;
&lt;li&gt;pullUpLoad: true&lt;/li&gt;
&lt;li&gt;bscroll .on(&#39;pullingUp&#39;, () =&amp;gt; {})&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3.click: false
&lt;ul&gt;
&lt;li&gt;button可以监听点击&lt;/li&gt;
&lt;li&gt;div不可以&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;52-在vue项目中使用better-scroll&#34;&gt;5.2. 在Vue项目中使用Better-Scroll&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在Profile.vue中简单的演示&lt;/li&gt;
&lt;li&gt;对Better-Scroll进行封装: Scroll.vue&lt;/li&gt;
&lt;li&gt;Home.vue和Scroll.vue之间进行通信
&lt;ul&gt;
&lt;li&gt;Home.vue将probeType设置为3&lt;/li&gt;
&lt;li&gt;Scroll.vue需要通过$emit, 实时将事件发送到Home.vue&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;六-回到顶部backtop&#34;&gt;六. 回到顶部BackTop&lt;/h3&gt;
&lt;h4 id=&#34;61-对backtopvue组件的封装&#34;&gt;6.1. 对BackTop.vue组件的封装&lt;/h4&gt;
&lt;h4 id=&#34;62-如何监听组件的点击&#34;&gt;6.2. 如何监听组件的点击&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;直接监听back-top的点击, 但是可以直接监听?
&lt;ul&gt;
&lt;li&gt;不可以, 必须添加修饰.native&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;回到顶部
&lt;ul&gt;
&lt;li&gt;scroll对象, scroll.scrollTo(x, y, time)&lt;/li&gt;
&lt;li&gt;this.$refs.scroll.scrollTo(0, 0, 500)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;63-backtop组件的显示和隐藏&#34;&gt;6.3. BackTop组件的显示和隐藏&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;isShowBackTop: false&lt;/li&gt;
&lt;li&gt;监听滚动, 拿到滚动的位置:
&lt;ul&gt;
&lt;li&gt;-position.y &amp;gt; 1000  -&amp;gt; isShowBackTop: true&lt;/li&gt;
&lt;li&gt;isShowBackTop = -position.y &amp;gt; 1000&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;七-解决首页中可滚动区域的问题&#34;&gt;七. 解决首页中可滚动区域的问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Better-Scroll在决定有多少区域可以滚动时, 是根据scrollerHeight属性决定&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scrollerHeight属性是根据放Better-Scroll的content中的子组件的高度&lt;/li&gt;
&lt;li&gt;但是我们的首页中, 刚开始在计算scrollerHeight属性时, 是没有将图片计算在内的&lt;/li&gt;
&lt;li&gt;所以, 计算出来的告诉是错误的(1300+)&lt;/li&gt;
&lt;li&gt;后来图片加载进来之后有了新的高度, 但是scrollerHeight属性并没有进行更新.&lt;/li&gt;
&lt;li&gt;所以滚动出现了问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何解决这个问题了?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监听每一张图片是否加载完成, 只要有一张图片加载完成了, 执行一次refresh()&lt;/li&gt;
&lt;li&gt;如何监听图片加载完成了?
&lt;ul&gt;
&lt;li&gt;原生的js监听图片: img.onload = function() {}&lt;/li&gt;
&lt;li&gt;Vue中监听: @load=&#39;方法&#39;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调用scroll的refresh()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何将GoodsListItem.vue中的事件传入到Home.vue中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为涉及到非父子组件的通信, 所以这里我们选择了&lt;strong&gt;事件总线&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;bus -&amp;gt;总线&lt;/li&gt;
&lt;li&gt;Vue.prototype.$bus = new Vue()&lt;/li&gt;
&lt;li&gt;this.bus.emit(&#39;事件名称&#39;, 参数)&lt;/li&gt;
&lt;li&gt;this.bus.on(&#39;事件名称&#39;, 回调函数(参数))&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;问题一: refresh找不到的问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一: 在Scroll.vue中, 调用this.scroll的方法之前, 判断this.scroll对象是否有值&lt;/li&gt;
&lt;li&gt;第二: 在mounted生命周期函数中使用 this.$refs.scroll而不是created中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;问题二: 对于refresh非常频繁的问题, 进行防抖操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;防抖debounce/节流throttle(课下研究一下)&lt;/li&gt;
&lt;li&gt;防抖函数起作用的过程:
&lt;ul&gt;
&lt;li&gt;如果我们直接执行refresh, 那么refresh函数会被执行30次.&lt;/li&gt;
&lt;li&gt;可以将refresh函数传入到debounce函数中, 生成一个新的函数.&lt;/li&gt;
&lt;li&gt;之后在调用非常频繁的时候, 就使用新生成的函数.&lt;/li&gt;
&lt;li&gt;而新生成的函数, 并不会非常频繁的调用, 如果下一次执行来的非常快, 那么会将上一次取消掉&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      debounce(func, delay) {
        let timer = null
        return function (...args) {
          if (timer) clearTimeout(timer)
          timer = setTimeout(() =&amp;gt; {
            func.apply(this, args)
          }, delay)
        }
      },
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;八-上拉加载更多的功能&#34;&gt;八. 上拉加载更多的功能&lt;/h3&gt;
&lt;p&gt;y  ifu&lt;/p&gt;
&lt;h3 id=&#34;九-tabcontrol的吸顶效果&#34;&gt;九. tabControl的吸顶效果&lt;/h3&gt;
&lt;h4 id=&#34;91-获取到tabcontrol的offsettop&#34;&gt;9.1. 获取到tabControl的offsetTop&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;必须知道滚动到多少时, 开始有吸顶效果, 这个时候就需要获取tabControl的offsetTop&lt;/li&gt;
&lt;li&gt;但是, 如果直接在mounted中获取tabControl的offsetTop, 那么值是不正确.&lt;/li&gt;
&lt;li&gt;如何获取正确的值了?
&lt;ul&gt;
&lt;li&gt;监听HomeSwiper中img的加载完成.&lt;/li&gt;
&lt;li&gt;加载完成后, 发出事件, 在Home.vue中, 获取正确的值.&lt;/li&gt;
&lt;li&gt;补充:
&lt;ul&gt;
&lt;li&gt;为了不让HomeSwiper多次发出事件,&lt;/li&gt;
&lt;li&gt;可以使用isLoad的变量进行状态的记录.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注意: 这里不进行多次调用和debounce的区别&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;92-监听滚动-动态的改变tabcontrol的样式&#34;&gt;9.2. 监听滚动, 动态的改变tabControl的样式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;问题:动态的改变tabControl的样式时, 会出现两个问题:
&lt;ul&gt;
&lt;li&gt;问题一: 下面的商品内容, 会突然上移&lt;/li&gt;
&lt;li&gt;问题二: tabControl虽然设置了fixed, 但是也随着Better-Scroll一起滚出去了.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;其他方案来解决停留问题.
&lt;ul&gt;
&lt;li&gt;在最上面, 多复制了一份PlaceHolderTabControl组件对象, 利用它来实现停留效果.&lt;/li&gt;
&lt;li&gt;当用户滚动到一定位置时, PlaceHolderTabControl显示出来.&lt;/li&gt;
&lt;li&gt;当用户滚动没有达到一定位置时, PlaceHolderTabControl隐藏起来.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;十-让home保持原来的状态&#34;&gt;十. 让Home保持原来的状态&lt;/h3&gt;
&lt;h4 id=&#34;101-让home不要随意销毁掉&#34;&gt;10.1. 让Home不要随意销毁掉&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;keep-alive&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;102-让home中的内容保持原来的位置&#34;&gt;10.2. 让Home中的内容保持原来的位置&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;离开时, 保存一个位置信息saveY.&lt;/li&gt;
&lt;li&gt;进来时, 将位置设置为原来保存的位置saveY信息即可.
&lt;ul&gt;
&lt;li&gt;注意: 最好回来时, 进行一次refresh()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非父子组件通信:&lt;/p&gt;
&lt;p&gt;https://www.jb51.net/article/132371.htm&lt;/p&gt;
">Vue从入门到未完待续</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/windows-xi-tong-xia-typora-wan-quan-shi-yong-xiang-jie/"" data-c="
          &lt;p&gt;最近在用这个软件，亲测确实觉得这个软件比较好用，所以写下这篇文章，分享给大家Typora 是一款极致简洁的 markdown 文本编辑器。 支持即时渲染技术 ，没有编辑工具栏！在快速文字排版以及代码编辑方面的效率是显而易见的，自己感觉比MarkdownPad好用。「它的功能之强大、设计之冷静、体验之美妙、理念之先进，我认为值得所有笔记应用厂商学习。」&lt;/p&gt;
&lt;h2 id=&#34;邂逅typora&#34;&gt;邂逅Typora&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.typora.io/#windows&#34; target=&#34;_blank&#34; style=&#34;&#34;&gt;初遇Typora&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;typora是什么&#34;&gt;Typora是什么？&lt;/h2&gt;
&lt;p&gt;Typora 是一款支持实时预览的 Markdown 文本编辑器。它有 OS X、Windows、Linux 三个平台的版本，并且由于仍在测试中，是完全免费的。&lt;/p&gt;
&lt;h2 id=&#34;一个-markdown-文本编辑器&#34;&gt;一个 Markdown 文本编辑器&lt;/h2&gt;
&lt;p&gt;Typora 首先是一个 Markdown 文本编辑器，它支持且仅支持 Markdown 语法的文本编辑。在 Typora 官网 上他们将 Typora 描述为 「A truly minimal markdown editor. 」。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606715264191.png&#34; alt=&#34;官网首页&#34; loading=&#34;lazy&#34;&gt;&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;官网首页&lt;/center&gt;&lt;/p&gt;
&lt;h2 id=&#34;关于markdown&#34;&gt;关于Markdown&lt;/h2&gt;
&lt;p&gt;Markdown 是用来编写结构化文档的一种纯文本格式，它使我们在双手不离开键盘的情况下，可以对文本进行一定程度的格式排版。你可以在&lt;a href=&#34;https://tyloo-code.github.io/post/markdown-ji-ben-yu-fa/&#34;&gt;这篇文章&lt;/a&gt;中快速入门 Markdown。&lt;/p&gt;
&lt;p&gt;由于目前还没有一个权威机构对 Markdown 的语法进行规范，各应用厂商制作时遵循的 Markdown 语法也是不尽相同的。其中比较受到认可的是&lt;a href=&#34;https://Tyloo-code.github.io/post-images/1606715866342.png&#34;&gt;GFM标准&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606718544020.png&#34; alt=&#34;严格模式&#34; loading=&#34;lazy&#34;&gt;&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;严格模式&lt;/center&gt;&lt;/p&gt;
&lt;h2 id=&#34;写得舒服&#34;&gt;写得舒服&lt;/h2&gt;
&lt;p&gt;一个文本编辑器，&lt;strong&gt;写得舒服&lt;/strong&gt;是关键。我曾说过，「更有趣的是，一个笔记应用不会因为它支持 Markdown 语法而高级或易用很多。」，细枝末节处的人性化考虑才是最重要的。而 Typora 的编辑体验显然是经过深思熟虑设计的产物。&lt;/p&gt;
&lt;p&gt;我认为：一个优秀的笔记应用应该给用户&lt;strong&gt;选择 Markdown 语法风格的权利&lt;/strong&gt;。而 Typora 在这一点上是我目前见过所有 Markdown 笔记应用中做得最好的。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606718646444.jpg&#34; alt=&#34;文本编辑设置&#34; loading=&#34;lazy&#34;&gt;&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;文本编辑设置&lt;/center&gt;&lt;br&gt;
通过打开 文件 - 偏好设置 你会发现 Typora 为编辑体验的考虑细致到了令人叹为观止的程度。Typora 中提供了大量有关 Markdown 偏好的设置，据此，你可以构建一个几乎完全适合自己的 Markdown 编辑器。下面我将依次介绍一些与文本编辑体验有关的功能亮点。&lt;/p&gt;
&lt;p&gt;##图片插入&lt;br&gt;
Typora 的图片插入功能是广受好评的。要知道，Markdown 原生不太注重图片插入的功能，但你可以在 Typora 中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接使用 右键 - 复制 Ctrl + V 将网络图片、剪贴板图片复制到文档中&lt;/li&gt;
&lt;li&gt;拖动本地图片到文档中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Typora 会自动帮你插入符合 Markdown 语法的图片语句，并给它加上标题。&lt;/p&gt;
&lt;p&gt;更强大的是，Typora 支持在拖动或 Ctrl + V 网络图片后自动将其保存到本地。你可以在 文件 - 偏好设置 - 编辑器 - 图片插入 中选择复制到哪个路径，什么情况下需要复制。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606719092672.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;图片插入&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;这一功能保证了即使网络图片源失效了，你还有本地的备份可用。同时也能使你的文档文件夹更合理、完整。&lt;/p&gt;
&lt;h2 id=&#34;打字机模式和专注模式&#34;&gt;打字机模式和专注模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;打字机模式&lt;/strong&gt;使得你所编辑的那一行永远处于屏幕正中。&lt;br&gt;
&lt;strong&gt;专注模式&lt;/strong&gt;使你正在编辑的那一行保留颜色，而其他行的字体呈灰色。&lt;/p&gt;
&lt;p&gt;你可以在 视图 - 专注模式 / 打字机模式 中勾选使用这两个模式。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606720738399.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;两种模式&lt;/center&gt; 
&lt;h2 id=&#34;实时预览&#34;&gt;实时预览&lt;/h2&gt;
&lt;p&gt;我想很果断地下这个结论：到现在还不支持编辑界面实时预览的 Markdown 编辑器基本可以退出市场了。Typora 在这一方面显然已经领先了一大步——他们连 Markdown 语法的标记都在实时预览中消去了。当你离开正在编辑的有格式的文本段后，Typora 会自动隐藏 Markdown 标记，只留下 &lt;strong&gt;所见即所得&lt;/strong&gt; 的美妙。他们把这称为&lt;em&gt;Hybrid View&lt;/em&gt; 。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606721116860.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;所见即所得&lt;/center&gt; 
&lt;p&gt;为了防止一些程序 bug 的发生（虽然在我使用下来感到是很少的）导致格式问题无法修改，Typora 保留了一个「源代码模式」。你可以通过 视图 - 源代码模式 或左下角的 &amp;lt;/&amp;gt; 按钮进入。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606721181434.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;源代码模式&lt;/center&gt; 
&lt;h2 id=&#34;大纲-文件侧边栏&#34;&gt;大纲 / 文件侧边栏&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606721243748.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;侧边栏&lt;/center&gt; 
&lt;p&gt;Typora 会根据你 Markdown 标记的 H1、H2、H3…… 各级标题为你呈现一个大纲。&lt;/p&gt;
&lt;p&gt;你也可以选择查看文件夹中的文件，但由于目前 Typora 只支持查看 md 文件，因此我认为文件侧边栏这个功能还是很鸡肋的。&lt;/p&gt;
&lt;h2 id=&#34;空格与换行&#34;&gt;空格与换行&lt;/h2&gt;
&lt;p&gt;Typora 在空格与换行部分主要是使用 &lt;a href=&#34;https://commonmark.org&#34;&gt;CommonMark&lt;/a&gt; 作为标注规范。与前文提到的 GFM 一样，CommonMark 也是比较流行的 Markdown 语言规范（解析器）之一。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;空格：&lt;/strong&gt;&lt;br&gt;
在输入连续的空格后，Typora 会在编辑器视图里为你保留这些空格，但当你打印或导出时，这些空格会被省略成一个。&lt;br&gt;
你可以在源代码模式下，为每个空格前加一个 \ 转义符，或者直接使用 HTML 风格的 &amp;amp;nbps; 来保持连续的空格。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;软换行：&lt;/strong&gt;&lt;br&gt;
需要说明的是，在 Markdown 语法中，换行（line break）与换段是不同的。且换行分为软换行和硬换行。在 Typora 中，你可以通过 Shift + Enter 完成一次软换行。软换行只在编辑界面可见，当文档被导出时换行会被省略。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;硬换行：&lt;/strong&gt;&lt;br&gt;
你可以通过 空格 + 空格 + Shift + Enter 完成一次硬换行，而这也是许多 Markdown 编辑器所原生支持的。硬换行在文档被导出时将被保留，且没有换段的段后距。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;换段：&lt;/strong&gt;&lt;br&gt;
你可以通过 Enter 完成一次换段。Typora 会自动帮你完成两次 Shift + Enter 的软换行，从而完成一次换段。这也意味着在 Markdown 语法下，换段是通过在段与段之间加入空行来实现的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Windows 风格（CR+LF）与 Unix 风格（CR）的换行符：&lt;/strong&gt;&lt;br&gt;
CR 表示回车 \r ，即回到一行的开头，而 LF 表示换行 \n ，即另起一行。&lt;br&gt;
所以 Windows 风格的换行符本质是「回车 + 换行」，而 Unix 风格的换行符是「换行」。这也是为什么 Unix / Mac 系统下的文件，如果在 Windows 系统直接打开会全部在同一行内。 你可以在 文件 - 偏好设置 - 编辑器 - 默认换行符 中对此进行切换。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下附以上各空格、换行、换段的测试结果图。具体内容你可以在官网的 &lt;a href=&#34;http://support.typora.io/Line-Break/&#34;&gt;这篇文档&lt;/a&gt; 中查阅。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606722389444.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;空格、换行、换段&lt;/center&gt; 
&lt;h2 id=&#34;一个学术文档编辑器&#34;&gt;一个学术文档编辑器&lt;/h2&gt;
&lt;p&gt;除了基本的文本编辑体验极佳之外，Typora 还是一个非常优秀的学术文档编辑器。当然作为一个轻量级的、基于 Markdown 的编辑器，它不能与那些 LaTeX 编辑器相提并论，但它仍支持了许多可用于学术写作的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LaTeX&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;LaTeX 是一种基于 TeX 的排版系统，由于它易于快速生成复杂表格和数学公式，非常适用于生成高印刷质量的科技和数学类文档。如果你常阅读数学、计算机等领域的学术论文，你一定对 LaTeX 不陌生。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Typora 原生支持 LaTeX 语法，你有两种方式输入 LaTeX 风格的数学公式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;行内公式（inline）：&lt;/strong&gt; 用 $...$ 括起公式，公式会出现在行内。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;块间公式（display）：&lt;/strong&gt; 用 $$...$$ 括起公式（注意 $$ 后需要换行），公式会默认显示在行中间。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体的 LaTeX 语法在此不赘述了，你可以在 &lt;a href=&#34;https://blog.csdn.net/happyday_d/article/details/83715440&#34;&gt;这篇文章&lt;/a&gt; 中查看。&lt;/p&gt;
&lt;h2 id=&#34;代码高亮&#34;&gt;代码高亮&lt;/h2&gt;
&lt;p&gt;Typora 中代码的插入也可以分为行内和块间两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;行内代码：用`...` 或``...`` 括起代码，代码会以主题中设置的样式出现在行内，但不会实现代码高亮。&lt;/li&gt;
&lt;li&gt;代码块：输入 ``` 后并输入语言名，换行，开始写代码，Typora 就会自动帮你实现代码高亮。Typora 原生支持许多编程语言代码块的语法高亮，基本日常常用的编程语言它都能很好地支持。&lt;br&gt;
除此以外，你也可以直接换行开始写，而后再选择语言。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;链接引用与脚注&#34;&gt;链接引用与脚注&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;链接引用&lt;/strong&gt;类似于我们常在论文末尾看到的「参考文献」的写法，你可以通过 []: 的语法来为你的文档加上链接引用。&lt;br&gt;
&lt;strong&gt;脚注&lt;/strong&gt;在少数派的文章中也很常见，即某段话结尾右上角标有数字标记，页面底部进行注释的写法。你可以在需要插入脚注标号的位置写 [^ number ] ，再在下方通过 [^ number ]: 在文档中插入脚注。注意不要遗漏了脚注编号 number 前后的空格。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606723891564.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;链接引用和脚注
&lt;/center&gt; 
&lt;h2 id=&#34;一个伪装成文本编辑器的浏览器&#34;&gt;一个伪装成文本编辑器的浏览器&lt;/h2&gt;
&lt;p&gt;当我的一个朋友问我「Typora 有什么好写的？」时，我回答「Typora 是一个伪装成文本编辑器的浏览器」。是的，事实上如果你有一定的计算机基础，你可以找到许多有关于「Typora 其实是一个浏览器」的蛛丝马迹。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606724542832.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;图片插入&lt;/p&gt;
&lt;/center&gt; 
&lt;p&gt;在图片插入的选项中，Typora 用了「复制图片到 ./${filename}.assets 文件夹」的说法，而这其实是网页前端常用的 Javascript 字符串模板语法的风格。&lt;/p&gt;
&lt;p&gt;再比如，Typora 将更遵循 GFM 标准的 Markdown 语法模式称为「严格模式 Strict Mode」，这一说法常见于 HTML 和 JavaScript 编程中。类似「源代码模式」的说法也是同理。&lt;/p&gt;
&lt;p&gt;当然，最明显的一点是当你按下 Shift + F12 快捷键时，页面会弹出一个基于 Chrome 的开发者工具栏，也就是我们在浏览器中常说的「审查元素」。&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606724640253.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;审查元素&lt;/p&gt;
&lt;/center&gt; 
&lt;h2 id=&#34;伪装从何而来&#34;&gt;伪装从何而来？&lt;/h2&gt;
&lt;p&gt;当我们把视角放在「Typora 是一个支持 Markdown 语言的文本编辑器」的出发点来考虑这个问题，一切就都显得很明白了。&lt;/p&gt;
&lt;p&gt;John Gruber 在 2004 年用 Perl 创造了 Markdown 语言，这个语言的目的是希望大家使用「易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的 XHTML（或是 HTML）」。也就是说，&lt;strong&gt;在 Markdown 诞生之初，它就是为了被浏览器阅读而设计的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们在用 Markdown 语言撰写文稿的时候，其实本质上是在借助某种编程语言的转化（解析器）来编写一个 HTML 网页。Markdown 从它诞生之初就与 Web 技术有着及其紧密的联系。&lt;/p&gt;
&lt;p&gt;如果我说，我们每一篇文稿都是一个网页，那就很好理解了。Typora 利用解析器先将我们写的 Markdown 文档解析成为 HTML 文档，再为它嵌入一个 CSS 样式，最后再加上可能需要的脚本等。&lt;/p&gt;
&lt;h2 id=&#34;html&#34;&gt;HTML&lt;/h2&gt;
&lt;p&gt;HTML 是一种标记语言，主要负责构成网页的骨架，它包含所有不加装饰的网页元素。在 Typora 的使用场景下则是所有的&lt;strong&gt;文本、段落、标题等&lt;/strong&gt;的记号。&lt;/p&gt;
&lt;p&gt;你可以把一张网页想象成一幅数字油画，HTML 就是那个黑白线条的底，上面写满了数字标记，示意你哪一块区域要涂什么颜色。而 CSS 则负责在对应的区域涂上颜色，甚至加上一些装饰等。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606724955000.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;数字油画
&lt;/center&gt; 
&lt;h3 id=&#34;html-标签&#34;&gt;HTML 标签&lt;/h3&gt;
&lt;p&gt;Typora 支持许多常用的 HTML 标签，如果你了解 HTML 语法的话，你可以写出十分美观丰富的文档页面。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606725029628.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;HTML 标签
&lt;/center&gt; 
&lt;p&gt;事实上你可以在 Typora 中完成许多基本的 HTML 风格的文本输入，例如 HTML 字符、HTML 块、HTML 风格的注释，甚至是视频和音频。具体支持的功能和限制请在 &lt;a href=&#34;http://support.typora.io/HTML/&#34;&gt;官方文档&lt;/a&gt; 中查阅。&lt;/p&gt;
&lt;h3 id=&#34;导出为-html&#34;&gt;导出为 HTML&lt;/h3&gt;
&lt;p&gt;有了这一功能，我们就可以在 Typora 中创造出远超普通 Markdown 文档的页面效果。&lt;/p&gt;
&lt;p&gt;Typora 原生支持将文档导出为 HTML 格式的文件，并选择是否要嵌入 style（也就是后文我将提到的 CSS 的部分）。&lt;/p&gt;
&lt;p&gt;除此之外，由于其本身「浏览器」的属性，你可以直接在实时预览界面用 Ctrl +C 复制到 HTML 代码。一个实用的用处是将这些 HTML 代码直接 Ctrl + V 黏贴到微信公众号后台，基本可以保证两边显示效果相同。这一点不仅使公众号推送可以有更自由、美观的样式，也让编辑、排版更轻松了。（由于微信自带浏览器的一些特性，可能有少部分 CSS style 不能生效，建议多多校对。）&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606725222158.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;公众号
&lt;/center&gt; 
&lt;p&gt;具体如何用 Typora 完成公众号写作，你可以在 &lt;a href=&#34;https://sspai.com/post/40524&#34;&gt;这篇文章&lt;/a&gt; 中进一步了解。&lt;/p&gt;
&lt;h2 id=&#34;css&#34;&gt;CSS&lt;/h2&gt;
&lt;p&gt;为了让文档更美观，我们可以为其加上 CSS style。我认为 Typora 对 CSS 的支持让它成为一众桌面笔记应用中最与众不同的一个。在 Typora 中 CSS 被称为「主题」，但其本质仍是 CSS 文件。你可以在 文件 - 偏好设置 - 主题 - 打开主题文件夹 看到这些 CSS 文件。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606725328223.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;主题&lt;/p&gt;
&lt;/center&gt; 
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606725342168.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;主题文件夹
&lt;/center&gt; 
&lt;p&gt;选择不同的主题可以使文档拥有不同的外观，但不会影响内容。Typora 自带了若干主题，你也可以在 &lt;a href=&#34;http://theme.typora.io&#34;&gt;官网&lt;/a&gt; 下载更多的主题。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606725423540.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;主题商店
&lt;/center&gt; 
&lt;p&gt;除此以外，如果你有一定的 Web 编程基础，你当然也可以自己修改、新建适合你使用需求的 CSS 文件。我自己就写了一份名为 WeChat 的 CSS 文件，来符合我公众号特定的排版需求，例如正文是 15px，页边距是 8，小标题是 18px 等等。&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606725495732.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;CSS文件
&lt;/center&gt; 
&lt;p&gt;使用 Typora 的「主题」功能写公众号的一个好处是，只需要每次都套用同样的主题，我们就可以在保证每次排版规范都相同的同时，节省许多重复的工作。&lt;/p&gt;
&lt;h2 id=&#34;yaml-front-matter&#34;&gt;YAML front-matter&lt;/h2&gt;
&lt;p&gt;Typora 支持在文档头部加上基于 YAML 的 front-matter 信息，这一特性适用于把 Markdown 文档分类归档上传到用 Hexo 框架搭建的博客中。我对于这一点不太了解，这里就不误导大家了。有所了解的朋友可以在评论区谈谈！&lt;/p&gt;
&lt;h2 id=&#34;写在最后&#34;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;因为移动端生产效率低，所以只有桌面端应用。因为左顾右盼的两栏式预览影响思路，所以他们甚至去掉了 Markdown 语法标记，只留下最终呈现的样式。因为 Markdown 是为了 HTML 呈现而设计的，所以他们提供了从入门到高级的一系列 Web 辅助功能…… 这一切都只是为了纯粹的&lt;strong&gt;生产效率&lt;/strong&gt;。如果我们回头想想，Markdown 语言本身，当初不也是为了高效地生成简单网页而诞生的吗？&lt;/p&gt;
&lt;p&gt;最后，让我们一起期待这款&lt;strong&gt;顶级桌面文本生产力工具&lt;/strong&gt;的正式版的到来吧！😆&lt;/p&gt;
&lt;p&gt;文章转自：https://sspai.com/post/54912&lt;/p&gt;
">Windows系统下Typora 完全使用详解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/markdown-ji-ben-yu-fa/"" data-c="
          &lt;p&gt;Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;br&gt;
1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。&lt;br&gt;
2、操作简单。添加标题时Markdown只需要在标题内容前加#即可&lt;br&gt;
&lt;strong&gt;缺点：&lt;/strong&gt;&lt;br&gt;
1、需要记一些语法（当然，是很简单。五分钟学会）。&lt;br&gt;
2、有些平台不支持Markdown编辑模式。&lt;/p&gt;
&lt;h1 id=&#34;一-标题&#34;&gt;一、标题&lt;/h1&gt;
&lt;p&gt;在想要设置为标题的文字前面加#来表示&lt;br&gt;
一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。&lt;/p&gt;
&lt;p&gt;注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606703470701.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;h1 id=&#34;这是一级标题&#34;&gt;这是一级标题&lt;/h1&gt;
&lt;h2 id=&#34;这是二级标题&#34;&gt;这是二级标题&lt;/h2&gt;
&lt;h3 id=&#34;这是三级标题&#34;&gt;这是三级标题&lt;/h3&gt;
&lt;h4 id=&#34;这是四级标题&#34;&gt;这是四级标题&lt;/h4&gt;
&lt;h5 id=&#34;这是五级标题&#34;&gt;这是五级标题&lt;/h5&gt;
&lt;h6 id=&#34;这是六级标题&#34;&gt;这是六级标题&lt;/h6&gt;
&lt;h1 id=&#34;二-字体&#34;&gt;二、字体&lt;/h1&gt;
&lt;h3 id=&#34;加粗&#34;&gt;加粗&lt;/h3&gt;
&lt;p&gt;要加粗的文字左右分别用两个*号包起来&lt;/p&gt;
&lt;h3 id=&#34;斜体&#34;&gt;斜体&lt;/h3&gt;
&lt;p&gt;要倾斜的文字左右分别用一个*号包起来&lt;/p&gt;
&lt;h3 id=&#34;斜体加粗&#34;&gt;斜体加粗&lt;/h3&gt;
&lt;p&gt;要倾斜和加粗的文字左右分别用三个*号包起来&lt;/p&gt;
&lt;h3 id=&#34;删除线&#34;&gt;删除线&lt;/h3&gt;
&lt;p&gt;要加删除线的文字左右分别用两个~~号包起来&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606703939197.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;br&gt;
&lt;strong&gt;这是加粗的文字&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;这是倾斜的文字&lt;/em&gt;`&lt;br&gt;
&lt;em&gt;&lt;strong&gt;这是斜体加粗的文字&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
&lt;s&gt;这是加删除线的文字&lt;/s&gt;&lt;/p&gt;
&lt;h1 id=&#34;三-引用&#34;&gt;三、引用&lt;/h1&gt;
&lt;p&gt;在引用的文字前加&amp;gt;即可。引用也可以嵌套，如加两个&amp;gt;&amp;gt;三个&amp;gt;&amp;gt;&amp;gt;n个...&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606704234954.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是引用的内容&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是引用的内容&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这是引用的内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;四-分割线&#34;&gt;四、分割线&lt;/h1&gt;
&lt;p&gt;三个或者三个以上的 - 或者 * 都可以。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606704462750.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;效果如下&#34;&gt;效果如下：&lt;/h2&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;h1 id=&#34;五-图片&#34;&gt;五、图片&lt;/h1&gt;
&lt;p&gt;语法：![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)&lt;br&gt;
图片alt就是显示在图片下面的文字，相当于对图片内容的解释。&lt;br&gt;
图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606704900357.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;![]&lt;/p&gt;
&lt;p&gt;效果如下：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606717141216.svg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;center style=&#34;font-size:14px;color:#C0C0C0;text-decoration:null;padding-bottom:4px&#34;&gt;Gridea-Markdown&lt;/center&gt; 
&lt;p&gt;&lt;strong&gt;上传本地图片直接点击导航栏的图片标志，选择图片即可&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;markdown格式追求的是简单、多平台统一。那么图片的存储就是一个问题，需要用图床，提供统一的外链，这样就不用在不同的平台去处理图片的问题了。才能做到书写一次，各处使用。&lt;/p&gt;
&lt;h1 id=&#34;六-超链接&#34;&gt;六、超链接&lt;/h1&gt;
&lt;p&gt;语法：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606708259670.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606708357274.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;br&gt;
&lt;a href=&#34;http://jianshu.com&#34;&gt;简书&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://baidu.com&#34;&gt;百度&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606708441292.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;七-列表&#34;&gt;七、列表&lt;/h1&gt;
&lt;h3 id=&#34;无序列表&#34;&gt;无序列表&lt;/h3&gt;
&lt;p&gt;语法：&lt;br&gt;
无序列表用 - + * 任何一种都可以&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606709101155.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列表内容&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;列表内容&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;列表内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;有序列表&#34;&gt;有序列表&lt;/h3&gt;
&lt;p&gt;语法：&lt;br&gt;
数字加点&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606709243091.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;列表内容&lt;/li&gt;
&lt;li&gt;列表内容&lt;/li&gt;
&lt;li&gt;列表内容&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;列表嵌套&#34;&gt;列表嵌套&lt;/h3&gt;
&lt;h4 id=&#34;上一级和下一级之间敲三个空格即可&#34;&gt;上一级和下一级之间敲三个空格即可&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606709356169.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;八-表格&#34;&gt;八、表格&lt;/h1&gt;
&lt;p&gt;语法：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606709722229.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606709789868.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;姓名&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;技能&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;排行&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;刘备&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;哭&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;大哥&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;关羽&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;打&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;二哥&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;张飞&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;骂&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;三弟&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;九-代码&#34;&gt;九、代码&lt;/h1&gt;
&lt;p&gt;语法：&lt;br&gt;
单行代码：代码之间分别用一个反引号包起来&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606709967461.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606709977762.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
单行代码&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606710064570.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;代码块&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606710077370.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;br&gt;
&lt;code&gt;create database hero;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    function fun(){
         echo &amp;quot;这是一句非常牛逼的代码&amp;quot;;
    }
    fun();
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;十-流程图&#34;&gt;十、流程图&lt;/h1&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-flow&#34;&gt;st=&amp;gt;start: 开始
op=&amp;gt;operation: My Operation
cond=&amp;gt;condition: Yes or No?
e=&amp;gt;end
st-&amp;gt;op-&amp;gt;cond
cond(yes)-&amp;gt;e
cond(no)-&amp;gt;op
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606710630750.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;文章转自：https://www.jianshu.com/p/191d1e21f7ed&lt;/p&gt;
">Markdown基本语法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/helloworld/"" data-c="
          &lt;p&gt;与Gridea的初次邂逅!😘&lt;br&gt;
&lt;img src=&#34;https://Tyloo-code.github.io/post-images/1606659885219.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Gridea 是一款麻雀虽小却五脏俱全的静态博客写作客户端，他能让你告别繁琐的 Git 操作，更加快速方便的管理你的个人 Blog，同时 Gridea 恰到好处的主题和实用的配置功能也能一定程度上帮助你美化 Blog，如果你的动手能力够强，甚至可以自己调教。作为一款免费的工具，如果你有任何的建议都可以去官方项目页面进行反馈，根据目前的版本迭代速度看，作者还是非常勤劳的，期待未来有更多的新鲜功能。&lt;/p&gt;
">HelloWorld</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;center style=&#34;font-size:16px;color:SlateGray;text-decoration:null;padding-bottom:4px&#34;&gt;在这个快、短社交时代，能够有一个独立的地方，一个属于自己的地方来记录下一些内容。能够让自己的声音不会随着各种信息流而流逝。&lt;/center&gt; 
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
 &lt;center style=&#34;font-size:16px;color:DarkOrange;text-decoration:underline;&#34;&gt;
1002705465@qq.com
&lt;/center&gt;">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tyloo-code.github.io/post/hello-gridea/"" data-c="
          &lt;p&gt;👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;
✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/getgridea/gridea&#34;&gt;Github&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://gridea.dev/&#34;&gt;Gridea 主页&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://fehey.com/&#34;&gt;示例网站&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性👇&lt;/h2&gt;
&lt;p&gt;📝  你可以使用最酷的 &lt;strong&gt;Markdown&lt;/strong&gt; 语法，进行快速创作&lt;/p&gt;
&lt;p&gt;🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片&lt;/p&gt;
&lt;p&gt;🏷️  你可以对文章进行标签分组&lt;/p&gt;
&lt;p&gt;📋  你可以自定义菜单，甚至可以创建外部链接菜单&lt;/p&gt;
&lt;p&gt;💻  你可以在 &lt;strong&gt;Windows&lt;/strong&gt;，&lt;strong&gt;MacOS&lt;/strong&gt; 或 &lt;strong&gt;Linux&lt;/strong&gt; 设备上使用此客户端&lt;/p&gt;
&lt;p&gt;🌎  你可以使用 &lt;strong&gt;𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌&lt;/strong&gt; 或 &lt;strong&gt;Coding Pages&lt;/strong&gt; 向世界展示，未来将支持更多平台&lt;/p&gt;
&lt;p&gt;💬  你可以进行简单的配置，接入 &lt;a href=&#34;https://github.com/gitalk/gitalk&#34;&gt;Gitalk&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/SukkaW/DisqusJS&#34;&gt;DisqusJS&lt;/a&gt; 评论系统&lt;/p&gt;
&lt;p&gt;🇬🇧  你可以使用&lt;strong&gt;中文简体&lt;/strong&gt;或&lt;strong&gt;英语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力&lt;/p&gt;
&lt;p&gt;🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步&lt;/p&gt;
&lt;p&gt;🌱 当然 &lt;strong&gt;Gridea&lt;/strong&gt; 还很年轻，有很多不足，但请相信，它会不停向前 🏃&lt;/p&gt;
&lt;p&gt;未来，它一定会成为你离不开的伙伴&lt;/p&gt;
&lt;p&gt;尽情发挥你的才华吧！&lt;/p&gt;
&lt;p&gt;😘 Enjoy~&lt;/p&gt;
">Hello Gridea</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>





</html>